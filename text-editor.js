! function() {
    "use strict";

    function r(e) {
        if (null === e) return "null";
        if (void 0 === e) return "undefined";
        var t = typeof e;
        return "object" == t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" == t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t
    }

    function f(o) {
        return m(function(e, t) {
            if (e.length !== t.length) return !1;
            for (var n = e.length, r = 0; r < n; r++)
                if (!o.eq(e[r], t[r])) return !1;
            return !0
        })
    }

    function d(l) {
        return m(function(e, t) {
            var n, r, o, i = Object.keys(e),
                a = Object.keys(t);
            if (r = f(g), o = function(e) {
                    return t = n, Array.prototype.slice.call(e).sort(t);
                    var t
                }, !m(function(e, t) {
                    return r.eq(o(e), o(t))
                }).eq(i, a)) return !1;
            for (var u = i.length, s = 0; s < u; s++) {
                var c = i[s];
                if (!l.eq(e[c], t[c])) return !1
            }
            return !0
        })
    }

    function e(r) {
        return function(e) {
            return n = typeof(t = e), (null === t ? "null" : "object" == n && (Array.prototype.isPrototypeOf(t) || t.constructor && "Array" === t.constructor.name) ? "array" : "object" == n && (String.prototype.isPrototypeOf(t) || t.constructor && "String" === t.constructor.name) ? "string" : n) === r;
            var t, n
        }
    }

    function t(t) {
        return function(e) {
            return typeof e === t
        }
    }

    function n(t) {
        return function(e) {
            return t === e
        }
    }

    function K(e) {
        return null == e
    }

    function V(e) {
        return !K(e)
    }

    function te() {}

    function i(n, r) {
        return function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return n(r.apply(null, e))
        }
    }

    function a(t, n) {
        return function(e) {
            return t(n(e))
        }
    }

    function J(e) {
        return function() {
            return e
        }
    }

    function u(e) {
        return e
    }

    function o(e, t) {
        return e === t
    }
    var m = function(e) {
            return {
                eq: e
            }
        },
        g = m(function(e, t) {
            return e === t
        }),
        p = m(function(e, t) {
            if (e === t) return !0;
            var n = r(e);
            return n === r(t) && (-1 !== ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(n) ? e === t : "array" === n ? f(p).eq(e, t) : "object" === n && d(p).eq(e, t))
        }),
        X = e("string"),
        h = e("object"),
        S = e("array"),
        l = n(null),
        v = t("boolean"),
        b = n(void 0),
        y = t("function"),
        N = t("number");

    function R(r) {
        for (var o = [], e = 1; e < arguments.length; e++) o[e - 1] = arguments[e];
        return function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var n = o.concat(e);
            return r.apply(null, n)
        }
    }

    function s(t) {
        return function(e) {
            return !t(e)
        }
    }

    function C(e) {
        return e()
    }

    function x(e) {
        e()
    }

    function c() {
        return E
    }
    var D = J(!1),
        w = J(!0),
        E = {
            fold: function(e, t) {
                return e()
            },
            isSome: D,
            isNone: w,
            getOr: u,
            getOrThunk: k,
            getOrDie: function(e) {
                throw new Error(e || "error: getOrDie called on none.")
            },
            getOrNull: J(null),
            getOrUndefined: J(void 0),
            or: u,
            orThunk: k,
            map: c,
            each: te,
            bind: c,
            exists: D,
            forall: w,
            filter: function() {
                return E
            },
            toArray: function() {
                return []
            },
            toString: J("none()")
        };

    function k(e) {
        return e()
    }

    function _(e, t) {
        return ye.call(e, t)
    }

    function T(e, t) {
        return -1 < _(e, t)
    }

    function F(e, t) {
        for (var n = 0, r = e.length; n < r; n++)
            if (t(e[n], n)) return !0;
        return !1
    }

    function A(e, t) {
        for (var n = e.length, r = new Array(n), o = 0; o < n; o++) {
            var i = e[o];
            r[o] = t(i, o)
        }
        return r
    }

    function Y(e, t) {
        for (var n = 0, r = e.length; n < r; n++) t(e[n], n)
    }

    function O(e, t) {
        for (var n = e.length - 1; 0 <= n; n--) t(e[n], n)
    }

    function B(e, t) {
        for (var n = [], r = [], o = 0, i = e.length; o < i; o++) {
            var a = e[o];
            (t(a, o) ? n : r).push(a)
        }
        return {
            pass: n,
            fail: r
        }
    }

    function U(e, t) {
        for (var n = [], r = 0, o = e.length; r < o; r++) {
            var i = e[r];
            t(i, r) && n.push(i)
        }
        return n
    }

    function P(e, n, r) {
        return O(e, function(e, t) {
            r = n(r, e, t)
        }), r
    }

    function L(e, n, r) {
        return Y(e, function(e, t) {
            r = n(r, e, t)
        }), r
    }

    function I(e, t, n) {
        for (var r = 0, o = e.length; r < o; r++) {
            var i = e[r];
            if (t(i, r)) return ve.some(i);
            if (n(i, r)) break
        }
        return ve.none()
    }

    function M(e, t) {
        return I(e, t, D)
    }

    function z(e, t) {
        for (var n = 0, r = e.length; n < r; n++)
            if (t(e[n], n)) return ve.some(n);
        return ve.none()
    }

    function H(e, t) {
        return function(e) {
            for (var t = [], n = 0, r = e.length; n < r; ++n) {
                if (!S(e[n])) throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
                Ce.apply(t, e[n])
            }
            return t
        }(A(e, t))
    }

    function j(e, t) {
        for (var n = 0, r = e.length; n < r; ++n)
            if (!0 !== t(e[n], n)) return !1;
        return !0
    }

    function q(e) {
        var t = be.call(e, 0);
        return t.reverse(), t
    }

    function $(e, t) {
        return U(e, function(e) {
            return !T(t, e)
        })
    }

    function W(e, t) {
        var n = be.call(e, 0);
        return n.sort(t), n
    }

    function G(e, t) {
        return 0 <= t && t < e.length ? ve.some(e[t]) : ve.none()
    }

    function Q(e) {
        return G(e, 0)
    }

    function Z(e) {
        return G(e, e.length - 1)
    }

    function ee(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r = t(e[n], n);
            if (r.isSome()) return r
        }
        return ve.none()
    }

    function ne(e, t) {
        for (var n = we(e), r = 0, o = n.length; r < o; r++) {
            var i = n[r];
            t(e[i], i)
        }
    }

    function re(e, n) {
        return Ne(e, function(e, t) {
            return {
                k: t,
                v: n(e, t)
            }
        })
    }

    function oe(n) {
        return function(e, t) {
            n[t] = e
        }
    }

    function ie(e, n, r, o) {
        return ne(e, function(e, t) {
            (n(e, t) ? r : o)(e, t)
        }), 1
    }

    function ae(e, t) {
        var n = {};
        return ie(e, t, oe(n), te), n
    }

    function ue(e, t) {
        return Ee(e, t) ? ve.from(e[t]) : ve.none()
    }

    function se(e, t) {
        return Ee(e, t) && void 0 !== e[t] && null !== e[t]
    }

    function ce(e, t, n) {
        var r, o;
        if (!e) return !1;
        if (n = n || e, void 0 !== e.length) {
            for (r = 0, o = e.length; r < o; r++)
                if (!1 === t.call(n, e[r], r, e)) return !1
        } else
            for (r in e)
                if (Ee(e, r) && !1 === t.call(n, e[r], r, e)) return !1;
        return !0
    }

    function le(n, r) {
        var o = [];
        return ce(n, function(e, t) {
            o.push(r(e, t, n))
        }), o
    }

    function fe(n, r) {
        var o = [];
        return ce(n, function(e, t) {
            r && !r(e, t, n) || o.push(e)
        }), o
    }

    function de(e, t) {
        if (e)
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] === t) return n;
        return -1
    }

    function me(e, t, n, r) {
        for (var o = b(n) ? e[0] : n, i = 0; i < e.length; i++) o = t.call(r, o, e[i], i);
        return o
    }

    function ge(e, t, n) {
        for (var r = 0, o = e.length; r < o; r++)
            if (t.call(n, e[r], r, e)) return r;
        return -1
    }

    function pe(e) {
        return e[e.length - 1]
    }
    var he = function(n) {
            function e() {
                return o
            }

            function t(e) {
                return e(n)
            }
            var r = J(n),
                o = {
                    fold: function(e, t) {
                        return t(n)
                    },
                    isSome: w,
                    isNone: D,
                    getOr: r,
                    getOrThunk: r,
                    getOrDie: r,
                    getOrNull: r,
                    getOrUndefined: r,
                    or: e,
                    orThunk: e,
                    map: function(e) {
                        return he(e(n))
                    },
                    each: function(e) {
                        e(n)
                    },
                    bind: t,
                    exists: t,
                    forall: t,
                    filter: function(e) {
                        return e(n) ? o : E
                    },
                    toArray: function() {
                        return [n]
                    },
                    toString: function() {
                        return "some(" + n + ")"
                    }
                };
            return o
        },
        ve = {
            some: he,
            none: c,
            from: function(e) {
                return null == e ? E : he(e)
            }
        },
        be = Array.prototype.slice,
        ye = Array.prototype.indexOf,
        Ce = Array.prototype.push,
        xe = y(Array.from) ? Array.from : function(e) {
            return be.call(e)
        },
        we = Object.keys,
        Se = Object.hasOwnProperty,
        Ne = function(e, r) {
            var o = {};
            return ne(e, function(e, t) {
                var n = r(e, t);
                o[n.k] = n.v
            }), o
        },
        Ee = function(e, t) {
            return Se.call(e, t)
        },
        ke = Array.isArray,
        _e = function() {
            return (_e = Object.assign || function(e) {
                for (var t, n = 1, r = arguments.length; n < r; n++)
                    for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                return e
            }).apply(this, arguments)
        };

    function Ae(e, t, n) {
        if (n || 2 === arguments.length)
            for (var r, o = 0, i = t.length; o < i; o++) !r && o in t || ((r = r || Array.prototype.slice.call(t, 0, o))[o] = t[o]);
        return e.concat(r || Array.prototype.slice.call(t))
    }

    function Re(n) {
        var r, o = !1;
        return function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return o || (o = !0, r = n.apply(null, e)), r
        }
    }

    function De(e, t) {
        var n = String(t).toLowerCase();
        return M(e, function(e) {
            return e.search(n)
        })
    }

    function Te(e, t) {
        return -1 !== e.indexOf(t)
    }

    function Oe(t) {
        return function(e) {
            return e.replace(t, "")
        }
    }

    function Be(e) {
        return 0 < e.length
    }

    function Pe(e) {
        return !Be(e)
    }

    function Le(t) {
        return function(e) {
            return Te(e, t)
        }
    }

    function Ie(e) {
        return window.matchMedia(e).matches
    }

    function Me(e) {
        return null == e ? "" : ("" + e).replace(wt, "")
    }

    function Fe(e, t) {
        return t ? !("array" !== t || !ke(e)) || typeof e === t : void 0 !== e
    }

    function Ue(e, t) {
        for (var n = [], r = function(e) {
                return n.push(e), t(e)
            }, o = t(e);
            (o = o.bind(r)).isSome(););
        return n
    }

    function ze(e, t) {
        var n = e.dom;
        if (1 !== n.nodeType) return !1;
        var r = n;
        if (void 0 !== r.matches) return r.matches(t);
        if (void 0 !== r.msMatchesSelector) return r.msMatchesSelector(t);
        if (void 0 !== r.webkitMatchesSelector) return r.webkitMatchesSelector(t);
        if (void 0 !== r.mozMatchesSelector) return r.mozMatchesSelector(t);
        throw new Error("Browser lacks native selectors")
    }

    function He(e) {
        return 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
    }

    function je(e, t) {
        return e.dom === t.dom
    }

    function Ve(e, t) {
        return dt().browser.isIE() ? (n = e.dom, r = t.dom, o = Node.DOCUMENT_POSITION_CONTAINED_BY, 0 != (n.compareDocumentPosition(r) & o)) : (i = e.dom) !== (a = t.dom) && i.contains(a);
        var n, r, o, i, a
    }

    function qe() {
        return Xe(0, 0)
    }

    function $e(e) {
        function t(e) {
            return function() {
                return n === e
            }
        }
        var n = e.current,
            r = e.version;
        return {
            current: n,
            version: r,
            isEdge: t("Edge"),
            isChrome: t("Chrome"),
            isIE: t("IE"),
            isOpera: t("Opera"),
            isFirefox: t(nt),
            isSafari: t("Safari")
        }
    }

    function We(e) {
        function t(e) {
            return function() {
                return n === e
            }
        }
        var n = e.current,
            r = e.version;
        return {
            current: n,
            version: r,
            isWindows: t(it),
            isiOS: t("iOS"),
            isAndroid: t(at),
            isOSX: t("OSX"),
            isLinux: t("Linux"),
            isSolaris: t(ut),
            isFreeBSD: t(st),
            isChromeOS: t(ct)
        }
    }

    function Ke(e) {
        if (null == e) throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
    var Xe = function(e, t) {
            return {
                major: e,
                minor: t
            }
        },
        Ye = {
            nu: Xe,
            detect: function(e, t) {
                var n, r, o = String(t).toLowerCase();
                return 0 === e.length ? qe() : (r = function(e, t) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        if (r.test(t)) return r
                    }
                }(e, n = o)) ? Xe(i(1), i(2)) : {
                    major: 0,
                    minor: 0
                };

                function i(e) {
                    return Number(n.replace(r, "$" + e))
                }
            },
            unknown: qe
        },
        Ge = function(e, t) {
            return "" === (n = t) || e.length >= n.length && e.substr(0, 0 + n.length) === n;
            var n
        },
        Je = Oe(/^\s+|\s+$/g),
        Qe = Oe(/^\s+/g),
        Ze = Oe(/\s+$/g),
        et = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        tt = {
            browsers: J([{
                name: "Edge",
                versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
                search: function(e) {
                    return Te(e, "edge/") && Te(e, "chrome") && Te(e, "safari") && Te(e, "applewebkit")
                }
            }, {
                name: "Chrome",
                brand: "Chromium",
                versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, et],
                search: function(e) {
                    return Te(e, "chrome") && !Te(e, "chromeframe")
                }
            }, {
                name: "IE",
                versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
                search: function(e) {
                    return Te(e, "msie") || Te(e, "trident")
                }
            }, {
                name: "Opera",
                versionRegexes: [et, /.*?opera\/([0-9]+)\.([0-9]+).*/],
                search: Le("opera")
            }, {
                name: "Firefox",
                versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
                search: Le("firefox")
            }, {
                name: "Safari",
                versionRegexes: [et, /.*?cpu os ([0-9]+)_([0-9]+).*/],
                search: function(e) {
                    return (Te(e, "safari") || Te(e, "mobile/")) && Te(e, "applewebkit")
                }
            }]),
            oses: J([{
                name: "Windows",
                search: Le("win"),
                versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
            }, {
                name: "iOS",
                search: function(e) {
                    return Te(e, "iphone") || Te(e, "ipad")
                },
                versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
            }, {
                name: "Android",
                search: Le("android"),
                versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
            }, {
                name: "OSX",
                search: Le("mac os x"),
                versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
            }, {
                name: "Linux",
                search: Le("linux"),
                versionRegexes: []
            }, {
                name: "Solaris",
                search: Le("sunos"),
                versionRegexes: []
            }, {
                name: "FreeBSD",
                search: Le("freebsd"),
                versionRegexes: []
            }, {
                name: "ChromeOS",
                search: Le("cros"),
                versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
            }])
        },
        nt = "Firefox",
        rt = function() {
            return $e({
                current: void 0,
                version: Ye.unknown()
            })
        },
        ot = $e,
        it = (J("Edge"), J("Chrome"), J("IE"), J("Opera"), J(nt), J("Safari"), "Windows"),
        at = "Android",
        ut = "Solaris",
        st = "FreeBSD",
        ct = "ChromeOS",
        lt = function() {
            return We({
                current: void 0,
                version: Ye.unknown()
            })
        },
        ft = We,
        dt = (J(it), J("iOS"), J(at), J("Linux"), J("OSX"), J(ut), J(st), J(ct), Re(function() {
            return e = navigator.userAgent, t = ve.from(navigator.userAgentData), n = Ie, p = tt.browsers(), h = tt.oses(), v = t.bind(function(e) {
                return r = p, ee(e.brands, function(t) {
                    var n = t.brand.toLowerCase();
                    return M(r, function(e) {
                        var t;
                        return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
                    }).map(function(e) {
                        return {
                            current: e.name,
                            version: Ye.nu(parseInt(t.version, 10), 0)
                        }
                    })
                });
                var r
            }).orThunk(function() {
                return De(p, n = e).map(function(e) {
                    var t = Ye.detect(e.versionRegexes, n);
                    return {
                        current: e.name,
                        version: t
                    }
                });
                var n
            }).fold(rt, ot), b = De(h, r = e).map(function(e) {
                var t = Ye.detect(e.versionRegexes, r);
                return {
                    current: e.name,
                    version: t
                }
            }).fold(lt, ft), {
                browser: v,
                os: b,
                deviceType: (i = v, a = e, u = n, s = (o = b).isiOS() && !0 === /ipad/i.test(a), c = o.isiOS() && !s, f = (l = o.isiOS() || o.isAndroid()) || u("(pointer:coarse)"), d = s || !c && l && u("(min-device-width:768px)"), m = c || l && !d, g = i.isSafari() && o.isiOS() && !1 === /safari/i.test(a), {
                    isiPad: J(s),
                    isiPhone: J(c),
                    isTablet: J(d),
                    isPhone: J(m),
                    isTouch: J(f),
                    isAndroid: o.isAndroid,
                    isiOS: o.isiOS,
                    isWebView: J(g),
                    isDesktop: J(!m && !d && !g)
                })
            };
            var e, t, n, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b
        })),
        mt = navigator.userAgent,
        gt = dt(),
        pt = gt.browser,
        ht = gt.os,
        vt = gt.deviceType,
        bt = /WebKit/.test(mt) && !pt.isEdge(),
        yt = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL,
        Ct = -1 !== mt.indexOf("Windows Phone"),
        xt = {
            opera: pt.isOpera(),
            webkit: bt,
            ie: !(!pt.isIE() && !pt.isEdge()) && pt.version.major,
            gecko: pt.isFirefox(),
            mac: ht.isOSX() || ht.isiOS(),
            iOS: vt.isiPad() || vt.isiPhone(),
            android: ht.isAndroid(),
            contentEditable: !0,
            transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
            caretAfter: !0,
            range: window.getSelection && "Range" in window,
            documentMode: pt.isIE() ? document.documentMode || 7 : 10,
            fileApi: yt,
            ceFalse: !0,
            cacheSuffix: null,
            container: null,
            experimentalShadowDom: !1,
            canHaveCSP: !pt.isIE(),
            desktop: vt.isDesktop(),
            windowsPhone: Ct,
            browser: {
                current: pt.current,
                version: pt.version,
                isChrome: pt.isChrome,
                isEdge: pt.isEdge,
                isFirefox: pt.isFirefox,
                isIE: pt.isIE,
                isOpera: pt.isOpera,
                isSafari: pt.isSafari
            },
            os: {
                current: ht.current,
                version: ht.version,
                isAndroid: ht.isAndroid,
                isChromeOS: ht.isChromeOS,
                isFreeBSD: ht.isFreeBSD,
                isiOS: ht.isiOS,
                isLinux: ht.isLinux,
                isOSX: ht.isOSX,
                isSolaris: ht.isSolaris,
                isWindows: ht.isWindows
            },
            deviceType: {
                isDesktop: vt.isDesktop,
                isiPad: vt.isiPad,
                isiPhone: vt.isiPhone,
                isPhone: vt.isPhone,
                isTablet: vt.isTablet,
                isTouch: vt.isTouch,
                isWebView: vt.isWebView
            }
        },
        wt = /^\s*|\s*$/g,
        St = function(e, n, r, o) {
            o = o || this, e && ce(e = r ? e[r] : e, function(e, t) {
                return !1 !== n.call(o, e, t, r) && void St(e, n, r, o)
            })
        },
        Nt = {
            trim: Me,
            isArray: ke,
            is: Fe,
            toArray: function(e) {
                if (ke(e)) return e;
                for (var t = [], n = 0, r = e.length; n < r; n++) t[n] = e[n];
                return t
            },
            makeMap: function(e, t, n) {
                var r;
                for (t = t || ",", n = n || {}, r = (e = "string" == typeof(e = e || []) ? e.split(t) : e).length; r--;) n[e[r]] = {};
                return n
            },
            each: ce,
            map: le,
            grep: fe,
            inArray: de,
            hasOwn: Ee,
            extend: function(e) {
                for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                for (var r = 0; r < t.length; r++) {
                    var o, i, a = t[r];
                    for (o in a) !Ee(a, o) || void 0 !== (i = a[o]) && (e[o] = i)
                }
                return e
            },
            create: function(e, t, n) {
                var r, o, i, a = this,
                    u = 0,
                    s = (e = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(e))[3].match(/(^|\.)(\w+)$/i)[2],
                    c = a.createNS(e[3].replace(/\.\w+$/, ""), n);
                if (!c[s]) {
                    if ("static" === e[2]) return c[s] = t, void(this.onCreate && this.onCreate(e[2], e[3], c[s]));
                    t[s] || (t[s] = function() {}, u = 1), c[s] = t[s], a.extend(c[s].prototype, t), e[5] && (r = a.resolve(e[5]).prototype, o = e[5].match(/\.(\w+)$/i)[1], i = c[s], c[s] = u ? function() {
                        return r[o].apply(this, arguments)
                    } : function() {
                        return this.parent = r[o], i.apply(this, arguments)
                    }, c[s].prototype[s] = c[s], a.each(r, function(e, t) {
                        c[s].prototype[t] = r[t]
                    }), a.each(t, function(e, t) {
                        r[t] ? c[s].prototype[t] = function() {
                            return this.parent = r[t], e.apply(this, arguments)
                        } : t !== s && (c[s].prototype[t] = e)
                    })), a.each(t.static, function(e, t) {
                        c[s][t] = e
                    })
                }
            },
            walk: St,
            createNS: function(e, t) {
                var n, r;
                for (t = t || window, e = e.split("."), n = 0; n < e.length; n++) t[r = e[n]] || (t[r] = {}), t = t[r];
                return t
            },
            resolve: function(e, t) {
                var n, r;
                for (t = t || window, n = 0, r = (e = e.split(".")).length; n < r && (t = t[e[n]]); n++);
                return t
            },
            explode: function(e, t) {
                return !e || Fe(e, "array") ? e : le(e.split(t || ","), Me)
            },
            _addCacheSuffix: function(e) {
                var t = xt.cacheSuffix;
                return t && (e += (-1 === e.indexOf("?") ? "?" : "&") + t), e
            }
        },
        Et = {
            fromHtml: function(e, t) {
                var n = (t || document).createElement("div");
                if (n.innerHTML = e, !n.hasChildNodes() || 1 < n.childNodes.length) throw console.error("HTML does not have a single root node", e), new Error("HTML must have a single root node");
                return Ke(n.childNodes[0])
            },
            fromTag: function(e, t) {
                var n = (t || document).createElement(e);
                return Ke(n)
            },
            fromText: function(e, t) {
                var n = (t || document).createTextNode(e);
                return Ke(n)
            },
            fromDom: Ke,
            fromPoint: function(e, t, n) {
                return ve.from(e.dom.elementFromPoint(t, n)).map(Ke)
            }
        };

    function kt(e) {
        return e.dom.nodeName.toLowerCase()
    }

    function _t(e) {
        return e.dom.nodeType
    }

    function At(t) {
        return function(e) {
            return _t(e) === t
        }
    }

    function Rt(e) {
        return Et.fromDom(e.dom.ownerDocument)
    }

    function Dt(e) {
        return Rn(e) ? e : Rt(e)
    }

    function Tt(e) {
        return Et.fromDom(Dt(e).dom.defaultView)
    }

    function Ot(e) {
        return ve.from(e.dom.parentNode).map(Et.fromDom)
    }

    function Bt(e) {
        return ve.from(e.dom.previousSibling).map(Et.fromDom)
    }

    function Pt(e) {
        return ve.from(e.dom.nextSibling).map(Et.fromDom)
    }

    function Lt(e) {
        return q(Ue(e, Bt))
    }

    function It(e) {
        return Ue(e, Pt)
    }

    function Mt(e, t) {
        var n = e.dom.childNodes;
        return ve.from(n[t]).map(Et.fromDom)
    }

    function Ft(e) {
        return Mt(e, 0)
    }

    function Ut(e) {
        return Mt(e, e.dom.childNodes.length - 1)
    }

    function zt(e) {
        return e.dom.childNodes.length
    }

    function Ht(e) {
        return Dn(e) && V(e.dom.host)
    }

    function jt(t) {
        return Ht(t) ? t : function() {
            var e = Dt(t).dom.head;
            if (null == e) throw new Error("Head is not available yet");
            return Et.fromDom(e)
        }()
    }

    function Vt(e) {
        return Et.fromDom(e.dom.host)
    }

    function qt(t, n) {
        Ot(t).each(function(e) {
            e.dom.insertBefore(n.dom, t.dom)
        })
    }

    function $t(e, t) {
        Pt(e).fold(function() {
            Ot(e).each(function(e) {
                Ln(e, t)
            })
        }, function(e) {
            qt(e, t)
        })
    }

    function Wt(t, n) {
        Ft(t).fold(function() {
            Ln(t, n)
        }, function(e) {
            t.dom.insertBefore(n.dom, e.dom)
        })
    }

    function Kt(t, e) {
        Y(e, function(e) {
            Ln(t, e)
        })
    }

    function Xt(e) {
        e.dom.textContent = "", Y(Tn(e), function(e) {
            In(e)
        })
    }

    function Yt(e) {
        var t, n = Tn(e);
        0 < n.length && (t = e, Y(n, function(e) {
            qt(t, e)
        })), In(e)
    }

    function Gt(e, t) {
        return void 0 !== e ? e : void 0 !== t ? t : 0
    }

    function Jt(e) {
        var t = void 0 !== e ? e.dom : document,
            n = t.body.scrollLeft || t.documentElement.scrollLeft,
            r = t.body.scrollTop || t.documentElement.scrollTop;
        return Un(n, r)
    }

    function Qt(e, t, n) {
        var r = (void 0 !== n ? n.dom : document).defaultView;
        r && r.scrollTo(e, t)
    }

    function Zt(e, t) {
        dt().browser.isSafari() && y(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t)
    }

    function en(e, t, n, r) {
        return {
            x: e,
            y: t,
            width: n,
            height: r,
            right: e + n,
            bottom: t + r
        }
    }

    function tn(e) {
        var r = void 0 === e ? window : e,
            t = r.document,
            o = Jt(Et.fromDom(t)),
            n = void 0 === r ? window : r;
        return (dt().browser.isFirefox() ? ve.none() : ve.from(n.visualViewport)).fold(function() {
            var e = r.document.documentElement,
                t = e.clientWidth,
                n = e.clientHeight;
            return en(o.left, o.top, t, n)
        }, function(e) {
            return en(Math.max(e.pageLeft, o.left), Math.max(e.pageTop, o.top), e.width, e.height)
        })
    }

    function nn(t) {
        return function(e) {
            return !!e && e.nodeType === t
        }
    }

    function rn(e) {
        return e && !Object.getPrototypeOf(e)
    }

    function on(e) {
        var n = e.map(function(e) {
            return e.toLowerCase()
        });
        return function(e) {
            if (e && e.nodeName) {
                var t = e.nodeName.toLowerCase();
                return T(n, t)
            }
            return !1
        }
    }

    function an(r, e) {
        var o = e.toLowerCase().split(" ");
        return function(e) {
            if (Hn(e))
                for (var t = 0; t < o.length; t++) {
                    var n = e.ownerDocument.defaultView.getComputedStyle(e, null);
                    if ((n ? n.getPropertyValue(r) : null) === o[t]) return !0
                }
            return !1
        }
    }

    function un(t) {
        return function(e) {
            return Hn(e) && e.hasAttribute(t)
        }
    }

    function sn(e) {
        return Hn(e) && e.hasAttribute("data-mce-bogus")
    }

    function cn(e) {
        return Hn(e) && "TABLE" === e.tagName
    }

    function ln(t) {
        return function(e) {
            if (Hn(e)) {
                if (e.contentEditable === t) return !0;
                if (e.getAttribute("data-mce-contenteditable") === t) return !0
            }
            return !1
        }
    }

    function fn(e, t, n) {
        return void 0 === n && (n = o), e.exists(function(e) {
            return n(e, t)
        })
    }

    function dn(e, t, n) {
        return e.isSome() && t.isSome() ? ve.some(n(e.getOrDie(), t.getOrDie())) : ve.none()
    }

    function mn(e) {
        return void 0 !== e.style && y(e.style.getPropertyValue)
    }

    function gn(e, t, n) {
        if (!(X(n) || v(n) || N(n))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e), new Error("Attribute value was not simple");
        e.setAttribute(t, n + "")
    }

    function pn(e, t, n) {
        gn(e.dom, t, n)
    }

    function hn(e, t) {
        var n = e.dom;
        ne(t, function(e, t) {
            gn(n, t, e)
        })
    }

    function vn(e, t) {
        var n = e.dom.getAttribute(t);
        return null === n ? void 0 : n
    }

    function bn(e, t) {
        return ve.from(vn(e, t))
    }

    function yn(e, t) {
        var n = e.dom;
        return n && n.hasAttribute && n.hasAttribute(t)
    }

    function Cn(e, t) {
        e.dom.removeAttribute(t)
    }

    function xn(e, t) {
        var n = e.dom;
        ne(t, function(e, t) {
            ! function(e, t, n) {
                if (!X(n)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e), new Error("CSS value must be a string: " + n);
                mn(e) && e.style.setProperty(t, n)
            }(n, t, e)
        })
    }

    function wn(e, t) {
        var n = e.dom,
            r = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== r || Mn(e) ? r : Zn(n, t)
    }

    function Sn(e, t) {
        var n = e.dom,
            r = Zn(n, t);
        return ve.from(r).filter(function(e) {
            return 0 < e.length
        })
    }

    function Nn(e) {
        var t = {},
            n = e.dom;
        if (mn(n))
            for (var r = 0; r < n.style.length; r++) {
                var o = n.style.item(r);
                t[o] = n.style[o]
            }
        return t
    }

    function En(e) {
        return M(e, _n)
    }

    function kn(e, t) {
        return e.children && T(e.children, t)
    }
    "undefined" != typeof window || Function("return this;")();
    var _n = At(1),
        An = At(3),
        Rn = At(9),
        Dn = At(11),
        Tn = function(e) {
            return A(e.dom.childNodes, Et.fromDom)
        },
        On = y(Element.prototype.attachShadow) && y(Node.prototype.getRootNode),
        Bn = J(On),
        Pn = On ? function(e) {
            return Et.fromDom(e.dom.getRootNode())
        } : Dt,
        Ln = function(e, t) {
            e.dom.appendChild(t.dom)
        },
        In = function(e) {
            var t = e.dom;
            null !== t.parentNode && t.parentNode.removeChild(t)
        },
        Mn = function(e) {
            var t = An(e) ? e.dom.parentNode : e.dom;
            if (null == t || null === t.ownerDocument) return !1;
            var n = t.ownerDocument,
                r = Et.fromDom(t),
                o = Pn(r);
            return (Ht(o) ? ve.some(o) : ve.none()).fold(function() {
                return n.body.contains(t)
            }, a(Mn, Vt))
        },
        Fn = function(n, r) {
            return {
                left: n,
                top: r,
                translate: function(e, t) {
                    return Fn(n + e, r + t)
                }
            }
        },
        Un = Fn,
        zn = function(e) {
            var t, n = e.dom,
                r = n.ownerDocument.body;
            return r === n ? Un(r.offsetLeft, r.offsetTop) : Mn(e) ? (t = n.getBoundingClientRect(), Un(t.left, t.top)) : Un(0, 0)
        },
        Hn = nn(1),
        jn = on(["textarea", "input"]),
        Vn = nn(3),
        qn = nn(8),
        $n = nn(9),
        Wn = nn(11),
        Kn = on(["br"]),
        Xn = on(["img"]),
        Yn = ln("true"),
        Gn = ln("false"),
        Jn = on(["td", "th"]),
        Qn = on(["video", "audio", "object", "embed"]),
        Zn = function(e, t) {
            return mn(e) ? e.style.getPropertyValue(t) : ""
        },
        er = dt().browser,
        tr = {},
        nr = {
            exports: tr
        };

    function rr(e) {
        setTimeout(function() {
            throw e
        }, 0)
    }! function() {
        var e = this,
            t = function() {
                var e, t, n, r = {
                    exports: {}
                };

                function o() {}

                function i(e) {
                    if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
                    if ("function" != typeof e) throw new TypeError("not a function");
                    this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], f(e, this)
                }

                function a(n, r) {
                    for (; 3 === n._state;) n = n._value;
                    0 !== n._state ? (n._handled = !0, i._immediateFn(function() {
                        var e, t = 1 === n._state ? r.onFulfilled : r.onRejected;
                        if (null !== t) {
                            try {
                                e = t(n._value)
                            } catch (e) {
                                return void s(r.promise, e)
                            }
                            u(r.promise, e)
                        } else(1 === n._state ? u : s)(r.promise, n._value)
                    })) : n._deferreds.push(r)
                }

                function u(t, e) {
                    try {
                        if (e === t) throw new TypeError("A promise cannot be resolved with itself.");
                        if (e && ("object" == typeof e || "function" == typeof e)) {
                            var n = e.then;
                            if (e instanceof i) return t._state = 3, t._value = e, void c(t);
                            if ("function" == typeof n) return void f((r = n, o = e, function() {
                                r.apply(o, arguments)
                            }), t)
                        }
                        t._state = 1, t._value = e, c(t)
                    } catch (e) {
                        s(t, e)
                    }
                    var r, o
                }

                function s(e, t) {
                    e._state = 2, e._value = t, c(e)
                }

                function c(e) {
                    2 === e._state && 0 === e._deferreds.length && i._immediateFn(function() {
                        e._handled || i._unhandledRejectionFn(e._value)
                    });
                    for (var t = 0, n = e._deferreds.length; t < n; t++) a(e, e._deferreds[t]);
                    e._deferreds = null
                }

                function l(e, t, n) {
                    this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.promise = n
                }

                function f(e, t) {
                    var n = !1;
                    try {
                        e(function(e) {
                            n || (n = !0, u(t, e))
                        }, function(e) {
                            n || (n = !0, s(t, e))
                        })
                    } catch (e) {
                        if (n) return;
                        n = !0, s(t, e)
                    }
                }
                e = r, t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, n = setTimeout, i.prototype.catch = function(e) {
                    return this.then(null, e)
                }, i.prototype.then = function(e, t) {
                    var n = new this.constructor(o);
                    return a(this, new l(e, t, n)), n
                }, i.all = function(e) {
                    var u = Array.prototype.slice.call(e);
                    return new i(function(o, i) {
                        if (0 === u.length) return o([]);
                        for (var a = u.length, e = 0; e < u.length; e++) ! function t(n, e) {
                            try {
                                if (e && ("object" == typeof e || "function" == typeof e)) {
                                    var r = e.then;
                                    if ("function" == typeof r) return r.call(e, function(e) {
                                        t(n, e)
                                    }, i), 0
                                }
                                u[n] = e, 0 == --a && o(u)
                            } catch (e) {
                                i(e)
                            }
                        }(e, u[e])
                    })
                }, i.resolve = function(t) {
                    return t && "object" == typeof t && t.constructor === i ? t : new i(function(e) {
                        e(t)
                    })
                }, i.reject = function(n) {
                    return new i(function(e, t) {
                        t(n)
                    })
                }, i.race = function(o) {
                    return new i(function(e, t) {
                        for (var n = 0, r = o.length; n < r; n++) o[n].then(e, t)
                    })
                }, i._immediateFn = "function" == typeof setImmediate ? function(e) {
                    setImmediate(e)
                } : function(e) {
                    n(e, 0)
                }, i._unhandledRejectionFn = function(e) {
                    "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", e)
                }, i._setImmediateFn = function(e) {
                    i._immediateFn = e
                }, i._setUnhandledRejectionFn = function(e) {
                    i._unhandledRejectionFn = e
                }, e.exports ? e.exports = i : t.Promise || (t.Promise = i);
                var d = r.exports;
                return {
                    boltExport: ("undefined" != typeof window ? window : Function("return this;")()).Promise || d
                }
            };
        "object" == typeof tr && void 0 !== nr ? nr.exports = t() : (e = "undefined" != typeof globalThis ? globalThis : e || self).EphoxContactWrapper = t()
    }();

    function or(e) {
        return cr(function() {
            return new ar(e)
        })
    }

    function ir(a) {
        if (!S(a)) throw new Error("cases must be an array");
        if (0 === a.length) throw new Error("there must be at least one case");
        var u = [],
            n = {};
        return Y(a, function(e, r) {
            var t = we(e);
            if (1 !== t.length) throw new Error("one and only one name per case");
            var o = t[0],
                i = e[o];
            if (void 0 !== n[o]) throw new Error("duplicate key detected:" + o);
            if ("cata" === o) throw new Error("cannot have a case named cata (sorry)");
            if (!S(i)) throw new Error("case arguments must be an array");
            u.push(o), n[o] = function() {
                for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
                var t = n.length;
                if (t !== i.length) throw new Error("Wrong number of arguments to case " + o + ". Expected " + i.length + " (" + i + "), got " + t);
                return {
                    fold: function() {
                        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                        if (e.length !== a.length) throw new Error("Wrong number of arguments to fold. Expected " + a.length + ", got " + e.length);
                        return e[r].apply(null, n)
                    },
                    match: function(e) {
                        var t = we(e);
                        if (u.length !== t.length) throw new Error("Wrong number of arguments to match. Expected: " + u.join(",") + "\nActual: " + t.join(","));
                        if (!j(u, function(e) {
                                return T(t, e)
                            })) throw new Error("Not all branches were specified when using match. Specified: " + t.join(", ") + "\nRequired: " + u.join(", "));
                        return e[o].apply(null, n)
                    },
                    log: function(e) {
                        console.log(e, {
                            constructors: u,
                            constructor: o,
                            params: n
                        })
                    }
                }
            }
        }), n
    }
    var ar = nr.exports.boltExport,
        ur = function(e) {
            function r(e) {
                o() ? i(e) : t.push(e)
            }
            var n = ve.none(),
                t = [],
                o = function() {
                    return n.isSome()
                },
                i = function(t) {
                    n.each(function(e) {
                        setTimeout(function() {
                            t(e)
                        }, 0)
                    })
                };
            return e(function(e) {
                o() || (n = ve.some(e), Y(t, i), t = [])
            }), {
                get: r,
                map: function(n) {
                    return ur(function(t) {
                        r(function(e) {
                            t(n(e))
                        })
                    })
                },
                isReady: o
            }
        },
        sr = {
            nu: ur,
            pure: function(t) {
                return ur(function(e) {
                    e(t)
                })
            }
        },
        cr = function(n) {
            function e(e) {
                n().then(e, rr)
            }
            return {
                map: function(e) {
                    return cr(function() {
                        return n().then(e)
                    })
                },
                bind: function(t) {
                    return cr(function() {
                        return n().then(function(e) {
                            return t(e).toPromise()
                        })
                    })
                },
                anonBind: function(e) {
                    return cr(function() {
                        return n().then(function() {
                            return e.toPromise()
                        })
                    })
                },
                toLazy: function() {
                    return sr.nu(e)
                },
                toCached: function() {
                    var e = null;
                    return cr(function() {
                        return e = null === e ? n() : e
                    })
                },
                toPromise: n,
                get: e
            }
        },
        lr = function(n) {
            return {
                isValue: w,
                isError: D,
                getOr: J(n),
                getOrThunk: J(n),
                getOrDie: J(n),
                or: function(e) {
                    return lr(n)
                },
                orThunk: function(e) {
                    return lr(n)
                },
                fold: function(e, t) {
                    return t(n)
                },
                map: function(e) {
                    return lr(e(n))
                },
                mapError: function(e) {
                    return lr(n)
                },
                each: function(e) {
                    e(n)
                },
                bind: function(e) {
                    return e(n)
                },
                exists: function(e) {
                    return e(n)
                },
                forall: function(e) {
                    return e(n)
                },
                toOptional: function() {
                    return ve.some(n)
                }
            }
        },
        fr = function(n) {
            return {
                isValue: D,
                isError: w,
                getOr: u,
                getOrThunk: function(e) {
                    return e()
                },
                getOrDie: function() {
                    return e = String(n),
                        function() {
                            throw new Error(e)
                        }();
                    var e
                },
                or: u,
                orThunk: function(e) {
                    return e()
                },
                fold: function(e, t) {
                    return e(n)
                },
                map: function(e) {
                    return fr(n)
                },
                mapError: function(e) {
                    return fr(e(n))
                },
                each: te,
                bind: function(e) {
                    return fr(n)
                },
                exists: D,
                forall: w,
                toOptional: ve.none
            }
        },
        dr = {
            value: lr,
            error: fr,
            fromOption: function(e, t) {
                return e.fold(function() {
                    return fr(t)
                }, lr)
            }
        };

    function mr(e) {
        return e.fold(u, u)
    }

    function gr(e, t, n, r, o) {
        return e(n, r) ? ve.some(n) : y(o) && o(n) ? ve.none() : t(n, r, o)
    }

    function pr(e, t, n) {
        for (var r = e.dom, o = y(n) ? n : D; r.parentNode;) {
            var r = r.parentNode,
                i = Et.fromDom(r);
            if (t(i)) return ve.some(i);
            if (o(i)) break
        }
        return ve.none()
    }

    function hr(e, t, n) {
        return gr(function(e, t) {
            return t(e)
        }, pr, e, t, n)
    }

    function vr(e, t, n) {
        return pr(e, function(e) {
            return ze(e, t)
        }, n)
    }

    function br(e, t) {
        return n = t, He(r = void 0 === e ? document : e.dom) ? ve.none() : ve.from(r.querySelector(n)).map(Et.fromDom);
        var n, r
    }

    function yr(e, t, n) {
        return gr(ze, vr, e, t, n)
    }

    function Cr(e, t) {
        return "number" != typeof t && (t = 0), setTimeout(e, t)
    }

    function xr(e, t) {
        return "number" != typeof t && (t = 1), setInterval(e, t)
    }

    function wr(n, r) {
        function e() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            clearTimeout(o), o = Cr(function() {
                n.apply(this, e)
            }, r)
        }
        var o;
        return e.stop = function() {
            clearTimeout(o)
        }, e
    }

    function Sr(m, g) {
        function n(e, t, n) {
            var r, o = Nt._addCacheSuffix(e),
                i = ue(h, o).getOrThunk(function() {
                    return {
                        id: "mce-u" + p++,
                        passed: [],
                        failed: [],
                        count: 0
                    }
                });

            function a(e, t) {
                for (var n = e.length; n--;) e[n]();
                i.status = t, i.passed = [], i.failed = [], r && (r.onload = null, r.onerror = null, r = null)
            }

            function u() {
                return a(i.passed, 2), 0
            }

            function s() {
                return a(i.failed, 3)
            }(h[o] = i).count++;
            var c, l, f, d = function() {
                var e = d;
                ! function() {
                    for (var e = m.styleSheets, t = e.length; t--;) {
                        var n = e[t].ownerNode;
                        if (n && n.id === r.id) return u(), 1
                    }
                }() && (Date.now() - l < y ? Ar.setTimeout(e) : s())
            };
            t && i.passed.push(t), n && i.failed.push(n), 1 !== i.status && (2 !== i.status ? 3 !== i.status ? (i.status = 1, hn(c = Et.fromTag("link", b.dom), {
                rel: "stylesheet",
                type: "text/css",
                id: i.id
            }), l = Date.now(), g.contentCssCors && pn(c, "crossOrigin", "anonymous"), g.referrerPolicy && pn(c, "referrerpolicy", g.referrerPolicy), (r = c.dom).onload = d, r.onerror = s, f = c, Ln(jt(v), f), pn(c, "href", o)) : s() : u())
        }

        function o(t) {
            return or(function(e) {
                n(t, i(e, J(dr.value(t))), i(e, J(dr.error(t))))
            })
        }

        function t(e) {
            var n = Nt._addCacheSuffix(e);
            ue(h, n).each(function(e) {
                var t;
                0 == --e.count && (delete h[n], t = e.id, br(jt(v), "#" + t).each(In))
            })
        }
        void 0 === g && (g = {});
        var p = 0,
            h = {},
            v = Et.fromDom(m),
            b = Dt(v),
            y = g.maxLoadTime || 5e3;
        return {
            load: n,
            loadAll: function(e, n, r) {
                var a, t = A(e, o);
                a = t, or(function(r) {
                    var o = [],
                        i = 0;
                    0 === a.length ? r([]) : Y(a, function(e, t) {
                        var n;
                        e.get((n = t, function(e) {
                            o[n] = e, ++i >= a.length && r(o)
                        }))
                    })
                }).get(function(e) {
                    var t = B(e, function(e) {
                        return e.isValue()
                    });
                    0 < t.fail.length ? r(t.fail.map(mr)) : n(t.pass.map(mr))
                })
            },
            unload: t,
            unloadAll: function(e) {
                Y(e, function(e) {
                    t(e)
                })
            },
            _setReferrerPolicy: function(e) {
                g.referrerPolicy = e
            }
        }
    }
    ir([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    var Nr, Er, kr = function(e, t) {
            return M(e.dom.childNodes, function(e) {
                return t(Et.fromDom(e))
            }).map(Et.fromDom)
        },
        _r = window.Promise || ar,
        Ar = {
            requestAnimationFrame: function(e, t) {
                Nr ? Nr.then(e) : Nr = new _r(function(e) {
                    (function(e, t) {
                        for (var n = window.requestAnimationFrame, r = ["ms", "moz", "webkit"], o = 0; o < r.length && !n; o++) n = window[r[o] + "RequestAnimationFrame"];
                        (n = n || function(e) {
                            window.setTimeout(e, 0)
                        })(e, t)
                    })(e, t = t || document.body)
                }).then(e)
            },
            setTimeout: Cr,
            setInterval: xr,
            setEditorTimeout: function(e, t, n) {
                return Cr(function() {
                    e.removed || t()
                }, n)
            },
            setEditorInterval: function(e, t, n) {
                var r = xr(function() {
                    e.removed ? clearInterval(r) : t()
                }, n);
                return r
            },
            debounce: wr,
            throttle: wr,
            clearInterval: function(e) {
                return clearInterval(e)
            },
            clearTimeout: function(e) {
                return clearTimeout(e)
            }
        },
        Rr = (Er = new WeakMap, {
            forElement: function(e, t) {
                var n = Pn(e).dom;
                return ve.from(Er.get(n)).getOrThunk(function() {
                    var e = Sr(n, t);
                    return Er.set(n, e), e
                })
            }
        }),
        Dr = (Tr.prototype.current = function() {
            return this.node
        }, Tr.prototype.next = function(e) {
            return this.node = this.findSibling(this.node, "firstChild", "nextSibling", e), this.node
        }, Tr.prototype.prev = function(e) {
            return this.node = this.findSibling(this.node, "lastChild", "previousSibling", e), this.node
        }, Tr.prototype.prev2 = function(e) {
            return this.node = this.findPreviousNode(this.node, "lastChild", "previousSibling", e), this.node
        }, Tr.prototype.findSibling = function(e, t, n, r) {
            var o, i;
            if (e) {
                if (!r && e[t]) return e[t];
                if (e !== this.rootNode) {
                    if (o = e[n]) return o;
                    for (i = e.parentNode; i && i !== this.rootNode; i = i.parentNode)
                        if (o = i[n]) return o
                }
            }
        }, Tr.prototype.findPreviousNode = function(e, t, n, r) {
            var o, i, a;
            if (e && (o = e[n], !this.rootNode || o !== this.rootNode)) {
                if (o) {
                    if (!r)
                        for (a = o[t]; a; a = a[t])
                            if (!a[t]) return a;
                    return o
                }
                return (i = e.parentNode) && i !== this.rootNode ? i : void 0
            }
        }, Tr);

    function Tr(e, t) {
        this.node = e, this.rootNode = t, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this)
    }

    function Or(t) {
        var n;
        return function(e) {
            return n = n || function(e, t) {
                for (var n = {}, r = 0, o = e.length; r < o; r++) {
                    var i = e[r];
                    n[String(i)] = t(i, r)
                }
                return n
            }(t, w), Ee(n, kt(e))
        }
    }

    function Br(e) {
        return _n(e) && !go(e)
    }

    function Pr(e) {
        return _n(e) && "br" === kt(e)
    }

    function Lr(e) {
        return _o(e) && (e = e.parentNode), ko(e) && e.hasAttribute("data-mce-caret")
    }

    function Ir(e) {
        return _o(e) && No(e.data)
    }

    function Mr(e) {
        return Lr(e) || Ir(e)
    }

    function Fr(e) {
        return e.firstChild !== e.lastChild || !Kn(e.firstChild)
    }

    function Ur(e) {
        var t = e.container();
        return !!Vn(t) && (t.data.charAt(e.offset()) === So || e.isAtStart() && Ir(t.previousSibling))
    }

    function zr(e) {
        var t = e.container();
        return !!Vn(t) && (t.data.charAt(e.offset() - 1) === So || e.isAtEnd() && Ir(t.nextSibling))
    }

    function Hr(e) {
        return e && e.hasAttribute("data-mce-caret") ? (sn(n = (t = e.getElementsByTagName("br"))[t.length - 1]) && n.parentNode.removeChild(n), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("_moz_abspos"), e) : null;
        var t, n
    }

    function jr(e) {
        return Lr(e.startContainer)
    }

    function Vr(e) {
        return !Mo(e) && (Bo(e) ? !Po(e.parentNode) : Lo(e) || Oo(e) || Io(e) || Fo(e))
    }

    function qr(e, t) {
        return Vr(e) && function(e, t) {
            for (e = e.parentNode; e && e !== t; e = e.parentNode) {
                if (Fo(e)) return !1;
                if (Do(e)) return !0
            }
            return !0
        }(e, t)
    }

    function $r(e) {
        return Uo.test(e)
    }

    function Wr(e, t) {
        return Vr(e) && !1 === (a = t, Vn(i = e) && $r(i.data) && !1 === (n = i, r = Et.fromDom(a), vr(Et.fromDom(n), "pre,code", R(je, r)).isSome())) || Hn(o = e) && "A" === o.nodeName && !o.hasAttribute("href") && (o.hasAttribute("name") || o.hasAttribute("id")) || zo(e);
        var n, r, o, i, a
    }

    function Kr(e, t) {
        return function(e, t) {
            var n = 0;
            if (Wr(e, e)) return !1;
            var r = e.firstChild;
            if (!r) return !0;
            var o = new Dr(r, e);
            do {
                if (t) {
                    if (jo(r)) {
                        r = o.next(!0);
                        continue
                    }
                    if (Ho(r)) {
                        r = o.next();
                        continue
                    }
                }
                if (Kn(r)) n++, r = o.next();
                else {
                    if (Wr(r, e)) return !1;
                    r = o.next()
                }
            } while (r);
            return n <= 1
        }(e.dom, t = void 0 === t || t)
    }

    function Xr(e, t) {
        return V(e) && (Wr(e, t) || Br(Et.fromDom(e)))
    }

    function Yr(e) {
        return "span" === e.nodeName.toLowerCase() && "bookmark" === e.getAttribute("data-mce-type")
    }

    function Gr(e, t) {
        var n, r, o, i = {};
        if (e) {
            for (e = e.split(","), t = t || 10, n = 0; n < e.length; n += 2) r = String.fromCharCode(parseInt(e[n], t)), Go[r] || (o = "&" + e[n + 1] + ";", i[r] = o, i[o] = r);
            return i
        }
    }

    function Jr(e, t) {
        return e.replace(t ? $o : Wo, function(e) {
            return Go[e] || e
        })
    }

    function Qr(e, t) {
        return e.replace(t ? $o : Wo, function(e) {
            return 1 < e.length ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : Go[e] || "&#" + e.charCodeAt(0) + ";"
        })
    }

    function Zr(e, t, n) {
        return n = n || Qo, e.replace(t ? $o : Wo, function(e) {
            return Go[e] || n[e] || e
        })
    }

    function eo(e, t) {
        return (e = Nt.trim(e)) ? e.split(t || " ") : []
    }

    function to(e, t) {
        var n = ni(e, " ", ni(e.toUpperCase(), " "));
        return oi(n, t)
    }

    function no(e) {
        return to("td th li dt dd figcaption caption details summary", e.getTextBlockElements())
    }

    function ro(e, n) {
        var r;
        return e && (r = {}, ri(e = "string" == typeof e ? {
            "*": e
        } : e, function(e, t) {
            r[t] = r[t.toUpperCase()] = ("map" === n ? ni : ii)(e, /[, ]/)
        })), r
    }

    function oo(i) {
        function e(e, t, n) {
            var r = i[e];
            return r ? r = ni(r, /[, ]/, ni(r.toUpperCase(), /[, ]/)) : (r = ei[e]) || (r = to(t, n), ei[e] = r), r
        }
        var t, s, n, r, o, a, u, c, S = {},
            l = {},
            N = [],
            f = {},
            d = {},
            m = (t = (i = i || {}).schema, c = {}, ei[t] || (s = "id accesskey class dir lang style tabindex title role", n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", r = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", "html4" !== t && (s += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", n += " article aside details dialog figure main header footer hgroup section nav", r += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen"), "html5-strict" !== t && (s += " xml:lang", r = [r, u = "acronym applet basefont big font strike tt"].join(" "), ri(eo(u), function(e) {
                g(e, "", r)
            }), n = [n, a = "center dir isindex noframes"].join(" "), o = [n, r].join(" "), ri(eo(a), function(e) {
                g(e, "", o)
            })), o = o || [n, r].join(" "), g("html", "manifest", "head body"), g("head", "", "base command link meta noscript script style title"), g("title hr noscript br"), g("base", "href target"), g("link", "href rel media hreflang type sizes hreflang"), g("meta", "name http-equiv content charset"), g("style", "media type scoped"), g("script", "src async defer type charset"), g("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", o), g("address dt dd div caption", "", o), g("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", r), g("blockquote", "cite", o), g("ol", "reversed start type", "li"), g("ul", "", "li"), g("li", "value", o), g("dl", "", "dt dd"), g("a", "href target rel media hreflang type", r), g("q", "cite", r), g("ins del", "cite datetime", o), g("img", "src sizes srcset alt usemap ismap width height"), g("iframe", "src name width height", o), g("embed", "src type width height"), g("object", "data type typemustmatch name usemap form width height", [o, "param"].join(" ")), g("param", "name value"), g("map", "name", [o, "area"].join(" ")), g("area", "alt coords shape href target rel media hreflang type"), g("table", "border", "caption colgroup thead tfoot tbody tr" + ("html4" === t ? " col" : "")), g("colgroup", "span", "col"), g("col", "span"), g("tbody thead tfoot", "", "tr"), g("tr", "", "td th"), g("td", "colspan rowspan headers", o), g("th", "colspan rowspan headers scope abbr", o), g("form", "accept-charset action autocomplete enctype method name novalidate target", o), g("fieldset", "disabled form name", [o, "legend"].join(" ")), g("label", "form for", r), g("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), g("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", "html4" === t ? o : r), g("select", "disabled form multiple name required size", "option optgroup"), g("optgroup", "disabled label", "option"), g("option", "disabled label selected value"), g("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), g("menu", "type label", [o, "li"].join(" ")), g("noscript", "", o), "html4" !== t && (g("wbr"), g("ruby", "", [r, "rt rp"].join(" ")), g("figcaption", "", o), g("mark rt rp summary bdi", "", r), g("canvas", "width height", o), g("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [o, "track source"].join(" ")), g("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [o, "track source"].join(" ")), g("picture", "", "img source"), g("source", "src srcset type media sizes"), g("track", "kind src srclang label default"), g("datalist", "", [r, "option"].join(" ")), g("article section nav aside main header footer", "", o), g("hgroup", "", "h1 h2 h3 h4 h5 h6"), g("figure", "", [o, "figcaption"].join(" ")), g("time", "datetime", r), g("dialog", "open", o), g("command", "type label icon disabled checked radiogroup command"), g("output", "for form name", r), g("progress", "value max", r), g("meter", "value min max low high optimum", r), g("details", "open", [o, "summary"].join(" ")), g("keygen", "autofocus challenge disabled form keytype name")), "html5-strict" !== t && (p("script", "language xml:space"), p("style", "xml:space"), p("object", "declare classid code codebase codetype archive standby align border hspace vspace"), p("embed", "align name hspace vspace"), p("param", "valuetype type"), p("a", "charset name rev shape coords"), p("br", "clear"), p("applet", "codebase archive code object alt name width height align hspace vspace"), p("img", "name longdesc align border hspace vspace"), p("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), p("font basefont", "size color face"), p("input", "usemap align"), p("select"), p("textarea"), p("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), p("ul", "type compact"), p("li", "type"), p("ol dl menu dir", "compact"), p("pre", "width xml:space"), p("hr", "align noshade size width"), p("isindex", "prompt"), p("table", "summary width frame rules cellspacing cellpadding align bgcolor"), p("col", "width align char charoff valign"), p("colgroup", "width align char charoff valign"), p("thead", "align char charoff valign"), p("tr", "align char charoff valign bgcolor"), p("th", "axis align char charoff valign nowrap bgcolor width height"), p("form", "accept"), p("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), p("tfoot", "align char charoff valign"), p("tbody", "align char charoff valign"), p("area", "nohref"), p("body", "background bgcolor text link vlink alink")), "html4" !== t && (p("input button select textarea", "autofocus"), p("input textarea", "placeholder"), p("a", "download"), p("link script img", "crossorigin"), p("img", "loading"), p("iframe", "sandbox seamless allowfullscreen loading")), ri(eo("a form meter progress dfn"), function(e) {
                c[e] && delete c[e].children[e]
            }), delete c.caption.children.table, delete c.script, ei[t] = c));

        function g(e, t, n) {
            function r(e, t) {
                for (var n = {}, r = 0, o = e.length; r < o; r++) n[e[r]] = t || {};
                return n
            }
            var o, i;
            t = t || "", "string" == typeof(n = n || []) && (n = eo(n));
            for (var a = eo(e), u = a.length; u--;) i = {
                attributes: r(o = eo([s, t].join(" "))),
                attributesOrder: o,
                children: r(n, ti)
            }, c[a[u]] = i
        }

        function p(e, t) {
            for (var n, r, o, i = eo(e), a = i.length, u = eo(t); a--;)
                for (n = c[i[a]], r = 0, o = u.length; r < o; r++) n.attributes[u[r]] = {}, n.attributesOrder.push(u[r])
        }!1 === i.verify_html && (i.valid_elements = "*[*]");
        var h = ro(i.valid_styles),
            v = ro(i.invalid_styles, "map"),
            b = ro(i.valid_classes, "map"),
            y = e("whitespace_elements", "pre script noscript style textarea video audio iframe object code"),
            C = e("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"),
            x = e("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"),
            w = e("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls"),
            E = "td th iframe video audio object script code",
            k = e("non_empty_elements", E + " pre", x),
            _ = e("move_caret_before_on_enter_elements", E + " table", x),
            A = e("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"),
            R = e("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", A),
            D = e("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");

        function T(e) {
            return new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$")
        }

        function O(e) {
            var t, n, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/,
                C = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/,
                x = /[*?+]/;
            if (e) {
                var w = eo(e, ",");
                for (S["@"] && (h = S["@"].attributes, v = S["@"].attributesOrder), t = 0, n = w.length; t < n; t++)
                    if (i = y.exec(w[t])) {
                        if (g = i[1], c = i[2], p = i[3], s = i[5], a = {
                                attributes: d = {},
                                attributesOrder: m = []
                            }, "#" === g && (a.paddEmpty = !0), "-" === g && (a.removeEmpty = !0), "!" === i[4] && (a.removeEmptyAttrs = !0), h && (ne(h, function(e, t) {
                                d[t] = e
                            }), m.push.apply(m, v)), s)
                            for (r = 0, o = (s = eo(s, "|")).length; r < o; r++)(i = C.exec(s[r])) && (u = {}, f = i[1], l = i[2].replace(/[\\:]:/g, ":"), g = i[3], b = i[4], "!" === f && (a.attributesRequired = a.attributesRequired || [], a.attributesRequired.push(l), u.required = !0), "-" !== f ? (g && ("=" === g && (a.attributesDefault = a.attributesDefault || [], a.attributesDefault.push({
                                name: l,
                                value: b
                            }), u.defaultValue = b), ":" === g && (a.attributesForced = a.attributesForced || [], a.attributesForced.push({
                                name: l,
                                value: b
                            }), u.forcedValue = b), "<" === g && (u.validValues = ni(b, "?"))), x.test(l) ? (a.attributePatterns = a.attributePatterns || [], u.pattern = T(l), a.attributePatterns.push(u)) : (d[l] || m.push(l), d[l] = u)) : (delete d[l], m.splice(ai(m, l), 1)));
                        h || "@" !== c || (h = d, v = m), p && (a.outputName = c, S[p] = a), x.test(c) ? (a.pattern = T(c), N.push(a)) : S[c] = a
                    }
            }
        }

        function B(e) {
            S = {}, N = [], O(e), ri(m, function(e, t) {
                l[t] = e.children
            })
        }

        function P(e) {
            var a = /^(~)?(.+)$/;
            e && (ei.text_block_elements = ei.block_elements = null, ri(eo(e, ","), function(e) {
                var t, n = a.exec(e),
                    r = "~" === n[1],
                    o = r ? "span" : "div",
                    i = n[2];
                l[i] = l[o], f[i] = o, r || (R[i.toUpperCase()] = {}, R[i] = {}), S[i] || (t = S[o], delete(t = oi({}, t)).removeEmptyAttrs, delete t.removeEmpty, S[i] = t), ri(l, function(e, t) {
                    e[o] && (l[t] = e = oi({}, l[t]), e[i] = e[o])
                })
            }))
        }

        function L(e) {
            var o = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
            ei[i.schema] = null, e && ri(eo(e, ","), function(e) {
                var t, n, r = o.exec(e);
                r && (n = r[1], t = n ? l[r[2]] : l[r[2]] = {
                    "#comment": {}
                }, t = l[r[2]], ri(eo(r[3], "|"), function(e) {
                    "-" === n ? delete t[e] : t[e] = {}
                }))
            })
        }

        function I(e) {
            var t, n = S[e];
            if (n) return n;
            for (t = N.length; t--;)
                if ((n = N[t]).pattern.test(e)) return n
        }
        ri((i.special || "script noscript iframe noframes noembed title style textarea xmp").split(" "), function(e) {
            d[e] = new RegExp("</" + e + "[^>]*>", "gi")
        }), i.valid_elements ? B(i.valid_elements) : (ri(m, function(e, t) {
            S[t] = {
                attributes: e.attributes,
                attributesOrder: e.attributesOrder
            }, l[t] = e.children
        }), "html5" !== i.schema && ri(eo("strong/b em/i"), function(e) {
            var t = eo(e, "/");
            S[t[1]].outputName = t[0]
        }), ri(D, function(e, t) {
            S[t] && (i.padd_empty_block_inline_children && (S[t].paddInEmptyBlock = !0), S[t].removeEmpty = !0)
        }), ri(eo("ol ul blockquote a table tbody"), function(e) {
            S[e] && (S[e].removeEmpty = !0)
        }), ri(eo("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), function(e) {
            S[e].paddEmpty = !0
        }), ri(eo("span"), function(e) {
            S[e].removeEmptyAttrs = !0
        })), P(i.custom_elements), L(i.valid_children), O(i.extended_valid_elements), L("+ol[ul|ol],+ul[ul|ol]"), ri({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
        }, function(e, t) {
            S[t] && (S[t].parentsRequired = eo(e))
        }), i.invalid_elements && ri(ii(i.invalid_elements), function(e) {
            S[e] && delete S[e]
        }), I("span") || O("span[!data-mce-type|*]");
        var M = J(h),
            F = J(v),
            U = J(b),
            z = J(w),
            H = J(R),
            j = J(A),
            V = J(D),
            q = J(x),
            $ = J(C),
            W = J(k),
            K = J(_),
            X = J(y),
            Y = J(d),
            G = J(f);
        return {
            children: l,
            elements: S,
            getValidStyles: M,
            getValidClasses: U,
            getBlockElements: H,
            getInvalidStyles: F,
            getShortEndedElements: q,
            getTextBlockElements: j,
            getTextInlineElements: V,
            getBoolAttrs: z,
            getElementRule: I,
            getSelfClosingElements: $,
            getNonEmptyElements: W,
            getMoveCaretBeforeOnEnterElements: K,
            getWhiteSpaceElements: X,
            getSpecialElements: Y,
            isValidChild: function(e, t) {
                var n = l[e.toLowerCase()];
                return !(!n || !n[t.toLowerCase()])
            },
            isValid: function(e, t) {
                var n, r, o = I(e);
                if (o) {
                    if (!t) return !0;
                    if (o.attributes[t]) return !0;
                    if (n = o.attributePatterns)
                        for (r = n.length; r--;)
                            if (n[r].pattern.test(e)) return !0
                }
                return !1
            },
            getCustomElements: G,
            addValidElements: O,
            setValidElements: B,
            addCustomElements: P,
            addValidChildren: L
        }
    }

    function io(e, t, n, r) {
        function o(e) {
            return 1 < (e = parseInt(e, 10).toString(16)).length ? e : "0" + e
        }
        return "#" + o(t) + o(n) + o(r)
    }

    function ao(b, e) {
        var u, o, y = this,
            C = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
            x = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
            w = /\s*([^:]+):\s*([^;]+);?/g,
            S = /\s+$/,
            N = {},
            E = xo;
        b = b || {}, e && (u = e.getValidStyles(), o = e.getInvalidStyles());
        for (var t = ("\\\" \\' \\; \\: ; : " + E).split(" "), k = 0; k < t.length; k++) N[t[k]] = E + k, N[E + k] = t[k];
        return {
            toHex: function(e) {
                return e.replace(C, io)
            },
            parse: function(e) {
                function t(e, t, n) {
                    var r = p[e + "-top" + t];
                    if (r) {
                        var o = p[e + "-right" + t];
                        if (o) {
                            var i = p[e + "-bottom" + t];
                            if (i) {
                                var a = p[e + "-left" + t];
                                if (a) {
                                    var u = [r, o, i, a];
                                    for (k = u.length - 1; k-- && u[k] === u[k + 1];); - 1 < k && n || (p[e + t] = -1 === k ? u[0] : u.join(" "), delete p[e + "-top" + t], delete p[e + "-right" + t], delete p[e + "-bottom" + t], delete p[e + "-left" + t])
                                }
                            }
                        }
                    }
                }

                function n(e) {
                    var t, n = p[e];
                    if (n) {
                        for (t = (n = n.split(" ")).length; t--;)
                            if (n[t] !== n[0]) return;
                        return p[e] = n[0], 1
                    }
                }

                function r(e) {
                    return f = !0, N[e]
                }

                function u(e, t) {
                    return f && (e = e.replace(/\uFEFF[0-9]/g, function(e) {
                        return N[e]
                    })), t ? e : e.replace(/\\([\'\";:])/g, "$1")
                }

                function o(e) {
                    return String.fromCharCode(parseInt(e.slice(1), 16))
                }

                function i(e) {
                    return e.replace(/\\[0-9a-f]+/gi, o)
                }

                function a(e, t, n, r, o, i) {
                    if (o = o || i) return "'" + (o = u(o)).replace(/\'/g, "\\'") + "'";
                    if (t = u(t || n || r), !b.allow_script_urls) {
                        var a = t.replace(/[\s\r\n]+/g, "");
                        if (/(java|vb)script:/i.test(a)) return "";
                        if (!b.allow_svg_data_urls && /^data:image\/svg/i.test(a)) return ""
                    }
                    return "url('" + (t = h ? h.call(v, t, "style") : t).replace(/\'/g, "\\'") + "')"
                }
                var s, c, l, f, d, m, g, p = {},
                    h = b.url_converter,
                    v = b.url_converter_scope || y;
                if (e) {
                    for (e = (e = e.replace(/[\u0000-\u001F]/g, "")).replace(/\\[\"\';:\uFEFF]/g, r).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(e) {
                            return e.replace(/[;:]/g, r)
                        }); s = w.exec(e);) w.lastIndex = s.index + s[0].length, c = s[1].replace(S, "").toLowerCase(), l = s[2].replace(S, ""), c && l && (c = i(c), l = i(l), -1 === c.indexOf(E) && -1 === c.indexOf('"') && (b.allow_script_urls || "behavior" !== c && !/expression\s*\(|\/\*|\*\//.test(l)) && ("font-weight" === c && "700" === l ? l = "bold" : "color" !== c && "background-color" !== c || (l = l.toLowerCase()), l = (l = l.replace(C, io)).replace(x, a), p[c] = f ? u(l, !0) : l));
                    t("border", "", !0), t("border", "-width"), t("border", "-color"), t("border", "-style"), t("padding", ""), t("margin", ""), m = "border-style", g = "border-color", n(d = "border-width") && n(m) && n(g) && (p.border = p[d] + " " + p[m] + " " + p[g], delete p[d], delete p[m], delete p[g]), "medium none" === p.border && delete p.border, "none" === p["border-image"] && delete p["border-image"]
                }
                return p
            },
            serialize: function(i, r) {
                function e(e) {
                    var t, n = u[e];
                    if (n)
                        for (var r = 0, o = n.length; r < o; r++) e = n[r], (t = i[e]) && (a += (0 < a.length ? " " : "") + e + ": " + t + ";")
                }
                var a = "";
                return r && u ? (e("*"), e(r)) : ne(i, function(e, t) {
                    var n;
                    !e || o && ((n = o["*"]) && n[t] || (n = o[r]) && n[t]) || (a += (0 < a.length ? " " : "") + t + ": " + e + ";")
                }), a
            }
        }
    }

    function uo(e) {
        return e instanceof Event || y(e.initEvent)
    }

    function so(e, t, n, r) {
        var o, i, a = function(e) {
            var t, n = null != r ? r : {};
            for (t in e) Ee(ui, t) || (n[t] = e[t]);
            return V(n.composedPath) && (n.composedPath = function() {
                return e.composedPath()
            }), n
        }(t);
        return a.type = e, K(a.target) && (a.target = null !== (o = a.srcElement) && void 0 !== o ? o : n), (K((i = t).preventDefault) || uo(i)) && (a.preventDefault = function() {
            a.defaultPrevented = !0, a.isDefaultPrevented = w, y(t.preventDefault) ? t.preventDefault() : uo(t) && (t.returnValue = !1)
        }, a.stopPropagation = function() {
            a.cancelBubble = !0, a.isPropagationStopped = w, y(t.stopPropagation) ? t.stopPropagation() : uo(t) && (t.cancelBubble = !0)
        }, a.stopImmediatePropagation = function() {
            a.isImmediatePropagationStopped = w, a.stopPropagation()
        }, a.isDefaultPrevented !== w && a.isDefaultPrevented !== D && (a.isDefaultPrevented = !0 === a.defaultPrevented ? w : D, a.isPropagationStopped = !0 === a.cancelBubble ? w : D, a.isImmediatePropagationStopped = D)), a
    }

    function co(e, t, n, r) {
        e.addEventListener ? e.addEventListener(t, n, r || !1) : e.attachEvent && e.attachEvent("on" + t, n)
    }

    function lo(e, t, n, r) {
        e.removeEventListener ? e.removeEventListener(t, n, r || !1) : e.detachEvent && e.detachEvent("on" + t, n)
    }

    function fo(e, t) {
        var n, r, o, i, a = so(e.type, e, document, t);
        return V(i = e) && si.test(i.type) && b(e.pageX) && !b(e.clientX) && (r = (n = a.target.ownerDocument || document).documentElement, o = n.body, a.pageX = e.clientX + (r && r.scrollLeft || o && o.scrollLeft || 0) - (r && r.clientLeft || o && o.clientLeft || 0), a.pageY = e.clientY + (r && r.scrollTop || o && o.scrollTop || 0) - (r && r.clientTop || o && o.clientTop || 0)), b(a.metaKey) && (a.metaKey = !1), a
    }
    var mo = Or(["h1", "h2", "h3", "h4", "h5", "h6"]),
        go = Or(["article", "aside", "details", "div", "dt", "figcaption", "footer", "form", "fieldset", "header", "hgroup", "html", "main", "nav", "section", "summary", "body", "p", "dl", "multicol", "dd", "figure", "address", "center", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6", "listing", "xmp", "pre", "plaintext", "menu", "dir", "ul", "ol", "li", "hr", "table", "tbody", "thead", "tfoot", "th", "tr", "td", "caption"]),
        po = Or(["h1", "h2", "h3", "h4", "h5", "h6", "p", "div", "address", "pre", "form", "blockquote", "center", "dir", "fieldset", "header", "footer", "article", "section", "hgroup", "aside", "nav", "figure"]),
        ho = Or(["ul", "ol", "dl"]),
        vo = Or(["li", "dd", "dt"]),
        bo = Or(["thead", "tbody", "tfoot"]),
        yo = Or(["td", "th"]),
        Co = Or(["pre", "script", "textarea", "style"]),
        xo = "\ufeff",
        wo = "\xa0",
        So = xo,
        No = function(e) {
            return e === xo
        },
        Eo = function(e) {
            return e.replace(/\uFEFF/g, "")
        },
        ko = Hn,
        _o = Vn,
        Ao = function(e) {
            return _o(e) && e.data[0] === So
        },
        Ro = function(e) {
            return _o(e) && e.data[e.data.length - 1] === So
        },
        Do = Yn,
        To = Gn,
        Oo = Kn,
        Bo = Vn,
        Po = on(["script", "style", "textarea"]),
        Lo = on(["img", "input", "textarea", "hr", "iframe", "video", "audio", "object", "embed"]),
        Io = on(["table"]),
        Mo = Mr,
        Fo = function(e) {
            return !1 === (Hn(t = e) && "true" === t.getAttribute("unselectable")) && To(e);
            var t
        },
        Uo = /^[ \t\r\n]*$/,
        zo = un("data-mce-bookmark"),
        Ho = un("data-mce-bogus"),
        jo = function(e) {
            return Hn(e) && "all" === e.getAttribute("data-mce-bogus")
        },
        Vo = function(e, t, n) {
            var r = n || t;
            if (Hn(t) && Yr(t)) return t;
            for (var o, i, a, u, s, c, l, f, d, m, g, p = t.childNodes, h = p.length - 1; 0 <= h; h--) Vo(e, p[h], r);
            return !Hn(t) || 1 === (o = t.childNodes).length && Yr(o[0]) && t.parentNode.insertBefore(o[0], t), Wn(a = t) || $n(a) || Wr(t, r) || Hn(i = t) && 0 < i.childNodes.length || (s = r, Vn(u = t) && 0 < u.data.length && (f = new Dr(c = u, l = s).prev(!1), d = new Dr(c, l).next(!1), m = b(f) || Xr(f, l), g = b(d) || Xr(d, l), m && g)) || e.remove(t), t
        },
        qo = Nt.makeMap,
        $o = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        Wo = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        Ko = /[<>&\"\']/g,
        Xo = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,
        Yo = {
            128: "\u20ac",
            130: "\u201a",
            131: "\u0192",
            132: "\u201e",
            133: "\u2026",
            134: "\u2020",
            135: "\u2021",
            136: "\u02c6",
            137: "\u2030",
            138: "\u0160",
            139: "\u2039",
            140: "\u0152",
            142: "\u017d",
            145: "\u2018",
            146: "\u2019",
            147: "\u201c",
            148: "\u201d",
            149: "\u2022",
            150: "\u2013",
            151: "\u2014",
            152: "\u02dc",
            153: "\u2122",
            154: "\u0161",
            155: "\u203a",
            156: "\u0153",
            158: "\u017e",
            159: "\u0178"
        },
        Go = {
            '"': "&quot;",
            "'": "&#39;",
            "<": "&lt;",
            ">": "&gt;",
            "&": "&amp;",
            "`": "&#96;"
        },
        Jo = {
            "&lt;": "<",
            "&gt;": ">",
            "&amp;": "&",
            "&quot;": '"',
            "&apos;": "'"
        },
        Qo = Gr("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32),
        Zo = {
            encodeRaw: Jr,
            encodeAllRaw: function(e) {
                return ("" + e).replace(Ko, function(e) {
                    return Go[e] || e
                })
            },
            encodeNumeric: Qr,
            encodeNamed: Zr,
            getEncodeFunc: function(e, t) {
                var n = Gr(t) || Qo,
                    r = qo(e.replace(/\+/g, ","));
                return r.named && r.numeric ? function(e, t) {
                    return e.replace(t ? $o : Wo, function(e) {
                        return void 0 !== Go[e] ? Go[e] : void 0 !== n[e] ? n[e] : 1 < e.length ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + e.charCodeAt(0) + ";"
                    })
                } : r.named ? t ? function(e, t) {
                    return Zr(e, t, n)
                } : Zr : r.numeric ? Qr : Jr
            },
            decode: function(e) {
                return e.replace(Xo, function(e, t) {
                    return t ? 65535 < (t = "x" === t.charAt(0).toLowerCase() ? parseInt(t.substr(1), 16) : parseInt(t, 10)) ? (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) : Yo[t] || String.fromCharCode(t) : Jo[e] || Qo[e] || (n = e, (r = Et.fromTag("div").dom).innerHTML = n, r.textContent || r.innerText || n);
                    var n, r
                })
            }
        },
        ei = {},
        ti = {},
        ni = Nt.makeMap,
        ri = Nt.each,
        oi = Nt.extend,
        ii = Nt.explode,
        ai = Nt.inArray,
        ui = {
            keyLocation: !0,
            layerX: !0,
            layerY: !0,
            returnValue: !0,
            webkitMovementX: !0,
            webkitMovementY: !0,
            keyIdentifier: !0,
            mozPressure: !0
        },
        si = /^(?:mouse|contextmenu)|click/,
        ci = (li.prototype.bind = function(e, t, n, r) {
            function o(e) {
                f.executeHandlers(fo(e || d.event), i)
            }
            var i, a, u, s, c, l, f = this,
                d = window;
            if (e && 3 !== e.nodeType && 8 !== e.nodeType) {
                e[f.expando] ? i = e[f.expando] : (i = f.count++, e[f.expando] = i, f.events[i] = {}), r = r || e;
                for (var m = t.split(" "), g = m.length; g--;) c = o, s = l = !1, "DOMContentLoaded" === (u = m[g]) && (u = "ready"), f.domLoaded && "ready" === u && "complete" === e.readyState ? n.call(r, fo({
                    type: u
                })) : (f.hasMouseEnterLeave || (s = f.mouseEnterLeave[u]) && (c = function(e) {
                    var t = e.currentTarget,
                        n = e.relatedTarget;
                    if (n && t.contains) n = t.contains(n);
                    else
                        for (; n && n !== t;) n = n.parentNode;
                    n || ((e = fo(e || d.event)).type = "mouseout" === e.type ? "mouseleave" : "mouseenter", e.target = t, f.executeHandlers(e, i))
                }), f.hasFocusIn || "focusin" !== u && "focusout" !== u || (l = !0, s = "focusin" === u ? "focus" : "blur", c = function(e) {
                    (e = fo(e || d.event)).type = "focus" === e.type ? "focusin" : "focusout", f.executeHandlers(e, i)
                }), (a = f.events[i][u]) ? "ready" === u && f.domLoaded ? n(fo({
                    type: u
                })) : a.push({
                    func: n,
                    scope: r
                }) : (f.events[i][u] = a = [{
                    func: n,
                    scope: r
                }], a.fakeName = s, a.capture = l, a.nativeHandler = c, "ready" === u ? function(e, t, n) {
                    var r, o = e.document,
                        i = {
                            type: "ready"
                        };
                    n.domLoaded ? t(i) : (r = function() {
                        lo(e, "DOMContentLoaded", r), lo(e, "load", r), n.domLoaded || (n.domLoaded = !0, t(i)), e = null
                    }, "complete" === o.readyState || "interactive" === o.readyState && o.body ? r() : co(e, "DOMContentLoaded", r), n.domLoaded || co(e, "load", r))
                }(e, c, f) : co(e, s || u, c, l)));
                return e = a = null, n
            }
        }, li.prototype.unbind = function(n, e, t) {
            var r, o, i;
            if (!n || 3 === n.nodeType || 8 === n.nodeType) return this;
            var a = n[this.expando];
            if (a) {
                if (i = this.events[a], e) {
                    for (var u, s, c, l, f = e.split(" "), d = f.length; d--;)
                        if (l = i[o = f[d]]) {
                            if (t)
                                for (r = l.length; r--;) l[r].func === t && (u = l.nativeHandler, s = l.fakeName, c = l.capture, (l = l.slice(0, r).concat(l.slice(r + 1))).nativeHandler = u, l.fakeName = s, l.capture = c, i[o] = l);
                            t && 0 !== l.length || (delete i[o], lo(n, l.fakeName || o, l.nativeHandler, l.capture))
                        }
                } else ne(i, function(e, t) {
                    lo(n, e.fakeName || t, e.nativeHandler, e.capture)
                }), i = {};
                for (o in i)
                    if (Ee(i, o)) return this;
                delete this.events[a];
                try {
                    delete n[this.expando]
                } catch (e) {
                    n[this.expando] = null
                }
            }
            return this
        }, li.prototype.fire = function(e, t, n) {
            var r;
            if (!e || 3 === e.nodeType || 8 === e.nodeType) return this;
            for (var o = fo({
                    type: t,
                    target: e
                }, n);
                (r = e[this.expando]) && this.executeHandlers(o, r), (e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow) && !o.isPropagationStopped(););
            return this
        }, li.prototype.clean = function(e) {
            var t, n;
            if (!e || 3 === e.nodeType || 8 === e.nodeType) return this;
            if (e[this.expando] && this.unbind(e), (e = e.getElementsByTagName ? e : e.document) && e.getElementsByTagName)
                for (this.unbind(e), t = (n = e.getElementsByTagName("*")).length; t--;)(e = n[t])[this.expando] && this.unbind(e);
            return this
        }, li.prototype.destroy = function() {
            this.events = {}
        }, li.prototype.cancel = function(e) {
            return e && (e.preventDefault(), e.stopImmediatePropagation()), !1
        }, li.prototype.executeHandlers = function(e, t) {
            var n = this.events[t],
                r = n && n[e.type];
            if (r)
                for (var o = 0, i = r.length; o < i; o++) {
                    var a = r[o];
                    if (a && !1 === a.func.call(a.scope, e) && e.preventDefault(), e.isImmediatePropagationStopped()) return
                }
        }, li.Event = new li, li);

    function li() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = "mce-data-" + (+new Date).toString(32), this.hasMouseEnterLeave = "onmouseenter" in document.documentElement, this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1
    }

    function fi(e, t, n) {
        var r = "0x" + t - 65536;
        return r != r || n ? t : r < 0 ? String.fromCharCode(65536 + r) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
    }
    var di, mi, gi, pi, hi, vi, bi, yi, Ci, xi, wi, Si, Ni, Ei, ki, _i, Ai, Ri = "sizzle" + -new Date,
        Di = window.document,
        Ti = 0,
        Oi = 0,
        Bi = la(),
        Pi = la(),
        Li = la(),
        Ii = function(e, t) {
            return e === t && (xi = !0), 0
        },
        Mi = "undefined",
        Fi = {}.hasOwnProperty,
        Ui = [],
        zi = Ui.pop,
        Hi = Ui.push,
        ji = Ui.push,
        Vi = Ui.slice,
        qi = Ui.indexOf || function(e) {
            for (var t = 0, n = this.length; t < n; t++)
                if (this[t] === e) return t;
            return -1
        },
        $i = "[\\x20\\t\\r\\n\\f]",
        Wi = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        Ki = "\\[" + $i + "*(" + Wi + ")(?:" + $i + "*([*^$|!~]?=)" + $i + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + Wi + "))|)" + $i + "*\\]",
        Xi = ":(" + Wi + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + Ki + ")*)|.*)\\)|)",
        Yi = new RegExp("^" + $i + "+|((?:^|[^\\\\])(?:\\\\.)*)" + $i + "+$", "g"),
        Gi = new RegExp("^" + $i + "*," + $i + "*"),
        Ji = new RegExp("^" + $i + "*([>+~]|" + $i + ")" + $i + "*"),
        Qi = new RegExp("=" + $i + "*([^\\]'\"]*?)" + $i + "*\\]", "g"),
        Zi = new RegExp(Xi),
        ea = new RegExp("^" + Wi + "$"),
        ta = {
            ID: new RegExp("^#(" + Wi + ")"),
            CLASS: new RegExp("^\\.(" + Wi + ")"),
            TAG: new RegExp("^(" + Wi + "|[*])"),
            ATTR: new RegExp("^" + Ki),
            PSEUDO: new RegExp("^" + Xi),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + $i + "*(even|odd|(([+-]|)(\\d*)n|)" + $i + "*(?:([+-]|)" + $i + "*(\\d+)|))" + $i + "*\\)|)", "i"),
            bool: new RegExp("^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$", "i"),
            needsContext: new RegExp("^" + $i + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + $i + "*((?:-\\d)?\\d*)" + $i + "*\\)|)(?=[^-]|$)", "i")
        },
        na = /^(?:input|select|textarea|button)$/i,
        ra = /^h\d$/i,
        oa = /^[^{]+\{\s*\[native \w/,
        ia = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        aa = /[+~]/,
        ua = /'|\\/g,
        sa = new RegExp("\\\\([\\da-f]{1,6}" + $i + "?|(" + $i + ")|.)", "ig");
    try {
        ji.apply(Ui = Vi.call(Di.childNodes), Di.childNodes), Ui[Di.childNodes.length].nodeType
    } catch (e) {
        ji = {
            apply: Ui.length ? function(e, t) {
                Hi.apply(e, Vi.call(t))
            } : function(e, t) {
                for (var n = e.length, r = 0; e[n++] = t[r++];);
                e.length = n - 1
            }
        }
    }
    var ca = function(e, t, n, r) {
        var o, i, a, u, s, c, l, f, d, m;
        if ((t ? t.ownerDocument || t : Di) !== Si && wi(t), n = n || [], !e || "string" != typeof e) return n;
        if (1 !== (u = (t = t || Si).nodeType) && 9 !== u) return [];
        if (Ei && !r) {
            if (o = ia.exec(e))
                if (a = o[1]) {
                    if (9 === u) {
                        if (!(i = t.getElementById(a)) || !i.parentNode) return n;
                        if (i.id === a) return n.push(i), n
                    } else if (t.ownerDocument && (i = t.ownerDocument.getElementById(a)) && Ai(t, i) && i.id === a) return n.push(i), n
                } else {
                    if (o[2]) return ji.apply(n, t.getElementsByTagName(e)), n;
                    if ((a = o[3]) && di.getElementsByClassName) return ji.apply(n, t.getElementsByClassName(a)), n
                } if (di.qsa && (!ki || !ki.test(e))) {
                if (f = l = Ri, d = t, m = 9 === u && e, 1 === u && "object" !== t.nodeName.toLowerCase()) {
                    for (c = hi(e), (l = t.getAttribute("id")) ? f = l.replace(ua, "\\$&") : t.setAttribute("id", f), f = "[id='" + f + "'] ", s = c.length; s--;) c[s] = f + ha(c[s]);
                    d = aa.test(e) && ga(t.parentNode) || t, m = c.join(",")
                }
                if (m) try {
                    return ji.apply(n, d.querySelectorAll(m)), n
                } catch (e) {} finally {
                    l || t.removeAttribute("id")
                }
            }
        }
        return bi(e.replace(Yi, "$1"), t, n, r)
    };

    function la() {
        var n = [];

        function r(e, t) {
            return n.push(e + " ") > mi.cacheLength && delete r[n.shift()], r[e + " "] = t
        }
        return r
    }

    function fa(e) {
        return e[Ri] = !0, e
    }

    function da(e, t) {
        var n = t && e,
            r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || 1 << 31) - (~e.sourceIndex || 1 << 31);
        if (r) return r;
        if (n)
            for (; n = n.nextSibling;)
                if (n === t) return -1;
        return e ? 1 : -1
    }

    function ma(a) {
        return fa(function(i) {
            return i = +i, fa(function(e, t) {
                for (var n, r = a([], e.length, i), o = r.length; o--;) e[n = r[o]] && (e[n] = !(t[n] = e[n]))
            })
        })
    }

    function ga(e) {
        return e && typeof e.getElementsByTagName != Mi && e
    }

    function pa() {}

    function ha(e) {
        for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
        return r
    }

    function va(a, e, t) {
        var u = e.dir,
            s = t && "parentNode" === u,
            c = Oi++;
        return e.first ? function(e, t, n) {
            for (; e = e[u];)
                if (1 === e.nodeType || s) return a(e, t, n)
        } : function(e, t, n) {
            var r, o, i = [Ti, c];
            if (n) {
                for (; e = e[u];)
                    if ((1 === e.nodeType || s) && a(e, t, n)) return !0
            } else
                for (; e = e[u];)
                    if (1 === e.nodeType || s) {
                        if ((r = (o = e[Ri] || (e[Ri] = {}))[u]) && r[0] === Ti && r[1] === c) return i[2] = r[2];
                        if ((o[u] = i)[2] = a(e, t, n)) return !0
                    }
        }
    }

    function ba(o) {
        return 1 < o.length ? function(e, t, n) {
            for (var r = o.length; r--;)
                if (!o[r](e, t, n)) return !1;
            return !0
        } : o[0]
    }

    function ya(e, t, n, r, o) {
        for (var i, a = [], u = 0, s = e.length, c = null != t; u < s; u++)(i = e[u]) && (n && !n(i, r, o) || (a.push(i), c && t.push(u)));
        return a
    }

    function Ca(e) {
        return void 0 !== e
    }

    function xa(e) {
        return "string" == typeof e
    }

    function wa(e, t) {
        var n, r = (t = t || Ra).createElement("div"),
            o = t.createDocumentFragment();
        for (r.innerHTML = e; n = r.firstChild;) o.appendChild(n);
        return o
    }

    function Sa(e, t) {
        return e && t && -1 !== (" " + e.className + " ").indexOf(" " + t + " ")
    }

    function Na(e, t, n) {
        var r, o;
        return t = Ya(t)[0], e.each(function() {
            n && r === this.parentNode || (r = this.parentNode, o = t.cloneNode(!1), this.parentNode.insertBefore(o, this)), o.appendChild(this)
        }), e
    }

    function Ea(e, t) {
        return new Ya.fn.init(e, t)
    }

    function ka(e) {
        return null == e ? "" : ("" + e).replace(ja, "")
    }

    function _a(e, t) {
        var n, r, o, i;
        if (e)
            if (void 0 === (n = e.length)) {
                for (r in e)
                    if (e.hasOwnProperty(r) && (i = e[r], !1 === t.call(i, r, i))) break
            } else
                for (o = 0; o < n && (i = e[o], !1 !== t.call(i, o, i)); o++);
        return e
    }

    function Aa(e, n) {
        var r = [];
        return _a(e, function(e, t) {
            n(t, e) && r.push(t)
        }), r
    }
    di = ca.support = {}, pi = ca.isXML = function(e) {
        var t = e && (e.ownerDocument || e).documentElement;
        return !!t && "HTML" !== t.nodeName
    }, wi = ca.setDocument = function(e) {
        var t, s = e ? e.ownerDocument || e : Di,
            n = s.defaultView;
        return s !== Si && 9 === s.nodeType && s.documentElement ? (Ni = (Si = s).documentElement, Ei = !pi(s), n && n !== function(e) {
            try {
                return e.top
            } catch (e) {}
            return null
        }(n) && (n.addEventListener ? n.addEventListener("unload", function() {
            wi()
        }, !1) : n.attachEvent && n.attachEvent("onunload", function() {
            wi()
        })), di.attributes = !0, di.getElementsByTagName = !0, di.getElementsByClassName = oa.test(s.getElementsByClassName), di.getById = !0, mi.find.ID = function(e, t) {
            if (typeof t.getElementById != Mi && Ei) {
                var n = t.getElementById(e);
                return n && n.parentNode ? [n] : []
            }
        }, mi.filter.ID = function(e) {
            var t = e.replace(sa, fi);
            return function(e) {
                return e.getAttribute("id") === t
            }
        }, mi.find.TAG = di.getElementsByTagName ? function(e, t) {
            if (typeof t.getElementsByTagName != Mi) return t.getElementsByTagName(e)
        } : function(e, t) {
            var n, r = [],
                o = 0,
                i = t.getElementsByTagName(e);
            if ("*" !== e) return i;
            for (; n = i[o++];) 1 === n.nodeType && r.push(n);
            return r
        }, mi.find.CLASS = di.getElementsByClassName && function(e, t) {
            if (Ei) return t.getElementsByClassName(e)
        }, _i = [], ki = [], di.disconnectedMatch = !0, ki = ki.length && new RegExp(ki.join("|")), _i = _i.length && new RegExp(_i.join("|")), t = oa.test(Ni.compareDocumentPosition), Ai = t || oa.test(Ni.contains) ? function(e, t) {
            var n = 9 === e.nodeType ? e.documentElement : e,
                r = t && t.parentNode;
            return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
        } : function(e, t) {
            if (t)
                for (; t = t.parentNode;)
                    if (t === e) return !0;
            return !1
        }, Ii = t ? function(e, t) {
            return e === t ? (xi = !0, 0) : (n = !e.compareDocumentPosition - !t.compareDocumentPosition) || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !di.sortDetached && t.compareDocumentPosition(e) === n ? e === s || e.ownerDocument === Di && Ai(Di, e) ? -1 : t === s || t.ownerDocument === Di && Ai(Di, t) ? 1 : Ci ? qi.call(Ci, e) - qi.call(Ci, t) : 0 : 4 & n ? -1 : 1);
            var n
        } : function(e, t) {
            if (e === t) return xi = !0, 0;
            var n, r = 0,
                o = e.parentNode,
                i = t.parentNode,
                a = [e],
                u = [t];
            if (!o || !i) return e === s ? -1 : t === s ? 1 : o ? -1 : i ? 1 : Ci ? qi.call(Ci, e) - qi.call(Ci, t) : 0;
            if (o === i) return da(e, t);
            for (n = e; n = n.parentNode;) a.unshift(n);
            for (n = t; n = n.parentNode;) u.unshift(n);
            for (; a[r] === u[r];) r++;
            return r ? da(a[r], u[r]) : a[r] === Di ? -1 : u[r] === Di ? 1 : 0
        }, s) : Si
    }, ca.matches = function(e, t) {
        return ca(e, null, null, t)
    }, ca.matchesSelector = function(e, t) {
        if ((e.ownerDocument || e) !== Si && wi(e), t = t.replace(Qi, "='$1']"), di.matchesSelector && Ei && (!_i || !_i.test(t)) && (!ki || !ki.test(t))) try {
            var n = (void 0).call(e, t);
            if (n || di.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
        } catch (e) {}
        return 0 < ca(t, Si, null, [e]).length
    }, ca.contains = function(e, t) {
        return (e.ownerDocument || e) !== Si && wi(e), Ai(e, t)
    }, ca.attr = function(e, t) {
        (e.ownerDocument || e) !== Si && wi(e);
        var n = mi.attrHandle[t.toLowerCase()],
            r = n && Fi.call(mi.attrHandle, t.toLowerCase()) ? n(e, t, !Ei) : void 0;
        return void 0 !== r ? r : di.attributes || !Ei ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
    }, ca.error = function(e) {
        throw new Error("Syntax error, unrecognized expression: " + e)
    }, ca.uniqueSort = function(e) {
        var t, n = [],
            r = 0,
            o = 0;
        if (xi = !di.detectDuplicates, Ci = !di.sortStable && e.slice(0), e.sort(Ii), xi) {
            for (; t = e[o++];) t === e[o] && (r = n.push(o));
            for (; r--;) e.splice(n[r], 1)
        }
        return Ci = null, e
    }, gi = ca.getText = function(e) {
        var t, n = "",
            r = 0,
            o = e.nodeType;
        if (o) {
            if (1 === o || 9 === o || 11 === o) {
                if ("string" == typeof e.textContent) return e.textContent;
                for (e = e.firstChild; e; e = e.nextSibling) n += gi(e)
            } else if (3 === o || 4 === o) return e.nodeValue
        } else
            for (; t = e[r++];) n += gi(t);
        return n
    }, (mi = ca.selectors = {
        cacheLength: 50,
        createPseudo: fa,
        match: ta,
        attrHandle: {},
        find: {},
        relative: {
            ">": {
                dir: "parentNode",
                first: !0
            },
            " ": {
                dir: "parentNode"
            },
            "+": {
                dir: "previousSibling",
                first: !0
            },
            "~": {
                dir: "previousSibling"
            }
        },
        preFilter: {
            ATTR: function(e) {
                return e[1] = e[1].replace(sa, fi), e[3] = (e[3] || e[4] || e[5] || "").replace(sa, fi), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
            },
            CHILD: function(e) {
                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || ca.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ca.error(e[0]), e
            },
            PSEUDO: function(e) {
                var t, n = !e[6] && e[2];
                return ta.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && Zi.test(n) && (t = hi(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
            }
        },
        filter: {
            TAG: function(e) {
                var t = e.replace(sa, fi).toLowerCase();
                return "*" === e ? function() {
                    return !0
                } : function(e) {
                    return e.nodeName && e.nodeName.toLowerCase() === t
                }
            },
            CLASS: function(e) {
                var t = Bi[e + " "];
                return t || (t = new RegExp("(^|" + $i + ")" + e + "(" + $i + "|$)")) && Bi(e, function(e) {
                    return t.test("string" == typeof e.className && e.className || typeof e.getAttribute != Mi && e.getAttribute("class") || "")
                })
            },
            ATTR: function(n, r, o) {
                return function(e) {
                    var t = ca.attr(e, n);
                    return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === o : "!=" === r ? t !== o : "^=" === r ? o && 0 === t.indexOf(o) : "*=" === r ? o && -1 < t.indexOf(o) : "$=" === r ? o && t.slice(-o.length) === o : "~=" === r ? -1 < (" " + t + " ").indexOf(o) : "|=" === r && (t === o || t.slice(0, o.length + 1) === o + "-"))
                }
            },
            CHILD: function(m, e, t, g, p) {
                var h = "nth" !== m.slice(0, 3),
                    v = "last" !== m.slice(-4),
                    b = "of-type" === e;
                return 1 === g && 0 === p ? function(e) {
                    return !!e.parentNode
                } : function(e, t, n) {
                    var r, o, i, a, u, s, c = h != v ? "nextSibling" : "previousSibling",
                        l = e.parentNode,
                        f = b && e.nodeName.toLowerCase(),
                        d = !n && !b;
                    if (l) {
                        if (h) {
                            for (; c;) {
                                for (i = e; i = i[c];)
                                    if (b ? i.nodeName.toLowerCase() === f : 1 === i.nodeType) return !1;
                                s = c = "only" === m && !s && "nextSibling"
                            }
                            return !0
                        }
                        if (s = [v ? l.firstChild : l.lastChild], v && d) {
                            for (u = (r = (o = l[Ri] || (l[Ri] = {}))[m] || [])[0] === Ti && r[1], a = r[0] === Ti && r[2], i = u && l.childNodes[u]; i = ++u && i && i[c] || (a = u = 0) || s.pop();)
                                if (1 === i.nodeType && ++a && i === e) {
                                    o[m] = [Ti, u, a];
                                    break
                                }
                        } else if (d && (r = (e[Ri] || (e[Ri] = {}))[m]) && r[0] === Ti) a = r[1];
                        else
                            for (;
                                (i = ++u && i && i[c] || (a = u = 0) || s.pop()) && ((b ? i.nodeName.toLowerCase() !== f : 1 !== i.nodeType) || !++a || (d && ((i[Ri] || (i[Ri] = {}))[m] = [Ti, a]), i !== e)););
                        return (a -= p) === g || a % g == 0 && 0 <= a / g
                    }
                }
            },
            PSEUDO: function(e, i) {
                var t, a = mi.pseudos[e] || mi.setFilters[e.toLowerCase()] || ca.error("unsupported pseudo: " + e);
                return a[Ri] ? a(i) : 1 < a.length ? (t = [e, e, "", i], mi.setFilters.hasOwnProperty(e.toLowerCase()) ? fa(function(e, t) {
                    for (var n, r = a(e, i), o = r.length; o--;) e[n = qi.call(e, r[o])] = !(t[n] = r[o])
                }) : function(e) {
                    return a(e, 0, t)
                }) : a
            }
        },
        pseudos: {
            not: fa(function(e) {
                var r = [],
                    o = [],
                    u = vi(e.replace(Yi, "$1"));
                return u[Ri] ? fa(function(e, t, n, r) {
                    for (var o, i = u(e, null, r, []), a = e.length; a--;)(o = i[a]) && (e[a] = !(t[a] = o))
                }) : function(e, t, n) {
                    return r[0] = e, u(r, null, n, o), r[0] = null, !o.pop()
                }
            }),
            has: fa(function(t) {
                return function(e) {
                    return 0 < ca(t, e).length
                }
            }),
            contains: fa(function(t) {
                return t = t.replace(sa, fi),
                    function(e) {
                        return -1 < (e.textContent || e.innerText || gi(e)).indexOf(t)
                    }
            }),
            lang: fa(function(n) {
                return ea.test(n || "") || ca.error("unsupported lang: " + n), n = n.replace(sa, fi).toLowerCase(),
                    function(e) {
                        var t;
                        do {
                            if (t = Ei ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1
                    }
            }),
            target: function(e) {
                var t = window.location && window.location.hash;
                return t && t.slice(1) === e.id
            },
            root: function(e) {
                return e === Ni
            },
            focus: function(e) {
                return e === Si.activeElement && (!Si.hasFocus || Si.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
            },
            enabled: function(e) {
                return !1 === e.disabled
            },
            disabled: function(e) {
                return !0 === e.disabled
            },
            checked: function(e) {
                var t = e.nodeName.toLowerCase();
                return "input" === t && !!e.checked || "option" === t && !!e.selected
            },
            selected: function(e) {
                return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
            },
            empty: function(e) {
                for (e = e.firstChild; e; e = e.nextSibling)
                    if (e.nodeType < 6) return !1;
                return !0
            },
            parent: function(e) {
                return !mi.pseudos.empty(e)
            },
            header: function(e) {
                return ra.test(e.nodeName)
            },
            input: function(e) {
                return na.test(e.nodeName)
            },
            button: function(e) {
                var t = e.nodeName.toLowerCase();
                return "input" === t && "button" === e.type || "button" === t
            },
            text: function(e) {
                var t;
                return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
            },
            first: ma(function() {
                return [0]
            }),
            last: ma(function(e, t) {
                return [t - 1]
            }),
            eq: ma(function(e, t, n) {
                return [n < 0 ? n + t : n]
            }),
            even: ma(function(e, t) {
                for (var n = 0; n < t; n += 2) e.push(n);
                return e
            }),
            odd: ma(function(e, t) {
                for (var n = 1; n < t; n += 2) e.push(n);
                return e
            }),
            lt: ma(function(e, t, n) {
                for (var r = n < 0 ? n + t : n; 0 <= --r;) e.push(r);
                return e
            }),
            gt: ma(function(e, t, n) {
                for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
                return e
            })
        }
    }).pseudos.nth = mi.pseudos.eq, Y(["radio", "checkbox", "file", "password", "image"], function(e) {
        var t;
        mi.pseudos[e] = (t = e, function(e) {
            return "input" === e.nodeName.toLowerCase() && e.type === t
        })
    }), Y(["submit", "reset"], function(e) {
        var n;
        mi.pseudos[e] = (n = e, function(e) {
            var t = e.nodeName.toLowerCase();
            return ("input" === t || "button" === t) && e.type === n
        })
    }), pa.prototype = mi.filters = mi.pseudos, mi.setFilters = new pa, hi = ca.tokenize = function(e, t) {
        var n, r, o, i, a, u, s, c = Pi[e + " "];
        if (c) return t ? 0 : c.slice(0);
        for (a = e, u = [], s = mi.preFilter; a;) {
            for (i in n && !(r = Gi.exec(a)) || (r && (a = a.slice(r[0].length) || a), u.push(o = [])), n = !1, (r = Ji.exec(a)) && (n = r.shift(), o.push({
                    value: n,
                    type: r[0].replace(Yi, " ")
                }), a = a.slice(n.length)), mi.filter) mi.filter.hasOwnProperty(i) && (!(r = ta[i].exec(a)) || s[i] && !(r = s[i](r)) || (n = r.shift(), o.push({
                value: n,
                type: i,
                matches: r
            }), a = a.slice(n.length)));
            if (!n) break
        }
        return t ? a.length : a ? ca.error(e) : Pi(e, u).slice(0)
    }, vi = ca.compile = function(e, t) {
        var n, h, v, b, y, r = [],
            o = [],
            i = Li[e + " "];
        if (!i) {
            for (n = (t = t || hi(e)).length; n--;)((i = function e(t) {
                for (var o, n, r, i = t.length, a = mi.relative[t[0].type], u = a || mi.relative[" "], s = a ? 1 : 0, c = va(function(e) {
                        return e === o
                    }, u, !0), l = va(function(e) {
                        return -1 < qi.call(o, e)
                    }, u, !0), f = [function(e, t, n) {
                        var r = !a && (n || t !== yi) || ((o = t).nodeType ? c : l)(e, t, n);
                        return o = null, r
                    }]; s < i; s++)
                    if (n = mi.relative[t[s].type]) f = [va(ba(f), n)];
                    else {
                        if ((n = mi.filter[t[s].type].apply(null, t[s].matches))[Ri]) {
                            for (r = ++s; r < i && !mi.relative[t[r].type]; r++);
                            return function e(m, g, p, h, v, t) {
                                return h && !h[Ri] && (h = e(h)), v && !v[Ri] && (v = e(v, t)), fa(function(e, t, n, r) {
                                    var o, i, a, u = [],
                                        s = [],
                                        c = t.length,
                                        l = e || function(e, t, n) {
                                            for (var r = 0, o = t.length; r < o; r++) ca(e, t[r], n);
                                            return n
                                        }(g || "*", n.nodeType ? [n] : n, []),
                                        f = !m || !e && g ? l : ya(l, u, m, n, r),
                                        d = p ? v || (e ? m : c || h) ? [] : t : f;
                                    if (p && p(f, d, n, r), h)
                                        for (o = ya(d, s), h(o, [], n, r), i = o.length; i--;)(a = o[i]) && (d[s[i]] = !(f[s[i]] = a));
                                    if (e) {
                                        if (v || m) {
                                            if (v) {
                                                for (o = [], i = d.length; i--;)(a = d[i]) && o.push(f[i] = a);
                                                v(null, d = [], o, r)
                                            }
                                            for (i = d.length; i--;)(a = d[i]) && -1 < (o = v ? qi.call(e, a) : u[i]) && (e[o] = !(t[o] = a))
                                        }
                                    } else d = ya(d === t ? d.splice(c, d.length) : d), v ? v(null, t, d, r) : ji.apply(t, d)
                                })
                            }(1 < s && ba(f), 1 < s && ha(t.slice(0, s - 1).concat({
                                value: " " === t[s - 2].type ? "*" : ""
                            })).replace(Yi, "$1"), n, s < r && e(t.slice(s, r)), r < i && e(t = t.slice(r)), r < i && ha(t))
                        }
                        f.push(n)
                    } return ba(f)
            }(t[n]))[Ri] ? r : o).push(i);
            (i = Li(e, (h = o, b = 0 < (v = r).length, y = 0 < h.length, b ? fa(a) : a))).selector = e
        }

        function a(e, t, n, r, o) {
            var i, a, u, s = 0,
                c = "0",
                l = e && [],
                f = [],
                d = yi,
                m = e || y && mi.find.TAG("*", o),
                g = Ti += null == d ? 1 : Math.random() || .1,
                p = m.length;
            for (o && (yi = t !== Si && t); c !== p && null != (i = m[c]); c++) {
                if (y && i) {
                    for (a = 0; u = h[a++];)
                        if (u(i, t, n)) {
                            r.push(i);
                            break
                        } o && (Ti = g)
                }
                b && ((i = !u && i) && s--, e && l.push(i))
            }
            if (s += c, b && c !== s) {
                for (a = 0; u = v[a++];) u(l, f, t, n);
                if (e) {
                    if (0 < s)
                        for (; c--;) l[c] || f[c] || (f[c] = zi.call(r));
                    f = ya(f)
                }
                ji.apply(r, f), o && !e && 0 < f.length && 1 < s + v.length && ca.uniqueSort(r)
            }
            return o && (Ti = g, yi = d), l
        }
        return i
    }, bi = ca.select = function(e, t, n, r) {
        var o, i, a, u, s, c = "function" == typeof e && e,
            l = !r && hi(e = c.selector || e);
        if (n = n || [], 1 === l.length) {
            if (2 < (i = l[0] = l[0].slice(0)).length && "ID" === (a = i[0]).type && di.getById && 9 === t.nodeType && Ei && mi.relative[i[1].type]) {
                if (!(t = (mi.find.ID(a.matches[0].replace(sa, fi), t) || [])[0])) return n;
                c && (t = t.parentNode), e = e.slice(i.shift().value.length)
            }
            for (o = ta.needsContext.test(e) ? 0 : i.length; o-- && (a = i[o], !mi.relative[u = a.type]);)
                if ((s = mi.find[u]) && (r = s(a.matches[0].replace(sa, fi), aa.test(i[0].type) && ga(t.parentNode) || t))) {
                    if (i.splice(o, 1), !(e = r.length && ha(i))) return ji.apply(n, r), n;
                    break
                }
        }
        return (c || vi(e, l))(r, t, !Ei, n, aa.test(e) && ga(t.parentNode) || t), n
    }, di.sortStable = Ri.split("").sort(Ii).join("") === Ri, di.detectDuplicates = !!xi, wi(), di.sortDetached = !0;
    var Ra = document,
        Da = Array.prototype.push,
        Ta = Array.prototype.slice,
        Oa = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
        Ba = ci.Event,
        Pa = Nt.makeMap("children,contents,next,prev"),
        La = function(e, t, n, r) {
            var o;
            if (xa(t)) t = wa(t, Va(e[0]));
            else if (t.length && !t.nodeType) {
                if (t = Ya.makeArray(t), r)
                    for (o = t.length - 1; 0 <= o; o--) La(e, t[o], n, r);
                else
                    for (o = 0; o < t.length; o++) La(e, t[o], n, r);
                return e
            }
            if (t.nodeType)
                for (o = e.length; o--;) n.call(e[o], t);
            return e
        },
        Ia = Nt.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " "),
        Ma = Nt.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " "),
        Fa = {
            for: "htmlFor",
            class: "className",
            readonly: "readOnly"
        },
        Ua = {
            float: "cssFloat"
        },
        za = {},
        Ha = {},
        ja = /^\s*|\s*$/g,
        Va = function(e) {
            return e ? 9 === e.nodeType ? e : e.ownerDocument : Ra
        };

    function qa(e, t, n) {
        var r = [],
            o = e[t];
        for ("string" != typeof n && n instanceof Ya && (n = n[0]); o && 9 !== o.nodeType;) {
            if (void 0 !== n) {
                if (o === n) break;
                if ("string" == typeof n && Ya(o).is(n)) break
            }
            1 === o.nodeType && r.push(o), o = o[t]
        }
        return r
    }

    function $a(e, t, n, r) {
        var o = [];
        for (r instanceof Ya && (r = r[0]); e; e = e[t])
            if (!n || e.nodeType === n) {
                if (void 0 !== r) {
                    if (e === r) break;
                    if ("string" == typeof r && Ya(e).is(r)) break
                }
                o.push(e)
            } return o
    }

    function Wa(e, t, n) {
        for (e = e[t]; e; e = e[t])
            if (e.nodeType === n) return e;
        return null
    }

    function Ka(e, t) {
        var n = t.attr("style"),
            r = e.serialize(e.parse(n), t[0].nodeName) || null;
        t.attr("data-mce-style", r)
    }

    function Xa(e, t) {
        var n, r, o = 0;
        if (e)
            for (n = e.nodeType, e = e.previousSibling; e; e = e.previousSibling) r = e.nodeType, (!t || 3 !== r || r !== n && e.nodeValue.length) && (o++, n = r);
        return o
    }
    Ea.fn = Ea.prototype = {
        constructor: Ea,
        selector: "",
        context: null,
        length: 0,
        init: function(e, t) {
            var n, r, o = this;
            if (!e) return o;
            if (e.nodeType) return o.context = o[0] = e, o.length = 1, o;
            if (t && t.nodeType) o.context = t;
            else {
                if (t) return Ya(e).attr(t);
                o.context = t = document
            }
            if (xa(e)) {
                if (!(n = "<" === (o.selector = e).charAt(0) && ">" === e.charAt(e.length - 1) && 3 <= e.length ? [null, e, null] : Oa.exec(e))) return Ya(t).find(e);
                if (n[1])
                    for (r = wa(e, Va(t)).firstChild; r;) Da.call(o, r), r = r.nextSibling;
                else {
                    if (!(r = Va(t).getElementById(n[2]))) return o;
                    if (r.id !== n[2]) return o.find(e);
                    o.length = 1, o[0] = r
                }
            } else this.add(e, !1);
            return o
        },
        toArray: function() {
            return Nt.toArray(this)
        },
        add: function(e, t) {
            var n, r;
            if (xa(e)) return this.add(Ya(e));
            if (!1 !== t)
                for (n = Ya.unique(this.toArray().concat(Ya.makeArray(e))), this.length = n.length, r = 0; r < n.length; r++) this[r] = n[r];
            else Da.apply(this, Ya.makeArray(e));
            return this
        },
        attr: function(t, n) {
            var e, r = this;
            if ("object" == typeof t) _a(t, function(e, t) {
                r.attr(e, t)
            });
            else {
                if (!Ca(n)) {
                    if (r[0] && 1 === r[0].nodeType) {
                        if ((e = za[t]) && e.get) return e.get(r[0], t);
                        if (Ma[t]) return r.prop(t) ? t : void 0;
                        null === (n = r[0].getAttribute(t, 2)) && (n = void 0)
                    }
                    return n
                }
                this.each(function() {
                    var e;
                    1 === this.nodeType && ((e = za[t]) && e.set ? e.set(this, n) : null === n ? this.removeAttribute(t, 2) : this.setAttribute(t, n, 2))
                })
            }
            return r
        },
        removeAttr: function(e) {
            return this.attr(e, null)
        },
        prop: function(e, t) {
            var n = this;
            if ("object" == typeof(e = Fa[e] || e)) _a(e, function(e, t) {
                n.prop(e, t)
            });
            else {
                if (!Ca(t)) return n[0] && n[0].nodeType && e in n[0] ? n[0][e] : t;
                this.each(function() {
                    1 === this.nodeType && (this[e] = t)
                })
            }
            return n
        },
        css: function(t, n) {
            function e(e) {
                return e.replace(/-(\D)/g, function(e, t) {
                    return t.toUpperCase()
                })
            }

            function r(e) {
                return e.replace(/[A-Z]/g, function(e) {
                    return "-" + e
                })
            }
            var o, i, a = this;
            if ("object" == typeof t) _a(t, function(e, t) {
                a.css(e, t)
            });
            else if (Ca(n)) t = e(t), "number" != typeof n || Ia[t] || (n = n.toString() + "px"), a.each(function() {
                var e = this.style;
                if ((i = Ha[t]) && i.set) i.set(this, n);
                else {
                    try {
                        this.style[Ua[t] || t] = n
                    } catch (e) {}
                    null !== n && "" !== n || (e.removeProperty ? e.removeProperty(r(t)) : e.removeAttribute(t))
                }
            });
            else {
                if (o = a[0], (i = Ha[t]) && i.get) return i.get(o);
                if (!o.ownerDocument.defaultView) return o.currentStyle ? o.currentStyle[e(t)] : "";
                try {
                    return o.ownerDocument.defaultView.getComputedStyle(o, null).getPropertyValue(r(t))
                } catch (e) {
                    return
                }
            }
            return a
        },
        remove: function() {
            for (var e, t = this.length; t--;) e = this[t], Ba.clean(e), e.parentNode && e.parentNode.removeChild(e);
            return this
        },
        empty: function() {
            for (var e, t = this.length; t--;)
                for (e = this[t]; e.firstChild;) e.removeChild(e.firstChild);
            return this
        },
        html: function(t) {
            var n;
            if (Ca(t)) {
                n = this.length;
                try {
                    for (; n--;) this[n].innerHTML = t
                } catch (e) {
                    Ya(this[n]).empty().append(t)
                }
                return this
            }
            return this[0] ? this[0].innerHTML : ""
        },
        text: function(e) {
            var t;
            if (Ca(e)) {
                for (t = this.length; t--;) "innerText" in this[t] ? this[t].innerText = e : this[0].textContent = e;
                return this
            }
            return this[0] ? this[0].innerText || this[0].textContent : ""
        },
        append: function() {
            return La(this, arguments, function(e) {
                (1 === this.nodeType || this.host && 1 === this.host.nodeType) && this.appendChild(e)
            })
        },
        prepend: function() {
            return La(this, arguments, function(e) {
                (1 === this.nodeType || this.host && 1 === this.host.nodeType) && this.insertBefore(e, this.firstChild)
            }, !0)
        },
        before: function() {
            return this[0] && this[0].parentNode ? La(this, arguments, function(e) {
                this.parentNode.insertBefore(e, this)
            }) : this
        },
        after: function() {
            return this[0] && this[0].parentNode ? La(this, arguments, function(e) {
                this.parentNode.insertBefore(e, this.nextSibling)
            }, !0) : this
        },
        appendTo: function(e) {
            return Ya(e).append(this), this
        },
        prependTo: function(e) {
            return Ya(e).prepend(this), this
        },
        replaceWith: function(e) {
            return this.before(e).remove()
        },
        wrap: function(e) {
            return Na(this, e)
        },
        wrapAll: function(e) {
            return Na(this, e, !0)
        },
        wrapInner: function(e) {
            return this.each(function() {
                Ya(this).contents().wrapAll(e)
            }), this
        },
        unwrap: function() {
            return this.parent().each(function() {
                Ya(this).replaceWith(this.childNodes)
            })
        },
        clone: function() {
            var e = [];
            return this.each(function() {
                e.push(this.cloneNode(!0))
            }), Ya(e)
        },
        addClass: function(e) {
            return this.toggleClass(e, !0)
        },
        removeClass: function(e) {
            return this.toggleClass(e, !1)
        },
        toggleClass: function(o, i) {
            var e = this;
            return "string" != typeof o || (-1 !== o.indexOf(" ") ? _a(o.split(" "), function() {
                e.toggleClass(this, i)
            }) : e.each(function(e, t) {
                var n, r = Sa(t, o);
                r !== i && (n = t.className, r ? t.className = ka((" " + n + " ").replace(" " + o + " ", " ")) : t.className += n ? " " + o : o)
            })), e
        },
        hasClass: function(e) {
            return Sa(this[0], e)
        },
        each: function(e) {
            return _a(this, e)
        },
        on: function(e, t) {
            return this.each(function() {
                Ba.bind(this, e, t)
            })
        },
        off: function(e, t) {
            return this.each(function() {
                Ba.unbind(this, e, t)
            })
        },
        trigger: function(e) {
            return this.each(function() {
                "object" == typeof e ? Ba.fire(this, e.type, e) : Ba.fire(this, e)
            })
        },
        show: function() {
            return this.css("display", "")
        },
        hide: function() {
            return this.css("display", "none")
        },
        slice: function() {
            return Ya(Ta.apply(this, arguments))
        },
        eq: function(e) {
            return -1 === e ? this.slice(e) : this.slice(e, +e + 1)
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        find: function(e) {
            for (var t = [], n = 0, r = this.length; n < r; n++) Ya.find(e, this[n], t);
            return Ya(t)
        },
        filter: function(n) {
            return Ya("function" == typeof n ? Aa(this.toArray(), function(e, t) {
                return n(t, e)
            }) : Ya.filter(n, this.toArray()))
        },
        closest: function(n) {
            var r = [];
            return n instanceof Ya && (n = n[0]), this.each(function(e, t) {
                for (; t;) {
                    if ("string" == typeof n && Ya(t).is(n)) {
                        r.push(t);
                        break
                    }
                    if (t === n) {
                        r.push(t);
                        break
                    }
                    t = t.parentNode
                }
            }), Ya(r)
        },
        offset: function(e) {
            var t, n, r, o, i = 0,
                a = 0;
            return e ? this.css(e) : ((t = this[0]) && (r = (n = t.ownerDocument).documentElement, t.getBoundingClientRect && (i = (o = t.getBoundingClientRect()).left + (r.scrollLeft || n.body.scrollLeft) - r.clientLeft, a = o.top + (r.scrollTop || n.body.scrollTop) - r.clientTop)), {
                left: i,
                top: a
            })
        },
        push: Da,
        sort: Array.prototype.sort,
        splice: Array.prototype.splice
    }, Nt.extend(Ea, {
        extend: Nt.extend,
        makeArray: function(e) {
            return e && e === e.window || e.nodeType ? [e] : Nt.toArray(e)
        },
        inArray: function(e, t) {
            var n;
            if (t.indexOf) return t.indexOf(e);
            for (n = t.length; n--;)
                if (t[n] === e) return n;
            return -1
        },
        isArray: Nt.isArray,
        each: _a,
        trim: ka,
        grep: Aa,
        find: ca,
        expr: ca.selectors,
        unique: ca.uniqueSort,
        text: ca.getText,
        contains: ca.contains,
        filter: function(e, t, n) {
            var r = t.length;
            for (n && (e = ":not(" + e + ")"); r--;) 1 !== t[r].nodeType && t.splice(r, 1);
            return 1 === t.length ? Ya.find.matchesSelector(t[0], e) ? [t[0]] : [] : Ya.find.matches(e, t)
        }
    }), _a({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents: function(e) {
            return qa(e, "parentNode")
        },
        next: function(e) {
            return Wa(e, "nextSibling", 1)
        },
        prev: function(e) {
            return Wa(e, "previousSibling", 1)
        },
        children: function(e) {
            return $a(e.firstChild, "nextSibling", 1)
        },
        contents: function(e) {
            return Nt.toArray(("iframe" === e.nodeName ? e.contentDocument || e.contentWindow.document : e).childNodes)
        }
    }, function(r, o) {
        Ea.fn[r] = function(t) {
            var n = [];
            this.each(function() {
                var e = o.call(n, this, t, n);
                e && (Ya.isArray(e) ? n.push.apply(n, e) : n.push(e))
            }), 1 < this.length && (Pa[r] || (n = Ya.unique(n)), 0 === r.indexOf("parents") && (n = n.reverse()));
            var e = Ya(n);
            return t ? e.filter(t) : e
        }
    }), _a({
        parentsUntil: function(e, t) {
            return qa(e, "parentNode", t)
        },
        nextUntil: function(e, t) {
            return $a(e, "nextSibling", 1, t).slice(1)
        },
        prevUntil: function(e, t) {
            return $a(e, "previousSibling", 1, t).slice(1)
        }
    }, function(o, i) {
        Ea.fn[o] = function(t, e) {
            var n = [];
            this.each(function() {
                var e = i.call(n, this, t, n);
                e && (Ya.isArray(e) ? n.push.apply(n, e) : n.push(e))
            }), 1 < this.length && (n = Ya.unique(n), 0 !== o.indexOf("parents") && "prevUntil" !== o || (n = n.reverse()));
            var r = Ya(n);
            return e ? r.filter(e) : r
        }
    }), Ea.fn.is = function(e) {
        return !!e && 0 < this.filter(e).length
    }, Ea.fn.init.prototype = Ea.fn, Ea.overrideDefaults = function(n) {
        var r, o = function(e, t) {
            return r = r || n(), 0 === arguments.length && (e = r.element), t = t || r.context, new o.fn.init(e, t)
        };
        return Ya.extend(o, this), o
    }, Ea.attrHooks = za, Ea.cssHooks = Ha;
    var Ya = Ea,
        Ga = Nt.each,
        Ja = Nt.grep,
        Qa = xt.ie,
        Za = /^([a-z0-9],?)+$/i,
        eu = function(a, u) {
            function s(e) {
                return e && a && X(e) ? a.getElementById(e) : e
            }

            function c(e) {
                return H("string" == typeof e ? s(e) : e)
            }

            function r(e, t, n) {
                var r, o, i = c(e);
                return void 0 === (o = i.length ? (r = W[t]) && r.get ? r.get(i, t) : i.attr(t) : o) ? n || "" : o
            }

            function o(e) {
                var t = s(e);
                return t ? t.attributes : []
            }

            function i(e, t, n) {
                "" === n && (n = null);
                var r, o = c(e),
                    i = o.attr(t);
                o.length && ((r = W[t]) && r.set ? r.set(o, n, t) : o.attr(t, n), i !== n && u.onSetAttrib && u.onSetAttrib({
                    attrElm: o,
                    attrName: t,
                    attrValue: n
                }))
            }

            function l() {
                return u.root_element || a.body
            }

            function f(e, t) {
                return function(e, t, n) {
                    var r, o = 0,
                        i = 0,
                        a = e.ownerDocument;
                    if (n = n || e, t) {
                        if (n === e && t.getBoundingClientRect && "static" === wn(Et.fromDom(e), "position")) {
                            var u = t.getBoundingClientRect();
                            return {
                                x: o = u.left + (a.documentElement.scrollLeft || e.scrollLeft) - a.documentElement.clientLeft,
                                y: i = u.top + (a.documentElement.scrollTop || e.scrollTop) - a.documentElement.clientTop
                            }
                        }
                        for (var s = t; s && s !== n && s.nodeType && !kn(s, n);) {
                            var c = s;
                            o += c.offsetLeft || 0, i += c.offsetTop || 0, s = c.offsetParent
                        }
                        for (s = t.parentNode; s && s !== n && s.nodeType && !kn(s, n);) o -= s.scrollLeft || 0, i -= s.scrollTop || 0, s = s.parentNode;
                        i += (r = Et.fromDom(t), er.isFirefox() && "table" === kt(r) ? En(Tn(r)).filter(function(e) {
                            return "caption" === kt(e)
                        }).bind(function(o) {
                            return En(It(o)).map(function(e) {
                                var t = e.dom.offsetTop,
                                    n = o.dom.offsetTop,
                                    r = o.dom.offsetHeight;
                                return t <= n ? -r : 0
                            })
                        }).getOr(0) : 0)
                    }
                    return {
                        x: o,
                        y: i
                    }
                }(a.body, s(e), t)
            }

            function d(e, t, n) {
                var r = c(e);
                return n ? r.css(t) : ("float" === (t = t.replace(/-(\D)/g, function(e, t) {
                    return t.toUpperCase()
                })) && (t = xt.browser.isIE() ? "styleFloat" : "cssFloat"), r[0] && r[0].style ? r[0].style[t] : void 0)
            }

            function m(e) {
                var t = d(e = s(e), "width"),
                    n = d(e, "height");
                return -1 === t.indexOf("px") && (t = 0), -1 === n.indexOf("px") && (n = 0), {
                    w: parseInt(t, 10) || e.offsetWidth || e.clientWidth,
                    h: parseInt(n, 10) || e.offsetHeight || e.clientHeight
                }
            }

            function g(e, t) {
                if (!e) return !1;
                if (!Array.isArray(e)) {
                    if ("*" === t) return 1 === e.nodeType;
                    if (Za.test(t)) {
                        for (var n = t.toLowerCase().split(/,/), r = e.nodeName.toLowerCase(), o = n.length - 1; 0 <= o; o--)
                            if (n[o] === r) return !0;
                        return !1
                    }
                    if (e.nodeType && 1 !== e.nodeType) return !1
                }
                var i = Array.isArray(e) ? e : [e];
                return 0 < ca(t, i[0].ownerDocument || i[0], null, i).length
            }

            function p(e, t, n, r) {
                var o, i = [],
                    a = s(e);
                for (r = void 0 === r, n = n || ("BODY" !== l().nodeName ? l().parentNode : null), Nt.is(t, "string") && (t = "*" === (o = t) ? function(e) {
                        return 1 === e.nodeType
                    } : function(e) {
                        return g(e, o)
                    }); a && !(a === n || K(a.nodeType) || $n(a) || Wn(a));) {
                    if (!t || "function" == typeof t && t(a)) {
                        if (!r) return [a];
                        i.push(a)
                    }
                    a = a.parentNode
                }
                return r ? i : null
            }

            function n(e, t, n) {
                var r = t;
                if (e)
                    for ("string" == typeof t && (r = function(e) {
                            return g(e, t)
                        }), e = e[n]; e; e = e[n])
                        if ("function" == typeof r && r(e)) return e;
                return null
            }

            function h(e, n, r) {
                var o, t = "string" == typeof e ? s(e) : e;
                return !!t && (Nt.isArray(t) && (t.length || 0 === t.length) ? (o = [], Ga(t, function(e, t) {
                    e && o.push(n.call(r, "string" == typeof e ? s(e) : e, t))
                }), o) : n.call(r || this, t))
            }

            function v(e, t) {
                c(e).each(function(e, n) {
                    Ga(t, function(e, t) {
                        i(n, t, e)
                    })
                })
            }

            function b(e, n) {
                var t = c(e);
                Qa ? t.each(function(e, t) {
                    if (!1 !== t.canHaveHTML) {
                        for (; t.firstChild;) t.removeChild(t.firstChild);
                        try {
                            t.innerHTML = "<br>" + n, t.removeChild(t.firstChild)
                        } catch (e) {
                            Ya("<div></div>").html("<br>" + n).contents().slice(1).appendTo(t)
                        }
                        return n
                    }
                }) : t.html(n)
            }

            function y(e, n, r, o, i) {
                return h(e, function(e) {
                    var t = "string" == typeof n ? a.createElement(n) : n;
                    return v(t, r), o && ("string" != typeof o && o.nodeType ? t.appendChild(o) : "string" == typeof o && b(t, o)), i ? t : e.appendChild(t)
                })
            }

            function C(e, t, n) {
                return y(a.createElement(e), e, t, n, !0)
            }

            function x(e, t) {
                var n = c(e);
                return (t ? n.each(function() {
                    for (var e; e = this.firstChild;) 3 === e.nodeType && 0 === e.data.length ? this.removeChild(e) : this.parentNode.insertBefore(e, this)
                }) : n).remove(), 1 < n.length ? n.toArray() : n[0]
            }

            function w(e, t, n) {
                c(e).toggleClass(t, n).each(function() {
                    "" === this.className && Ya(this).attr("class", null)
                })
            }

            function S(t, e, n) {
                return h(e, function(e) {
                    return Nt.is(e, "array") && (t = t.cloneNode(!0)), n && Ga(Ja(e.childNodes), function(e) {
                        t.appendChild(e)
                    }), e.parentNode.replaceChild(t, e)
                })
            }

            function N(e) {
                if (Hn(e)) {
                    var t = "a" === e.nodeName.toLowerCase() && !r(e, "href") && r(e, "id");
                    return r(e, "name") || r(e, "data-mce-bookmark") || t ? 1 : void 0
                }
            }

            function E() {
                return a.createRange()
            }

            function k(e) {
                if (e && Hn(e)) {
                    var t = e.getAttribute("data-mce-contenteditable");
                    return t && "inherit" !== t ? t : "inherit" !== e.contentEditable ? e.contentEditable : null
                }
                return null
            }
            void 0 === u && (u = {});
            var _, A, R, D, e, t, T = {},
                O = window,
                B = {},
                P = 0,
                L = Rr.forElement(Et.fromDom(a), {
                    contentCssCors: u.contentCssCors,
                    referrerPolicy: u.referrerPolicy
                }),
                I = [],
                M = u.schema || oo({}),
                F = ao({
                    url_converter: u.url_converter,
                    url_converter_scope: u.url_converter_scope
                }, u.schema),
                U = u.ownEvents ? new ci : ci.Event,
                z = M.getBlockElements(),
                H = Ya.overrideDefaults(function() {
                    return {
                        context: a,
                        element: $.getRoot()
                    }
                }),
                j = Zo.encodeAllRaw,
                V = function(e, t, n, r) {
                    if (Nt.isArray(e)) {
                        for (var o = e.length, i = []; o--;) i[o] = V(e[o], t, n, r);
                        return i
                    }
                    return !u.collect || e !== a && e !== O || I.push([e, t, n, r]), U.bind(e, t, n, r || $)
                },
                q = function(e, t, n) {
                    if (Nt.isArray(e)) {
                        for (var r = e.length, o = []; r--;) o[r] = q(e[r], t, n);
                        return o
                    }
                    if (0 < I.length && (e === a || e === O))
                        for (r = I.length; r--;) {
                            var i = I[r];
                            e !== i[0] || t && t !== i[1] || n && n !== i[2] || U.unbind(i[0], i[1], i[2])
                        }
                    return U.unbind(e, t, n)
                },
                $ = {
                    doc: a,
                    settings: u,
                    win: O,
                    files: B,
                    stdMode: !0,
                    boxModel: !0,
                    styleSheetLoader: L,
                    boundEvents: I,
                    styles: F,
                    schema: M,
                    events: U,
                    isBlock: function(e) {
                        if ("string" == typeof e) return !!z[e];
                        if (e) {
                            var t = e.nodeType;
                            if (t) return !(1 !== t || !z[e.nodeName])
                        }
                        return !1
                    },
                    $: H,
                    $$: c,
                    root: null,
                    clone: function(t, e) {
                        if (!Qa || 1 !== t.nodeType || e) return t.cloneNode(e);
                        var n = a.createElement(t.nodeName);
                        return Ga(o(t), function(e) {
                            i(n, e.nodeName, r(t, e.nodeName))
                        }), n
                    },
                    getRoot: l,
                    getViewPort: function(e) {
                        var t = tn(e);
                        return {
                            x: t.x,
                            y: t.y,
                            w: t.width,
                            h: t.height
                        }
                    },
                    getRect: function(e) {
                        var t = f(e = s(e)),
                            n = m(e);
                        return {
                            x: t.x,
                            y: t.y,
                            w: n.w,
                            h: n.h
                        }
                    },
                    getSize: m,
                    getParent: function(e, t, n) {
                        var r = p(e, t, n, !1);
                        return r && 0 < r.length ? r[0] : null
                    },
                    getParents: p,
                    get: s,
                    getNext: function(e, t) {
                        return n(e, t, "nextSibling")
                    },
                    getPrev: function(e, t) {
                        return n(e, t, "previousSibling")
                    },
                    select: function(e, t) {
                        return ca(e, s(t) || u.root_element || a, [])
                    },
                    is: g,
                    add: y,
                    create: C,
                    createHTML: function(e, t, n) {
                        var r, o = "";
                        for (r in o += "<" + e, t) se(t, r) && (o += " " + r + '="' + j(t[r]) + '"');
                        return void 0 !== n ? o + ">" + n + "</" + e + ">" : o + " />"
                    },
                    createFragment: function(e) {
                        var t, n = a.createElement("div"),
                            r = a.createDocumentFragment();
                        for (r.appendChild(n), e && (n.innerHTML = e); t = n.firstChild;) r.appendChild(t);
                        return r.removeChild(n), r
                    },
                    remove: x,
                    setStyle: function(e, t, n) {
                        var r = X(t) ? c(e).css(t, n) : c(e).css(t);
                        u.update_styles && Ka(F, r)
                    },
                    getStyle: d,
                    setStyles: function(e, t) {
                        var n = c(e).css(t);
                        u.update_styles && Ka(F, n)
                    },
                    removeAllAttribs: function(e) {
                        return h(e, function(e) {
                            for (var t = e.attributes, n = t.length - 1; 0 <= n; n--) e.removeAttributeNode(t.item(n))
                        })
                    },
                    setAttrib: i,
                    setAttribs: v,
                    getAttrib: r,
                    getPos: f,
                    parseStyle: function(e) {
                        return F.parse(e)
                    },
                    serializeStyle: function(e, t) {
                        return F.serialize(e, t)
                    },
                    addStyle: function(e) {
                        var t, n;
                        if ($ !== eu.DOM && a === document) {
                            if (T[e]) return;
                            T[e] = !0
                        }(n = a.getElementById("mceDefaultStyles")) || ((n = a.createElement("style")).id = "mceDefaultStyles", n.type = "text/css", (t = a.getElementsByTagName("head")[0]).firstChild ? t.insertBefore(n, t.firstChild) : t.appendChild(n)), n.styleSheet ? n.styleSheet.cssText += e : n.appendChild(a.createTextNode(e))
                    },
                    loadCSS: function(e) {
                        Y((e = e || "").split(","), function(e) {
                            B[e] = !0, L.load(e, te)
                        })
                    },
                    addClass: function(e, t) {
                        c(e).addClass(t)
                    },
                    removeClass: function(e, t) {
                        w(e, t, !1)
                    },
                    hasClass: function(e, t) {
                        return c(e).hasClass(t)
                    },
                    toggleClass: w,
                    show: function(e) {
                        c(e).show()
                    },
                    hide: function(e) {
                        c(e).hide()
                    },
                    isHidden: function(e) {
                        return "none" === c(e).css("display")
                    },
                    uniqueId: function(e) {
                        return (e || "mce_") + P++
                    },
                    setHTML: b,
                    getOuterHTML: function(e) {
                        var t = "string" == typeof e ? s(e) : e;
                        return Hn(t) ? t.outerHTML : Ya("<div></div>").append(Ya(t).clone()).html()
                    },
                    setOuterHTML: function(e, t) {
                        c(e).each(function() {
                            try {
                                if ("outerHTML" in this) return void(this.outerHTML = t)
                            } catch (e) {}
                            x(Ya(this).html(t), !0)
                        })
                    },
                    decode: Zo.decode,
                    encode: j,
                    insertAfter: function(e, t) {
                        var r = s(t);
                        return h(e, function(e) {
                            var t = r.parentNode,
                                n = r.nextSibling;
                            return n ? t.insertBefore(e, n) : t.appendChild(e), e
                        })
                    },
                    replace: S,
                    rename: function(t, e) {
                        var n;
                        return t.nodeName !== e.toUpperCase() && (n = C(e), Ga(o(t), function(e) {
                            i(n, e.nodeName, r(t, e.nodeName))
                        }), S(n, t, !0)), n || t
                    },
                    findCommonAncestor: function(e, t) {
                        for (var n, r = e; r;) {
                            for (n = t; n && r !== n;) n = n.parentNode;
                            if (r === n) break;
                            r = r.parentNode
                        }
                        return !r && e.ownerDocument ? e.ownerDocument.documentElement : r
                    },
                    toHex: function(e) {
                        return F.toHex(Nt.trim(e))
                    },
                    run: h,
                    getAttribs: o,
                    isEmpty: function(e, t) {
                        var n, r, o = 0;
                        if (N(e)) return !1;
                        if (e = e.firstChild) {
                            var i = new Dr(e, e.parentNode),
                                a = M ? M.getWhiteSpaceElements() : {};
                            t = t || (M ? M.getNonEmptyElements() : null);
                            do {
                                if (n = e.nodeType, Hn(e)) {
                                    var u = e.getAttribute("data-mce-bogus");
                                    if (u) {
                                        e = i.next("all" === u);
                                        continue
                                    }
                                    if (r = e.nodeName.toLowerCase(), t && t[r]) {
                                        if ("br" !== r) return !1;
                                        o++, e = i.next();
                                        continue
                                    }
                                    if (N(e)) return !1
                                }
                                if (8 === n) return !1;
                                if (3 === n && !$r(e.nodeValue)) return !1;
                                if (3 === n && e.parentNode && a[e.parentNode.nodeName] && $r(e.nodeValue)) return !1;
                                e = i.next()
                            } while (e)
                        }
                        return o <= 1
                    },
                    createRng: E,
                    nodeIndex: Xa,
                    split: function(e, t, n) {
                        var r, o, i, a = E();
                        if (e && t) return a.setStart(e.parentNode, Xa(e)), a.setEnd(t.parentNode, Xa(t)), r = a.extractContents(), (a = E()).setStart(t.parentNode, Xa(t) + 1), a.setEnd(e.parentNode, Xa(e) + 1), o = a.extractContents(), (i = e.parentNode).insertBefore(Vo($, r), e), n ? i.insertBefore(n, e) : i.insertBefore(t, e), i.insertBefore(Vo($, o), e), x(e), n || t
                    },
                    bind: V,
                    unbind: q,
                    fire: function(e, t, n) {
                        return U.fire(e, t, n)
                    },
                    getContentEditable: k,
                    getContentEditableParent: function(e) {
                        for (var t = l(), n = null; e && e !== t && null === (n = k(e)); e = e.parentNode);
                        return n
                    },
                    destroy: function() {
                        if (0 < I.length)
                            for (var e = I.length; e--;) {
                                var t = I[e];
                                U.unbind(t[0], t[1], t[2])
                            }
                        ne(B, function(e, t) {
                            L.unload(t), delete B[t]
                        }), ca.setDocument && ca.setDocument()
                    },
                    isChildOf: function(e, t) {
                        if (Qa) {
                            for (; e;) {
                                if (t === e) return !0;
                                e = e.parentNode
                            }
                            return !1
                        }
                        return e === t || t.contains(e)
                    },
                    dumpRng: function(e) {
                        return "startContainer: " + e.startContainer.nodeName + ", startOffset: " + e.startOffset + ", endContainer: " + e.endContainer.nodeName + ", endOffset: " + e.endOffset
                    }
                },
                W = (_ = F, R = J($), e = {
                    set: function(e, t, n) {
                        A.url_converter && null !== t && (t = A.url_converter.call(A.url_converter_scope || R(), t, n, e[0])), e.attr("data-mce-" + n, t).attr(n, t)
                    },
                    get: function(e, t) {
                        return e.attr("data-mce-" + t) || e.attr(t)
                    }
                }, t = {
                    style: {
                        set: function(e, t) {
                            null === t || "object" != typeof t ? (D && e.attr("data-mce-style", t), null !== t && "string" == typeof t ? (e.removeAttr("style"), e.css(_.parse(t))) : e.attr("style", t)) : e.css(t)
                        },
                        get: function(e) {
                            var t = e.attr("data-mce-style") || e.attr("style");
                            return _.serialize(_.parse(t), e[0].nodeName)
                        }
                    }
                }, (D = (A = u).keep_values) && (t.href = t.src = e), t);
            return $
        };
    eu.DOM = eu(document), eu.nodeIndex = Xa;
    var tu = eu.DOM,
        nu = Nt.each,
        ru = Nt.grep,
        ou = (iu.prototype._setReferrerPolicy = function(e) {
            this.settings.referrerPolicy = e
        }, iu.prototype.loadScript = function(e, t, n) {
            function r() {
                o.remove(i), a && (a.onerror = a.onload = a = null)
            }
            var o = tu,
                i = o.uniqueId(),
                a = document.createElement("script");
            a.id = i, a.type = "text/javascript", a.src = Nt._addCacheSuffix(e), this.settings.referrerPolicy && o.setAttrib(a, "referrerpolicy", this.settings.referrerPolicy), a.onload = function() {
                r(), t()
            }, a.onerror = function() {
                r(), y(n) ? n() : "undefined" != typeof console && console.log && console.log("Failed to load script: " + e)
            }, (document.getElementsByTagName("head")[0] || document.body).appendChild(a)
        }, iu.prototype.isDone = function(e) {
            return 2 === this.states[e]
        }, iu.prototype.markDone = function(e) {
            this.states[e] = 2
        }, iu.prototype.add = function(e, t, n, r) {
            var o = this.states[e];
            this.queue.push(e), void 0 === o && (this.states[e] = 0), t && (this.scriptLoadedCallbacks[e] || (this.scriptLoadedCallbacks[e] = []), this.scriptLoadedCallbacks[e].push({
                success: t,
                failure: r,
                scope: n || this
            }))
        }, iu.prototype.load = function(e, t, n, r) {
            return this.add(e, t, n, r)
        }, iu.prototype.remove = function(e) {
            delete this.states[e], delete this.scriptLoadedCallbacks[e]
        }, iu.prototype.loadQueue = function(e, t, n) {
            this.loadScripts(this.queue, e, t, n)
        }, iu.prototype.loadScripts = function(n, e, t, r) {
            function o(t, e) {
                nu(i.scriptLoadedCallbacks[e], function(e) {
                    y(e[t]) && e[t].call(e.scope)
                }), i.scriptLoadedCallbacks[e] = void 0
            }
            var i = this,
                a = [];
            i.queueLoadedCallbacks.push({
                success: e,
                failure: r,
                scope: t || this
            });
            var u = function() {
                var e, t = ru(n);
                n.length = 0, nu(t, function(e) {
                    2 !== i.states[e] ? 3 !== i.states[e] ? 1 !== i.states[e] && (i.states[e] = 1, i.loading++, i.loadScript(e, function() {
                        i.states[e] = 2, i.loading--, o("success", e), u()
                    }, function() {
                        i.states[e] = 3, i.loading--, a.push(e), o("failure", e), u()
                    })) : o("failure", e) : o("success", e)
                }), i.loading || (e = i.queueLoadedCallbacks.slice(0), i.queueLoadedCallbacks.length = 0, nu(e, function(e) {
                    0 === a.length ? y(e.success) && e.success.call(e.scope) : y(e.failure) && e.failure.call(e.scope, a)
                }))
            };
            u()
        }, iu.ScriptLoader = new iu, iu);

    function iu(e) {
        void 0 === e && (e = {}), this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = 0, this.settings = e
    }

    function au(e) {
        var t = e;
        return {
            get: function() {
                return t
            },
            set: function(e) {
                t = e
            }
        }
    }

    function uu() {
        return ue(su, cu.get())
    }
    var su = {},
        cu = au("en"),
        lu = {
            getData: function() {
                return re(su, function(e) {
                    return _e({}, e)
                })
            },
            setCode: function(e) {
                e && cu.set(e)
            },
            getCode: function() {
                return cu.get()
            },
            add: function(e, t) {
                var n = su[e];
                n || (su[e] = n = {}), ne(t, function(e, t) {
                    n[t.toLowerCase()] = e
                })
            },
            translate: function(e) {
                function n(e) {
                    return y(e) ? Object.prototype.toString.call(e) : u(e) ? "" : "" + e
                }

                function t(e) {
                    var t = n(e);
                    return ue(a, t.toLowerCase()).map(n).getOr(t)
                }

                function r(e) {
                    return e.replace(/{context:\w+}$/, "")
                }
                var o, i, a = uu().getOr({}),
                    u = function(e) {
                        return "" === e || null == e
                    };
                if (u(e)) return "";
                if (h(o = e) && Ee(o, "raw")) return n(e.raw);
                if (S(i = e) && 1 < i.length) {
                    var s = e.slice(1);
                    return r(t(e[0]).replace(/\{([0-9]+)\}/g, function(e, t) {
                        return Ee(s, t) ? n(s[t]) : e
                    }))
                }
                return r(t(e))
            },
            isRtl: function() {
                return uu().bind(function(e) {
                    return ue(e, "_dir")
                }).exists(function(e) {
                    return "rtl" === e
                })
            },
            hasCode: function(e) {
                return Ee(su, e)
            }
        },
        fu = function() {
            function u(t, n) {
                Y(U(r, function(e) {
                    return e.name === t && e.state === n
                }), function(e) {
                    return e.callback()
                })
            }

            function s(e) {
                var t;
                return (f[e] ? f[e].dependencies : t) || []
            }

            function c(e, t) {
                return "object" == typeof t ? t : "string" == typeof e ? {
                    prefix: "",
                    resource: t,
                    suffix: ""
                } : {
                    prefix: e.prefix,
                    resource: t,
                    suffix: e.suffix
                }
            }

            function e(e, t, n) {
                void 0 === n && (n = "added"), Ee(f, e) && "added" === n || Ee(l, e) && "loaded" === n ? t() : r.push({
                    name: e,
                    state: n,
                    callback: t
                })
            }
            var o = [],
                l = {},
                f = {},
                r = [],
                d = function(r, o, i, a, e) {
                    var t, n;
                    l[r] || (0 !== (t = "string" == typeof o ? o : o.prefix + o.resource + o.suffix).indexOf("/") && -1 === t.indexOf("://") && (t = fu.baseURL + "/" + t), l[r] = t.substring(0, t.lastIndexOf("/")), n = function() {
                        var n, e, t;
                        u(r, "loaded"), n = o, e = i, t = a, Y(s(r), function(e) {
                            var t = c(n, e);
                            d(t.resource, t, void 0, void 0)
                        }), e && (t ? e.call(t) : e.call(ou))
                    }, f[r] ? n() : ou.ScriptLoader.add(t, n, a, e))
                };
            return {
                items: o,
                urls: l,
                lookup: f,
                _listeners: r,
                get: function(e) {
                    if (f[e]) return f[e].instance
                },
                dependencies: s,
                requireLangPack: function(t, n) {
                    !1 !== fu.languageLoad && e(t, function() {
                        var e = lu.getCode();
                        !e || n && -1 === ("," + (n || "") + ",").indexOf("," + e + ",") || ou.ScriptLoader.add(l[t] + "/langs/" + e + ".js")
                    }, "loaded")
                },
                add: function(e, t, n) {
                    var r = t;
                    return o.push(r), f[e] = {
                        instance: r,
                        dependencies: n
                    }, u(e, "added"), r
                },
                remove: function(e) {
                    delete l[e], delete f[e]
                },
                createUrl: c,
                addComponents: function(e, t) {
                    var n = l[e];
                    Y(t, function(e) {
                        ou.ScriptLoader.add(n + "/" + e)
                    })
                },
                load: d,
                waitFor: e
            }
        };

    function du() {
        var e, t, n = (e = te, t = au(ve.none()), {
            clear: function() {
                r(), t.set(ve.none())
            },
            isSet: function() {
                return t.get().isSome()
            },
            get: function() {
                return t.get()
            },
            set: function(e) {
                r(), t.set(ve.some(e))
            }
        });

        function r() {
            return t.get().each(e)
        }
        return _e(_e({}, n), {
            on: function(e) {
                return n.get().each(e)
            }
        })
    }

    function mu(n, r) {
        var o = null;
        return {
            cancel: function() {
                l(o) || (clearTimeout(o), o = null)
            },
            throttle: function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                l(o) && (o = setTimeout(function() {
                    o = null, n.apply(null, e)
                }, r))
            }
        }
    }

    function gu(n, r) {
        function o() {
            l(i) || (clearTimeout(i), i = null)
        }
        var i = null;
        return {
            cancel: o,
            throttle: function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                o(), i = setTimeout(function() {
                    i = null, n.apply(null, e)
                }, r)
            }
        }
    }

    function pu(e, t) {
        var n = vn(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ")
    }

    function hu(e) {
        return void 0 !== e.dom.classList
    }

    function vu(e, t) {
        var n, r, o;
        hu(e) ? e.dom.classList.add(t) : (r = t, o = pu(n = e, "class").concat([r]), pn(n, "class", o.join(" ")))
    }

    function bu(e, t) {
        return hu(e) && e.dom.classList.contains(t)
    }

    function yu(e, t) {
        return He(n = void 0 === e ? document : e.dom) ? [] : A(n.querySelectorAll(t), Et.fromDom);
        var n
    }

    function Cu(r, e) {
        function t(e, t) {
            return yn(e, t) ? ve.some(vn(e, t)) : ve.none()
        }
        var n = r.selection.getRng(),
            o = Et.fromDom(n.startContainer),
            i = Et.fromDom(r.getBody()),
            a = e.fold(function() {
                return "." + $u()
            }, function(e) {
                return "[" + Wu() + '="' + e + '"]'
            });
        return yr(Mt(o, n.startOffset).getOr(o), a, function(e) {
            return je(e, i)
        }).bind(function(e) {
            return t(e, "" + Ku()).bind(function(n) {
                return t(e, "" + Wu()).map(function(e) {
                    var t = Xu(r, n);
                    return {
                        uid: n,
                        name: e,
                        elements: t
                    }
                })
            })
        })
    }

    function xu(t) {
        function o() {
            return {
                listeners: [],
                previous: du()
            }
        }

        function c(e, t) {
            n(e, function(e) {
                return t(e), e
            })
        }

        function n(e, t) {
            var n = i.get(),
                r = t(ue(n, e).getOrThunk(o));
            n[e] = r, i.set(n)
        }
        var i = au({}),
            e = gu(function() {
                var e = i.get();
                Y(W(we(e)), function(e) {
                    n(e, function(u) {
                        var s = u.previous.get();
                        return Cu(t, ve.some(e)).fold(function() {
                            var t;
                            s.isSome() && (c(t = e, function(e) {
                                Y(e.listeners, function(e) {
                                    return e(!1, t)
                                })
                            }), u.previous.clear())
                        }, function(e) {
                            var t, n, r, o = e.uid,
                                i = e.name,
                                a = e.elements;
                            fn(s, o) || (n = o, r = a, c(t = i, function(e) {
                                Y(e.listeners, function(e) {
                                    return e(!0, t, {
                                        uid: n,
                                        nodes: A(r, function(e) {
                                            return e.dom
                                        })
                                    })
                                })
                            }), u.previous.set(o))
                        }), {
                            previous: u.previous,
                            listeners: u.listeners
                        }
                    })
                })
            }, 30);
        return t.on("remove", function() {
            e.cancel()
        }), t.on("NodeChange", function() {
            e.throttle()
        }), {
            addListener: function(e, t) {
                n(e, function(e) {
                    return {
                        previous: e.previous,
                        listeners: e.listeners.concat([t])
                    }
                })
            }
        }
    }

    function wu(e) {
        var t = (new Date).getTime();
        return e + "_" + Math.floor(1e9 * Math.random()) + ++Yu + String(t)
    }

    function Su(e, t) {
        var n, r, o = Rt(e).dom,
            i = Et.fromDom(o.createDocumentFragment());
        Kt(i, (n = t, (r = (o || document).createElement("div")).innerHTML = n, Tn(Et.fromDom(r)))), Xt(e), Ln(e, i)
    }

    function Nu(e, t) {
        return Et.fromDom(e.dom.cloneNode(t))
    }

    function Eu(e) {
        return Nu(e, !1)
    }

    function ku(e) {
        return Nu(e, !0)
    }

    function _u(e, t, n) {
        function r(e) {
            for (var t;
                (t = o[e]()) && !Vn(t) && !n(t););
            return ve.from(t).filter(Vn)
        }
        void 0 === n && (n = D);
        var o = new Dr(e, t);
        return {
            current: function() {
                return ve.from(o.current()).filter(Vn)
            },
            next: function() {
                return r("next")
            },
            prev: function() {
                return r("prev")
            },
            prev2: function() {
                return r("prev2")
            }
        }
    }

    function Au(t, e) {
        var i = e || function(e) {
                return t.isBlock(e) || Kn(e) || Gn(e)
            },
            a = function(e, t, n, r) {
                if (Vn(e)) {
                    var o = r(e, t, e.data);
                    if (-1 !== o) return ve.some({
                        container: e,
                        offset: o
                    })
                }
                return n().bind(function(e) {
                    return a(e.container, e.offset, n, r)
                })
            };
        return {
            backwards: function(e, t, n, r) {
                var o = _u(e, r, i);
                return a(e, t, function() {
                    return o.prev().map(function(e) {
                        return {
                            container: e,
                            offset: e.length
                        }
                    })
                }, n).getOrNull()
            },
            forwards: function(e, t, n, r) {
                var o = _u(e, r, i);
                return a(e, t, function() {
                    return o.next().map(function(e) {
                        return {
                            container: e,
                            offset: 0
                        }
                    })
                }, n).getOrNull()
            }
        }
    }

    function Ru(e) {
        return e ? {
            left: Gu(e.left),
            top: Gu(e.top),
            bottom: Gu(e.bottom),
            right: Gu(e.right),
            width: Gu(e.width),
            height: Gu(e.height)
        } : {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0,
            width: 0,
            height: 0
        }
    }

    function Du(e, t) {
        return e = Ru(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e
    }

    function Tu(e, t, n) {
        return 0 <= e && e <= Math.min(t.height, n.height) / 2
    }

    function Ou(e, t) {
        var n = Math.min(t.height / 2, e.height / 2);
        return e.bottom - n < t.top || !(e.top > t.bottom) && Tu(t.top - e.bottom, e, t)
    }

    function Bu(e, t) {
        return e.top > t.bottom || !(e.bottom < t.top) && Tu(t.bottom - e.top, e, t)
    }

    function Pu(e, t, n) {
        return t >= e.left && t <= e.right && n >= e.top && n <= e.bottom
    }

    function Lu(e) {
        var t = e.startContainer,
            n = e.startOffset;
        return t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null
    }

    function Iu(e, t) {
        if (Hn(e) && e.hasChildNodes()) {
            var n = e.childNodes;
            return n[r = n.length - 1, Math.min(Math.max(t, 0), r)]
        }
        return e;
        var r
    }

    function Mu(e) {
        return "string" == typeof e && 768 <= e.charCodeAt(0) && Ju.test(e)
    }

    function Fu(e) {
        return "createRange" in e ? e.createRange() : eu.DOM.createRng()
    }

    function Uu(e) {
        return e && /[\r\n\t ]/.test(e)
    }

    function zu(e) {
        return e.setStart && e.setEnd
    }

    function Hu(e) {
        var t = e.startContainer,
            n = e.startOffset;
        if (Uu(e.toString()) && rs(t.parentNode) && Vn(t)) {
            var r = t.data;
            return Uu(r[n - 1]) || Uu(r[n + 1]) ? 1 : void 0
        }
    }

    function ju(e) {
        return 0 === e.left && 0 === e.right && 0 === e.top && 0 === e.bottom
    }

    function Vu(e, t) {
        var n = Du(e, t);
        return n.width = 1, n.right = n.left + 1, n
    }
    fu.languageLoad = !0, fu.baseURL = "", fu.PluginManager = fu(), fu.ThemeManager = fu();
    var qu = function(e, t) {
            var n = [];
            return Y(Tn(e), function(e) {
                n = (n = t(e) ? n.concat([e]) : n).concat(qu(e, t))
            }), n
        },
        $u = J("mce-annotation"),
        Wu = J("data-mce-annotation"),
        Ku = J("data-mce-annotation-uid"),
        Xu = function(e, t) {
            return yu(Et.fromDom(e.getBody()), "[" + Ku() + '="' + t + '"]')
        },
        Yu = 0,
        Gu = Math.round,
        Ju = new RegExp("[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1abe\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20dd-\u20e0\u20e1\u20e2-\u20e4\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\ua670-\ua672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]"),
        Qu = Hn,
        Zu = Vr,
        es = an("display", "block table"),
        ts = an("float", "left right"),
        ns = function() {
            for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
            return function(e) {
                for (var t = 0; t < n.length; t++)
                    if (!n[t](e)) return !1;
                return !0
            }
        }(Qu, Zu, s(ts)),
        rs = s(an("white-space", "pre pre-line pre-wrap")),
        os = Vn,
        is = Kn,
        as = eu.nodeIndex,
        us = function(e, t) {
            if (!(t < 0 && Hn(e) && e.hasChildNodes())) return Iu(e, t)
        },
        ss = function(e) {
            var t = e.getClientRects(),
                n = 0 < t.length ? Ru(t[0]) : Ru(e.getBoundingClientRect());
            return !zu(e) && is(e) && ju(n) ? function(e) {
                var t = e.ownerDocument,
                    n = Fu(t),
                    r = t.createTextNode(wo),
                    o = e.parentNode;
                o.insertBefore(r, e), n.setStart(r, 0), n.setEnd(r, 1);
                var i = Ru(n.getBoundingClientRect());
                return o.removeChild(r), i
            }(e) : ju(n) && zu(e) ? function(e) {
                var t = e.startContainer,
                    n = e.endContainer,
                    r = e.startOffset,
                    o = e.endOffset;
                if (t === n && Vn(n) && 0 === r && 1 === o) {
                    var i = e.cloneRange();
                    return i.setEndAfter(n), ss(i)
                }
                return null
            }(e) : n
        },
        cs = function(t, n, e) {
            function r() {
                return e = e || function(e) {
                    function r(e) {
                        var t;
                        0 !== e.height && (0 < o.length && (t = o[o.length - 1], e.left === t.left && e.top === t.top && e.bottom === t.bottom && e.right === t.right) || o.push(e))
                    }

                    function t(e, t) {
                        var n = Fu(e.ownerDocument);
                        if (t < e.data.length) {
                            if (Mu(e.data[t])) return o;
                            if (Mu(e.data[t - 1]) && (n.setStart(e, t), n.setEnd(e, t + 1), !Hu(n))) return r(Vu(ss(n), !1)), o
                        }
                        0 < t && (n.setStart(e, t - 1), n.setEnd(e, t), Hu(n) || r(Vu(ss(n), !1))), t < e.data.length && (n.setStart(e, t), n.setEnd(e, t + 1), Hu(n) || r(Vu(ss(n), !0)))
                    }
                    var o = [],
                        n = e.container(),
                        i = e.offset();
                    if (os(n)) return t(n, i), o;
                    if (Qu(n))
                        if (e.isAtEnd()) {
                            var a = us(n, i);
                            os(a) && t(a, a.data.length), ns(a) && !is(a) && r(Vu(ss(a), !1))
                        } else {
                            if (a = us(n, i), os(a) && t(a, 0), ns(a) && e.isAtEnd()) return r(Vu(ss(a), !1)), o;
                            var u = us(e.container(), e.offset() - 1);
                            ns(u) && !is(u) && (!es(u) && !es(a) && ns(a) || r(Vu(ss(u), !1))), ns(a) && r(Vu(ss(a), !0))
                        } return o
                }(cs(t, n))
            }
            return {
                container: J(t),
                offset: J(n),
                toRange: function() {
                    var e = Fu(t.ownerDocument);
                    return e.setStart(t, n), e.setEnd(t, n), e
                },
                getClientRects: r,
                isVisible: function() {
                    return 0 < r().length
                },
                isAtStart: function() {
                    return os(t), 0 === n
                },
                isAtEnd: function() {
                    return os(t) ? n >= t.data.length : n >= t.childNodes.length
                },
                isEqual: function(e) {
                    return e && t === e.container() && n === e.offset()
                },
                getNode: function(e) {
                    return us(t, e ? n - 1 : n)
                }
            }
        };

    function ls(e, t) {
        Vn(t) && 0 === t.data.length && e.remove(t)
    }

    function fs(e, t, n) {
        var r, o, i, a, u, s, c;
        Wn(n) ? (i = e, a = t, s = ve.from((u = n).firstChild), c = ve.from(u.lastChild), a.insertNode(u), s.each(function(e) {
            return ls(i, e.previousSibling)
        }), c.each(function(e) {
            return ls(i, e.nextSibling)
        })) : (r = e, t.insertNode(o = n), ls(r, o.previousSibling), ls(r, o.nextSibling))
    }

    function ds(t) {
        return function(e) {
            return t === e
        }
    }

    function ms(e) {
        var t, r, n, o;
        return (lc(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + (r = gc(mc(t = e)), n = ge(r, ds(t), t), o = me(r = r.slice(0, n + 1), function(e, t, n) {
            return lc(t) && lc(r[n - 1]) && e++, e
        }, 0), ge(r = fe(r, on([t.nodeName])), ds(t), t) - o) + "]"
    }

    function gs(e, t) {
        var n, r, o, i = [],
            a = t.container(),
            u = t.offset();
        return lc(a) ? n = function(e, t) {
            for (;
                (e = e.previousSibling) && lc(e);) t += e.data.length;
            return t
        }(a, u) : (u >= (r = a.childNodes).length ? (n = "after", u = r.length - 1) : n = "before", a = r[u]), i.push(ms(a)), o = fe(function(e, t) {
            var n = [];
            for (t = t.parentNode; t !== e; t = t.parentNode) n.push(t);
            return n
        }(e, a), s(sn)), (i = i.concat(le(o, ms))).reverse().join("/") + "," + n
    }

    function ps(e, t) {
        if (!t) return null;
        var n = t.split(","),
            r = n[0].split("/"),
            o = 1 < n.length ? n[1] : "before",
            i = me(r, function(e, t) {
                var n, r, o, i, a = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(t);
                return a ? ("text()" === a[1] && (a[1] = "#text"), n = e, r = a[1], o = parseInt(a[2], 10), i = fe(i = gc(n), function(e, t) {
                    return !lc(e) || !lc(i[t - 1])
                }), (i = fe(i, on([r])))[o]) : null
            }, e);
        return i ? lc(i) ? function(e, t) {
            for (var n, r = e, o = 0; lc(r);) {
                if (n = r.data.length, o <= t && t <= o + n) {
                    e = r, t -= o;
                    break
                }
                if (!lc(r.nextSibling)) {
                    e = r, t = n;
                    break
                }
                o += n, r = r.nextSibling
            }
            return lc(e) && t > e.data.length && (t = e.data.length), cs(e, t)
        }(i, parseInt(o, 10)) : (o = "after" === o ? dc(i) + 1 : dc(i), cs(i.parentNode, o)) : null
    }

    function hs(e, t, n, r, o) {
        var i, a = r[o ? "startContainer" : "endContainer"],
            u = r[o ? "startOffset" : "endOffset"],
            s = [],
            c = 0,
            l = e.getRoot();
        for (Vn(a) ? s.push(n ? function(e, t, n) {
                for (var r = e(t.data.slice(0, n)).length, o = t.previousSibling; o && Vn(o); o = o.previousSibling) r += e(o.data).length;
                return r
            }(t, a, u) : u) : (u >= (i = a.childNodes).length && i.length && (c = 1, u = Math.max(0, i.length - 1)), s.push(e.nodeIndex(i[u], n) + c)); a && a !== l; a = a.parentNode) s.push(e.nodeIndex(a, n));
        return s
    }

    function vs(e, t, n) {
        var r = 0;
        return Nt.each(e.select(t), function(e) {
            if ("all" !== e.getAttribute("data-mce-bogus")) return e !== n && void r++
        }), r
    }

    function bs(e, t) {
        var n, r = t ? "start" : "end",
            o = e[r + "Container"],
            i = e[r + "Offset"];
        Hn(o) && "TR" === o.nodeName && (o = (n = o.childNodes)[Math.min(t ? i : i - 1, n.length - 1)]) && (i = t ? 0 : o.childNodes.length, e["set" + (t ? "Start" : "End")](o, i))
    }

    function ys(e) {
        return bs(e, !0), bs(e, !1), e
    }

    function Cs(e, t) {
        var n;
        return Hn(e) && (e = Iu(e, t), pc(e)) ? e : Mr(e) ? (n = (e = Vn(e) && Lr(e) ? e.parentNode : e).previousSibling, pc(n) ? n : (n = e.nextSibling, pc(n) ? n : void 0)) : void 0
    }

    function xs(e, t, n) {
        var r = n.getNode(),
            o = r ? r.nodeName : null,
            i = n.getRng();
        if (pc(r) || "IMG" === o) return {
            name: o,
            index: vs(n.dom, o, r)
        };
        var a, u, s, c, l, f, d, m = Cs((a = i).startContainer, a.startOffset) || Cs(a.endContainer, a.endOffset);
        return m ? {
            name: o = m.tagName,
            index: vs(n.dom, o, m)
        } : (f = (s = n).dom, (d = {}).start = hs(f, u = e, c = t, l = i, !0), s.isCollapsed() || (d.end = hs(f, u, c, l, !1)), jr(l) && (d.isFakeCaret = !0), d)
    }

    function ws(e, t, n) {
        var r = {
            "data-mce-type": "bookmark",
            id: t,
            style: "overflow:hidden;line-height:0px"
        };
        return n ? e.create("span", r, "&#xFEFF;") : e.create("span", r)
    }

    function Ss(e, t) {
        var n = e.dom,
            r = e.getRng(),
            o = n.uniqueId(),
            i = e.isCollapsed(),
            a = e.getNode(),
            u = a.nodeName;
        if ("IMG" === u) return {
            name: u,
            index: vs(n, u, a)
        };
        var s = ys(r.cloneRange());
        return i || (s.collapse(!1), fs(n, s, ws(n, o + "_end", t))), (r = ys(r)).collapse(!0), fs(n, r, ws(n, o + "_start", t)), e.moveToBookmark({
            id: o,
            keep: !0
        }), {
            id: o
        }
    }

    function Ns(e, t, n) {
        var r = e.getParam(t, n);
        return -1 === r.indexOf("=") ? r : ue(e.getParam(t, "", "hash"), e.id).getOr(n)
    }

    function Es(e) {
        return e.getParam("content_security_policy", "")
    }

    function ks(e) {
        if (e.getParam("force_p_newlines", !1)) return "p";
        var t = e.getParam("forced_root_block", "p");
        return !1 === t ? "" : !0 === t ? "p" : t
    }

    function _s(e) {
        return e.getParam("forced_root_block_attrs", {})
    }

    function As(e) {
        return e.getParam("automatic_uploads", !0, "boolean")
    }

    function Rs(e) {
        return e.getParam("icons", "", "string")
    }

    function Ds(e) {
        return e.getParam("referrer_policy", "", "string")
    }

    function Ts(e) {
        return e.getParam("language", "en", "string")
    }

    function Os(e) {
        return e.getParam("indent_use_margin", !1)
    }

    function Bs(e) {
        var t = e.getParam("font_css", []);
        return S(t) ? t : A(t.split(","), Je)
    }

    function Ps(e) {
        var t = e.getParam("object_resizing");
        return !1 !== t && !xt.iOS && (X(t) ? t : "table,img,figure.image,div,video,iframe")
    }

    function Ls(e) {
        return e.getParam("event_root")
    }

    function Is(e) {
        return e.getParam("theme")
    }

    function Ms(e) {
        return !1 !== e.getParam("inline_boundaries")
    }

    function Fs(e) {
        return e.getParam("plugins", "", "string")
    }

    function Us(e) {
        var t = e.parentNode;
        t && t.removeChild(e)
    }

    function zs(e) {
        var t = Eo(e);
        return {
            count: e.length - t.length,
            text: t
        }
    }

    function Hs(e) {
        for (var t; - 1 !== (t = e.data.lastIndexOf(So));) e.deleteData(t, 1)
    }

    function js(e, t) {
        return Cc(e), t
    }

    function Vs(e, t) {
        var n, r = t.container(),
            o = (-1 === (n = _(xe(r.childNodes), e)) ? ve.none() : ve.some(n)).map(function(e) {
                return e < t.offset() ? cs(r, t.offset() - 1) : t
            }).getOr(t);
        return Cc(e), o
    }

    function qs(e, t) {
        return cs.isTextPosition(t) ? (r = t, yc(n = e) && r.container() === n ? (a = zs((o = n).data.substr(0, (i = r).offset())), u = zs(o.data.substr(i.offset())), 0 < (a.text + u.text).length ? (Hs(o), cs(o, i.offset() - a.count)) : i) : js(n, r)) : (s = e, ((c = t).container() === s.parentNode ? Vs : js)(s, c));
        var n, r, o, i, a, u, s, c
    }

    function $s(e, t, n) {
        var r, o, i, a = Du(t.getBoundingClientRect(), n),
            u = "BODY" === e.tagName ? (r = e.ownerDocument.documentElement, o = e.scrollLeft || r.scrollLeft, e.scrollTop || r.scrollTop) : (i = e.getBoundingClientRect(), o = e.scrollLeft - i.left, e.scrollTop - i.top);
        a.left += o, a.right += o, a.top += u, a.bottom += u, a.width = 1;
        var s = t.offsetWidth - t.clientWidth;
        return 0 < s && (n && (s *= -1), a.left += s, a.right += s), a
    }

    function Ws(e, i, a, u) {
        function s() {
            ! function() {
                for (var e = yu(Et.fromDom(i), "*[contentEditable=false],video,audio,embed,object"), t = 0; t < e.length; t++) {
                    var n, r = e[t].dom,
                        o = r.previousSibling;
                    Ro(o) && (1 === (n = o.data).length ? o.parentNode.removeChild(o) : o.deleteData(n.length - 1, 1)), o = r.nextSibling, Ao(o) && (1 === (n = o.data).length ? o.parentNode.removeChild(o) : o.deleteData(0, 1))
                }
            }(), l && (Cc(l), l = null), f.on(function(e) {
                Ya(e.caret).remove(), f.clear()
            }), c && (Ar.clearInterval(c), c = void 0)
        }
        var c, l, f = du(),
            t = ks(e),
            d = 0 < t.length ? t : "p";
        return {
            show: function(e, t) {
                var n;
                if (s(), Nc(t)) return null;
                if (!a(t)) return l = function(e, t) {
                    var n = e.ownerDocument.createTextNode(So),
                        r = e.parentNode;
                    if (t) {
                        if (o = e.previousSibling, _o(o)) {
                            if (Mr(o)) return o;
                            if (Ro(o)) return o.splitText(o.data.length - 1)
                        }
                        r.insertBefore(n, e)
                    } else {
                        var o = e.nextSibling;
                        if (_o(o)) {
                            if (Mr(o)) return o;
                            if (Ao(o)) return o.splitText(1), o
                        }
                        e.nextSibling ? r.insertBefore(n, e.nextSibling) : r.appendChild(n)
                    }
                    return n
                }(t, e), n = t.ownerDocument.createRange(), Ec(l.nextSibling) ? (n.setStart(l, 0), n.setEnd(l, 0)) : (n.setStart(l, 1), n.setEnd(l, 1)), n;
                l = function(e, t, n) {
                    var r, o = t.ownerDocument.createElement(e);
                    o.setAttribute("data-mce-caret", n ? "before" : "after"), o.setAttribute("data-mce-bogus", "all"), o.appendChild(((r = document.createElement("br")).setAttribute("data-mce-bogus", "1"), r));
                    var i = t.parentNode;
                    return n ? i.insertBefore(o, t) : t.nextSibling ? i.insertBefore(o, t.nextSibling) : i.appendChild(o), o
                }(d, t, e);
                var r = $s(i, t, e);
                Ya(l).css("top", r.top);
                var o = Ya('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(_e({}, r)).appendTo(i)[0];
                return f.set({
                    caret: o,
                    element: t,
                    before: e
                }), e && Ya(o).addClass("mce-visual-caret-before"), c = Ar.setInterval(function() {
                    u() ? Ya("div.mce-visual-caret", i).toggleClass("mce-visual-caret-hidden") : Ya("div.mce-visual-caret", i).addClass("mce-visual-caret-hidden")
                }, 500), (n = t.ownerDocument.createRange()).setStart(l, 0), n.setEnd(l, 0), n
            },
            hide: s,
            getCss: function() {
                return ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}"
            },
            reposition: function() {
                f.on(function(e) {
                    var t = $s(i, e.element, e.before);
                    Ya(e.caret).css(_e({}, t))
                })
            },
            destroy: function() {
                return Ar.clearInterval(c)
            }
        }
    }

    function Ks() {
        return xc.isIE() || xc.isEdge() || xc.isFirefox()
    }

    function Xs(e) {
        return Ec(e) || cn(e) && Ks()
    }

    function Ys(e, t) {
        for (var n; n = e(t);)
            if (!Dc(n)) return n;
        return null
    }

    function Gs(e, t, n, r, o) {
        var i = new Dr(e, r),
            a = kc(e) || Dc(e);
        if (t < 0) {
            if (a && n(e = Ys(i.prev.bind(i), !0))) return e;
            for (; e = Ys(i.prev.bind(i), o);)
                if (n(e)) return e
        }
        if (0 < t) {
            if (a && n(e = Ys(i.next.bind(i), !0))) return e;
            for (; e = Ys(i.next.bind(i), o);)
                if (n(e)) return e
        }
        return null
    }

    function Js(e, t) {
        for (; e && e !== t;) {
            if (Ac(e)) return e;
            e = e.parentNode
        }
        return null
    }

    function Qs(e, t, n) {
        return Js(e.container(), n) === Js(t.container(), n)
    }

    function Zs(e, t) {
        if (!t) return null;
        var n = t.container(),
            r = t.offset();
        return Tc(n) ? n.childNodes[r + e] : null
    }

    function ec(e, t) {
        var n = t.ownerDocument.createRange();
        return e ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), n
    }

    function tc(e, t, n) {
        for (var r, o, i = e ? "previousSibling" : "nextSibling"; n && n !== t;) {
            var a = n[i];
            if (Rc(a) && (a = a[i]), kc(a) || _c(a)) {
                if (o = n, Js(a, r = t) === Js(o, r)) return a;
                break
            }
            if (Oc(a)) break;
            n = n.parentNode
        }
        return null
    }

    function nc(e, t, n) {
        var r, o = R(tc, !0, t),
            i = R(tc, !1, t),
            a = n.startContainer,
            u = n.startOffset;
        if (Lr(a)) {
            var s = (a = Tc(a) ? a : a.parentNode).getAttribute("data-mce-caret");
            if ("before" === s && Xs(r = a.nextSibling)) return Bc(r);
            if ("after" === s && Xs(r = a.previousSibling)) return Pc(r)
        }
        if (!n.collapsed) return n;
        if (Vn(a)) {
            if (Rc(a)) {
                if (1 === e) {
                    if (r = i(a)) return Bc(r);
                    if (r = o(a)) return Pc(r)
                }
                if (-1 === e) {
                    if (r = o(a)) return Pc(r);
                    if (r = i(a)) return Bc(r)
                }
                return n
            }
            if (Ro(a) && u >= a.data.length - 1) return 1 === e && (r = i(a)) ? Bc(r) : n;
            if (Ao(a) && u <= 1) return -1 === e && (r = o(a)) ? Pc(r) : n;
            if (u === a.data.length) return (r = i(a)) ? Bc(r) : n;
            if (0 === u) return (r = o(a)) ? Pc(r) : n
        }
        return n
    }

    function rc(e, t) {
        return ve.from(Zs(e ? 0 : -1, t)).filter(kc)
    }

    function oc(e, t, n) {
        var r = nc(e, t, n);
        return -1 === e ? cs.fromRangeStart(r) : cs.fromRangeEnd(r)
    }

    function ic(e) {
        return ve.from(e.getNode()).map(Et.fromDom)
    }

    function ac(e, t) {
        for (; t = e(t);)
            if (t.isVisible()) return t;
        return t
    }

    function uc(e, t) {
        var n = Qs(e, t);
        return !(n || !Kn(e.getNode())) || n
    }
    cs.fromRangeStart = function(e) {
        return cs(e.startContainer, e.startOffset)
    }, cs.fromRangeEnd = function(e) {
        return cs(e.endContainer, e.endOffset)
    }, cs.after = function(e) {
        return cs(e.parentNode, as(e) + 1)
    }, cs.before = function(e) {
        return cs(e.parentNode, as(e))
    }, cs.isAbove = function(e, t) {
        return dn(Q(t.getClientRects()), Z(e.getClientRects()), Ou).getOr(!1)
    }, cs.isBelow = function(e, t) {
        return dn(Z(t.getClientRects()), Q(e.getClientRects()), Bu).getOr(!1)
    }, cs.isAtStart = function(e) {
        return !!e && e.isAtStart()
    }, cs.isAtEnd = function(e) {
        return !!e && e.isAtEnd()
    }, cs.isTextPosition = function(e) {
        return !!e && Vn(e.container())
    }, cs.isElementPosition = function(e) {
        return !1 === cs.isTextPosition(e)
    };
    var sc, cc, lc = Vn,
        fc = sn,
        dc = eu.nodeIndex,
        mc = function(e) {
            var t = e.parentNode;
            return fc(t) ? mc(t) : t
        },
        gc = function(e) {
            return e ? me(e.childNodes, function(e, t) {
                return fc(t) && "BR" !== t.nodeName ? e = e.concat(gc(t)) : e.push(t), e
            }, []) : []
        },
        pc = Gn,
        hc = R(xs, u, !0),
        vc = eu.DOM,
        bc = Hn,
        yc = Vn,
        Cc = function(e) {
            bc(e) && Mr(e) && (Fr(e) ? e.removeAttribute("data-mce-caret") : Us(e)), yc(e) && (Hs(e), 0 === e.data.length && Us(e))
        },
        xc = dt().browser,
        wc = Gn,
        Sc = Qn,
        Nc = Jn,
        Ec = function(e) {
            return wc(e) || Sc(e)
        },
        kc = Gn,
        _c = Qn,
        Ac = an("display", "block table table-cell table-caption list-item"),
        Rc = Mr,
        Dc = Lr,
        Tc = Hn,
        Oc = Vr,
        Bc = R(ec, !0),
        Pc = R(ec, !1);

    function Lc(e, t) {
        return e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null
    }

    function Ic(e, t) {
        if (0 < e) {
            if (Gl(t.previousSibling) && !Kl(t.previousSibling)) return cs.before(t);
            if (Kl(t)) return cs(t, 0)
        }
        if (e < 0) {
            if (Gl(t.nextSibling) && !Kl(t.nextSibling)) return cs.after(t);
            if (Kl(t)) return cs(t, t.data.length)
        }
        return e < 0 && !Yl(t) ? cs.after(t) : cs.before(t)
    }

    function Mc(t) {
        return {
            next: function(e) {
                return Ql(sc.Forwards, e, t)
            },
            prev: function(e) {
                return Ql(sc.Backwards, e, t)
            }
        }
    }

    function Fc(e) {
        return cs.isTextPosition(e) ? 0 === e.offset() : Vr(e.getNode())
    }

    function Uc(e) {
        if (cs.isTextPosition(e)) {
            var t = e.container();
            return e.offset() === t.data.length
        }
        return Vr(e.getNode(!0))
    }

    function zc(e, t) {
        return !cs.isTextPosition(e) && !cs.isTextPosition(t) && e.getNode() === t.getNode(!0)
    }

    function Hc(o, i, a) {
        return Zl(o, i, a).bind(function(e) {
            return Qs(a, e, i) && (t = a, n = e, o ? !zc(t, n) && (cs.isTextPosition(r = t) || !Kn(r.getNode())) && Uc(t) && Fc(n) : !zc(n, t) && Fc(t) && Uc(n)) ? Zl(o, i, e) : ve.some(e);
            var t, n, r
        })
    }

    function jc(e, t) {
        var n, r, o, i, a, u = e ? t.firstChild : t.lastChild;
        return Vn(u) ? ve.some(cs(u, e ? 0 : u.data.length)) : u ? Vr(u) ? ve.some(e ? cs.before(u) : Kn(a = u) ? cs.before(a) : cs.after(a)) : (r = t, o = u, i = (n = e) ? cs.before(o) : cs.after(o), Zl(n, r, i)) : ve.none()
    }

    function Vc(e) {
        return Hn(e) && e.id === af
    }

    function qc(e, t) {
        for (; t && t !== e;) {
            if (t.id === af) return t;
            t = t.parentNode
        }
        return null
    }

    function $c(e) {
        return Nt.isArray(e.start)
    }

    function Wc(e, t) {
        return Hn(t) && e.isBlock(t) && !t.innerHTML && !xt.ie && (t.innerHTML = '<br data-mce-bogus="1" />'), t
    }

    function Kc(e, t, n) {
        return !1 === t.hasChildNodes() && qc(e, t) && (o = n, i = (r = t).ownerDocument.createTextNode(So), r.appendChild(i), o.setStart(i, 0), o.setEnd(i, 0), 1);
        var r, o, i
    }

    function Xc(e, t, n, r) {
        var o, i, a, u, s = n[t ? "start" : "end"],
            c = e.getRoot();
        if (s) {
            for (a = s[0], i = c, o = s.length - 1; 1 <= o; o--) {
                if (u = i.childNodes, Kc(c, i, r)) return 1;
                if (s[o] > u.length - 1) return Kc(c, i, r) || function(t) {
                    return of(i).fold(D, function(e) {
                        return t.setStart(e.container(), e.offset()), t.setEnd(e.container(), e.offset()), !0
                    })
                }(r);
                i = u[s[o]]
            }
            3 === i.nodeType && (a = Math.min(s[0], i.nodeValue.length)), 1 === i.nodeType && (a = Math.min(s[0], i.childNodes.length)), t ? r.setStart(i, a) : r.setEnd(i, a)
        }
        return 1
    }

    function Yc(e) {
        return Vn(e) && 0 < e.data.length
    }

    function Gc(e, t, n) {
        var r, o, i, a, u, s, c = e.get(n.id + "_" + t),
            l = n.keep;
        if (c) {
            if (r = c.parentNode, o = "start" === t ? l ? c.hasChildNodes() ? (r = c.firstChild, 1) : Yc(c.nextSibling) ? (r = c.nextSibling, 0) : Yc(c.previousSibling) ? (r = c.previousSibling, c.previousSibling.data.length) : (r = c.parentNode, e.nodeIndex(c) + 1) : e.nodeIndex(c) : l ? c.hasChildNodes() ? (r = c.firstChild, 1) : Yc(c.previousSibling) ? (r = c.previousSibling, c.previousSibling.data.length) : (r = c.parentNode, e.nodeIndex(c)) : e.nodeIndex(c), u = r, s = o, !l) {
                for (a = c.previousSibling, i = c.nextSibling, Nt.each(Nt.grep(c.childNodes), function(e) {
                        Vn(e) && (e.nodeValue = e.nodeValue.replace(/\uFEFF/g, ""))
                    }); c = e.get(n.id + "_" + t);) e.remove(c, !0);
                a && i && a.nodeType === i.nodeType && Vn(a) && !xt.opera && (o = a.nodeValue.length, a.appendData(i.nodeValue), e.remove(i), u = a, s = o)
            }
            return ve.some(cs(u, s))
        }
        return ve.none()
    }

    function Jc(t, e) {
        ! function(e, t) {
            var n, r, o, i, a, u, s, c, l, f, d, m, g = e.dom;
            if (t) {
                if ($c(t)) return d = t, m = (f = g).createRng(), Xc(f, !0, d, m) && Xc(f, !1, d, m) ? ve.some(m) : ve.none();
                if (X(t.start)) return ve.some((s = t, c = (u = g).createRng(), l = ps(u.getRoot(), s.start), c.setStart(l.container(), l.offset()), l = ps(u.getRoot(), s.end), c.setEnd(l.container(), l.offset()), c));
                if (Ee(t, "id")) return dn(a = Gc(o = g, "start", i = t), Gc(o, "end", i).or(a), function(e, t) {
                    var n = o.createRng();
                    return n.setStart(Wc(o, e.container()), e.offset()), n.setEnd(Wc(o, t.container()), t.offset()), n
                });
                if (Ee(t, "name")) return n = g, ve.from(n.select((r = t).name)[r.index]).map(function(e) {
                    var t = n.createRng();
                    return t.selectNode(e), t
                });
                if (Ee(t, "rng")) return ve.some(t.rng)
            }
            return ve.none()
        }(t, e).each(function(e) {
            t.setRng(e)
        })
    }

    function Qc(e) {
        return Hn(e) && "SPAN" === e.tagName && "bookmark" === e.getAttribute("data-mce-type")
    }

    function Zc(e) {
        return "" !== e && -1 !== " \f\n\r\t\v".indexOf(e)
    }

    function el(e) {
        return !Zc(e) && !sf(e)
    }

    function tl(e) {
        return e.nodeType
    }

    function nl(e, t, n) {
        var r, o = n.startOffset,
            i = n.startContainer;
        if ((i !== n.endContainer || !(r = i.childNodes[o]) || !/^(IMG)$/.test(r.nodeName)) && Hn(i)) {
            var a = i.childNodes,
                u = void 0;
            o < a.length ? (i = a[o], u = new Dr(i, e.getParent(i, e.isBlock))) : (i = a[a.length - 1], (u = new Dr(i, e.getParent(i, e.isBlock))).next(!0));
            for (var s = u.current(); s; s = u.next())
                if (Vn(s) && !cf(s)) return n.setStart(s, 0), t.setRng(n), 0
        }
    }

    function rl(e, t, n) {
        if (e) {
            var r = t ? "nextSibling" : "previousSibling";
            for (e = n ? e : e[r]; e; e = e[r])
                if (Hn(e) || !cf(e)) return e
        }
    }

    function ol(e, t) {
        return tl(t) && (t = t.nodeName), !!e.schema.getTextBlockElements()[t.toLowerCase()]
    }

    function il(e, t, n) {
        return e.schema.isValidChild(t, n)
    }

    function al(e, n) {
        return y(e) ? e = e(n) : V(n) && (e = e.replace(/%(\w+)/g, function(e, t) {
            return n[t] || e
        })), e
    }

    function ul(e, t) {
        return e = "" + ((e = e || "").nodeName || e), t = "" + ((t = t || "").nodeName || t), e.toLowerCase() === t.toLowerCase()
    }

    function sl(e, t, n) {
        return "color" !== n && "backgroundColor" !== n || (t = e.toHex(t)), "fontWeight" === n && 700 === t && (t = "bold"), "" + ("fontFamily" === n ? t.replace(/[\'\"]/g, "").replace(/,\s+/g, ",") : t)
    }

    function cl(e, t, n) {
        return sl(e, e.getStyle(t, n), n)
    }

    function ll(t, e) {
        var n;
        return t.getParent(e, function(e) {
            return (n = t.getStyle(e, "text-decoration")) && "none" !== n
        }), n
    }

    function fl(e, t, n) {
        return e.getParents(t, n, e.getRoot())
    }

    function dl(e, t) {
        return F(e.formatter.get(t), function(t) {
            function o(e) {
                return 1 < e.length && "%" === e.charAt(0)
            }
            return F(["styles", "attributes"], function(e) {
                return ue(t, e).exists(function(e) {
                    var n, r;
                    return F(S(e) ? e : (n = u, r = [], ne(e, function(e, t) {
                        r.push(n(e, t))
                    }), r), o)
                })
            })
        })
    }

    function ml(e) {
        return se(e, "block")
    }

    function gl(e) {
        return se(e, "selector")
    }

    function pl(e) {
        return se(e, "inline")
    }

    function hl(e) {
        return gl(e) && !1 !== e.expand && !pl(e)
    }

    function vl(e, t) {
        for (var n = t; n;) {
            if (Hn(n) && e.getContentEditable(n)) return "false" === e.getContentEditable(n) ? n : t;
            n = n.parentNode
        }
        return t
    }

    function bl(e, t, n, r) {
        for (var o = t.data, i = n; e ? 0 <= i : i < o.length; e ? i-- : i++)
            if (r(o.charAt(i))) return e ? i + 1 : i;
        return -1
    }

    function yl(e, t, n) {
        return bl(e, t, n, function(e) {
            return sf(e) || Zc(e)
        })
    }

    function Cl(e, t, n) {
        return bl(e, t, n, el)
    }

    function xl(i, e, t, n, a, r) {
        function o(e, t, n) {
            var r = Au(i),
                o = a ? r.backwards : r.forwards;
            return ve.from(o(e, t, function(e, t) {
                return lf(e.parentNode) ? -1 : n(a, u = e, t)
            }, s))
        }
        var u, s = i.getParent(t, i.isBlock) || e;
        return o(t, n, yl).bind(function(e) {
            return r ? o(e.container, e.offset + (a ? -1 : 0), Cl) : ve.some(e)
        }).orThunk(function() {
            return u ? ve.some({
                container: u,
                offset: a ? 0 : u.length
            }) : ve.none()
        })
    }

    function wl(e, t, n, r, o) {
        Vn(r) && Pe(r.data) && r[o] && (r = r[o]);
        for (var i = ff(e, r), a = 0; a < i.length; a++)
            for (var u = 0; u < t.length; u++) {
                var s = t[u];
                if ((!V(s.collapsed) || s.collapsed === n.collapsed) && gl(s) && e.is(i[a], s.selector)) return i[a]
            }
        return r
    }

    function Sl(t, e, n, r) {
        var o, i = n,
            a = t.dom,
            u = a.getRoot(),
            s = e[0];
        if ((i = ml(s) ? s.wrapper ? null : a.getParent(n, s.block, u) : i) || (o = a.getParent(n, "LI,TD,TH"), i = a.getParent(Vn(n) ? n.parentNode : n, function(e) {
                return e !== u && mf(t, e)
            }, o)), !(i = i && ml(s) && s.wrapper && ff(a, i, "ul,ol").reverse()[0] || i))
            for (i = n; i[r] && !a.isBlock(i[r]) && !ul(i = i[r], "br"););
        return i || n
    }

    function Nl(e, t, n, r, o) {
        var i, a = n,
            u = o ? "previousSibling" : "nextSibling",
            s = e.getRoot();
        if (Vn(n) && !df(n) && (o ? 0 < r : r < n.data.length)) return n;
        for (;;) {
            if (!t[0].block_expand && e.isBlock(a)) return a;
            for (var c = a[u]; c; c = c[u]) {
                var l = Vn(c) && !gf(e, s, c, u);
                if (!lf(c) && (!Kn(i = c) || !i.getAttribute("data-mce-bogus") || i.nextSibling) && !df(c, l)) return a
            }
            if (a === s || a.parentNode === s) {
                n = a;
                break
            }
            a = a.parentNode
        }
        return n
    }

    function El(e) {
        return lf(e.parentNode) || lf(e)
    }

    function kl(e, t, n, r) {
        void 0 === r && (r = !1);
        var o = t.startContainer,
            i = t.startOffset,
            a = t.endContainer,
            u = t.endOffset,
            s = e.dom,
            c = n[0];
        return Hn(o) && o.hasChildNodes() && (o = Iu(o, i), Vn(o) && (i = 0)), Hn(a) && a.hasChildNodes() && (a = Iu(a, t.collapsed ? u : u - 1), Vn(a) && (u = a.nodeValue.length)), o = vl(s, o), a = vl(s, a), El(o) && (o = lf(o) ? o : o.parentNode, o = t.collapsed ? o.previousSibling || o : o.nextSibling || o, Vn(o) && (i = t.collapsed ? o.length : 0)), El(a) && (a = lf(a) ? a : a.parentNode, a = t.collapsed ? a.nextSibling || a : a.previousSibling || a, Vn(a) && (u = t.collapsed ? 0 : a.length)), t.collapsed && (xl(s, e.getBody(), o, i, !0, r).each(function(e) {
            var t = e.container,
                n = e.offset;
            o = t, i = n
        }), xl(s, e.getBody(), a, u, !1, r).each(function(e) {
            var t = e.container,
                n = e.offset;
            a = t, u = n
        })), (pl(c) || c.block_expand) && (pl(c) && Vn(o) && 0 !== i || (o = Nl(s, n, o, i, !0)), pl(c) && Vn(a) && u !== a.nodeValue.length || (a = Nl(s, n, a, u, !1))), hl(c) && (o = wl(s, n, t, o, "previousSibling"), a = wl(s, n, t, a, "nextSibling")), (ml(c) || gl(c)) && (o = Sl(e, n, o, "previousSibling"), a = Sl(e, n, a, "nextSibling"), ml(c) && (s.isBlock(o) || (o = Nl(s, n, o, i, !0)), s.isBlock(a) || (a = Nl(s, n, a, u, !1)))), Hn(o) && (i = s.nodeIndex(o), o = o.parentNode), Hn(a) && (u = s.nodeIndex(a) + 1, a = a.parentNode), {
            startContainer: o,
            startOffset: i,
            endContainer: a,
            endOffset: u
        }
    }

    function _l(n, e, u) {
        function s(e) {
            var t = e[0];
            Vn(t) && t === i && o >= t.data.length && e.splice(0, 1);
            var n = e[e.length - 1];
            return 0 === a && 0 < e.length && n === l && Vn(n) && e.splice(e.length - 1, 1), e
        }

        function c(e, t, n) {
            for (var r = []; e && e !== n; e = e[t]) r.push(e);
            return r
        }

        function t(e, t) {
            return n.getParent(e, function(e) {
                return e.parentNode === t
            }, t)
        }

        function r(e, t, n) {
            var r = n ? "nextSibling" : "previousSibling",
                o = e;
            for (o.parentNode; o && o !== t; o = i) {
                var i = o.parentNode,
                    a = c(o === e ? o : o[r], r);
                a.length && (n || a.reverse(), u(s(a)))
            }
        }
        var o = e.startOffset,
            i = Iu(e.startContainer, o),
            a = e.endOffset,
            l = Iu(e.endContainer, a - 1);
        if (i === l) return u(s([i]));
        var f = n.findCommonAncestor(i, l);
        if (n.isChildOf(i, l)) return r(i, f, !0);
        if (n.isChildOf(l, i)) return r(l, f);
        var d = t(i, f) || i,
            m = t(l, f) || l;
        r(i, d, !0);
        var g = c(d === i ? d : d.nextSibling, "nextSibling", m === l ? m.nextSibling : m);
        g.length && u(s(g)), r(l, m)
    }

    function Al(e) {
        var t = [];
        if (e)
            for (var n = 0; n < e.rangeCount; n++) t.push(e.getRangeAt(n));
        return t
    }

    function Rl(e, t) {
        var n = yu(t, "td[data-mce-selected],th[data-mce-selected]");
        return 0 < n.length ? n : U(H(e, function(e) {
            var t = Lu(e);
            return t ? [Et.fromDom(t)] : []
        }), yo)
    }

    function Dl(e) {
        return Rl(Al(e.selection.getSel()), Et.fromDom(e.getBody()))
    }

    function Tl(e, t) {
        return vr(e, "table", t)
    }

    function Ol(o, e) {
        return dn((r = e.startContainer, i = e.startOffset, Vn(r) ? 0 === i ? ve.some(Et.fromDom(r)) : ve.none() : ve.from(r.childNodes[i]).map(Et.fromDom)), (t = e.endContainer, n = e.endOffset, Vn(t) ? n === t.data.length ? ve.some(Et.fromDom(t)) : ve.none() : ve.from(t.childNodes[n - 1]).map(Et.fromDom)), function(e, t) {
            var n = M(pf(o), R(je, e)),
                r = M(hf(o), R(je, t));
            return n.isSome() && r.isSome()
        }).getOr(!1);
        var t, n, r, i
    }

    function Bl(e, t, n, r) {
        var o = n,
            i = new Dr(n, o),
            a = ae(e.schema.getMoveCaretBeforeOnEnterElements(), function(e, t) {
                return !T(["td", "th", "table"], t.toLowerCase())
            });
        do {
            if (Vn(n) && 0 !== Nt.trim(n.nodeValue).length) return r ? t.setStart(n, 0) : t.setEnd(n, n.nodeValue.length), 0;
            if (a[n.nodeName]) return r ? t.setStartBefore(n) : "BR" === n.nodeName ? t.setEndBefore(n) : t.setEndAfter(n), 0
        } while (n = r ? i.next() : i.prev());
        "BODY" === o.nodeName && (r ? t.setStart(o, 0) : t.setEnd(o, o.childNodes.length))
    }

    function Pl(e) {
        var t = e.selection.getSel();
        return t && 0 < t.rangeCount
    }

    function Ll(r, o) {
        var e = Dl(r);
        0 < e.length ? Y(e, function(e) {
            var t = e.dom,
                n = r.dom.createRng();
            n.setStartBefore(t), n.setEndAfter(t), o(n, !0)
        }) : o(r.selection.getRng(), !1)
    }

    function Il(e, t, n) {
        var r = Ss(e, t);
        n(r), e.moveToBookmark(r)
    }

    function Ml(e) {
        return vf.get(e)
    }

    function Fl(e, t, n, r) {
        var o = t.uid,
            i = void 0 === o ? wu("mce-annotation") : o,
            a = function(e, t) {
                var n = {};
                for (o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
                if (null != e && "function" == typeof Object.getOwnPropertySymbols)
                    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++) t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
                return n
            }(t, ["uid"]),
            u = Et.fromTag("span", e);
        vu(u, $u()), pn(u, "" + Ku(), i), pn(u, "" + Wu(), n);
        var s, c = r(i, a),
            l = c.attributes,
            f = c.classes,
            d = void 0 === f ? [] : f;
        return hn(u, void 0 === l ? {} : l), s = u, Y(d, function(e) {
            vu(s, e)
        }), u
    }

    function Ul(u, e, t, n, r) {
        function s() {
            d.clear()
        }

        function c(e) {
            Y(e, o)
        }
        var l = [],
            f = Fl(u.getDoc(), r, t, n),
            d = du(),
            o = function(e) {
                var t, n, r, o, i, a;
                switch (r = u, i = "span", a = kt(o = e), Ot(o).fold(function() {
                        return "skipping"
                    }, function(e) {
                        return "br" === a || An(n = o) && Ml(n) === So ? "valid" : _n(t = o) && bu(t, $u()) ? "existing" : Vc(o.dom) ? "caret" : il(r, i, a) && il(r, kt(e), i) ? "valid" : "invalid-child";
                        var t, n
                    })) {
                    case "invalid-child":
                        s(), c(Tn(e)), s();
                        break;
                    case "valid":
                        qt(t = e, n = d.get().getOrThunk(function() {
                            var e = Eu(f);
                            return l.push(e), d.set(e), e
                        })), Ln(n, t)
                }
            };
        return _l(u.dom, e, function(e) {
            s(), c(A(e, Et.fromDom))
        }), l
    }

    function zl(o) {
        var n, e, r, i = (n = {}, {
            register: function(e, t) {
                n[e] = {
                    name: e,
                    settings: t
                }
            },
            lookup: function(e) {
                return ue(n, e).map(function(e) {
                    return e.settings
                })
            }
        });
        r = i, (e = o).on("init", function() {
            e.serializer.addNodeFilter("span", function(e) {
                Y(e, function(t) {
                    ve.from(t.attr(Wu())).bind(r.lookup).each(function(e) {
                        !1 === e.persistent && t.unwrap()
                    })
                })
            })
        });
        var a = xu(o);
        return {
            register: function(e, t) {
                i.register(e, t)
            },
            annotate: function(t, n) {
                i.lookup(t).each(function(e) {
                    var u, s, c, l;
                    s = t, c = e, l = n, (u = o).undoManager.transact(function() {
                        var e, t, n, r, o = u.selection,
                            i = o.getRng(),
                            a = 0 < Dl(u).length;
                        i.collapsed && !a && (n = kl(e = u, t = i, [{
                            inline: "span"
                        }]), t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t)), o.getRng().collapsed && !a ? (Su(r = Fl(u.getDoc(), l, s, c.decorate), wo), o.getRng().insertNode(r.dom), o.select(r.dom)) : Il(o, !1, function() {
                            Ll(u, function(e) {
                                Ul(u, e, s, c.decorate, l)
                            })
                        })
                    })
                })
            },
            annotationChanged: function(e, t) {
                a.addListener(e, t)
            },
            remove: function(e) {
                Cu(o, ve.some(e)).each(function(e) {
                    Y(e.elements, Yt)
                })
            },
            getAll: function(e) {
                var t, n, r;
                return re((t = e, n = yu(Et.fromDom(o.getBody()), "[" + Wu() + '="' + t + '"]'), r = {}, Y(n, function(e) {
                    var t = vn(e, Ku()),
                        n = ue(r, t).getOr([]);
                    r[t] = n.concat([e])
                }), r), function(e) {
                    return A(e, function(e) {
                        return e.dom
                    })
                })
            }
        }
    }

    function Hl(e) {
        return {
            getBookmark: R(uf, e),
            moveToBookmark: R(Jc, e)
        }
    }(cc = sc = sc || {})[cc.Backwards = -1] = "Backwards", cc[cc.Forwards = 1] = "Forwards";

    function jl(e) {
        return Lo(e) || !!Fo(t = e) && !0 !== L(xe(t.getElementsByTagName("*")), function(e, t) {
            return e || Do(t)
        }, !1);
        var t
    }
    var Vl, ql, $l, Wl = Gn,
        Kl = Vn,
        Xl = Hn,
        Yl = Kn,
        Gl = Vr,
        Jl = qr,
        Ql = function(e, t, n) {
            var r, o, i;
            if (!Xl(n) || !t) return null;
            if (t.isEqual(cs.after(n)) && n.lastChild) {
                if (i = cs.after(n.lastChild), e < 0 && Gl(n.lastChild) && Xl(n.lastChild)) return Yl(n.lastChild) ? cs.before(n.lastChild) : i
            } else i = t;
            var a, u, s, c = i.container(),
                l = i.offset();
            if (Kl(c)) {
                if (e < 0 && 0 < l) return cs(c, --l);
                if (0 < e && l < c.length) return cs(c, ++l);
                r = c
            } else {
                if (e < 0 && 0 < l && (f = Lc(c, l - 1), Gl(f))) return !jl(f) && (o = Gs(f, e, Jl, f)) ? Kl(o) ? cs(o, o.data.length) : cs.after(o) : Kl(f) ? cs(f, f.data.length) : cs.before(f);
                if (0 < e && l < c.childNodes.length && (f = Lc(c, l), Gl(f))) return Yl(f) ? (a = n, (s = (u = f).nextSibling) && Gl(s) ? Kl(s) ? cs(s, 0) : cs.before(s) : Ql(sc.Forwards, cs.after(u), a)) : !jl(f) && (o = Gs(f, e, Jl, f)) ? Kl(o) ? cs(o, 0) : cs.before(o) : Kl(f) ? cs(f, 0) : cs.after(f);
                r = f || i.getNode()
            }
            if ((0 < e && i.isAtEnd() || e < 0 && i.isAtStart()) && (r = Gs(r, e, w, n, !0), Jl(r, n))) return Ic(e, r);
            var f = Gs(r, e, Jl, n),
                d = pe(U(function(e, t) {
                    for (var n = []; e && e !== t;) n.push(e), e = e.parentNode;
                    return n
                }(c, n), Wl));
            return !d || f && d.contains(f) ? f ? Ic(e, f) : null : 0 < e ? cs.after(d) : cs.before(d)
        },
        Zl = function(e, t, n) {
            var r = Mc(t);
            return ve.from(e ? r.next(n) : r.prev(n))
        },
        ef = function(t, n, e, r) {
            return Hc(t, n, e).bind(function(e) {
                return r(e) ? ef(t, n, e, r) : ve.some(e)
            })
        },
        tf = R(Zl, !0),
        nf = R(Zl, !1),
        rf = R(jc, !0),
        of = R(jc, !1),
        af = "_mce_caret",
        uf = function(e, t, n) {
            return 2 === t ? xs(Eo, n, e) : 3 === t ? (o = (r = e).getRng(), {
                start: gs(r.dom.getRoot(), cs.fromRangeStart(o)),
                end: gs(r.dom.getRoot(), cs.fromRangeEnd(o))
            }) : t ? {
                rng: e.getRng()
            } : Ss(e, !1);
            var r, o
        },
        sf = (Vl = wo, function(e) {
            return Vl === e
        }),
        cf = function(e, t) {
            return void 0 === t && (t = !1), !(!V(e) || !Vn(e)) && $r(t ? e.data.replace(/ /g, "\xa0") : e.data)
        },
        lf = Qc,
        ff = fl,
        df = cf,
        mf = ol,
        gf = function(e, t, n, r) {
            var o = n.parentNode;
            return !V(n[r]) && (!(o !== t && !K(o) && !e.isBlock(o)) || gf(e, t, o, r))
        },
        pf = function(t) {
            return Ft(t).fold(J([t]), function(e) {
                return [t].concat(pf(e))
            })
        },
        hf = function(t) {
            return Ut(t).fold(J([t]), function(e) {
                return "br" === kt(e) ? Bt(e).map(function(e) {
                    return [t].concat(hf(e))
                }).getOr([]) : [t].concat(hf(e))
            })
        },
        vf = (ql = An, {
            get: function(e) {
                if (!ql(e)) throw new Error("Can only get text value of a text node");
                return $l(e).getOr("")
            },
            getOption: $l = function(e) {
                return ql(e) ? ve.from(e.dom.nodeValue) : ve.none()
            },
            set: function(e, t) {
                if (!ql(e)) throw new Error("Can only set raw text value of a text node");
                e.dom.nodeValue = t
            }
        });

    function bf(e, t) {
        for (; t && t !== e;) {
            if (Yn(t) || Gn(t)) return t;
            t = t.parentNode
        }
        return null
    }

    function yf(t, n, e) {
        if (!e.collapsed) {
            if (xt.browser.isIE() && e.startOffset === e.endOffset - 1 && e.startContainer === e.endContainer) {
                var r = e.startContainer.childNodes[e.startOffset];
                if (Hn(r)) return F(r.getClientRects(), function(e) {
                    return Pu(e, t, n)
                })
            }
            return F(e.getClientRects(), function(e) {
                return Pu(e, t, n)
            })
        }
    }

    function Cf(e, t, n) {
        return e.fire(t, n)
    }

    function xf(e, t, n, r) {
        return e.fire("FormatApply", {
            format: t,
            node: n,
            vars: r
        })
    }

    function wf(e, t, n, r) {
        return e.fire("FormatRemove", {
            format: t,
            node: n,
            vars: r
        })
    }

    function Sf(r, l) {
        function c(e) {
            return e && ("IMG" === e.nodeName || l.dom.is(e, "figure.image"))
        }

        function f(e) {
            return Qn(e) || T.hasClass(e, "mce-preview-object")
        }

        function n(e) {
            var t = e.target;
            ! function(e, t) {
                if ("longpress" !== e.type && 0 !== e.type.indexOf("touch")) return c(e.target) && !yf(e.clientX, e.clientY, t);
                var n = e.touches[0];
                return c(e.target) && !yf(n.clientX, n.clientY, t)
            }(e, l.selection.getRng()) || e.isDefaultPrevented() || l.selection.select(t)
        }

        function d(e) {
            return T.is(e, "figure.image") ? [e.querySelector("img")] : T.hasClass(e, "mce-preview-object") && V(e.firstElementChild) ? [e, e.firstElementChild] : [e]
        }

        function i(e) {
            var t = Ps(l);
            return !!t && "false" !== e.getAttribute("data-mce-resize") && e !== l.getBody() && (T.hasClass(e, "mce-preview-object") ? ze(Et.fromDom(e.firstElementChild), t) : ze(Et.fromDom(e), t))
        }

        function a(e, t, n) {
            V(n) && Y(d(e), function(e) {
                e.style[t] || !l.schema.isValid(e.nodeName.toLowerCase(), t) ? T.setStyle(e, t, n) : T.setAttrib(e, t, "" + n)
            })
        }

        function m(e, t, n) {
            a(e, "width", t), a(e, "height", n)
        }

        function g(e) {
            var t, n, r, o, i, a, u = e.screenX - C,
                s = e.screenY - x;
            k = u * b[2] + w, _ = s * b[3] + S, k = k < 5 ? 5 : k, _ = _ < 5 ? 5 : _, ((c(p) || f(p)) && !1 !== l.getParam("resize_img_proportional", !0, "boolean") ? !If.modifierPressed(e) : If.modifierPressed(e)) && (L(u) > L(s) ? (_ = I(k * N), k = I(_ / N)) : (k = I(_ / N), _ = I(k * N))), m(h, k, _), t = b.startPos.x + u, n = b.startPos.y + s, T.setStyles(v, {
                left: t = 0 < t ? t : 0,
                top: n = 0 < n ? n : 0,
                display: "block"
            }), v.innerHTML = k + " &times; " + _, b[2] < 0 && h.clientWidth <= k && T.setStyle(h, "left", void 0 + (w - k)), b[3] < 0 && h.clientHeight <= _ && T.setStyle(h, "top", void 0 + (S - _)), (u = M.scrollWidth - A) + (s = M.scrollHeight - R) != 0 && T.setStyles(v, {
                left: t - u,
                top: n - s
            }), E || (r = p, o = w, i = S, a = "corner-" + b.name, l.fire("ObjectResizeStart", {
                target: r,
                width: o,
                height: i,
                origin: a
            }), E = !0)
        }

        function o(e) {
            function t(e, t) {
                if (e)
                    do {
                        if (e === t) return 1
                    } while (e = e.parentNode)
            }
            var n;
            E || l.removed || (O(T.select("img[data-mce-selected],hr[data-mce-selected]"), function(e) {
                e.removeAttribute(D)
            }), n = "mousedown" === e.type ? e.target : r.getNode(), t(n = T.$(n).closest("table,img,figure.image,hr,video,span.mce-preview-object")[0], M) && (s(), t(r.getStart(!0), n) && t(r.getEnd(!0), n)) ? z(n) : H())
        }

        function u(e) {
            return Mf(bf(l.getBody(), e))
        }

        function s() {
            try {
                l.getDoc().execCommand("enableObjectResizing", !1, "false")
            } catch (e) {}
        }
        var p, h, v, b, y, C, x, w, S, N, E, k, _, A, R, D = "data-mce-selected",
            T = l.dom,
            O = Nt.each,
            B = l.getDoc(),
            P = document,
            L = Math.abs,
            I = Math.round,
            M = l.getBody(),
            F = {
                nw: [0, 0, -1, -1],
                ne: [1, 0, 1, -1],
                se: [1, 1, 1, 1],
                sw: [0, 1, -1, 1]
            },
            U = function() {
                var e, t, n, r, o = E;
                E = !1, o && (a(p, "width", k), a(p, "height", _)), T.unbind(B, "mousemove", g), T.unbind(B, "mouseup", U), P !== B && (T.unbind(P, "mousemove", g), T.unbind(P, "mouseup", U)), T.remove(h), T.remove(v), T.remove(y), z(p), o && (e = p, t = k, n = _, r = "corner-" + b.name, l.fire("ObjectResized", {
                    target: e,
                    width: t,
                    height: n,
                    origin: r
                }), T.setAttrib(p, "style", T.getAttrib(p, "style"))), l.nodeChanged()
            },
            z = function(e) {
                j();
                var t = T.getPos(e, M),
                    a = t.x,
                    u = t.y,
                    n = e.getBoundingClientRect(),
                    s = n.width || n.right - n.left,
                    c = n.height || n.bottom - n.top;
                p !== e && (H(), p = e, k = _ = 0);
                var r = l.fire("ObjectSelected", {
                        target: e
                    }),
                    o = T.getAttrib(p, D, "1");
                i(e) && !r.isDefaultPrevented() ? O(F, function(o, i) {
                    var e = T.get("mceResizeHandle" + i);
                    e && T.remove(e), e = T.add(M, "div", {
                        id: "mceResizeHandle" + i,
                        "data-mce-bogus": "all",
                        class: "mce-resizehandle",
                        unselectable: !0,
                        style: "cursor:" + i + "-resize; margin:0; padding:0"
                    }), 11 === xt.ie && (e.contentEditable = !1), T.bind(e, "mousedown", function(e) {
                        var t, n, r;
                        e.stopImmediatePropagation(), e.preventDefault(), t = e, r = d(p)[0], C = t.screenX, x = t.screenY, w = r.clientWidth, S = r.clientHeight, N = S / w, (b = o).name = i, b.startPos = {
                            x: s * o[0] + a,
                            y: c * o[1] + u
                        }, A = M.scrollWidth, R = M.scrollHeight, y = T.add(M, "div", {
                            class: "mce-resize-backdrop",
                            "data-mce-bogus": "all"
                        }), T.setStyles(y, {
                            position: "fixed",
                            left: "0",
                            top: "0",
                            width: "100%",
                            height: "100%"
                        }), h = f(n = p) ? T.create("img", {
                            src: xt.transparentSrc
                        }) : n.cloneNode(!0), T.addClass(h, "mce-clonedresizable"), T.setAttrib(h, "data-mce-bogus", "all"), h.contentEditable = "false", T.setStyles(h, {
                            left: a,
                            top: u,
                            margin: 0
                        }), m(h, s, c), h.removeAttribute(D), M.appendChild(h), T.bind(B, "mousemove", g), T.bind(B, "mouseup", U), P !== B && (T.bind(P, "mousemove", g), T.bind(P, "mouseup", U)), v = T.add(M, "div", {
                            class: "mce-resize-helper",
                            "data-mce-bogus": "all"
                        }, w + " &times; " + S)
                    }), o.elm = e, T.setStyles(e, {
                        left: s * o[0] + a - e.offsetWidth / 2,
                        top: c * o[1] + u - e.offsetHeight / 2
                    })
                }) : H(), T.getAttrib(p, D) || p.setAttribute(D, o)
            },
            H = function() {
                j(), p && p.removeAttribute(D), ne(F, function(e, t) {
                    var n = T.get("mceResizeHandle" + t);
                    n && (T.unbind(n), T.remove(n))
                })
            },
            j = function() {
                ne(F, function(e) {
                    e.elm && (T.unbind(e.elm), delete e.elm)
                })
            };
        return l.on("init", function() {
            var e;
            s(), (xt.browser.isIE() || xt.browser.isEdge()) && (l.on("mousedown click", function(e) {
                var t = e.target,
                    n = t.nodeName;
                E || !/^(TABLE|IMG|HR)$/.test(n) || u(t) || (2 !== e.button && l.selection.select(t, "TABLE" === n), "mousedown" === e.type && l.nodeChanged())
            }), T.bind(M, "mscontrolselect", e = function(e) {
                function t(e) {
                    Ar.setEditorTimeout(l, function() {
                        return l.selection.select(e)
                    })
                }
                if (u(e.target) || Qn(e.target)) return e.preventDefault(), void t(e.target);
                /^(TABLE|IMG|HR)$/.test(e.target.nodeName) && (e.preventDefault(), "IMG" === e.target.tagName && t(e.target))
            }), l.on("remove", function() {
                return T.unbind(M, "mscontrolselect", e)
            }));
            var t = Ar.throttle(function(e) {
                l.composing || o(e)
            });
            l.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", t), l.on("keyup compositionend", function(e) {
                p && "TABLE" === p.nodeName && t(e)
            }), l.on("hide blur", H), l.on("contextmenu longpress", n, !0)
        }), l.on("remove", j), {
            isResizable: i,
            showResizeRect: z,
            hideResizeRect: H,
            updateResizeRect: o,
            destroy: function() {
                p = h = y = null
            }
        }
    }

    function Nf(e) {
        return Yn(e) || Gn(e)
    }

    function Ef(t, n, r) {
        var o, e, i, a, u, s = r;
        if (s.caretPositionFromPoint)(e = s.caretPositionFromPoint(t, n)) && ((o = r.createRange()).setStart(e.offsetNode, e.offset), o.collapse(!0));
        else if (s.caretRangeFromPoint) o = s.caretRangeFromPoint(t, n);
        else if (s.body.createTextRange) {
            o = s.body.createTextRange();
            try {
                o.moveToPoint(t, n), o.collapse(!0)
            } catch (e) {
                o = function(e, n, t) {
                    var r, o = t.elementFromPoint(e, n),
                        i = t.body.createTextRange();
                    if (o && "HTML" !== o.tagName || (o = t.body), i.moveToElementText(o), 0 < (r = (r = Nt.toArray(i.getClientRects())).sort(function(e, t) {
                            return (e = Math.abs(Math.max(e.top - n, e.bottom - n))) - Math.abs(Math.max(t.top - n, t.bottom - n))
                        })).length) {
                        n = (r[0].bottom + r[0].top) / 2;
                        try {
                            return i.moveToPoint(e, n), i.collapse(!0), i
                        } catch (e) {}
                    }
                    return null
                }(t, n, r)
            }
            return i = o, a = r.body, u = i && i.parentElement ? i.parentElement() : null, Gn(function(e, t, n) {
                for (; e && e !== t;) {
                    if (n(e)) return e;
                    e = e.parentNode
                }
                return null
            }(u, a, Nf)) ? null : i
        }
        return o
    }

    function kf(e, t) {
        return e && t && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset
    }

    function _f(e, t, n) {
        return null !== function(e, t, n) {
            for (; e && e !== t;) {
                if (n(e)) return e;
                e = e.parentNode
            }
            return null
        }(e, t, n)
    }

    function Af(e) {
        return e && "TABLE" === e.nodeName
    }

    function Rf(e, t, n) {
        for (var r = new Dr(t, e.getParent(t.parentNode, e.isBlock) || e.getRoot()); t = r[n ? "prev" : "next"]();)
            if (Kn(t)) return 1
    }

    function Df(e, t, n, r, o) {
        var i, a, u = e.getRoot(),
            s = e.schema.getNonEmptyElements(),
            c = e.getParent(o.parentNode, e.isBlock) || u;
        if (r && Kn(o) && t && e.isEmpty(c)) return ve.some(cs(o.parentNode, e.nodeIndex(o)));
        for (var l, f, d = new Dr(o, c); a = d[r ? "prev" : "next"]();) {
            if ("false" === e.getContentEditableParent(a) || (f = u, Mr(l = a) && !1 === _f(l, f, Vc))) return ve.none();
            if (Vn(a) && 0 < a.nodeValue.length) return !1 === _f(a, u, function(e) {
                return "A" === e.nodeName
            }) ? ve.some(cs(a, r ? a.nodeValue.length : 0)) : ve.none();
            if (e.isBlock(a) || s[a.nodeName.toLowerCase()]) return ve.none();
            i = a
        }
        return n && i ? ve.some(cs(i, 0)) : ve.none()
    }

    function Tf(e, t, n, r) {
        var o, i = e.getRoot(),
            a = !1,
            u = r[(n ? "start" : "end") + "Container"],
            s = r[(n ? "start" : "end") + "Offset"],
            c = Hn(u) && s === u.childNodes.length,
            l = e.schema.getNonEmptyElements(),
            f = n;
        if (Mr(u)) return ve.none();
        if (Hn(u) && s > u.childNodes.length - 1 && (f = !1), $n(u) && (u = i, s = 0), u === i) {
            if (f && (d = u.childNodes[0 < s ? s - 1 : 0])) {
                if (Mr(d)) return ve.none();
                if (l[d.nodeName] || Af(d)) return ve.none()
            }
            if (u.hasChildNodes()) {
                if (s = Math.min(!f && 0 < s ? s - 1 : s, u.childNodes.length - 1), u = u.childNodes[s], s = Vn(u) && c ? u.data.length : 0, !t && u === i.lastChild && Af(u)) return ve.none();
                if (function(e, t) {
                        for (; t && t !== e;) {
                            if (Gn(t)) return 1;
                            t = t.parentNode
                        }
                    }(i, u) || Mr(u)) return ve.none();
                if (u.hasChildNodes() && !1 === Af(u)) {
                    var d = u,
                        m = new Dr(u, i);
                    do {
                        if (Gn(d) || Mr(d)) {
                            a = !1;
                            break
                        }
                        if (Vn(d) && 0 < d.nodeValue.length) {
                            s = f ? 0 : d.nodeValue.length, u = d, a = !0;
                            break
                        }
                        if (l[d.nodeName.toLowerCase()] && (!(o = d) || !/^(TD|TH|CAPTION)$/.test(o.nodeName))) {
                            s = e.nodeIndex(d), u = d.parentNode, f || s++, a = !0;
                            break
                        }
                    } while (d = f ? m.next() : m.prev())
                }
            }
        }
        return t && (Vn(u) && 0 === s && Df(e, c, t, !0, u).each(function(e) {
            u = e.container(), s = e.offset(), a = !0
        }), Hn(u) && (!(d = (d = u.childNodes[s]) || u.childNodes[s - 1]) || !Kn(d) || d.previousSibling && "A" === d.previousSibling.nodeName || Rf(e, d, !1) || Rf(e, d, !0) || Df(e, c, t, !0, d).each(function(e) {
            u = e.container(), s = e.offset(), a = !0
        }))), f && !t && Vn(u) && s === u.nodeValue.length && Df(e, c, t, !1, u).each(function(e) {
            u = e.container(), s = e.offset(), a = !0
        }), a ? ve.some(cs(u, s)) : ve.none()
    }

    function Of(e, t) {
        var n = t.collapsed,
            r = t.cloneRange(),
            o = cs.fromRangeStart(t);
        return Tf(e, n, !0, r).each(function(e) {
            n && cs.isAbove(o, e) || r.setStart(e.container(), e.offset())
        }), n || Tf(e, n, !1, r).each(function(e) {
            r.setEnd(e.container(), e.offset())
        }), n && r.collapse(!0), kf(t, r) ? ve.none() : ve.some(r)
    }

    function Bf(e, t) {
        return e.splitText(t)
    }

    function Pf(e) {
        var t = e.startContainer,
            n = e.startOffset,
            r = e.endContainer,
            o = e.endOffset;
        return t === r && Vn(t) ? 0 < n && n < t.nodeValue.length && (t = (r = Bf(t, n)).previousSibling, n < o ? (t = r = Bf(r, o -= n).previousSibling, o = r.nodeValue.length, n = 0) : o = 0) : (Vn(t) && 0 < n && n < t.nodeValue.length && (t = Bf(t, n), n = 0), Vn(r) && 0 < o && o < r.nodeValue.length && (o = (r = Bf(r, o).previousSibling).nodeValue.length)), {
            startContainer: t,
            startOffset: n,
            endContainer: r,
            endOffset: o
        }
    }

    function Lf(n) {
        return {
            walk: function(e, t) {
                return _l(n, e, t)
            },
            split: Pf,
            normalize: function(t) {
                return Of(n, t).fold(D, function(e) {
                    return t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), !0
                })
            }
        }
    }
    Hl.isBookmarkNode = Qc;
    var If = {
            BACKSPACE: 8,
            DELETE: 46,
            DOWN: 40,
            ENTER: 13,
            ESC: 27,
            LEFT: 37,
            RIGHT: 39,
            SPACEBAR: 32,
            TAB: 9,
            UP: 38,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            modifierPressed: function(e) {
                return e.shiftKey || e.ctrlKey || e.altKey || If.metaKeyPressed(e)
            },
            metaKeyPressed: function(e) {
                return xt.mac ? e.metaKey : e.ctrlKey && !e.altKey
            }
        },
        Mf = Gn;
    Lf.compareRanges = kf, Lf.getCaretRangeFromPoint = Ef, Lf.getSelectedNode = Lu, Lf.getNode = Iu;
    var Ff, Uf, zf = (Ff = "height", Uf = function(e) {
        var t = e.dom;
        return Mn(e) ? t.getBoundingClientRect().height : t.offsetHeight
    }, {
        set: function(e, t) {
            if (!N(t) && !t.match(/^[0-9]+$/)) throw new Error(Ff + ".set accepts only positive integer values. Value was " + t);
            var n = e.dom;
            mn(n) && (n.style[Ff] = t + "px")
        },
        get: Hf,
        getOuter: Hf,
        aggregate: jf,
        max: function(e, t, n) {
            var r = jf(e, n);
            return r < t ? t - r : 0
        }
    });

    function Hf(e) {
        var t = Uf(e);
        if (t <= 0 || null === t) {
            var n = wn(e, Ff);
            return parseFloat(n) || 0
        }
        return t
    }

    function jf(o, e) {
        return L(e, function(e, t) {
            var n = wn(o, t),
                r = void 0 === n ? 0 : parseInt(n, 10);
            return isNaN(r) ? e : e + r
        }, 0)
    }

    function Vf(e) {
        return "textarea" === kt(e)
    }

    function qf(e, t) {
        var n = function(e) {
                var t = e.dom.ownerDocument,
                    n = t.body,
                    r = t.defaultView,
                    o = t.documentElement;
                if (n === e.dom) return Un(n.offsetLeft, n.offsetTop);
                var i = Gt(null == r ? void 0 : r.pageYOffset, o.scrollTop),
                    a = Gt(null == r ? void 0 : r.pageXOffset, o.scrollLeft),
                    u = Gt(o.clientTop, n.clientTop),
                    s = Gt(o.clientLeft, n.clientLeft);
                return zn(e).translate(a - s, i - u)
            }(e),
            r = zf.get(e);
        return {
            element: e,
            bottom: n.top + r,
            height: r,
            pos: n,
            cleanup: t
        }
    }

    function $f(n, r, o, i) {
        Od(n, function(e, t) {
            return Td(n, r, o, i)
        }, o)
    }

    function Wf(e, t, n, r, o) {
        var i = {
            elm: r.element.dom,
            alignToTop: o
        };
        e.fire("ScrollIntoView", i).isDefaultPrevented() || (n(t, Jt(t).top, r, o), e.fire("AfterScrollIntoView", i))
    }

    function Kf(e, t, n, r) {
        var o = Et.fromDom(e.getDoc());
        Wf(e, o, n, qf(Et.fromDom(t), te), r)
    }

    function Xf(e, t, n, r) {
        var o, i = e.pos;
        n ? Qt(i.left, i.top, r) : (o = i.top - t + e.height, Qt(i.left, o, r))
    }

    function Yf(e, t, n, r, o) {
        var i = n + t,
            a = r.pos.top,
            u = r.bottom,
            s = n <= u - a;
        a < t ? Xf(r, n, !1 !== o, e) : i < a ? Xf(r, n, s ? !1 !== o : !0 === o, e) : i < u && !s && Xf(r, n, !0 === o, e)
    }

    function Gf(e, t, n, r) {
        Yf(e, t, e.dom.defaultView.innerHeight, n, r)
    }

    function Jf(e, t, n, r) {
        Yf(e, t, e.dom.defaultView.innerHeight, n, r);
        var o, i, a, u, s, c, l, f = (o = n.element, u = Jt(Et.fromDom(document)), a = (i = Dd).owner(o), s = Rd(i, a), c = zn(o), l = P(s, function(e, t) {
                var n = zn(t);
                return {
                    left: e.left + n.left,
                    top: e.top + n.top
                }
            }, {
                left: 0,
                top: 0
            }), Un(l.left + c.left + u.left, l.top + c.top + u.top)),
            d = tn(window);
        f.top < d.y ? Zt(n.element, !1 !== r) : f.top > d.bottom && Zt(n.element, !0 === r)
    }

    function Qf(e, t, n) {
        return $f(e, Gf, t, n)
    }

    function Zf(e, t, n) {
        return Kf(e, t, Gf, n)
    }

    function ed(e, t, n) {
        return $f(e, Jf, t, n)
    }

    function td(e, t, n) {
        return Kf(e, t, Jf, n)
    }

    function nd(e, t, n) {
        (e.inline ? Qf : ed)(e, t, n)
    }

    function rd(e) {
        var t = Pn(e).dom;
        return e.dom === t.activeElement
    }

    function od(e) {
        return void 0 === e && (e = Et.fromDom(document)), ve.from(e.dom.activeElement).map(Et.fromDom)
    }

    function id(e, t) {
        var n = An(t) ? Ml(t).length : Tn(t).length + 1;
        return n < e ? n : e < 0 ? 0 : e
    }

    function ad(e) {
        return Id.range(e.start, id(e.soffset, e.start), e.finish, id(e.foffset, e.finish))
    }

    function ud(e, t) {
        return !rn(t.dom) && (Ve(e, t) || je(e, t))
    }

    function sd(t) {
        return function(e) {
            return ud(t, e.start) && ud(t, e.finish)
        }
    }

    function cd(e) {
        return !0 === e.inline || Md.isIE()
    }

    function ld(e) {
        return Id.range(Et.fromDom(e.startContainer), e.startOffset, Et.fromDom(e.endContainer), e.endOffset)
    }

    function fd(e) {
        var t = document.createRange();
        try {
            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), ve.some(t)
        } catch (e) {
            return ve.none()
        }
    }

    function dd(e) {
        var t, n, r = cd(e) ? (t = Et.fromDom(e.getBody()), ((n = Tt(t).dom.getSelection()) && 0 !== n.rangeCount ? ve.from(n.getRangeAt(0)) : ve.none()).map(ld).filter(sd(t))) : ve.none();
        e.bookmark = r.isSome() ? r : e.bookmark
    }

    function md(n) {
        return (n.bookmark || ve.none()).bind(function(e) {
            return t = Et.fromDom(n.getBody()), ve.from(e).filter(sd(t)).map(ad);
            var t
        }).bind(fd)
    }

    function gd(u) {
        var s = mu(function() {
            dd(u)
        }, 0);
        u.on("init", function() {
            function e() {
                n.throttle()
            }
            var t, n, r, o, i, a;
            u.inline && (t = u, n = s, eu.DOM.bind(document, "mouseup", e), t.on("remove", function() {
                eu.DOM.unbind(document, "mouseup", e)
            })), r = u, o = s, dt().browser.isIE() ? (a = r).on("focusout", function() {
                dd(a)
            }) : (i = o, r.on("mouseup touchend", function(e) {
                i.throttle()
            })), r.on("keyup NodeChange", function(e) {
                "nodechange" === e.type && e.selectionChange || dd(r)
            })
        }), u.on("remove", function() {
            s.cancel()
        })
    }

    function pd(t, e) {
        var n = t.getParam("custom_ui_selector", "", "string");
        return null !== Ud.getParent(e, function(e) {
            return Fd.isEditorUIElement(e) || !!n && t.dom.is(e, n)
        })
    }

    function hd(n, e) {
        var t = e.editor;
        gd(t), t.on("focusin", function() {
            var e = n.focusedEditor;
            e !== t && (e && e.fire("blur", {
                focusedEditor: t
            }), n.setActive(t), (n.focusedEditor = t).fire("focus", {
                blurredEditor: e
            }), t.focus(!0))
        }), t.on("focusout", function() {
            Ar.setEditorTimeout(t, function() {
                var e = n.focusedEditor;
                pd(t, function(e) {
                    try {
                        return od(Pn(Et.fromDom(e.getElement()))).fold(function() {
                            return document.body
                        }, function(e) {
                            return e.dom
                        })
                    } catch (e) {
                        return document.body
                    }
                }(t)) || e !== t || (t.fire("blur", {
                    focusedEditor: null
                }), n.focusedEditor = null)
            })
        }), Ad || (Ad = function(e) {
            var t = n.activeEditor;
            t && ! function(e) {
                if (Bn() && V(e.target)) {
                    var t = Et.fromDom(e.target);
                    if (_n(t) && V(t.dom.shadowRoot) && e.composed && e.composedPath) {
                        var n = e.composedPath();
                        if (n) return Q(n)
                    }
                }
                return ve.from(e.target)
            }(e).each(function(e) {
                e.ownerDocument === document && (e === document.body || pd(t, e) || n.focusedEditor !== t || (t.fire("blur", {
                    focusedEditor: null
                }), n.focusedEditor = null))
            })
        }, Ud.bind(document, "focusin", Ad))
    }

    function vd(e, t) {
        e.focusedEditor === t.editor && (e.focusedEditor = null), e.activeEditor || (Ud.unbind(document, "focusin", Ad), Ad = null)
    }

    function bd(t, e) {
        var n, r;
        n = Et.fromDom(t.getBody()), ((r = e).collapsed ? ve.from(Iu(r.startContainer, r.startOffset)).map(Et.fromDom) : ve.none()).bind(function(e) {
            return bo(e) ? ve.some(e) : !1 === Ve(n, e) ? ve.some(n) : ve.none()
        }).bind(function(e) {
            return rf(e.dom)
        }).fold(function() {
            t.selection.normalize()
        }, function(e) {
            return t.selection.setRng(e.toRange())
        })
    }

    function yd(t) {
        if (t.setActive) try {
            t.setActive()
        } catch (e) {
            t.focus()
        } else t.focus()
    }

    function Cd(e) {
        return e.inline ? (r = e.getBody()) && (rd(t = Et.fromDom(r)) || od(Pn(n = t)).filter(function(e) {
            return n.dom.contains(e.dom)
        }).isSome()) : e.iframeElement && rd(Et.fromDom(e.iframeElement));
        var t, n, r
    }

    function xd(e, t, n, r, o) {
        var i = n ? t.startContainer : t.endContainer,
            a = n ? t.startOffset : t.endOffset;
        return ve.from(i).map(Et.fromDom).map(function(e) {
            return r && t.collapsed ? e : Mt(e, o(e, a)).getOr(e)
        }).bind(function(e) {
            return _n(e) ? ve.some(e) : Ot(e).filter(_n)
        }).map(function(e) {
            return e.dom
        }).getOr(e)
    }

    function wd(e, t, n) {
        return xd(e, t, !0, n, function(e, t) {
            return Math.min(zt(e), t)
        })
    }

    function Sd(e, t, n) {
        return xd(e, t, !1, n, function(e, t) {
            return 0 < t ? t - 1 : t
        })
    }

    function Nd(e, t) {
        for (var n = e; e && Vn(e) && 0 === e.length;) e = t ? e.nextSibling : e.previousSibling;
        return e || n
    }

    function Ed(n, e) {
        return A(e, function(e) {
            var t = n.fire("GetSelectionRange", {
                range: e
            });
            return t.range !== e ? t.range : e
        })
    }

    function kd(e, t, n) {
        var r = n ? "lastChild" : "firstChild",
            o = n ? "prev" : "next";
        if (e[r]) return e[r];
        if (e !== t) {
            var i = e[o];
            if (i) return i;
            for (var a = e.parent; a && a !== t; a = a.parent)
                if (i = a[o]) return i
        }
    }

    function _d(e) {
        var t = "a" === e.name && !e.attr("href") && e.attr("id");
        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t
    }
    var Ad, Rd = function(r, e) {
            return r.view(e).fold(J([]), function(e) {
                var t = r.owner(e),
                    n = Rd(r, t);
                return [e].concat(n)
            })
        },
        Dd = Object.freeze({
            __proto__: null,
            view: function(e) {
                var t;
                return (e.dom === document ? ve.none() : ve.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(Et.fromDom)
            },
            owner: Dt
        }),
        Td = function(e, t, n, r) {
            var o = Et.fromDom(e.getBody()),
                i = Et.fromDom(e.getDoc());
            o.dom.offsetWidth;
            var a, u, s, c, l = (a = Et.fromDom(n.startContainer), u = n.startOffset, s = function(e, t) {
                var n = Tn(e);
                if (0 === n.length || Vf(e)) return {
                    element: e,
                    offset: t
                };
                if (t < n.length && !Vf(n[t])) return {
                    element: n[t],
                    offset: 0
                };
                var r = n[n.length - 1];
                return Vf(r) ? {
                    element: e,
                    offset: t
                } : "img" === kt(r) ? {
                    element: r,
                    offset: 1
                } : An(r) ? {
                    element: r,
                    offset: Ml(r).length
                } : {
                    element: r,
                    offset: Tn(r).length
                }
            }(a, u), c = Et.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">\ufeff</span>'), qt(s.element, c), qf(c, function() {
                return In(c)
            }));
            Wf(e, i, t, l, r), l.cleanup()
        },
        Od = function(e, t, n) {
            var r = n.startContainer,
                o = n.startOffset,
                i = n.endContainer,
                a = n.endOffset;
            t(Et.fromDom(r), Et.fromDom(i));
            var u = e.dom.createRng();
            u.setStart(r, o), u.setEnd(i, a), e.selection.setRng(n)
        },
        Bd = ir([{
            before: ["element"]
        }, {
            on: ["element", "offset"]
        }, {
            after: ["element"]
        }]),
        Pd = (Bd.before, Bd.on, Bd.after, function(e) {
            return e.fold(u, u, u)
        }),
        Ld = ir([{
            domRange: ["rng"]
        }, {
            relative: ["startSitu", "finishSitu"]
        }, {
            exact: ["start", "soffset", "finish", "foffset"]
        }]),
        Id = {
            domRange: Ld.domRange,
            relative: Ld.relative,
            exact: Ld.exact,
            exactFromRange: function(e) {
                return Ld.exact(e.start, e.soffset, e.finish, e.foffset)
            },
            getWin: function(e) {
                return Tt(e.match({
                    domRange: function(e) {
                        return Et.fromDom(e.startContainer)
                    },
                    relative: function(e, t) {
                        return Pd(e)
                    },
                    exact: function(e, t, n, r) {
                        return e
                    }
                }))
            },
            range: function(e, t, n, r) {
                return {
                    start: e,
                    soffset: t,
                    finish: n,
                    foffset: r
                }
            }
        },
        Md = dt().browser,
        Fd = {
            isEditorUIElement: function(e) {
                var t = e.className.toString();
                return -1 !== t.indexOf("tox-") || -1 !== t.indexOf("mce-")
            }
        },
        Ud = eu.DOM,
        zd = function(e) {
            return e.editorManager.setActive(e)
        },
        Hd = {
            "#text": 3,
            "#comment": 8,
            "#cdata": 4,
            "#pi": 7,
            "#doctype": 10,
            "#document-fragment": 11
        },
        jd = (Vd.create = function(e, t) {
            var n = new Vd(e, Hd[e] || 1);
            return t && ne(t, function(e, t) {
                n.attr(t, e)
            }), n
        }, Vd.prototype.replace = function(e) {
            return e.parent && e.remove(), this.insert(e, this), this.remove(), this
        }, Vd.prototype.attr = function(e, t) {
            var n, r = this;
            if ("string" != typeof e) return null != e && ne(e, function(e, t) {
                r.attr(t, e)
            }), r;
            if (n = r.attributes) {
                if (void 0 === t) return n.map[e];
                if (null === t) {
                    if (e in n.map) {
                        delete n.map[e];
                        for (var o = n.length; o--;)
                            if (n[o].name === e) return n.splice(o, 1), r
                    }
                    return r
                }
                if (e in n.map) {
                    for (o = n.length; o--;)
                        if (n[o].name === e) {
                            n[o].value = t;
                            break
                        }
                } else n.push({
                    name: e,
                    value: t
                });
                return n.map[e] = t, r
            }
        }, Vd.prototype.clone = function() {
            var e, t = new Vd(this.name, this.type);
            if (e = this.attributes) {
                var n = [];
                n.map = {};
                for (var r = 0, o = e.length; r < o; r++) {
                    var i = e[r];
                    "id" !== i.name && (n[n.length] = {
                        name: i.name,
                        value: i.value
                    }, n.map[i.name] = i.value)
                }
                t.attributes = n
            }
            return t.value = this.value, t.shortEnded = this.shortEnded, t
        }, Vd.prototype.wrap = function(e) {
            return this.parent.insert(e, this), e.append(this), this
        }, Vd.prototype.unwrap = function() {
            for (var e = this.firstChild; e;) {
                var t = e.next;
                this.insert(e, this, !0), e = t
            }
            this.remove()
        }, Vd.prototype.remove = function() {
            var e = this.parent,
                t = this.next,
                n = this.prev;
            return e && (e.firstChild === this ? (e.firstChild = t) && (t.prev = null) : n.next = t, e.lastChild === this ? (e.lastChild = n) && (n.next = null) : t.prev = n, this.parent = this.next = this.prev = null), this
        }, Vd.prototype.append = function(e) {
            e.parent && e.remove();
            var t = this.lastChild;
            return t ? ((t.next = e).prev = t, this.lastChild = e) : this.lastChild = this.firstChild = e, e.parent = this, e
        }, Vd.prototype.insert = function(e, t, n) {
            e.parent && e.remove();
            var r = t.parent || this;
            return n ? (t === r.firstChild ? r.firstChild = e : t.prev.next = e, e.prev = t.prev, (e.next = t).prev = e) : (t === r.lastChild ? r.lastChild = e : t.next.prev = e, e.next = t.next, (e.prev = t).next = e), e.parent = r, e
        }, Vd.prototype.getAll = function(e) {
            for (var t = [], n = this.firstChild; n; n = kd(n, this)) n.name === e && t.push(n);
            return t
        }, Vd.prototype.children = function() {
            for (var e = [], t = this.firstChild; t; t = t.next) e.push(t);
            return e
        }, Vd.prototype.empty = function() {
            if (this.firstChild) {
                for (var e = [], t = this.firstChild; t; t = kd(t, this)) e.push(t);
                for (var n = e.length; n--;)(t = e[n]).parent = t.firstChild = t.lastChild = t.next = t.prev = null
            }
            return this.firstChild = this.lastChild = null, this
        }, Vd.prototype.isEmpty = function(e, t, n) {
            void 0 === t && (t = {});
            var r = this.firstChild;
            if (_d(this)) return !1;
            if (r)
                do {
                    if (1 === r.type) {
                        if (r.attr("data-mce-bogus")) continue;
                        if (e[r.name]) return !1;
                        if (_d(r)) return !1
                    }
                    if (8 === r.type) return !1;
                    if (3 === r.type && ! function(e) {
                            if ($r(e.value)) {
                                var t = e.parent;
                                return !t || "span" === t.name && !t.attr("style") || !/^[ ]+$/.test(e.value)
                            }
                        }(r)) return !1;
                    if (3 === r.type && r.parent && t[r.parent.name] && $r(r.value)) return !1;
                    if (n && n(r)) return !1
                } while (r = kd(r, this));
            return !0
        }, Vd.prototype.walk = function(e) {
            return kd(this, null, e)
        }, Vd);

    function Vd(e, t) {
        this.name = e, 1 === (this.type = t) && (this.attributes = [], this.attributes.map = {})
    }

    function qd(e) {
        return X(e.nodeValue) && Te(e.nodeValue, So)
    }

    function $d(e) {
        return (0 === e.length ? "" : A(e, function(e) {
            return "[" + e + "]"
        }).join(",") + ",") + '[data-mce-bogus="all"]'
    }

    function Wd(e, t, n) {
        return document.createTreeWalker(e, t, n, !1)
    }

    function Kd(e) {
        return Wd(e, NodeFilter.SHOW_COMMENT, function(e) {
            return qd(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        })
    }

    function Xd(e) {
        return Wd(e, NodeFilter.SHOW_TEXT, function(e) {
            if (qd(e)) {
                var t = e.parentNode;
                return t && Ee(om, t.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
            }
            return NodeFilter.FILTER_SKIP
        })
    }

    function Yd(e) {
        return null !== Kd(e).nextNode()
    }

    function Gd(e) {
        return null !== Xd(e).nextNode()
    }

    function Jd(e, t) {
        return null !== t.querySelector($d(e))
    }

    function Qd(n, e) {
        Y(e.querySelectorAll($d(n)), function(e) {
            var t = Et.fromDom(e);
            "all" === vn(t, "data-mce-bogus") ? In(t) : Y(n, function(e) {
                yn(t, e) && Cn(t, e)
            })
        })
    }

    function Zd(e) {
        for (var t = e.nextNode(); null !== t;) t.nodeValue = null, t = e.nextNode()
    }

    function em(r, e) {
        var t = [{
                condition: R(Jd, e),
                action: R(Qd, e)
            }, {
                condition: Yd,
                action: im
            }, {
                condition: Gd,
                action: am
            }],
            o = r,
            i = !1;
        return Y(t, function(e) {
            var t = e.condition,
                n = e.action;
            t(o) && (i || (o = r.cloneNode(!0), i = !0), n(o))
        }), o
    }

    function tm(o) {
        return {
            compare: function(e, t) {
                return e.nodeName === t.nodeName && !(!r(n(e), n(t)) || !r(o.parseStyle(o.getAttrib(e, "style")), o.parseStyle(o.getAttrib(t, "style"))) || Qc(e) || Qc(t));

                function n(n) {
                    var r = {};
                    return um(o.getAttribs(n), function(e) {
                        var t = e.nodeName.toLowerCase();
                        0 !== t.indexOf("_") && "style" !== t && 0 !== t.indexOf("data-") && (r[t] = o.getAttrib(n, t))
                    }), r
                }

                function r(e, t) {
                    var n, r;
                    for (r in e)
                        if (Ee(e, r)) {
                            if (void 0 === (n = t[r])) return;
                            if (e[r] !== n) return;
                            delete t[r]
                        } for (r in t)
                        if (Ee(t, r)) return;
                    return 1
                }
            }
        }
    }

    function nm(e) {
        var u = [],
            s = (e = e || {}).indent,
            c = sm(e.indent_before || ""),
            l = sm(e.indent_after || ""),
            f = Zo.getEncodeFunc(e.entity_encoding || "raw", e.entities),
            d = "html" === e.element_format;
        return {
            start: function(e, t, n) {
                var r, o, i, a;
                if (s && c[e] && 0 < u.length && 0 < (a = u[u.length - 1]).length && "\n" !== a && u.push("\n"), u.push("<", e), t)
                    for (r = 0, o = t.length; r < o; r++) i = t[r], u.push(" ", i.name, '="', f(i.value, !0), '"');
                u[u.length] = !n || d ? ">" : " />", n && s && l[e] && 0 < u.length && 0 < (a = u[u.length - 1]).length && "\n" !== a && u.push("\n")
            },
            end: function(e) {
                var t;
                u.push("</", e, ">"), s && l[e] && 0 < u.length && 0 < (t = u[u.length - 1]).length && "\n" !== t && u.push("\n")
            },
            text: function(e, t) {
                0 < e.length && (u[u.length] = t ? e : f(e))
            },
            cdata: function(e) {
                u.push("<![CDATA[", e, "]]>")
            },
            comment: function(e) {
                u.push("\x3c!--", e, "--\x3e")
            },
            pi: function(e, t) {
                t ? u.push("<?", e, " ", f(t), "?>") : u.push("<?", e, "?>"), s && u.push("\n")
            },
            doctype: function(e) {
                u.push("<!DOCTYPE", e, ">", s ? "\n" : "")
            },
            reset: function() {
                u.length = 0
            },
            getContent: function() {
                return u.join("").replace(/\n$/, "")
            }
        }
    }

    function rm(t, g) {
        void 0 === g && (g = oo());
        var p = nm(t);
        return (t = t || {}).validate = !("validate" in t) || t.validate, {
            serialize: function(e) {
                var f = t.validate,
                    d = {
                        3: function(e) {
                            p.text(e.value, e.raw)
                        },
                        8: function(e) {
                            p.comment(e.value)
                        },
                        7: function(e) {
                            p.pi(e.name, e.value)
                        },
                        10: function(e) {
                            p.doctype(e.value)
                        },
                        4: function(e) {
                            p.cdata(e.value)
                        },
                        11: function(e) {
                            if (e = e.firstChild)
                                for (; m(e), e = e.next;);
                        }
                    };
                p.reset();
                var m = function(e) {
                    var t = d[e.type];
                    if (t) t(e);
                    else {
                        var n = e.name,
                            r = e.shortEnded,
                            o = e.attributes;
                        if (f && o && 1 < o.length) {
                            var i = [];
                            i.map = {};
                            var a = g.getElementRule(e.name);
                            if (a) {
                                for (var u = 0, s = a.attributesOrder.length; u < s; u++)(c = a.attributesOrder[u]) in o.map && (l = o.map[c], i.map[c] = l, i.push({
                                    name: c,
                                    value: l
                                }));
                                for (var c, l, u = 0, s = o.length; u < s; u++)(c = o[u].name) in i.map || (l = o.map[c], i.map[c] = l, i.push({
                                    name: c,
                                    value: l
                                }));
                                o = i
                            }
                        }
                        if (p.start(e.name, o, r), !r) {
                            if (e = e.firstChild)
                                for (; m(e), e = e.next;);
                            p.end(n)
                        }
                    }
                };
                return 1 !== e.type || t.inner ? d[11](e) : m(e), p.getContent()
            }
        }
    }
    var om = Nt.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "),
        im = i(Zd, Kd),
        am = i(Zd, Xd),
        um = Nt.each,
        sm = Nt.makeMap,
        cm = new Set;

    function lm(e, t) {
        return we(e.parseStyle(e.getAttrib(t, "style")))
    }

    function fm(n, r, o) {
        return ve.from(o.container()).filter(Vn).exists(function(e) {
            var t = n ? 0 : -1;
            return r(e.data.charAt(o.offset() + t))
        })
    }

    function dm(e) {
        var t = e.container();
        return Vn(t) && (0 === t.data.length || No(t.data) && Hl.isBookmarkNode(t.parentNode))
    }

    function mm(t, n) {
        return function(e) {
            return ve.from(Zs(t ? 0 : -1, e)).filter(n).isSome()
        }
    }

    function gm(e) {
        return Xn(e) && "block" === wn(Et.fromDom(e), "display")
    }

    function pm(e) {
        return Gn(e) && !(Hn(t = e) && "all" === t.getAttribute("data-mce-bogus"));
        var t
    }

    function hm(e) {
        Xt(e), Ln(e, Et.fromHtml('<br data-mce-bogus="1">'))
    }

    function vm(n) {
        Ut(n).each(function(t) {
            Bt(t).each(function(e) {
                go(n) && Pr(t) && go(e) && In(t)
            })
        })
    }

    function bm(e, t) {
        return o = D, Ve(r = t, n = e) ? function(e, t) {
            for (var n = y(t) ? t : D, r = e.dom, o = []; null !== r.parentNode && void 0 !== r.parentNode;) {
                var i = r.parentNode,
                    a = Et.fromDom(i);
                if (o.push(a), !0 === n(a)) break;
                r = i
            }
            return o
        }(n, function(e) {
            return o(e) || je(e, r)
        }).slice(0, -1) : [];
        var n, r, o
    }

    function ym(e, t) {
        return [e].concat(bm(e, t))
    }

    function Cm(e, t, n) {
        return ef(e, t, n, dm)
    }

    function xm(e, t) {
        return M(ym(Et.fromDom(t.container()), e), go)
    }

    function wm(e, n, r) {
        return Cm(e, n.dom, r).forall(function(t) {
            return xm(n, r).fold(function() {
                return !1 === Qs(t, r, n.dom)
            }, function(e) {
                return !1 === Qs(t, r, n.dom) && Ve(e, Et.fromDom(t.container()))
            })
        })
    }

    function Sm(t, n, r) {
        return xm(n, r).fold(function() {
            return Cm(t, n.dom, r).forall(function(e) {
                return !1 === Qs(e, r, n.dom)
            })
        }, function(e) {
            return Cm(t, e.dom, r).isNone()
        })
    }

    function Nm(e) {
        return ic(e).exists(Pr)
    }

    function Em(e, t, n) {
        var r = Q(U(ym(Et.fromDom(n.container()), t), go)).getOr(t);
        return Zl(e, r.dom, n).filter(Nm)
    }

    function km(e, t) {
        return ic(t).exists(Pr) || Em(!0, e, t).isSome()
    }

    function _m(e, t) {
        return ve.from(t.getNode(!0)).map(Et.fromDom).exists(Pr) || Em(!1, e, t).isSome()
    }

    function Am(e) {
        return cs.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd()
    }

    function Rm(e, t) {
        return Q(U(ym(Et.fromDom(t.container()), e), go)).getOr(e)
    }

    function Dm(e, t) {
        return Am(t) ? Gg(t) : Gg(t) || nf(Rm(e, t).dom, t).exists(Gg)
    }

    function Tm(e, t) {
        return Am(t) ? Yg(t) : Yg(t) || tf(Rm(e, t).dom, t).exists(Yg)
    }

    function Om(e) {
        return ic(e).bind(function(e) {
            return hr(e, _n)
        }).exists(function(e) {
            return T(["pre", "pre-wrap"], wn(e, "white-space"))
        })
    }

    function Bm(e, t) {
        return !Om(t) && (ip(e, t) || up(e, t) || _m(e, t) || Dm(e, t))
    }

    function Pm(e, t) {
        return !Om(t) && (ap(e, t) || sp(e, t) || km(e, t) || Tm(e, t))
    }

    function Lm(e, t) {
        return Bm(e, t) || Pm(e, (r = (n = t).container(), o = n.offset(), Vn(r) && o < r.data.length ? cs(r, o + 1) : n));
        var n, r, o
    }

    function Im(e, t) {
        return sf(e.charAt(t))
    }

    function Mm(e) {
        var t = e.container();
        return Vn(t) && Te(t.data, wo)
    }

    function Fm(g, e) {
        return ve.some(e).filter(Mm).bind(function(e) {
            var t, n, r, o, i, a, u, s, c, l = e.container(),
                f = g,
                d = (i = l).data,
                m = cs(i, 0);
            return (!Im(d, 0) || Lm(f, m) ? (s = (a = l).data, (c = A(u = s.split(""), function(e, t) {
                return sf(e) && 0 < t && t < u.length - 1 && el(u[t - 1]) && el(u[t + 1]) ? " " : e
            }).join("")) !== s && (a.data = c, 1)) : (i.data = " " + d.slice(1), 1)) || (t = g, r = (n = l).data, o = cs(n, r.length - 1), Im(r, r.length - 1) && !Lm(t, o) && (n.data = r.slice(0, -1) + " ", 1)) ? ve.some(e) : ve.none()
        })
    }

    function Um(t) {
        var e = Et.fromDom(t.getBody());
        t.selection.isCollapsed() && Fm(e, cs.fromRangeStart(t.selection.getRng())).each(function(e) {
            t.selection.setRng(e.toRange())
        })
    }

    function zm(e, t, n) {
        var r, o, i, a, u, s, c, l;
        0 !== n && (o = pr(r = Et.fromDom(e), go).getOr(r), i = e.data.slice(t, t + n), a = t + n >= e.data.length && Pm(o, cs(e, e.data.length)), u = 0 === t && Bm(o, cs(e, 0)), e.replaceData(t, n, (c = u, l = a, L(s = i, function(e, t) {
            return Zc(t) || sf(t) ? e.previousCharIsSpace || "" === e.str && c || e.str.length === s.length - 1 && l ? {
                previousCharIsSpace: !1,
                str: e.str + wo
            } : {
                previousCharIsSpace: !0,
                str: e.str + " "
            } : {
                previousCharIsSpace: !1,
                str: e.str + t
            }
        }, {
            previousCharIsSpace: !1,
            str: ""
        }).str)))
    }

    function Hm(e, t) {
        var n = e.data.slice(t);
        zm(e, t, n.length - Qe(n).length)
    }

    function jm(e, t) {
        var n = e.data.slice(0, t),
            r = n.length - Ze(n).length;
        zm(e, t - r, r)
    }

    function Vm(e, t, n, r) {
        void 0 === r && (r = !0);
        var o = Ze(e.data).length,
            i = r ? e : t,
            a = r ? t : e;
        return r ? i.appendData(a.data) : i.insertData(0, a.data), In(Et.fromDom(a)), n && Hm(i, o), i
    }

    function qm(e, t) {
        return r = e, o = (n = t).container(), i = n.offset(), !1 === cs.isTextPosition(n) && o === r.parentNode && i > cs.before(r).offset() ? cs(t.container(), t.offset() - 1) : t;
        var n, r, o, i
    }

    function $m(e) {
        return Vr(e.previousSibling) ? ve.some((t = e.previousSibling, Vn(t) ? cs(t, t.data.length) : cs.after(t))) : e.previousSibling ? of(e.previousSibling) : ve.none();
        var t
    }

    function Wm(e) {
        return Vr(e.nextSibling) ? ve.some((t = e.nextSibling, Vn(t) ? cs(t, 0) : cs.before(t))) : e.nextSibling ? rf(e.nextSibling) : ve.none();
        var t
    }

    function Km(r, o) {
        return $m(o).orThunk(function() {
            return Wm(o)
        }).orThunk(function() {
            return e = r, n = cs.before((t = o).previousSibling || t.parentNode), nf(e, n).fold(function() {
                return tf(e, cs.after(t))
            }, ve.some);
            var e, t, n
        })
    }

    function Xm(n, r) {
        return Wm(r).orThunk(function() {
            return $m(r)
        }).orThunk(function() {
            return tf(e = n, cs.after(t = r)).fold(function() {
                return nf(e, cs.before(t))
            }, ve.some);
            var e, t
        })
    }

    function Ym(t, n, e) {
        e.fold(function() {
            t.focus()
        }, function(e) {
            t.selection.setRng(e.toRange(), n)
        })
    }

    function Gm(e, t) {
        return t && Ee(e.schema.getBlockElements(), kt(t))
    }

    function Jm(e) {
        if (Kr(e)) {
            var t = Et.fromHtml('<br data-mce-bogus="1">');
            return Xt(e), Ln(e, t), ve.some(cs.before(t.dom))
        }
        return ve.none()
    }

    function Qm(t, n, e, r) {
        void 0 === r && (r = !0);
        var o, i, a, u, s, c, l, f, d, m, g, p, h, v, b = (p = n, h = t.getBody(), v = e.dom, (p ? Xm : Km)(h, v).map(R(qm, v))),
            y = pr(e, R(Gm, t), (o = t.getBody(), function(e) {
                return e.dom === o
            })),
            C = (u = b, i = a = e, s = Ee(t.schema.getTextInlineElements(), kt(i)), m = Bt(a).filter(An), g = Pt(a).filter(An), In(a), l = g, f = u, d = function(e, t, n) {
                var r = e.dom,
                    o = t.dom,
                    i = r.data.length;
                return Vm(r, o, s), n.container() === o ? cs(r, i) : n
            }, ((c = m).isSome() && l.isSome() && f.isSome() ? ve.some(d(c.getOrDie(), l.getOrDie(), f.getOrDie())) : ve.none()).orThunk(function() {
                return s && (m.each(function(e) {
                    return jm(e.dom, e.dom.length)
                }), g.each(function(e) {
                    return Hm(e.dom, 0)
                })), u
            }));
        t.dom.isEmpty(t.getBody()) ? (t.setContent(""), t.selection.setCursorLocation()) : y.bind(Jm).fold(function() {
            r && Ym(t, n, C)
        }, function(e) {
            r && Ym(t, n, ve.some(e))
        })
    }

    function Zm(e) {
        return yu(e, "td,th")
    }

    function eg(e, t) {
        return {
            start: e,
            end: t
        }
    }

    function tg(e, t) {
        return yr(Et.fromDom(e), "td,th", t)
    }

    function ng(e) {
        return !je(e.start, e.end)
    }

    function rg(e, n) {
        return Tl(e.start, n).bind(function(t) {
            return Tl(e.end, n).bind(function(e) {
                return je(t, e) ? ve.some(t) : ve.none()
            })
        })
    }

    function og(e) {
        return function(t) {
            return rg(t, e).map(function(e) {
                return {
                    rng: t,
                    table: e,
                    cells: Zm(e)
                }
            })
        }
    }

    function ig(e, t, n, r) {
        if (n.collapsed || !e.forall(ng)) return ve.none();
        if (t.isSameTable) {
            var o = e.bind(og(r));
            return ve.some({
                start: o,
                end: o
            })
        }
        var i, a, u = tg(n.startContainer, r),
            s = tg(n.endContainer, r),
            c = u.bind((a = r, function(t) {
                return Tl(t, a).bind(function(e) {
                    return Z(Zm(e)).map(function(e) {
                        return eg(t, e)
                    })
                })
            })).bind(og(r)),
            l = s.bind((i = r, function(t) {
                return Tl(t, i).bind(function(e) {
                    return Q(Zm(e)).map(function(e) {
                        return eg(e, t)
                    })
                })
            })).bind(og(r));
        return ve.some({
            start: c,
            end: l
        })
    }

    function ag(e, t) {
        return z(e, function(e) {
            return je(e, t)
        })
    }

    function ug(n) {
        return dn(ag(n.cells, n.rng.start), ag(n.cells, n.rng.end), function(e, t) {
            return n.cells.slice(e, t + 1)
        })
    }

    function sg(e, t) {
        var n = t.startTable,
            r = t.endTable,
            o = e.cloneRange();
        return n.each(function(e) {
            return o.setStartAfter(e.dom)
        }), r.each(function(e) {
            return o.setEndBefore(e.dom)
        }), o
    }

    function cg(e, t) {
        var n, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b = (n = e, function(e) {
                return je(n, e)
            }),
            y = dn(tg((r = t).startContainer, o = b), tg(r.endContainer, o), eg),
            C = (l = b, f = x((c = t).startContainer), d = x(c.endContainer), m = f.isSome(), g = d.isSome(), p = dn(f, d, je).getOr(!1), {
                startTable: f,
                endTable: d,
                isStartInTable: m,
                isEndInTable: g,
                isSameTable: p,
                isMultiTable: !p && m && g
            });

        function x(e) {
            return Tl(Et.fromDom(e), l)
        }
        return h = t, v = b, y.exists(function(e) {
            return !ng(t = e) && rg(t, v).exists(function(e) {
                var t = e.dom.rows;
                return 1 === t.length && 1 === t[0].cells.length
            }) && Ol(e.start, h);
            var t
        }) ? y.map(function(e) {
            return fp.singleCellTable(t, e.start)
        }) : C.isMultiTable ? ig(y, u = C, s = t, b).bind(function(e) {
            var t = e.start,
                n = e.end,
                r = t.bind(ug).getOr([]),
                o = n.bind(ug).getOr([]);
            if (0 < r.length && 0 < o.length) {
                var i = sg(s, u);
                return ve.some(fp.multiTable(r, o, i))
            }
            return ve.none()
        }) : ig(y, i = C, a = t, b).bind(function(e) {
            var t = e.start,
                n = e.end;
            return t.or(n)
        }).bind(function(e) {
            var t = i.isSameTable,
                n = ug(e).getOr([]);
            if (t && e.cells.length === n.length) return ve.some(fp.fullTable(e.table));
            if (0 < n.length) {
                if (t) return ve.some(fp.partialTable(n, ve.none()));
                var r = sg(a, i);
                return ve.some(fp.partialTable(n, ve.some(_e(_e({}, i), {
                    rng: r
                }))))
            }
            return ve.none()
        })
    }

    function lg(e) {
        return Y(e, function(e) {
            Cn(e, "contenteditable"), hm(e)
        }), 0
    }

    function fg(e, t, n, r) {
        var o = n.cloneRange();
        r ? (o.setStart(n.startContainer, n.startOffset), o.setEndAfter(t.dom.lastChild)) : (o.setStartBefore(t.dom.firstChild), o.setEnd(n.endContainer, n.endOffset)), mp(e, o, t, !1)
    }

    function dg(e) {
        var t = Dl(e),
            n = Et.fromDom(e.selection.getNode());
        Jn(n.dom) && Kr(n) ? e.selection.setCursorLocation(n.dom, 0) : e.selection.collapse(!0), 1 < t.length && F(t, function(e) {
            return je(e, n)
        }) && pn(n, "data-mce-selected", "1")
    }

    function mg(s, c, e) {
        var l = s.selection.getRng();
        return lg(e.bind(function(e) {
            var t, n, r, o = e.rng,
                i = e.isStartInTable,
                a = (t = i ? o.endContainer : o.startContainer, ve.from(s.dom.getParent(t, s.dom.isBlock)).map(Et.fromDom));
            o.deleteContents(), n = s, r = i, a.filter(Kr).each(function(e) {
                r ? In(e) : (hm(e), n.selection.setCursorLocation(e.dom, 0))
            });
            var u = i ? c[0] : c[c.length - 1];
            return fg(s, u, l, i), Kr(u) ? ve.none() : ve.some(i ? c.slice(1) : c.slice(0, -1))
        }).getOr(c)), dg(s), !0
    }

    function gg(e, t, n, r) {
        var o = e.selection.getRng(),
            i = t[0],
            a = n[n.length - 1];
        fg(e, i, o, !0), fg(e, a, o, !1);
        var u = Kr(i) ? t : t.slice(1),
            s = Kr(a) ? n : n.slice(0, -1);
        return lg(u.concat(s)), r.deleteContents(), dg(e), !0
    }

    function pg(e, t) {
        return Qm(e, !1, t), !0
    }

    function hg(e, t) {
        return M(ym(t, e), yo)
    }

    function vg(e, t) {
        return (e ? tp : np)(t)
    }

    function bg(f, d, s) {
        var m = Et.fromDom(f.getBody());
        return gp(m, s).fold(function() {
            return o = f, i = d, a = m, e = s, u = cs.fromRangeStart(o.selection.getRng()), hg(a, e).bind(function(e) {
                return Kr(e) ? pp(o, e) : (t = a, n = e, r = u, Hc(i, o.getBody(), r).bind(function(e) {
                    return hg(t, Et.fromDom(e.getNode())).map(function(e) {
                        return !1 === je(e, n)
                    })
                }));
                var t, n, r
            }).getOr(!1) || (n = d, r = cs.fromRangeStart((t = f).selection.getRng()), vg(n, r) || Zl(n, t.getBody(), r).exists(function(e) {
                return vg(n, e)
            }));
            var o, i, a, e, u, t, n, r
        }, function(e) {
            return n = d, r = m, o = e, i = cs.fromRangeStart((t = f).selection.getRng()), (Kr(o) ? pp(t, o) : (u = r, c = o, l = i, Hc(s = n, (a = t).getBody(), l).bind(function(e) {
                return r = s, o = l, i = e, rf((n = c).dom).bind(function(t) {
                    return of(n.dom).map(function(e) {
                        return r ? o.isEqual(t) && i.isEqual(e) : o.isEqual(e) && i.isEqual(t)
                    })
                }).getOr(!0) ? pp(a, c) : (t = c, gp(u, Et.fromDom(e.getNode())).map(function(e) {
                    return !1 === je(e, t)
                }));
                var t, n, r, o, i
            }).or(ve.some(!0)))).getOr(!1);
            var a, u, s, c, l, t, n, r, o, i
        })
    }

    function yg(e, t) {
        var n, r, o, i, a, u, s, c, l = Et.fromDom(e.selection.getStart(!0)),
            f = Dl(e);
        return e.selection.isCollapsed() && 0 === f.length ? bg(e, t, l) : (r = l, o = f, i = Et.fromDom((n = e).getBody()), a = n.selection.getRng(), 0 !== o.length ? mg(n, o, ve.none()) : (u = n, c = a, gp(s = i, r).fold(function() {
            return t = u, cg(s, c).map(function(e) {
                return e.fold(R(mp, t), R(pg, t), R(mg, t), R(gg, t))
            });
            var t
        }, function(e) {
            return pp(u, e)
        }).getOr(!1)))
    }

    function Cg(e) {
        return e.collapsed ? e : (a = e, u = cs.fromRangeStart(a), s = cs.fromRangeEnd(a), c = a.commonAncestorContainer, Zl(!1, c, s).map(function(e) {
            return !Qs(u, s, c) && Qs(u, e, c) ? (t = u.container(), n = u.offset(), r = e.container(), o = e.offset(), (i = document.createRange()).setStart(t, n), i.setEnd(r, o), i) : a;
            var t, n, r, o, i
        }).getOr(a));
        var a, u, s, c
    }

    function xg(e, t) {
        var n, r, o, i, a, u = t.firstChild,
            s = t.lastChild;
        return u && "meta" === u.name && (u = u.next), r = s = s && "mce_marker" === s.attr("id") ? s.prev : s, o = (n = e).getNonEmptyElements(), r && (r.isEmpty(o) || (i = r, n.getBlockElements()[i.name] && i.firstChild && i.firstChild === i.lastChild && ("br" === (a = i.firstChild).name || a.value === wo))) && (s = s.prev), u && u === s && ("ul" === u.name || "ol" === u.name)
    }

    function wg(e) {
        return 0 < e.length && (!(r = e[e.length - 1]).firstChild || (t = r) && t.firstChild && t.firstChild === t.lastChild && ((n = t.firstChild).data === wo || Kn(n))) ? e.slice(0, -1) : e;
        var t, n, r
    }

    function Sg(e, t) {
        var n = e.getParent(t, e.isBlock);
        return n && "LI" === n.nodeName ? n : null
    }

    function Ng(e, t) {
        var n = cs.after(e),
            r = Mc(t).prev(n);
        return r ? r.toRange() : null
    }

    function Eg(e, o, i, t) {
        function n(e) {
            var t = cs.fromRangeStart(i),
                n = Mc(o.getRoot()),
                r = 1 === e ? n.prev(t) : n.next(t);
            return !r || Sg(o, r.getNode()) !== R
        }
        var r, a, u, s, c, l, f, d, m, g, p, h, v, b, y, C, x, w, S, N, E, k, _, A = (r = o, c = e.serialize(t), u = (a = r.createFragment(c)).firstChild, s = a.lastChild, u && "META" === u.nodeName && u.parentNode.removeChild(u), s && "mce_marker" === s.id && s.parentNode.removeChild(s), a),
            R = Sg(o, i.startContainer),
            D = wg(U(A.firstChild.childNodes, function(e) {
                return "LI" === e.nodeName
            })),
            T = o.getRoot();
        return n(1) ? (S = T, _ = (w = R).parentNode, Nt.each(D, function(e) {
            _.insertBefore(e, w)
        }), N = S, E = cs.before(w), (k = Mc(N).next(E)) ? k.toRange() : null) : n(2) ? (l = R, d = T, o.insertAfter((f = D).reverse(), l), Ng(f[0], d)) : (g = D, p = T, h = m = R, b = (v = i).cloneRange(), y = v.cloneRange(), b.setStartBefore(h), y.setEndAfter(h), C = [b.cloneContents(), y.cloneContents()], (x = m.parentNode).insertBefore(C[0], m), Nt.each(g, function(e) {
            x.insertBefore(e, m)
        }), x.insertBefore(C[1], m), x.removeChild(m), Ng(g[g.length - 1], p))
    }

    function kg(e, t, n) {
        var r, o, i, a, u = e.selection,
            s = e.dom;
        /^ | $/.test(t) && (r = s, o = u.getRng(), i = t, i = Bm(a = Et.fromDom(r.getRoot()), cs.fromRangeStart(o)) ? i.replace(/^ /, "&nbsp;") : i.replace(/^&nbsp;/, " "), t = i = Pm(a, cs.fromRangeEnd(o)) ? i.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : i.replace(/&nbsp;(<br( \/)?>)?$/, " "));
        var c = e.parser,
            l = n.merge,
            f = rm({
                validate: e.getParam("validate")
            }, e.schema),
            d = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>',
            m = e.fire("BeforeSetContent", {
                content: t,
                format: "html",
                selection: !0,
                paste: n.paste
            });
        if (m.isDefaultPrevented()) e.fire("SetContent", {
            content: m.content,
            format: "html",
            selection: !0,
            paste: n.paste
        });
        else {
            t = m.content, -1 === (t = n.preserve_zwsp ? t : Eo(t)).indexOf("{$caret}") && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, d);
            var g, p, h = (g = u.getRng()).startContainer || (g.parentElement ? g.parentElement() : null),
                v = e.getBody();
            h === v && u.isCollapsed() && s.isBlock(v.firstChild) && ((p = v.firstChild) && !e.schema.getShortEndedElements()[p.nodeName]) && s.isEmpty(v.firstChild) && ((g = s.createRng()).setStart(v.firstChild, 0), g.setEnd(v.firstChild, 0), u.setRng(g)), u.isCollapsed() || function(e) {
                var t = e.dom,
                    n = Cg(e.selection.getRng());
                e.selection.setRng(n);
                var r, o = t.getParent(n.startContainer, hp),
                    i = n;
                null !== (r = o) && r === t.getParent(i.endContainer, hp) && Ol(Et.fromDom(r), i) ? mp(e, n, Et.fromDom(o)) : e.getDoc().execCommand("Delete", !1, null)
            }(e);
            var b, y, C, x, w, S, N, E, k, _, A, R, D, T, O = {
                    context: (I = u.getNode()).nodeName.toLowerCase(),
                    data: n.data,
                    insert: !0
                },
                B = c.parse(t, O);
            if (!0 === n.paste && xg(e.schema, B) && Sg(s, I)) return g = Eg(f, s, u.getRng(), B), u.setRng(g), void e.fire("SetContent", m);
            if (function() {
                    for (var e = B; e = e.walk();) 1 === e.type && e.attr("data-mce-fragment", "1")
                }(), "mce_marker" === (L = B.lastChild).attr("id"))
                for (var P = L, L = L.prev; L; L = L.walk(!0))
                    if (3 === L.type || !s.isBlock(L.name)) {
                        e.schema.isValidChild(L.parent.name, "span") && L.parent.insert(P, L, "br" === L.name);
                        break
                    } if (e._selectionOverrides.showBlockCaretContainer(I), O.invalid) {
                e.selection.setContent(d);
                var I = u.getNode(),
                    M = e.getBody();
                for (9 === I.nodeType ? I = L = M : L = I; L !== M;) L = (I = L).parentNode;
                t = I === M ? M.innerHTML : s.getOuterHTML(I), t = f.serialize(c.parse(t.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
                    return f.serialize(B)
                }))), I === M ? s.setHTML(M, t) : s.setOuterHTML(I, t)
            } else b = e, y = t = f.serialize(B), "all" === (C = I).getAttribute("data-mce-bogus") ? C.parentNode.insertBefore(b.dom.createFragment(y), C) : (x = C.firstChild, w = C.lastChild, !x || x === w && "BR" === x.nodeName ? b.dom.setHTML(C, y) : b.selection.setContent(y));
            N = l, _ = (S = e).schema.getTextInlineElements(), A = S.dom, N && (E = S.getBody(), k = tm(A), Nt.each(A.select("*[data-mce-fragment]"), function(e) {
                    if (V(_[e.nodeName.toLowerCase()]) && j(lm(A, e), function(e) {
                            return !cm.has(e)
                        }))
                        for (var t = e.parentNode; V(t) && t !== E && ! function(r, o, i) {
                                function a(e) {
                                    var t = r.getStyle(o, e),
                                        n = r.getStyle(i, e);
                                    return Be(t) && Be(n) && t !== n
                                }
                                var e = lm(r, o),
                                    u = lm(r, i);
                                return F(e, function(t) {
                                    function e(e) {
                                        return F(e, function(e) {
                                            return e === t
                                        })
                                    }
                                    if (e(u) || !e(Xg)) return a(t);
                                    var n = U(u, function(t) {
                                        return F(Xg, function(e) {
                                            return Ge(t, e)
                                        })
                                    });
                                    return F(n, a)
                                })
                            }(A, e, t); t = t.parentNode)
                            if (k.compare(t, e)) {
                                A.remove(e, !0);
                                break
                            }
                })),
                function(n, e) {
                    var t, r = n.dom,
                        o = n.selection;
                    if (e) {
                        o.scrollIntoView(e);
                        var i = bf(n.getBody(), e);
                        if ("false" === r.getContentEditable(i)) return r.remove(e), o.select(i);
                        var a, u = r.createRng(),
                            s = e.previousSibling;
                        Vn(s) ? (u.setStart(s, s.nodeValue.length), xt.ie || (a = e.nextSibling, Vn(a) && (s.appendData(a.data), a.parentNode.removeChild(a)))) : (u.setStartBefore(e), u.setEndBefore(e));
                        var c = r.getParent(e, r.isBlock);
                        r.remove(e), c && r.isEmpty(c) && (n.$(c).empty(), u.setStart(c, 0), u.setEnd(c, 0), hp(c) || c.getAttribute("data-mce-fragment") || !(t = function(e) {
                            var t = cs.fromRangeStart(e);
                            if (t = Mc(n.getBody()).next(t)) return t.toRange()
                        }(u)) ? r.add(c, r.create("br", {
                            "data-mce-bogus": "1"
                        })) : (u = t, r.remove(c))), o.setRng(u)
                    }
                }(e, s.get("mce_marker")), R = e.getBody(), Nt.each(R.getElementsByTagName("*"), function(e) {
                    e.removeAttribute("data-mce-fragment")
                }), D = s, T = u.getStart(), ve.from(D.getParent(T, "td,th")).map(Et.fromDom).each(vm), e.fire("SetContent", m), e.addVisual()
        }
    }

    function _g(e) {
        return e instanceof jd
    }

    function Ag(e, t, n) {
        var r;
        e.dom.setHTML(e.getBody(), t), !0 !== n && Cd(r = e) && rf(r.getBody()).each(function(e) {
            var t = e.getNode(),
                n = cn(t) ? rf(t).getOr(e) : e;
            r.selection.setRng(n.toRange())
        })
    }

    function Rg(u, s, e) {
        var t, n = (t = s, _e(_e({
                format: "html"
            }, e), {
                set: !0,
                content: _g(t) ? "" : t
            })),
            c = e.no_events ? n : u.fire("BeforeSetContent", n);
        return _g(s) || (s = c.content), ve.from(u.getBody()).fold(J(s), function(e) {
            return _g(s) ? function(e, t, n, r) {
                var o, i, u, a;
                o = e.parser.getNodeFilters(), i = e.parser.getAttributeFilters(), u = n, a = function(e, n) {
                    var t, r, o = {},
                        i = {},
                        a = [];
                    for (t in u.firstChild && vp(u.firstChild, function(t) {
                            Y(e, function(e) {
                                e.name === t.name && (o[e.name] ? o[e.name].nodes.push(t) : o[e.name] = {
                                    filter: e,
                                    nodes: [t]
                                })
                            }), Y(n, function(e) {
                                "string" == typeof t.attr(e.name) && (i[e.name] ? i[e.name].nodes.push(t) : i[e.name] = {
                                    filter: e,
                                    nodes: [t]
                                })
                            })
                        }), o) Ee(o, t) && a.push(o[t]);
                    for (r in i) Ee(i, r) && a.push(i[r]);
                    return a
                }(o, i), Y(a, function(t) {
                    Y(t.filter.callbacks, function(e) {
                        e(t.nodes, t.filter.name, {})
                    })
                });
                var s = rm({
                    validate: e.validate
                }, e.schema).serialize(n);
                return r.content = Eo(Co(Et.fromDom(t)) ? s : Nt.trim(s)), Ag(e, r.content, r.no_selection), r.no_events || e.fire("SetContent", r), n
            }(u, e, s, c) : (t = u, n = e, o = c, 0 === (r = Eo(r = s)).length || /^\s+$/.test(r) ? (i = '<br data-mce-bogus="1">', "TABLE" === n.nodeName ? r = "<tr><td>" + i + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (r = "<li>" + i + "</li>"), r = (a = ks(t)) && t.schema.isValidChild(n.nodeName.toLowerCase(), a.toLowerCase()) ? (r = i, t.dom.createHTML(a, _s(t), r)) : r || '<br data-mce-bogus="1">', Ag(t, r, o.no_selection), t.fire("SetContent", o)) : ("raw" !== o.format && (r = rm({
                validate: t.validate
            }, t.schema).serialize(t.parser.parse(r, {
                isRootContent: !0,
                insert: !0
            }))), o.content = Co(Et.fromDom(n)) ? r : Nt.trim(r), Ag(t, o.content, o.no_selection), o.no_events || t.fire("SetContent", o)), o.content);
            var t, n, r, o, i, a
        })
    }

    function Dg(e) {
        return y(e) ? e : D
    }

    function Tg(i, e, t) {
        var n = e(i),
            a = Dg(t);
        return n.orThunk(function() {
            return a(i) ? ve.none() : function(e) {
                for (var t = i.dom, n = Dg(a); t.parentNode;) {
                    var t = t.parentNode,
                        r = Et.fromDom(t),
                        o = e(r);
                    if (o.isSome()) return o;
                    if (n(r)) break
                }
                return ve.none()
            }(e)
        })
    }

    function Og(e, t, n) {
        var r = e.formatter.get(n);
        if (r)
            for (var o = 0; o < r.length; o++) {
                var i = r[o];
                if (gl(i) && !1 === i.inherit && e.dom.is(t, i.selector)) return 1
            }
    }

    function Bg(t, e, n, r, o) {
        var i = t.dom.getRoot();
        return e !== i && (e = t.dom.getParent(e, function(e) {
            return !!Og(t, e, n) || e.parentNode === i || !!yp(t, e, n, r, !0)
        }), !!yp(t, e, n, r, o))
    }

    function Pg(e, t, n) {
        return !!bp(t, n.inline) || !!bp(t, n.block) || (n.selector ? 1 === t.nodeType && e.is(t, n.selector) : void 0)
    }

    function Lg(e, t, n, r, o, i) {
        var a = n[r];
        if (y(n.onmatch)) return n.onmatch(t, n, r);
        if (a)
            if (b(a.length)) {
                for (var u in a)
                    if (Ee(a, u)) {
                        var s = "attributes" === r ? e.getAttrib(t, u) : cl(e, t, u),
                            c = al(a[u], i),
                            l = K(s) || Pe(s);
                        if (!l || !K(c)) {
                            if (o && l && !n.exact) return;
                            if ((!o || n.exact) && !bp(s, sl(e, c, u))) return
                        }
                    }
            } else
                for (var f = 0; f < a.length; f++)
                    if ("attributes" === r ? e.getAttrib(t, a[f]) : cl(e, t, a[f])) return 1;
        return 1
    }

    function Ig(e, t, n, r, o) {
        if (r) return Bg(e, r, t, n, o);
        if (r = e.selection.getNode(), Bg(e, r, t, n, o)) return !0;
        var i = e.selection.getStart();
        return !(i === r || !Bg(e, i, t, n, o))
    }

    function Mg(e) {
        return 0 < function(e) {
            for (var t = []; e;) {
                if (3 === e.nodeType && e.nodeValue !== Cp || 1 < e.childNodes.length) return [];
                1 === e.nodeType && t.push(e), e = e.firstChild
            }
            return t
        }(e).length
    }

    function Fg(e) {
        if (e) {
            var t = new Dr(e, e);
            for (e = t.current(); e; e = t.next())
                if (Vn(e)) return e
        }
        return null
    }

    function Ug(e) {
        var t = Et.fromTag("span");
        return hn(t, {
            id: xp,
            "data-mce-bogus": "1",
            "data-mce-type": "format-caret"
        }), e && Ln(t, Et.fromText(Cp)), t
    }

    function zg(e, t, n) {
        void 0 === n && (n = !0);
        var r, o, i, a, u, s, c, l, f = e.dom,
            d = e.selection;
        Mg(t) ? Qm(e, !1, Et.fromDom(t), n) : (r = d.getRng(), o = f.getParent(t, f.isBlock), i = r.startContainer, a = r.startOffset, u = r.endContainer, s = r.endOffset, (l = Fg(t)) && l.nodeValue.charAt(0) === Cp && l.deleteData(0, 1), c = l, f.remove(t, !0), i === c && 0 < a && r.setStart(c, a - 1), u === c && 0 < s && r.setEnd(c, s - 1), o && f.isEmpty(o) && hm(Et.fromDom(o)), d.setRng(r))
    }

    function Hg(e, t, n) {
        void 0 === n && (n = !0);
        var r = e.dom,
            o = e.selection;
        if (t) zg(e, t, n);
        else if (!(t = qc(e.getBody(), o.getStart())))
            for (; t = r.get(xp);) zg(e, t, !1)
    }

    function jg(e, t) {
        return e.appendChild(t), t
    }

    function Vg(e, t) {
        var n = P(e, function(e, t) {
            return jg(e, t.cloneNode(!1))
        }, t);
        return jg(n, n.ownerDocument.createTextNode(Cp))
    }

    function qg(o, e, t, i, n, r) {
        var a, u, s = o.formatter,
            c = o.dom,
            l = U(we(s.get()), function(e) {
                return e !== i && !Te(e, "removeformat")
            });
        if (0 < U((a = o, u = t, L(l, function(e, t) {
                var n = dl(a, t);
                return a.formatter.matchNode(u, t, {}, n) ? e.concat([t]) : e
            }, [])), function(e) {
                return n = i, r = ["inline", "block", "selector", "attributes", "styles", "classes"], !F((t = o).formatter.get(e), function(e) {
                    var i = a(e);
                    return F(t.formatter.get(n), function(e) {
                        var t, n = a(e),
                            r = i,
                            o = n;
                        return d(t = void 0 === t ? p : t).eq(r, o)
                    })
                });

                function a(e) {
                    return ae(e, function(e, t) {
                        return F(r, function(e) {
                            return e === t
                        })
                    })
                }
                var t, n, r
            }).length) {
            var f = t.cloneNode(!1);
            return c.add(e, f), s.remove(i, n, f, r), c.remove(f), ve.some(f)
        }
        return ve.none()
    }

    function $g(e, t, n, r) {
        var o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y = e.dom,
            C = e.selection,
            x = [],
            w = C.getRng(),
            S = w.startContainer,
            N = w.startOffset,
            E = S;
        for (3 === S.nodeType && (N !== S.nodeValue.length && (o = !0), E = E.parentNode); E;) {
            if (yp(e, E, t, n, r)) {
                i = E;
                break
            }
            E.nextSibling && (o = !0), x.push(E), E = E.parentNode
        }
        i && (o ? (a = C.getBookmark(), w.collapse(!0), u = Pf(kl(e, w, e.formatter.get(t), !0)), e.formatter.remove(t, n, u, r), C.moveToBookmark(a)) : (s = qc(e.getBody(), i), d = c = Ug(!1).dom, (p = (g = e.dom).getParent(m = null !== s ? s : i, R(ol, e))) && g.isEmpty(p) ? m.parentNode.replaceChild(d, m) : (h = Et.fromDom(m), v = yu(h, "br"), b = U(function() {
            for (var e = [], t = h.dom; t;) e.push(Et.fromDom(t)), t = t.lastChild;
            return e
        }().slice(-1), Pr), v.length === b.length && Y(b, In), g.isEmpty(m) ? m.parentNode.replaceChild(d, m) : g.insertAfter(d, m)), l = qg(e, c, i, t, n, r), f = Vg(x.concat(l.toArray()), c), zg(e, s, !1), C.setCursorLocation(f, 1), y.isEmpty(i) && y.remove(i)))
    }

    function Wg(e, t) {
        var n = e.schema.getTextInlineElements();
        return Ee(n, kt(t)) && !Vc(t.dom) && !sn(t.dom)
    }
    Y(["margin", "margin-left", "margin-right", "margin-top", "margin-bottom", "padding", "padding-left", "padding-right", "padding-top", "padding-bottom", "border", "border-width", "border-style", "border-color", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "float", "position", "left", "right", "top", "bottom", "z-index", "display", "transform", "width", "max-width", "min-width", "height", "max-height", "min-height", "overflow", "overflow-x", "overflow-y", "text-overflow", "vertical-align", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function"], function(e) {
        cm.add(e)
    });
    var Kg, Xg = ["font", "text-decoration", "text-emphasis"],
        Yg = R(fm, !0, Zc),
        Gg = R(fm, !1, Zc),
        Jg = mm(!0, gm),
        Qg = mm(!1, gm),
        Zg = mm(!0, Qn),
        ep = mm(!1, Qn),
        tp = mm(!0, cn),
        np = mm(!1, cn),
        rp = mm(!0, pm),
        op = mm(!1, pm),
        ip = R(Sm, !1),
        ap = R(Sm, !0),
        up = R(wm, !1),
        sp = R(wm, !0),
        cp = R(Em, !1),
        lp = R(Em, !0),
        fp = ir([{
            singleCellTable: ["rng", "cell"]
        }, {
            fullTable: ["table"]
        }, {
            partialTable: ["cells", "outsideDetails"]
        }, {
            multiTable: ["startTableCells", "endTableCells", "betweenRng"]
        }]),
        dp = function(e) {
            var t;
            return (8 === _t(t = e) || "#comment" === kt(t) ? Bt : Ut)(e).bind(dp).orThunk(function() {
                return ve.some(e)
            })
        },
        mp = function(e, t, n, r) {
            void 0 === r && (r = !0), t.deleteContents();
            var o, i = dp(n).getOr(n),
                a = Et.fromDom(e.dom.getParent(i.dom, e.dom.isBlock));
            return Kr(a) && (hm(a), r && e.selection.setCursorLocation(a.dom, 0)), je(n, a) || Y((fn(Ot(a), n) ? [] : Ot(o = a).map(Tn).map(function(e) {
                return U(e, function(e) {
                    return !je(o, e)
                })
            }).getOr([])).concat(Tn(n)), function(e) {
                je(e, a) || Ve(e, a) || !Kr(e) || In(e)
            }), !0
        },
        gp = function(e, t) {
            return M(ym(t, e), function(e) {
                return _n(e) && "caption" === kt(e)
            })
        },
        pp = function(e, t) {
            return hm(t), e.selection.setCursorLocation(t.dom, 0), ve.some(!0)
        },
        hp = Jn,
        vp = function(e, t) {
            t(e), e.firstChild && vp(e.firstChild, t), e.next && vp(e.next, t)
        },
        bp = ul,
        yp = function(e, t, n, r, o) {
            var i = e.formatter.get(n),
                a = e.dom;
            if (i && t)
                for (var u = 0; u < i.length; u++) {
                    var s = i[u];
                    if (Pg(e.dom, t, s) && Lg(a, t, s, "attributes", o, r) && Lg(a, t, s, "styles", o, r)) {
                        var c = s.classes;
                        if (c)
                            for (var l = 0; l < c.length; l++)
                                if (!e.dom.hasClass(t, al(c[l], r))) return;
                        return s
                    }
                }
        },
        Cp = So,
        xp = "_mce_caret",
        wp = {},
        Sp = fe,
        Np = ce;

    function Ep(e) {
        return Hn(e) && !Qc(e) && !Vc(e) && !sn(e)
    }

    function kp(e, t) {
        for (var n = e; n; n = n[t]) {
            if (Vn(n) && Be(n.data)) return e;
            if (Hn(n) && !Qc(n)) return n
        }
        return e
    }

    function _p(e, t, n) {
        var r = tm(e);
        if (t && n && (t = kp(t, "previousSibling"), n = kp(n, "nextSibling"), r.compare(t, n))) {
            for (var o = t.nextSibling; o && o !== n;) {
                var i = o,
                    o = o.nextSibling;
                t.appendChild(i)
            }
            return e.remove(n), Nt.each(Nt.grep(n.childNodes), function(e) {
                t.appendChild(e)
            }), t
        }
        return n
    }

    function Ap(e, t, n, r) {
        var o;
        r && !1 !== t.merge_siblings && (o = _p(e, rl(r), r), _p(e, o, rl(o, !0)))
    }

    function Rp(t, n) {
        return function(e) {
            return !(!e || !cl(t, e, n))
        }
    }

    function Dp(r, o, i) {
        return function(e) {
            var t, n;
            r.setStyle(e, o, i), "" === e.getAttribute("style") && e.removeAttribute("style"), t = r, "SPAN" === (n = e).nodeName && 0 === t.getAttribs(n).length && t.remove(n, !0)
        }
    }

    function Tp(e, t, n) {
        return e.isChildOf(t, n) && t !== n && !e.isBlock(n)
    }

    function Op(e, t, n) {
        var r, o = t[n ? "startContainer" : "endContainer"],
            i = t[n ? "startOffset" : "endOffset"];
        return Hn(o) && (r = o.childNodes.length - 1, !n && i && i--, o = o.childNodes[r < i ? r : i]), Vn(o) && n && i >= o.nodeValue.length && (o = new Dr(o, e.getBody()).next() || o), Vn(o) && !n && 0 === i && new Dr(o, e.getBody()).prev() || o
    }

    function Bp(e, t) {
        var n = t ? "firstChild" : "lastChild";
        if (/^(TR|TH|TD)$/.test(e.nodeName) && e[n]) {
            var r = e[n];
            return "TR" === e.nodeName && r[n] || r
        }
        return e
    }

    function Pp(e, t, n, r) {
        var o = e.create(n, r);
        return t.parentNode.insertBefore(o, t), o.appendChild(t), o
    }

    function Lp(e, t, n, r, o) {
        var i = Et.fromDom(t),
            a = Et.fromDom(e.create(r, o));
        return Kt(a, (n ? It : Lt)(i)), n ? (qt(i, a), Wt(a, i)) : ($t(i, a), Ln(a, i)), a.dom
    }

    function Ip(e, t, n, r) {
        var o = rl(t, n, r);
        return K(o) || "BR" === o.nodeName || e.isBlock(o)
    }

    function Mp(e, r, o, t, i) {
        var n, a, u = e.dom,
            s = u,
            c = t;
        if (!(pl(a = r) && Rh(c, a.inline) || ml(a) && Rh(c, a.block) || gl(a) && (Hn(c) && s.is(c, a.selector)) || r.links && "A" === t.nodeName)) return kh.keep();
        var l, f, d, m, g, p, h, v, b = t;
        if (pl(r) && "all" === r.remove && S(r.preserve_attributes)) {
            var y = U(u.getAttribs(b), function(e) {
                return T(r.preserve_attributes, e.name.toLowerCase())
            });
            if (u.removeAllAttribs(b), Y(y, function(e) {
                    return u.setAttrib(b, e.name, e.value)
                }), 0 < y.length) return kh.rename("span")
        }
        if ("all" !== r.remove) {
            Ah(r.styles, function(e, t) {
                e = sl(u, al(e, o), t + ""), N(t) && (t = e, i = null), !r.remove_similar && i && !Rh(cl(u, i, t), e) || u.setStyle(b, t, ""), n = !0
            }), n && "" === u.getAttrib(b, "style") && (b.removeAttribute("style"), b.removeAttribute("data-mce-style")), Ah(r.attributes, function(e, t) {
                var n;
                if (e = al(e, o), N(t) && (t = e, i = null), r.remove_similar || !i || Rh(u.getAttrib(i, t), e))
                    if ("class" === t && (e = u.getAttrib(b, t)) && (n = "", Y(e.split(/\s+/), function(e) {
                            /mce\-\w+/.test(e) && (n += (n ? " " : "") + e)
                        }), n)) u.setAttrib(b, t, n);
                    else {
                        if (_h.test(t) && b.removeAttribute("data-mce-" + t), "style" === t && on(["li"])(b) && "none" === u.getStyle(b, "list-style-type")) return b.removeAttribute(t), void u.setStyle(b, "list-style-type", "none");
                        "class" === t && b.removeAttribute("className"), b.removeAttribute(t)
                    }
            }), Ah(r.classes, function(e) {
                e = al(e, o), i && !u.hasClass(i, e) || u.removeClass(b, e)
            });
            for (var C = u.getAttribs(b), x = 0; x < C.length; x++) {
                var w = C[x].nodeName;
                if (0 !== w.indexOf("_") && 0 !== w.indexOf("data-")) return kh.keep()
            }
        }
        return "none" !== r.remove ? (l = e, d = r, p = (f = b).parentNode, h = l.dom, v = ks(l), ml(d) && (v ? p === h.getRoot() && (d.list_block && Rh(f, d.list_block) || Y(xe(f.childNodes), function(e) {
            il(l, v, e.nodeName.toLowerCase()) ? m ? m.appendChild(e) : (m = Pp(h, e, v), h.setAttribs(m, l.settings.forced_root_block_attrs)) : m = null
        })) : h.isBlock(f) && !h.isBlock(p) && (Ip(h, f, !1) || Ip(h, f.firstChild, !0, !0) || f.insertBefore(h.create("br"), f.firstChild), Ip(h, f, !0) || Ip(h, f.lastChild, !1, !0) || f.appendChild(h.create("br")))), gl(g = d) && pl(g) && fn(ue(g, "mixed"), !0) && !Rh(d.inline, f) || h.remove(f, !0), kh.removed()) : kh.keep()
    }

    function Fp(t, e, n, r, o) {
        return Mp(t, e, n, r, o).fold(D, function(e) {
            return t.dom.rename(r, e), !0
        }, w)
    }

    function Up(u, s, c, e, l) {
        function a(e) {
            var n, r, o, i, a, t = (r = s, o = c, i = l, Y(fl((n = u).dom, e.parentNode).reverse(), function(e) {
                var t;
                a || "_start" === e.id || "_end" === e.id || (t = yp(n, e, r, o, i)) && !1 !== t.split && (a = e)
            }), a);
            return function(e, t, n, r, o, i, a, u) {
                var s, c, l = e.dom;
                if (n) {
                    for (var f = n.parentNode, d = r.parentNode; d && d !== f; d = d.parentNode) {
                        for (var m = l.clone(d, !1), g = 0; g < t.length && null !== (m = function(t, e, n) {
                                return Mp(t, e, u, n, n).fold(J(n), function(e) {
                                    return t.dom.createFragment().appendChild(n), t.dom.rename(n, e)
                                }, J(null))
                            }(e, t[g], m)); g++);
                        m && (s && m.appendChild(s), c = c || m, s = m)
                    }!i || a.mixed && l.isBlock(n) || (r = l.split(n, r)), s && (o.parentNode.insertBefore(s, o), c.appendChild(o), pl(a) && Ap(l, a, 0, s))
                }
                return r
            }(u, m, t, e, e, !0, g, c)
        }

        function f(t) {
            return F(m, function(e) {
                return Fp(u, e, c, t, t)
            })
        }

        function d(e) {
            var t, n = h.get(e ? "_start" : "_end"),
                r = n[e ? "firstChild" : "lastChild"];
            return Qc(t = r) && Hn(t) && ("_start" === t.id || "_end" === t.id) && (r = r[e ? "firstChild" : "lastChild"]), Vn(r) && 0 === r.data.length && (r = e ? n.previousSibling || n.nextSibling : n.nextSibling || n.previousSibling), h.remove(n, !0), r
        }

        function t(e) {
            var t = kl(u, e, m, e.collapsed);
            if (g.split) {
                if (t = Pf(t), (r = Op(u, t, !0)) !== (o = Op(u, t))) {
                    if (r = Bp(r, !0), o = Bp(o, !1), Tp(h, r, o)) {
                        var n = ve.from(r.firstChild).getOr(r);
                        return a(Lp(h, n, !0, "span", {
                            id: "_start",
                            "data-mce-type": "bookmark"
                        })), void d(!0)
                    }
                    if (Tp(h, o, r)) return n = ve.from(o.lastChild).getOr(o), a(Lp(h, n, !1, "span", {
                        id: "_end",
                        "data-mce-type": "bookmark"
                    })), void d(!1);
                    var r = Pp(h, r, "span", {
                            id: "_start",
                            "data-mce-type": "bookmark"
                        }),
                        o = Pp(h, o, "span", {
                            id: "_end",
                            "data-mce-type": "bookmark"
                        }),
                        i = h.createRng();
                    i.setStartAfter(r), i.setEndBefore(o), _l(h, i, function(e) {
                        Y(e, function(e) {
                            Qc(e) || Qc(e.parentNode) || a(e)
                        })
                    }), a(r), a(o), r = d(!0), o = d()
                } else r = o = a(r);
                t.startContainer = r.parentNode || r, t.startOffset = h.nodeIndex(r), t.endContainer = o.parentNode || o, t.endOffset = h.nodeIndex(o) + 1
            }
            _l(h, t, function(e) {
                Y(e, v)
            })
        }
        var n, m = u.formatter.get(s),
            g = m[0],
            p = !0,
            h = u.dom,
            r = u.selection,
            v = function(t) {
                var e = !0,
                    n = !1;
                Hn(t) && h.getContentEditable(t) && (e = p, p = "true" === h.getContentEditable(t), n = !0);
                var r, o, i = xe(t.childNodes);
                if (p && !n && (r = f(t) || F(m, function(e) {
                        return Pg(h, t, e)
                    }), o = t.parentNode, !r && V(o) && hl(g) && f(o)), g.deep && i.length) {
                    for (var a = 0; a < i.length; a++) v(i[a]);
                    n && (p = e)
                }
                Y(["underline", "line-through", "overline"], function(e) {
                    Hn(t) && u.dom.getStyle(t, "text-decoration") === e && t.parentNode && ll(h, t.parentNode) === e && Fp(u, {
                        deep: !1,
                        exact: !0,
                        inline: "span",
                        styles: {
                            textDecoration: e
                        }
                    }, null, t)
                })
            };
        if (e) return tl(e) ? ((n = h.createRng()).setStartBefore(e), n.setEndAfter(e), t(n)) : t(e), void wf(u, s, e, c);
        if ("false" !== h.getContentEditable(r.getNode())) r.isCollapsed() && pl(g) && !Dl(u).length ? $g(u, s, c, l) : (Il(r, !0, function() {
            Ll(u, t)
        }), pl(g) && Ig(u, s, c, r.getStart()) && nl(h, r, r.getRng()), u.nodeChanged()), wf(u, s, e, c);
        else {
            e = r.getNode();
            for (var o = 0; o < m.length && (!m[o].ceFalseOverride || !Fp(u, m[o], c, e, e)); o++);
            wf(u, s, e, c)
        }
    }

    function zp(e) {
        return Hn(e) && !Qc(e) && !Vc(e) && !sn(e)
    }

    function Hp(e) {
        return Ee(e, "vars")
    }

    function jp(n, e, r, o, i) {
        return I(e, function(e) {
            var t = n.formatter.matchNode(e, r, null != i ? i : {}, o);
            return !b(t)
        }, function(e) {
            return Og(n, e, r) || !o && V(n.formatter.matchNode(e, r, i, !0))
        })
    }

    function Vp(e, t) {
        var n = null != t ? t : Bh(e);
        return U(fl(e.dom, n), function(e) {
            return Hn(e) && !sn(e)
        })
    }

    function qp(e, o, i, a, t, n) {
        var r, u, s, c, l, f, d, m, g;
        return null === o.get() && (u = e, (r = o).set({}), u.on("NodeChange", function(e) {
            Ph(u, e.element, r.get())
        }), u.on("FormatApply FormatRemove", function(e) {
            var t = ve.from(e.node).map(function(e) {
                return tl(e) ? e : e.startContainer
            }).bind(function(e) {
                return Hn(e) ? ve.some(e) : ve.from(e.parentElement)
            }).getOrThunk(function() {
                return Bh(u)
            });
            Ph(u, t, r.get())
        })), s = e, l = i, f = a, d = t, m = n, g = (c = o).get(), Y(l.split(","), function(t) {
            function e() {
                var e = Vp(s);
                return jp(s, e, t, d, m).isSome()
            }
            var n, r = ue(g, t).getOrThunk(function() {
                var e = {
                    withSimilar: {
                        state: au(!1),
                        similar: !0,
                        callbacks: []
                    },
                    withoutSimilar: {
                        state: au(!1),
                        similar: !1,
                        callbacks: []
                    },
                    withVars: []
                };
                return g[t] = e
            });
            b(m) ? ((n = d ? r.withSimilar : r.withoutSimilar).callbacks.push(f), 1 === n.callbacks.length && n.state.set(e())) : r.withVars.push({
                state: au(e()),
                similar: d,
                vars: m,
                callback: f
            })
        }), c.set(g), {
            unbind: function() {
                var e, t = i,
                    n = a,
                    r = (e = o).get();
                Y(t.split(","), function(t) {
                    return ue(r, t).each(function(e) {
                        r[t] = {
                            withSimilar: _e(_e({}, e.withSimilar), {
                                callbacks: U(e.withSimilar.callbacks, function(e) {
                                    return e !== n
                                })
                            }),
                            withoutSimilar: _e(_e({}, e.withoutSimilar), {
                                callbacks: U(e.withoutSimilar.callbacks, function(e) {
                                    return e !== n
                                })
                            }),
                            withVars: U(e.withVars, function(e) {
                                return e.callback !== n
                            })
                        }
                    })
                }), e.set(r)
            }
        }
    }

    function $p(e, t) {
        var n = (t || document).createDocumentFragment();
        return Y(e, function(e) {
            n.appendChild(e.dom)
        }), Et.fromDom(n)
    }

    function Wp(e, t, n) {
        return {
            element: e,
            width: t,
            rows: n
        }
    }

    function Kp(e, t) {
        return {
            element: e,
            cells: t
        }
    }

    function Xp(e, t) {
        var n = parseInt(vn(e, t), 10);
        return isNaN(n) ? 1 : n
    }

    function Yp(e) {
        return L(e, function(e, t) {
            return t.cells.length > e ? t.cells.length : e
        }, 0)
    }

    function Gp(e, t) {
        for (var n = e.rows, r = 0; r < n.length; r++)
            for (var o = n[r].cells, i = 0; i < o.length; i++)
                if (je(o[i], t)) return ve.some({
                    x: i,
                    y: r
                });
        return ve.none()
    }

    function Jp(e, t, n, r, o) {
        for (var i = [], a = e.rows, u = n; u <= o; u++) {
            var s = a[u].cells,
                c = t < r ? s.slice(t, r + 1) : s.slice(r, t + 1);
            i.push(Kp(a[u].element, c))
        }
        return i
    }

    function Qp(e) {
        var o = Wp(Eu(e), 0, []);
        return Y(yu(e, "tr"), function(n, r) {
            Y(yu(n, "td,th"), function(e, t) {
                ! function(e, t, n, r, o) {
                    for (var i = Xp(o, "rowspan"), a = Xp(o, "colspan"), u = e.rows, s = n; s < n + i; s++) {
                        u[s] || (u[s] = Kp(ku(r), []));
                        for (var c = t; c < t + a; c++) u[s].cells[c] = s === n && c === t ? o : Eu(o)
                    }
                }(o, function(e, t, n) {
                    for (; r = t, ((o = e.rows)[n] ? o[n].cells : [])[r];) t++;
                    var r, o;
                    return t
                }(o, t, r), r, n, e)
            })
        }), Wp(o.element, Yp(o.rows), o.rows)
    }

    function Zp(e, t) {
        var n, r, o, i = Et.fromDom(t.commonAncestorContainer),
            a = ym(i, e),
            u = U(a, function(e) {
                return Br(e) || mo(e)
            }),
            s = (o = t, M(r = a, function(e) {
                return "li" === kt(e) && Ol(e, o)
            }).fold(J([]), function(e) {
                return M(r, function(e) {
                    return "ul" === kt(e) || "ol" === kt(e)
                }).map(function(e) {
                    var t = Et.fromTag(kt(e));
                    return xn(t, ae(Nn(e), function(e, t) {
                        return Ge(t, "list-style")
                    })), [Et.fromTag("li"), t]
                }).getOr([])
            }));
        return A(u.concat(s.length ? s : vo(n = i) ? Ot(n).filter(ho).fold(J([]), function(e) {
            return [n, e]
        }) : ho(n) ? [n] : []), Eu)
    }

    function eh() {
        return $p([])
    }

    function th(e, i) {
        return vr(i[0], "table", R(je, e)).bind(function(e) {
            var s, t, n = i[0],
                r = i[i.length - 1],
                o = Qp(e);
            return t = r, Gp(s = o, n).bind(function(u) {
                return Gp(s, t).map(function(e) {
                    return t = s, n = u.x, r = u.y, o = e.x, a = r < (i = e.y) ? Jp(t, n, r, o, i) : Jp(t, n, i, o, r), Wp(t.element, Yp(a), a);
                    var t, n, r, o, i, a
                })
            }).map(function(e) {
                return $p([(n = A((t = e).rows, function(e) {
                    var t = A(e.cells, function(e) {
                            var t = ku(e);
                            return Cn(t, "colspan"), Cn(t, "rowspan"), t
                        }),
                        n = Eu(e.element);
                    return Kt(n, t), n
                }), r = Eu(t.element), Kt(o = Et.fromTag("tbody"), n), Ln(r, o), r)]);
                var t, n, r, o
            })
        }).getOrThunk(eh)
    }

    function nh(e, t) {
        var n, r, o, i, a, u, s, c = Rl(t, e);
        return 0 < c.length ? th(e, c) : (n = e, 0 < (r = t).length && r[0].collapsed ? eh() : (o = n, i = r[0], a = Et.fromDom(i.cloneContents()), s = L(u = Zp(o, i), function(e, t) {
            return Ln(t, e), t
        }, a), 0 < u.length ? $p([s]) : s))
    }

    function rh(e, t) {
        return 0 <= t && t < e.length && Zc(e.charAt(t))
    }

    function oh(e, t) {
        var n = Eo(e.innerText);
        return t ? n.replace(/^[ \f\n\r\t\v]+/, "") : n
    }

    function ih(e) {
        return Hn(e) ? e.outerHTML : Vn(e) ? Zo.encodeRaw(e.data, !1) : qn(e) ? "\x3c!--" + e.data + "--\x3e" : ""
    }

    function ah(e, c) {
        var l = 0;
        Y(e, function(e) {
            var t, n, r, o, i, a, u, s;
            0 === e[0] ? l++ : 1 === e[0] ? (o = c, i = e[1], a = l, s = function(e) {
                var t, n = document.createElement("div"),
                    r = document.createDocumentFragment();
                for (e && (n.innerHTML = e); t = n.firstChild;) r.appendChild(t);
                return r
            }(i), o.hasChildNodes() && a < o.childNodes.length ? (u = o.childNodes[a]).parentNode.insertBefore(s, u) : o.appendChild(s), l++) : 2 === e[0] && (n = l, (t = c).hasChildNodes() && n < t.childNodes.length && (r = t.childNodes[n]).parentNode.removeChild(r))
        })
    }

    function uh(e) {
        var t = e.serializer.getTempAttrs(),
            n = em(e.getBody(), t);
        return null !== n.querySelector("iframe") ? {
            type: "fragmented",
            fragments: U(A(xe(n.childNodes), i(Eo, ih)), function(e) {
                return 0 < e.length
            }),
            content: "",
            bookmark: null,
            beforeBookmark: null
        } : {
            type: "complete",
            fragments: null,
            content: Eo(n.innerHTML),
            bookmark: null,
            beforeBookmark: null
        }
    }

    function sh(e, t, n) {
        var r, o, i, g, p, a, h, v, c, l, u, s = n ? t.beforeBookmark : t.bookmark;

        function b(e, t, n, r) {
            for (var o = e; o - t < r && o < n && g[o] === p[o - t];) ++o;
            return {
                start: e,
                end: o,
                diag: t
            }
        }
        "fragmented" === t.type ? (r = t.fragments, o = e.getBody(), i = A(xe(o.childNodes), ih), ah((p = r, a = (g = i).length + p.length + 2, h = new Array(a), v = new Array(a), c = function(e, t, n, r, o) {
            var i = l(e, t, n, r);
            if (null === i || i.start === t && i.diag === t - r || i.end === e && i.diag === e - n)
                for (var a = e, u = n; a < t || u < r;) a < t && u < r && g[a] === p[u] ? (o.push([0, g[a]]), ++a, ++u) : r - n < t - e ? (o.push([2, g[a]]), ++a) : (o.push([1, p[u]]), ++u);
            else {
                c(e, i.start, n, i.start - i.diag, o);
                for (var s = i.start; s < i.end; ++s) o.push([0, g[s]]);
                c(i.end, t, i.end - i.diag, r, o)
            }
        }, l = function(e, t, n, r) {
            var o = t - e,
                i = r - n;
            if (0 == o || 0 == i) return null;
            var a, u, s, c, l, f = o - i,
                d = i + o,
                m = (d % 2 == 0 ? d : 1 + d) / 2;
            for (h[1 + m] = e, v[1 + m] = t + 1, a = 0; a <= m; ++a) {
                for (u = -a; u <= a; u += 2) {
                    for (s = u + m, u === -a || u !== a && h[s - 1] < h[s + 1] ? h[s] = h[s + 1] : h[s] = h[s - 1] + 1, l = (c = h[s]) - e + n - u; c < t && l < r && g[c] === p[l];) h[s] = ++c, ++l;
                    if (f % 2 != 0 && f - a <= u && u <= f + a && v[s - f] <= h[s]) return b(v[s - f], u + e - n, t, r)
                }
                for (u = f - a; u <= f + a; u += 2) {
                    for (s = u + m - f, u === f - a || u !== f + a && v[s + 1] <= v[s - 1] ? v[s] = v[s + 1] - 1 : v[s] = v[s - 1], l = (c = v[s] - 1) - e + n - u; e <= c && n <= l && g[c] === p[l];) v[s] = c--, l--;
                    if (f % 2 == 0 && -a <= u && u <= a && v[s] <= h[s + f]) return b(v[s], u + e - n, t, r)
                }
            }
        }, u = [], c(0, g.length, 0, p.length, u), u), o)) : e.setContent(t.content, {
            format: "raw",
            no_selection: !V(s) || !$c(s) || !s.isFakeCaret
        }), e.selection.moveToBookmark(s)
    }

    function ch(e) {
        return "fragmented" === e.type ? e.fragments.join("") : e.content
    }

    function lh(e) {
        var t = Et.fromTag("body", Lh());
        return Su(t, ch(e)), Y(yu(t, "*[data-mce-bogus]"), Yt), t.dom.innerHTML
    }

    function fh(e, t) {
        return !(!e || !t) && (r = t, ch(e) === ch(r) || (n = t, lh(e) === lh(n)));
        var n, r
    }

    function dh(e) {
        return 0 === e.get()
    }

    function mh(e, t, n) {
        dh(n) && (e.typing = t)
    }

    function gh(e, t) {
        e.typing && (mh(e, !1, t), e.add())
    }

    function ph(c) {
        return {
            undoManager: {
                beforeChange: function(e, t) {
                    var n = c,
                        r = t;
                    dh(e) && r.set(hc(n.selection))
                },
                add: function(e, t, n, r, o, i) {
                    return function(e, t, n, r, o, i, a) {
                        var u = uh(e);
                        if (i = Nt.extend(i = i || {}, u), !1 === dh(r) || e.removed) return null;
                        var s = t.data[n.get()];
                        if (e.fire("BeforeAddUndo", {
                                level: i,
                                lastLevel: s,
                                originalEvent: a
                            }).isDefaultPrevented()) return null;
                        if (s && fh(s, i)) return null;
                        t.data[n.get()] && o.get().each(function(e) {
                            t.data[n.get()].beforeBookmark = e
                        });
                        var c = e.getParam("custom_undo_redo_levels", 0, "number");
                        if (c && t.data.length > c) {
                            for (var l = 0; l < t.data.length - 1; l++) t.data[l] = t.data[l + 1];
                            t.data.length--, n.set(t.data.length)
                        }
                        i.bookmark = hc(e.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(i), n.set(t.data.length - 1);
                        var f = {
                            level: i,
                            lastLevel: s,
                            originalEvent: a
                        };
                        return 0 < n.get() ? (e.setDirty(!0), e.fire("AddUndo", f), e.fire("change", f)) : e.fire("AddUndo", f), i
                    }(c, e, t, n, r, o, i)
                },
                undo: function(e, t, n) {
                    return r = c, i = t, a = n, (o = e).typing && (o.add(), o.typing = !1, mh(o, !1, i)), 0 < a.get() && (a.set(a.get() - 1), sh(r, u = o.data[a.get()], !0), r.setDirty(!0), r.fire("Undo", {
                        level: u
                    })), u;
                    var r, o, i, a, u
                },
                redo: function(e, t) {
                    return n = c, o = t, (r = e).get() < o.length - 1 && (r.set(r.get() + 1), sh(n, i = o[r.get()], !1), n.setDirty(!0), n.fire("Redo", {
                        level: i
                    })), i;
                    var n, r, o, i
                },
                clear: function(e, t) {
                    var n, r = c,
                        o = t;
                    (n = e).data = [], o.set(0), n.typing = !1, r.fire("ClearUndos")
                },
                reset: function(e) {
                    var t;
                    (t = e).clear(), t.add()
                },
                hasUndo: function(e, t) {
                    return n = c, r = e, 0 < t.get() || r.typing && r.data[0] && !fh(uh(n), r.data[0]);
                    var n, r
                },
                hasRedo: function(e, t) {
                    return n = e, t.get() < n.data.length - 1 && !n.typing;
                    var n
                },
                transact: function(e, t, n) {
                    return o = n, gh(r = e, t), r.beforeChange(), r.ignore(o), r.add();
                    var r, o
                },
                ignore: function(e, t) {
                    try {
                        e.set(e.get() + 1), t()
                    } finally {
                        e.set(e.get() - 1)
                    }
                },
                extra: function(e, t, n, r) {
                    var o, i, a = c,
                        u = t,
                        s = r;
                    (o = e).transact(n) && (i = o.data[u.get()].bookmark, sh(a, o.data[u.get() - 1], !0), o.transact(s) && (o.data[u.get() - 1].beforeBookmark = i))
                }
            },
            formatter: {
                match: function(e, t, n, r) {
                    return Ig(c, e, t, n, r)
                },
                matchAll: function(e, t) {
                    return o = e, i = t, a = [], u = {}, n = (r = c).selection.getStart(), r.dom.getParent(n, function(e) {
                        for (var t = 0; t < o.length; t++) {
                            var n = o[t];
                            !u[n] && yp(r, e, n, i) && (u[n] = !0, a.push(n))
                        }
                    }, r.dom.getRoot()), a;
                    var r, o, i, a, u, n
                },
                matchNode: function(e, t, n, r) {
                    return yp(c, e, t, n, r)
                },
                canApply: function(u) {
                    return function(e) {
                        var t = e.formatter.get(u),
                            n = e.dom;
                        if (t)
                            for (var r = fl(n, e.selection.getStart()), o = t.length - 1; 0 <= o; o--) {
                                var i = t[o];
                                if (!gl(i) || V(i.defaultBlock)) return !0;
                                for (var a = r.length - 1; 0 <= a; a--)
                                    if (n.is(r[a], i.selector)) return !0
                            }
                        return !1
                    }(c)
                },
                closest: function(e) {
                    return r = c, o = e, ve.from(r.selection.getStart(!0)).bind(function(e) {
                        return Tg(Et.fromDom(e), function(n) {
                            return ee(o, function(e) {
                                return yp(r, n.dom, t = e) ? ve.some(t) : ve.none();
                                var t
                            })
                        }, t)
                    }).getOrNull();

                    function t(e) {
                        return je(e, Et.fromDom(r.getBody()))
                    }
                    var r, o
                },
                apply: function(e, t, n) {
                    return Oh(c, e, t, n)
                },
                remove: function(e, t, n, r) {
                    return Up(c, e, t, n, r)
                },
                toggle: function(e, t, n) {
                    var r, o = e,
                        i = t,
                        a = n,
                        u = (r = c).formatter.get(o);
                    (!Ig(r, o, i, a) || "toggle" in u[0] && !u[0].toggle ? Oh : Up)(r, o, i, a)
                },
                formatChanged: function(e, t, n, r, o) {
                    return qp(c, e, t, n, r, o)
                }
            },
            editor: {
                getContent: function(e, t) {
                    return d = c, m = e, g = t, ve.from(d.getBody()).fold(J("tree" === m.format ? new jd("body", 11) : ""), function(e) {
                        return t = d, r = e, o = g, c = _e(_e({}, n = m), {
                            format: o,
                            get: !0,
                            getInner: !0
                        }), l = n.no_events ? c : t.fire("BeforeGetContent", c), f = "raw" === l.format ? Nt.trim(Eo(em(r, t.serializer.getTempAttrs()).innerHTML)) : "text" === l.format ? t.dom.isEmpty(r) ? "" : Eo(r.innerText || r.textContent) : "tree" === l.format ? t.serializer.serialize(r, l) : (a = (i = t).serializer.serialize(r, l), u = ks(i), s = new RegExp("^(<" + u + "[^>]*>(&nbsp;|&#160;|\\s|\xa0|<br \\/>|)<\\/" + u + ">[\r\n]*|<br \\/>[\r\n]*)$"), a.replace(s, "")), T(["text", "tree"], l.format) || Co(Et.fromDom(r)) ? l.content = f : l.content = Nt.trim(f), (l.no_events ? l : t.fire("GetContent", l)).content;
                        var t, n, r, o, i, a, u, s, c, l, f
                    });
                    var d, m, g
                },
                setContent: function(e, t) {
                    return Rg(c, e, t)
                },
                insertContent: function(e, t) {
                    return kg(c, e, t)
                },
                addVisual: function(e) {
                    var i, t = e,
                        a = (i = c).dom,
                        n = V(t) ? t : i.getBody();
                    b(i.hasVisual) && (i.hasVisual = i.getParam("visual", !0, "boolean")), Y(a.select("table,a", n), function(e) {
                        switch (e.nodeName) {
                            case "TABLE":
                                var t = i.getParam("visual_table_class", "mce-item-table", "string"),
                                    n = a.getAttrib(e, "border");
                                n && "0" !== n || !i.hasVisual ? a.removeClass(e, t) : a.addClass(e, t);
                                break;
                            case "A":
                                var r, o;
                                a.getAttrib(e, "href") || (r = a.getAttrib(e, "name") || e.id, o = i.getParam("visual_anchor_class", "mce-item-anchor", "string"), r && i.hasVisual ? a.addClass(e, o) : a.removeClass(e, o))
                        }
                    }), i.fire("VisualAid", {
                        element: t,
                        hasVisual: i.hasVisual
                    })
                }
            },
            selection: {
                getContent: function(e, t) {
                    return function(e, t, n) {
                        var r, o = (r = t, _e(_e({}, n = void 0 === n ? {} : n), {
                                format: r,
                                get: !0,
                                selection: !0
                            })),
                            i = e.fire("BeforeGetContent", o);
                        if (i.isDefaultPrevented()) return e.fire("GetContent", i), i.content;
                        if ("text" === i.format) return m = e, ve.from(m.selection.getRng()).map(function(e) {
                            var t = ve.from(m.dom.getParent(e.commonAncestorContainer, m.dom.isBlock)),
                                n = m.getBody(),
                                r = t.map(function(e) {
                                    return e.nodeName
                                }).getOr("div").toLowerCase(),
                                o = xt.browser.isIE() && "pre" !== r,
                                i = m.dom.add(n, r, {
                                    "data-mce-bogus": "all",
                                    style: "overflow: hidden; opacity: 0;"
                                }, e.cloneContents()),
                                a = oh(i, o),
                                u = Eo(i.textContent);
                            if (m.dom.remove(i), rh(u, 0) || rh(u, u.length - 1)) {
                                var s = oh(t.getOr(n), o),
                                    c = s.indexOf(a);
                                return -1 === c ? a : (rh(s, c - 1) ? " " : "") + a + (rh(s, c + a.length) ? " " : "")
                            }
                            return a
                        }).getOr("");
                        i.getInner = !0;
                        var a, u, s, c, l, f, d, m, g = (u = i, s = (a = e).selection.getRng(), c = a.dom.create("body"), l = a.selection.getSel(), f = Ed(a, Al(l)), (d = u.contextual ? nh(Et.fromDom(a.getBody()), f).dom : s.cloneContents()) && c.appendChild(d), a.selection.serializer.serialize(c, u));
                        return "tree" === i.format ? g : (i.content = e.selection.isCollapsed() ? "" : g, e.fire("GetContent", i), i.content)
                    }(c, e, t)
                }
            },
            raw: {
                getModel: function() {
                    return ve.none()
                }
            }
        }
    }

    function hh(e) {
        return Ee(e.plugins, "rtc")
    }

    function vh(e) {
        var u = e;
        return ue(e.plugins, "rtc").bind(function(e) {
            return ve.from(e.setup)
        }).fold(function() {
            return u.rtcInstance = ph(e), ve.none()
        }, function(e) {
            var t, n;
            return u.rtcInstance = (t = J(null), n = J(""), {
                undoManager: {
                    beforeChange: te,
                    add: t,
                    undo: t,
                    redo: t,
                    clear: te,
                    reset: te,
                    hasUndo: D,
                    hasRedo: D,
                    transact: t,
                    ignore: te,
                    extra: te
                },
                formatter: {
                    match: D,
                    matchAll: J([]),
                    matchNode: J(void 0),
                    canApply: D,
                    closest: n,
                    apply: te,
                    remove: te,
                    toggle: te,
                    formatChanged: J({
                        unbind: te
                    })
                },
                editor: {
                    getContent: n,
                    setContent: n,
                    insertContent: te,
                    addVisual: te
                },
                selection: {
                    getContent: n
                },
                raw: {
                    getModel: J(ve.none())
                }
            }), ve.some(function() {
                return e().then(function(e) {
                    return u.rtcInstance = (i = e.undoManager, a = e.formatter, n = e.editor, r = e.selection, t = e.raw, {
                        undoManager: {
                            beforeChange: i.beforeChange,
                            add: i.add,
                            undo: i.undo,
                            redo: i.redo,
                            clear: i.clear,
                            reset: i.reset,
                            hasUndo: i.hasUndo,
                            hasRedo: i.hasRedo,
                            transact: function(e, t, n) {
                                return i.transact(n)
                            },
                            ignore: function(e, t) {
                                return i.ignore(t)
                            },
                            extra: function(e, t, n, r) {
                                return i.extra(n, r)
                            }
                        },
                        formatter: {
                            match: function(e, t, n, r) {
                                return a.match(e, o(t), r)
                            },
                            matchAll: a.matchAll,
                            matchNode: a.matchNode,
                            canApply: function(e) {
                                return a.canApply(e)
                            },
                            closest: function(e) {
                                return a.closest(e)
                            },
                            apply: function(e, t, n) {
                                return a.apply(e, o(t))
                            },
                            remove: function(e, t, n, r) {
                                return a.remove(e, o(t))
                            },
                            toggle: function(e, t, n) {
                                return a.toggle(e, o(t))
                            },
                            formatChanged: function(e, t, n, r, o) {
                                return a.formatChanged(t, n, r, o)
                            }
                        },
                        editor: {
                            getContent: function(e, t) {
                                return n.getContent(e)
                            },
                            setContent: function(e, t) {
                                return n.setContent(e, t)
                            },
                            insertContent: function(e, t) {
                                return n.insertContent(e)
                            },
                            addVisual: n.addVisual
                        },
                        selection: {
                            getContent: function(e, t) {
                                return r.getContent(t)
                            }
                        },
                        raw: {
                            getModel: function() {
                                return ve.some(t.getRawModel())
                            }
                        }
                    }), e.rtc.isRemote;

                    function o(e) {
                        return h(e) ? e : {}
                    }
                    var i, a, n, r, t
                })
            })
        })
    }

    function bh(e) {
        return e.rtcInstance || ph(e)
    }

    function yh(e) {
        var t = e.rtcInstance;
        if (t) return t;
        throw new Error("Failed to get RTC instance not yet initialized.")
    }

    function Ch(e) {
        return 0 === e.dom.length ? (In(e), ve.none()) : ve.some(e)
    }

    function xh(e, t, u, s) {
        e.bind(function(a) {
            return (s ? jm : Hm)(a.dom, s ? a.dom.length : 0), t.filter(An).map(function(e) {
                var t = u,
                    n = s,
                    r = a.dom,
                    o = e.dom,
                    i = (n ? r : o).length;
                n ? (Vm(r, o, !1, !n), t.setStart(o, i)) : (Vm(o, r, !1, !n), t.setEnd(o, i))
            })
        }).orThunk(function() {
            var e = s;
            return t.filter(function(e) {
                return Hl.isBookmarkNode(e.dom)
            }).bind(e ? Pt : Bt).or(t).filter(An).map(function(e) {
                var n, r = s;
                Ot(n = e).each(function(e) {
                    var t = n.dom;
                    r && Bm(e, cs(t, 0)) ? Hm(t, 0) : !r && Pm(e, cs(t, t.length)) && jm(t, t.length)
                })
            })
        })
    }

    function wh(e, t, n) {
        var r, o = (r = t, _e(_e({
                format: "html"
            }, n = void 0 === n ? {} : n), {
                set: !0,
                selection: !0,
                content: r
            })),
            i = o;
        if (!o.no_events) {
            var a = e.fire("BeforeSetContent", o);
            if (a.isDefaultPrevented()) return void e.fire("SetContent", a);
            i = a
        }
        i.content = function(e, t) {
            if ("raw" === t.format) return t.content;
            var n = e.selection.getRng(),
                r = e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock),
                o = r ? {
                    context: r.nodeName.toLowerCase()
                } : {},
                i = e.parser.parse(t.content, _e(_e({
                    isRootContent: !0,
                    forced_root_block: !1
                }, o), t));
            return rm({
                validate: e.validate
            }, e.schema).serialize(i)
        }(e, i);
        var u = e.selection.getRng();
        ! function(e, t) {
            var n = ve.from(t.firstChild).map(Et.fromDom),
                r = ve.from(t.lastChild).map(Et.fromDom);
            e.deleteContents(), e.insertNode(t);
            var o = n.bind(Bt).filter(An).bind(Ch),
                i = r.bind(Pt).filter(An).bind(Ch);
            xh(o, n, e, !0), xh(i, r, e, !1), e.collapse(!1)
        }(u, u.createContextualFragment(i.content)), e.selection.setRng(u), nd(e, u), i.no_events || e.fire("SetContent", i)
    }

    function Sh(e, t, n) {
        var r;
        e && Ee(e, t) && (0 === (r = U(e[t], function(e) {
            return e !== n
        })).length ? delete e[t] : e[t] = r)
    }
    Kg = function(e) {
        var t, n = e.selection.getRng(),
            r = on(["pre"]);
        n.collapsed || (t = e.selection.getSelectedBlocks(), Np(Sp(Sp(t, r), function(e) {
            return r(e.previousSibling) && -1 !== de(t, e.previousSibling)
        }), function(e) {
            var t, n = e.previousSibling;
            Ya(t = e).remove(), Ya(n).append("<br><br>").append(t.childNodes)
        }))
    }, wp["pre"] || (wp.pre = []), wp.pre.push(Kg);
    var Nh = Nt.each,
        Eh = function(e, t, n) {
            Nh(e.childNodes, function(e) {
                Ep(e) && (t(e) && n(e), e.hasChildNodes() && Eh(e, t, n))
            })
        },
        kh = ir([{
            keep: []
        }, {
            rename: ["name"]
        }, {
            removed: []
        }]),
        _h = /^(src|href|style)$/,
        Ah = Nt.each,
        Rh = ul,
        Dh = Nt.each,
        Th = Nt.each,
        Oh = function(S, N, E, r) {
            function k(n, e) {
                var t;
                y((e = void 0 === e ? A : e).onformat) && e.onformat(n, e, E, r), Th(e.styles, function(e, t) {
                    u.setStyle(n, t, al(e, E))
                }), !e.styles || (t = u.getAttrib(n, "style")) && u.setAttrib(n, "data-mce-style", t), Th(e.attributes, function(e, t) {
                    u.setAttrib(n, t, al(e, E))
                }), Th(e.classes, function(e) {
                    e = al(e, E), u.hasClass(n, e) || u.addClass(n, e)
                })
            }

            function g(e, t) {
                var n = !1;
                return Th(e, function(e) {
                    return !!gl(e) && (V(e.collapsed) && e.collapsed !== a || !u.is(t, e.selector) || Vc(t) ? void 0 : (k(t, e), !(n = !0)))
                }), n
            }

            function o(x, e, l) {
                var w = [],
                    f = !0,
                    d = A.inline || A.block,
                    m = function(e) {
                        if (X(e)) {
                            var t = u.create(e);
                            return k(t), t
                        }
                        return null
                    }(d);
                _l(x, e, function(e) {
                    var s, c = function(e) {
                        var t = !1,
                            n = f,
                            r = e.nodeName.toLowerCase(),
                            o = e.parentNode,
                            i = o.nodeName.toLowerCase();
                        if (Hn(e) && x.getContentEditable(e) && (n = f, f = "true" === x.getContentEditable(e), t = !0), Kn(e) && ! function(e, t, n, r) {
                                if (e.getParam("format_empty_lines", !1, "boolean") && pl(t)) {
                                    var o = no(e.schema),
                                        i = (a = Et.fromDom(n), s = function(e) {
                                            return Vc(e.dom)
                                        }, ((c = (u = a).dom).parentNode ? kr(Et.fromDom(c.parentNode), function(e) {
                                            return !je(u, e) && s(e)
                                        }) : ve.none()).isSome());
                                    return se(o, r) && Kr(Et.fromDom(n.parentNode), !1) && !i
                                }
                                var a, u, s, c
                            }(S, A, e, i)) return s = null, void(ml(A) && x.remove(e));
                        if (ml(A) && A.wrapper && yp(S, e, N, E)) s = null;
                        else {
                            if (f && !t && ml(A) && !A.wrapper && ol(S, r) && il(S, i, d)) {
                                var a = x.rename(e, d);
                                return k(a), w.push(a), void(s = null)
                            }
                            if (gl(A)) {
                                var u = g(_, e);
                                if (!u && V(o) && hl(A) && (u = g(_, o)), !pl(A) || u) return void(s = null)
                            }!f || t || !il(S, d, r) || !il(S, i, d) || !l && Vn(e) && No(e.data) || Vc(e) || pl(A) && x.isBlock(e) ? (s = null, Y(xe(e.childNodes), c), t && (f = n), s = null) : (s || (s = x.clone(m, !1), e.parentNode.insertBefore(s, e), w.push(s)), s.appendChild(e))
                        }
                    };
                    Y(e, c)
                }), !0 === A.links && Y(w, function(e) {
                    var t = function(e) {
                        "A" === e.nodeName && k(e, A), Y(xe(e.childNodes), t)
                    };
                    t(e)
                }), Y(w, function(e) {
                    var n, t, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y = (n = 0, Y(e.childNodes, function(e) {
                        var t;
                        V(t = e) && Vn(t) && 0 === t.length || Qc(e) || n++
                    }), n);

                    function C(e) {
                        var t;
                        1 === e.nodeType && e.parentNode && 1 === e.parentNode.nodeType && (t = ll(m, e.parentNode), m.getStyle(e, "color") && t ? m.setStyle(e, "text-decoration", t) : m.getStyle(e, "text-decoration") === t && m.setStyle(e, "text-decoration", null))
                    }!(1 < w.length) && x.isBlock(e) || 0 !== y ? (pl(A) || ml(A) && A.wrapper) && (A.exact || 1 !== y || (e = M((d = e).childNodes, zp).filter(function(e) {
                        return Pg(x, e, A)
                    }).map(function(e) {
                        var t = x.clone(e, !1);
                        return k(t), x.replace(t, d, !0), x.remove(e, !0), t
                    }).getOr(d)), h = S, v = E, b = e, Dh(_, function(t) {
                        var r, e, n;
                        pl(t) && Dh(h.dom.select(t.inline, b), function(e) {
                            Ep(e) && Fp(h, t, v, e, t.exact ? e : null)
                        }), r = h.dom, (e = t).clear_child_styles && (n = e.links ? "*:not(a)" : "*", Nh(r.select(n, b), function(n) {
                            Ep(n) && Nh(e.styles, function(e, t) {
                                r.setStyle(n, t, "")
                            })
                        }))
                    }), s = A, yp(u = S, (f = e).parentNode, c = N, l = E) && Fp(u, s, l, f) || s.merge_with_parents && u.dom.getParent(f.parentNode, function(e) {
                        if (yp(u, e, c, l)) return Fp(u, s, l, f), !0
                    }), a = e, (i = A).styles && i.styles.backgroundColor && Eh(a, Rp(x, "fontSize"), Dp(x, "backgroundColor", al(i.styles.backgroundColor, E))), m = x, p = e, (g = A).styles && (g.styles.color || g.styles.textDecoration) && (Nt.walk(p, C, "childNodes"), C(p)), t = x, o = e, !pl(r = A) || "sub" !== r.inline && "sup" !== r.inline || (Eh(o, Rp(t, "fontSize"), Dp(t, "fontSize", "")), t.remove(t.select("sup" === r.inline ? "sub" : "sup", o), !0)), Ap(x, A, 0, e)) : x.remove(e, !0)
                })
            }
            var e, t, n, i, _ = S.formatter.get(N),
                A = _[0],
                a = !r && S.selection.isCollapsed(),
                u = S.dom,
                s = S.selection;
            if ("false" !== u.getContentEditable(s.getNode())) A && (r ? tl(r) ? g(_, r) || ((e = u.createRng()).setStartBefore(r), e.setEndAfter(r), o(u, kl(S, e, _), !0)) : o(u, r, !0) : a && pl(A) && !Dl(S).length ? function(e, t, n) {
                var r, o = e.selection,
                    i = o.getRng(),
                    a = i.startOffset,
                    u = i.startContainer.nodeValue,
                    s = qc(e.getBody(), o.getStart());
                s && (r = Fg(s));
                var c, l, f, d, m = /[^\s\u00a0\u00ad\u200b\ufeff]/;
                u && 0 < a && a < u.length && m.test(u.charAt(a)) && m.test(u.charAt(a - 1)) ? (c = o.getBookmark(), i.collapse(!0), l = Pf(kl(e, i, e.formatter.get(t))), e.formatter.apply(t, n, l), o.moveToBookmark(c)) : (s && r.nodeValue === Cp || (f = e.getDoc(), d = Ug(!0).dom, r = (s = f.importNode(d, !0)).firstChild, i.insertNode(s), a = 1), e.formatter.apply(t, n, s), o.setCursorLocation(r, a))
            }(S, N, E) : (t = s.getNode(), n = _[0], S.settings.forced_root_block || !n.defaultBlock || u.getParent(t, u.isBlock) || Oh(S, n.defaultBlock), s.setRng(Cg(s.getRng())), Il(s, !0, function() {
                Ll(S, function(e, t) {
                    var n = t ? e : kl(S, e, _);
                    o(u, n, !1)
                })
            }), nl(u, s, s.getRng()), S.nodeChanged()), i = S, Np(wp[N], function(e) {
                e(i)
            })), xf(S, N, r, E);
            else {
                r = s.getNode();
                for (var c = 0, l = _.length; c < l; c++) {
                    var f = _[c];
                    if (f.ceFalseOverride && gl(f) && u.is(r, f.selector)) {
                        k(r, f);
                        break
                    }
                }
                xf(S, N, r, E)
            }
        },
        Bh = function(e) {
            return e.selection.getStart()
        },
        Ph = function(i, a, e) {
            var u = Vp(i, a);
            ne(e, function(e, o) {
                function t(e) {
                    var t, n = jp(i, u, o, e.similar, Hp(e) ? e.vars : void 0),
                        r = n.isSome();
                    e.state.get() !== r && (e.state.set(r), t = n.getOr(a), Hp(e) ? e.callback(r, {
                        node: t,
                        format: o,
                        parents: u
                    }) : Y(e.callbacks, function(e) {
                        return e(r, {
                            node: t,
                            format: o,
                            parents: u
                        })
                    }))
                }
                Y([e.withSimilar, e.withoutSimilar], t), Y(e.withVars, t)
            })
        },
        Lh = Re(function() {
            return document.implementation.createHTMLDocument("undo")
        });

    function Ih(e) {
        return e.select
    }

    function Mh(e) {
        return e && e.ownerDocument && Ve(Et.fromDom(e.ownerDocument), Et.fromDom(e))
    }

    function Fh(a, u, e, s) {
        function t(e, t) {
            return wh(s, e, t)
        }

        function n() {
            var e = c(),
                t = null == e ? void 0 : e.anchorNode,
                n = null == e ? void 0 : e.focusNode;
            if (!e || !t || !n || rn(t) || rn(n)) return !0;
            var r = a.createRng();
            r.setStart(t, e.anchorOffset), r.collapse(!0);
            var o = a.createRng();
            return o.setStart(n, e.focusOffset), o.collapse(!0), r.compareBoundaryPoints(r.START_TO_START, o) <= 0
        }

        function r(e) {
            var t = p();
            t.collapse(!!e), h(t)
        }

        function c() {
            return u.getSelection ? u.getSelection() : u.document.selection
        }
        var l, f, o, i, d, m, g = function(e, t) {
                return d || (d = {}, m = {}, i.on("NodeChange", function(e) {
                    var n = e.element,
                        r = x(n),
                        o = {};
                    Nt.each(d, function(e, n) {
                        C(n, r).each(function(t) {
                            m[n] || (Y(e, function(e) {
                                e(!0, {
                                    node: t,
                                    selector: n,
                                    parents: r
                                })
                            }), m[n] = e), o[n] = e
                        })
                    }), Nt.each(m, function(e, t) {
                        o[t] || (delete m[t], Nt.each(e, function(e) {
                            e(!1, {
                                node: n,
                                selector: t,
                                parents: r
                            })
                        }))
                    })
                })), d[e] || (d[e] = []), d[e].push(t), C(e, x(i.selection.getStart())).each(function() {
                    m[e] = d[e]
                }), {
                    unbind: function() {
                        Sh(d, e, t), Sh(m, e, t)
                    }
                }
            },
            p = function() {
                function e(e, t, n) {
                    try {
                        return t.compareBoundaryPoints(e, n)
                    } catch (e) {
                        return -1
                    }
                }
                var t, n, r, o = u.document;
                if (void 0 !== s.bookmark && !1 === Cd(s)) {
                    var i = md(s);
                    if (i.isSome()) return i.map(function(e) {
                        return Ed(s, [e])[0]
                    }).getOr(o.createRange())
                }
                try {
                    (t = c()) && !rn(t.anchorNode) && (n = 0 < t.rangeCount ? t.getRangeAt(0) : (t.createRange ? t : o).createRange(), n = Ed(s, [n])[0])
                } catch (e) {}
                return (n = n || (o.createRange ? o.createRange() : o.body.createTextRange())).setStart && 9 === n.startContainer.nodeType && n.collapsed && (r = a.getRoot(), n.setStart(r, 0), n.setEnd(r, 0)), l && f && (0 === e(n.START_TO_START, n, l) && 0 === e(n.END_TO_END, n, l) ? n = f : f = l = null), n
            },
            h = function(e, t) {
                var n;
                if ((r = e) && (Ih(r) || Mh(r.startContainer) && Mh(r.endContainer))) {
                    var r, o = Ih(e) ? e : null;
                    if (o) {
                        f = null;
                        try {
                            o.select()
                        } catch (e) {}
                    } else {
                        var i = c();
                        if (e = s.fire("SetSelectionRange", {
                                range: e,
                                forward: t
                            }).range, i) {
                            f = e;
                            try {
                                i.removeAllRanges(), i.addRange(e)
                            } catch (e) {}!1 === t && i.extend && (i.collapse(e.endContainer, e.endOffset), i.extend(e.startContainer, e.startOffset)), l = 0 < i.rangeCount ? i.getRangeAt(0) : null
                        }
                        e.collapsed || e.startContainer !== e.endContainer || !i.setBaseAndExtent || xt.ie || e.endOffset - e.startOffset < 2 && e.startContainer.hasChildNodes() && (n = e.startContainer.childNodes[e.startOffset]) && "IMG" === n.tagName && (i.setBaseAndExtent(e.startContainer, e.startOffset, e.endContainer, e.endOffset), i.anchorNode === e.startContainer && i.focusNode === e.endContainer || i.setBaseAndExtent(n, 0, n, 1)), s.fire("AfterSetSelectionRange", {
                            range: e,
                            forward: t
                        })
                    }
                }
            },
            v = {
                bookmarkManager: null,
                controlSelection: null,
                dom: o = a,
                win: u,
                serializer: e,
                editor: i = s,
                collapse: r,
                setCursorLocation: function(e, t) {
                    var n = a.createRng();
                    V(e) && V(t) ? (n.setStart(e, t), n.setEnd(e, t), h(n), r(!1)) : (Bl(a, n, s.getBody(), !0), h(n))
                },
                getContent: function(e) {
                    return n = (t = void 0 === (t = e) ? {} : t).format || "html", r = t, yh(s).selection.getContent(n, r);
                    var t, n, r
                },
                setContent: t,
                getBookmark: function(e, t) {
                    return b.getBookmark(e, t)
                },
                moveToBookmark: function(e) {
                    return b.moveToBookmark(e)
                },
                select: function(e, t) {
                    var r = a,
                        o = t;
                    return ve.from(e).map(function(e) {
                        var t = r.nodeIndex(e),
                            n = r.createRng();
                        return n.setStart(e.parentNode, t), n.setEnd(e.parentNode, t + 1), o && (Bl(r, n, e, !0), Bl(r, n, e, !1)), n
                    }).each(h), e
                },
                isCollapsed: function() {
                    var e = p(),
                        t = c();
                    return !(!e || e.item) && (e.compareEndPoints ? 0 === e.compareEndPoints("StartToEnd", e) : !t || e.collapsed)
                },
                isForward: n,
                setNode: function(e) {
                    return t(a.getOuterHTML(e)), e
                },
                getNode: function() {
                    return function(e, t) {
                        if (!t) return e;
                        var n = t.startContainer,
                            r = t.endContainer,
                            o = t.startOffset,
                            i = t.endOffset,
                            a = t.commonAncestorContainer;
                        return !t.collapsed && (n === r && i - o < 2 && n.hasChildNodes() && (a = n.childNodes[o]), 3 === n.nodeType && 3 === r.nodeType && (n = n.length === o ? Nd(n.nextSibling, !0) : n.parentNode, r = 0 === i ? Nd(r.previousSibling, !1) : r.parentNode, n && n === r)) ? n : a && 3 === a.nodeType ? a.parentNode : a
                    }(s.getBody(), p())
                },
                getSel: c,
                setRng: h,
                getRng: p,
                getStart: function(e) {
                    return wd(s.getBody(), p(), e)
                },
                getEnd: function(e) {
                    return Sd(s.getBody(), p(), e)
                },
                getSelectedBlocks: function(e, t) {
                    return function(e, t, n, r) {
                        var o = [],
                            i = e.getRoot();
                        if (n = e.getParent(n || wd(i, t, t.collapsed), e.isBlock), r = e.getParent(r || Sd(i, t, t.collapsed), e.isBlock), n && n !== i && o.push(n), n && r && n !== r)
                            for (var a, u = new Dr(n, i);
                                (a = u.next()) && a !== r;) e.isBlock(a) && o.push(a);
                        return r && n !== r && r !== i && o.push(r), o
                    }(a, p(), e, t)
                },
                normalize: function() {
                    var e = p();
                    if (1 < Al(c()).length || !Pl(s)) return e;
                    var t = Of(a, e);
                    return t.each(function(e) {
                        h(e, n())
                    }), t.getOr(e)
                },
                selectorChanged: function(e, t) {
                    return g(e, t), v
                },
                selectorChangedWithUnbind: g,
                getScrollContainer: function() {
                    for (var e, t = a.getRoot(); t && "BODY" !== t.nodeName;) {
                        if (t.scrollHeight > t.clientHeight) {
                            e = t;
                            break
                        }
                        t = t.parentNode
                    }
                    return e
                },
                scrollIntoView: function(e, t) {
                    V(e) ? (s.inline ? Zf : td)(s, e, t) : nd(s, p(), t)
                },
                placeCaretAt: function(e, t) {
                    return h(Ef(e, t, s.getDoc()))
                },
                getBoundingClientRect: function() {
                    var e = p();
                    return e.collapsed ? cs.fromRangeStart(e).getClientRects()[0] : e.getBoundingClientRect()
                },
                destroy: function() {
                    u = l = f = null, y.destroy()
                }
            },
            b = Hl(v),
            y = Sf(v, s);

        function C(t, e) {
            return M(e, function(e) {
                return o.is(e, t)
            })
        }

        function x(e) {
            return o.getParents(e, null, o.getRoot())
        }
        return v.bookmarkManager = b, v.controlSelection = y, v
    }

    function Uh(e, t) {
        var n, r, a, u, o = ao();
        t.convert_fonts_to_spans && (r = e, a = o, u = Nt.explode(t.font_size_legacy_values), r.addNodeFilter("font", function(e) {
            Y(e, function(e) {
                var t, n = a.parse(e.attr("style")),
                    r = e.attr("color"),
                    o = e.attr("face"),
                    i = e.attr("size");
                r && (n.color = r), o && (n["font-family"] = o), i && (n["font-size"] = u[parseInt(e.attr("size"), 10) - 1]), e.name = "span", e.attr("style", a.serialize(n)), t = e, Y(["color", "face", "size"], function(e) {
                    t.attr(e, null)
                })
            })
        })), n = o, e.addNodeFilter("strike", function(e) {
            Y(e, function(e) {
                var t = n.parse(e.attr("style"));
                t["text-decoration"] = "line-through", e.name = "span", e.attr("style", n.serialize(t))
            })
        })
    }

    function zh(e) {
        var t, n = decodeURIComponent(e).split(","),
            r = /data:([^;]+)/.exec(n[0]);
        return {
            type: t = r ? r[1] : t,
            data: n[1]
        }
    }

    function Hh(e, t) {
        var n;
        try {
            n = atob(t)
        } catch (e) {
            return ve.none()
        }
        for (var r = new Uint8Array(n.length), o = 0; o < r.length; o++) r[o] = n.charCodeAt(o);
        return ve.some(new Blob([r], {
            type: e
        }))
    }

    function jh(e) {
        return 0 === e.indexOf("blob:") ? (o = e, new _r(function(e, t) {
            function n() {
                t("Cannot convert " + o + " to Blob. Resource might not exist or is inaccessible.")
            }
            try {
                var r = new XMLHttpRequest;
                r.open("GET", o, !0), r.responseType = "blob", r.onload = function() {
                    200 === r.status ? e(r.response) : n()
                }, r.onerror = n, r.send()
            } catch (e) {
                n()
            }
        })) : 0 === e.indexOf("data:") ? (n = e, new _r(function(e) {
            var t = zh(n);
            Hh(t.type, t.data).fold(function() {
                return e(new Blob([]))
            }, e)
        })) : null;
        var o, n
    }

    function Vh(e) {
        return (e || "blobid") + Yh++
    }

    function qh(r, d) {
        var o = {};
        return {
            findAll: function(e, n) {
                n = n || w;
                var t = A(U(e ? xe(e.getElementsByTagName("img")) : [], function(e) {
                    var t = e.src;
                    return xt.fileApi && !e.hasAttribute("data-mce-bogus") && !e.hasAttribute("data-mce-placeholder") && t && t !== xt.transparentSrc && (0 === t.indexOf("blob:") ? !r.isUploaded(t) && n(e) : 0 === t.indexOf("data:") && n(e))
                }), function(f) {
                    if (void 0 !== o[f.src]) return new _r(function(t) {
                        o[f.src].then(function(e) {
                            return "string" == typeof e ? e : void t({
                                image: f,
                                blobInfo: e.blobInfo
                            })
                        })
                    });
                    var e = new _r(function(e, t) {
                        var r, o, i, n, a, u, s, c, l;
                        r = d, i = e, n = t, 0 !== (o = f).src.indexOf("blob:") ? (u = (a = zh(o.src)).data, s = a.type, c = u, (l = r.getByData(c, s)) ? i({
                            image: o,
                            blobInfo: l
                        }) : jh(o.src).then(function(e) {
                            l = r.create(Vh(), e, c), r.add(l), i({
                                image: o,
                                blobInfo: l
                            })
                        }, function(e) {
                            n(e)
                        })) : (l = r.getByUri(o.src)) ? i({
                            image: o,
                            blobInfo: l
                        }) : jh(o.src).then(function(t) {
                            var n = t;
                            new _r(function(e) {
                                var t = new FileReader;
                                t.onloadend = function() {
                                    e(t.result)
                                }, t.readAsDataURL(n)
                            }).then(function(e) {
                                c = zh(e).data, l = r.create(Vh(), t, c), r.add(l), i({
                                    image: o,
                                    blobInfo: l
                                })
                            })
                        }, function(e) {
                            n(e)
                        })
                    }).then(function(e) {
                        return delete o[e.image.src], e
                    }).catch(function(e) {
                        return delete o[f.src], e
                    });
                    return o[f.src] = e
                });
                return _r.all(t)
            }
        }
    }

    function $h(e, t) {
        return e.replace(t.re, function(e) {
            return ue(t.uris, e).getOr(e)
        })
    }

    function Wh(e, t, n, r) {
        (e.padd_empty_with_br || t.insert) && n[r.name] ? r.empty().append(new jd("br", 1)).shortEnded = !0 : r.empty().append(new jd("#text", 3)).value = wo
    }

    function Kh(n, e, t, r) {
        return r.isEmpty(e, t, function(e) {
            return (t = n.getElementRule(e.name)) && t.paddEmpty;
            var t
        })
    }

    function Xh(e, p) {
        var t, o, i, h = e.schema;

        function n(t) {
            var e, n, r = t.attr("src");
            (e = t).attr("src") === xt.transparentSrc || V(e.attr("data-mce-placeholder")) || V(t.attr("data-mce-bogus")) || ((n = /data:([^;]+);base64,([a-z0-9\+\/=\s]+)/i.exec(r)) ? ve.some({
                type: n[1],
                data: decodeURIComponent(n[2])
            }) : ve.none()).filter(function() {
                return function(e, t) {
                    if (t.images_dataimg_filter) {
                        var n = new Image;
                        return n.src = e.attr("src"), ne(e.attributes.map, function(e, t) {
                            n.setAttribute(t, e)
                        }), t.images_dataimg_filter(n)
                    }
                    return !0
                }(t, o)
            }).bind(function(e) {
                var t = e.type,
                    n = e.data;
                return ve.from(i.getByData(n, t)).orThunk(function() {
                    return Hh(t, n).map(function(e) {
                        var t = i.create(Vh(), e, n);
                        return i.add(t), t
                    })
                })
            }).each(function(e) {
                t.attr("src", e.blobUri())
            })
        }
        p.remove_trailing_brs && e.addNodeFilter("br", function(e, t, n) {
            var r, o, i, a, u, s, c, l, f = e.length,
                d = Nt.extend({}, h.getBlockElements()),
                m = h.getNonEmptyElements(),
                g = h.getWhiteSpaceElements();
            for (d.body = 1, r = 0; r < f; r++)
                if (i = (o = e[r]).parent, d[o.parent.name] && o === i.lastChild) {
                    for (u = o.prev; u;) {
                        if ("span" !== (s = u.name) || "bookmark" !== u.attr("data-mce-type")) {
                            "br" === s && (o = null);
                            break
                        }
                        u = u.prev
                    }
                    o && (o.remove(), Kh(h, m, g, i) && (c = h.getElementRule(i.name)) && (c.removeEmpty ? i.remove() : c.paddEmpty && Wh(p, n, d, i)))
                } else {
                    for (a = o; i && i.firstChild === a && i.lastChild === a && !d[(a = i).name];) i = i.parent;
                    a === i && !0 !== p.padd_empty_with_br && ((l = new jd("#text", 3)).value = wo, o.replace(l))
                }
        }), e.addAttributeFilter("href", function(e) {
            var t, n, r = e.length;
            if (!p.allow_unsafe_link_target)
                for (; r--;) {
                    var o = e[r];
                    "a" === o.name && "_blank" === o.attr("target") && o.attr("rel", (n = void 0, n = (t = o.attr("rel")) ? Nt.trim(t) : "", /\b(noopener)\b/g.test(n) ? n : n.split(" ").filter(function(e) {
                        return 0 < e.length
                    }).concat(["noopener"]).sort().join(" ")))
                }
        }), p.allow_html_in_named_anchor || e.addAttributeFilter("id,name", function(e) {
            for (var t, n, r, o, i = e.length; i--;)
                if ("a" === (o = e[i]).name && o.firstChild && !o.attr("href"))
                    for (r = o.parent, t = o.lastChild; n = t.prev, r.insert(t, o), t = n;);
        }), p.fix_list_elements && e.addNodeFilter("ul,ol", function(e) {
            for (var t, n, r, o = e.length; o--;) "ul" !== (r = (n = e[o]).parent).name && "ol" !== r.name || (n.prev && "li" === n.prev.name ? n.prev.append(n) : ((t = new jd("li", 1)).attr("style", "list-style-type: none"), n.wrap(t)))
        }), p.validate && h.getValidClasses() && e.addAttributeFilter("class", function(e) {
            for (var t = h.getValidClasses(), n = e.length; n--;) {
                for (var r = e[n], o = r.attr("class").split(" "), i = "", a = 0; a < o.length; a++) {
                    var u = o[a],
                        s = !1,
                        c = t["*"];
                    c && c[u] && (s = !0), c = t[r.name], (s = !(s || !c || !c[u]) || s) && (i && (i += " "), i += u)
                }
                i.length || (i = null), r.attr("class", i)
            }
        }), t = e, (i = (o = p).blob_cache) && t.addAttributeFilter("src", function(e) {
            return Y(e, n)
        })
    }
    var Yh = 0,
        Gh = function(e, t) {
            return e && e.firstChild && e.firstChild === e.lastChild && e.firstChild.name === t
        },
        Jh = Nt.each,
        Qh = Nt.trim,
        Zh = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" "),
        ev = {
            ftp: 21,
            http: 80,
            https: 443,
            mailto: 25
        },
        tv = ["img", "video"],
        nv = (rv.parseDataUri = function(e) {
            var t, n = decodeURIComponent(e).split(","),
                r = /data:([^;]+)/.exec(n[0]);
            return {
                type: t = r ? r[1] : t,
                data: n[1]
            }
        }, rv.isDomSafe = function(e, t, n) {
            if ((n = void 0 === n ? {} : n).allow_script_urls) return !0;
            var r, o, i, a, u = Zo.decode(e).replace(/[\s\u0000-\u001F]+/g, "");
            try {
                u = decodeURIComponent(u)
            } catch (e) {
                u = unescape(u)
            }
            return !(/((java|vb)script|mhtml):/i.test(u) || (o = u, i = t, !(r = n).allow_html_data_urls && (/^data:image\//i.test(o) ? (V(a = r.allow_svg_data_urls) ? !a : !V(i) || !T(tv, i)) && /^data:image\/svg\+xml/i.test(o) : /^data:/i.test(o))))
        }, rv.getDocumentBaseUrl = function(e) {
            var t = 0 !== e.protocol.indexOf("http") && "file:" !== e.protocol ? e.href : e.protocol + "//" + e.host + e.pathname;
            return /^[^:]+:\/\/\/?[^\/]+\//.test(t) && (t = t.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(t) || (t += "/")), t
        }, rv.prototype.setPath = function(e) {
            var t = /^(.*?)\/?(\w+)?$/.exec(e);
            this.path = t[0], this.directory = t[1], this.file = t[2], this.source = "", this.getURI()
        }, rv.prototype.toRelative = function(e) {
            var t;
            if ("./" === e) return e;
            var n = new rv(e, {
                base_uri: this
            });
            if ("mce_host" !== n.host && this.host !== n.host && n.host || this.port !== n.port || this.protocol !== n.protocol && "" !== n.protocol) return n.getURI();
            var r = this.getURI(),
                o = n.getURI();
            return r === o || "/" === r.charAt(r.length - 1) && r.substr(0, r.length - 1) === o ? r : (t = this.toRelPath(this.path, n.path), n.query && (t += "?" + n.query), n.anchor && (t += "#" + n.anchor), t)
        }, rv.prototype.toAbsolute = function(e, t) {
            var n = new rv(e, {
                base_uri: this
            });
            return n.getURI(t && this.isSameOrigin(n))
        }, rv.prototype.isSameOrigin = function(e) {
            if (this.host == e.host && this.protocol == e.protocol) {
                if (this.port == e.port) return !0;
                var t = ev[this.protocol];
                if (t && (this.port || t) == (e.port || t)) return !0
            }
            return !1
        }, rv.prototype.toRelPath = function(e, t) {
            var n, r, o = 0,
                i = "",
                a = e.substring(0, e.lastIndexOf("/")).split("/"),
                u = t.split("/");
            if (a.length >= u.length)
                for (n = 0, r = a.length; n < r; n++)
                    if (n >= u.length || a[n] !== u[n]) {
                        o = n + 1;
                        break
                    } if (a.length < u.length)
                for (n = 0, r = u.length; n < r; n++)
                    if (n >= a.length || a[n] !== u[n]) {
                        o = n + 1;
                        break
                    } if (1 === o) return t;
            for (n = 0, r = a.length - (o - 1); n < r; n++) i += "../";
            for (n = o - 1, r = u.length; n < r; n++) i += n !== o - 1 ? "/" + u[n] : u[n];
            return i
        }, rv.prototype.toAbsPath = function(e, t) {
            var n, r, o = 0,
                i = [],
                a = /\/$/.test(t) ? "/" : "",
                u = e.split("/"),
                s = t.split("/");
            for (Jh(u, function(e) {
                    e && i.push(e)
                }), u = i, n = s.length - 1, i = []; 0 <= n; n--) 0 !== s[n].length && "." !== s[n] && (".." !== s[n] ? 0 < o ? o-- : i.push(s[n]) : o++);
            return 0 !== (r = (n = u.length - o) <= 0 ? q(i).join("/") : u.slice(0, n).join("/") + "/" + q(i).join("/")).indexOf("/") && (r = "/" + r), a && r.lastIndexOf("/") !== r.length - 1 && (r += a), r
        }, rv.prototype.getURI = function(e) {
            var t;
            return void 0 === e && (e = !1), this.source && !e || (t = "", e || (this.protocol ? t += this.protocol + "://" : t += "//", this.userInfo && (t += this.userInfo + "@"), this.host && (t += this.host), this.port && (t += ":" + this.port)), this.path && (t += this.path), this.query && (t += "?" + this.query), this.anchor && (t += "#" + this.anchor), this.source = t), this.source
        }, rv);

    function rv(e, t) {
        e = Qh(e), this.settings = t || {};
        var n, r, o, i, a = this.settings.base_uri,
            u = this;
        /^([\w\-]+):([^\/]{2})/i.test(e) || /^\s*#/.test(e) ? u.source = e : (n = 0 === e.indexOf("//"), 0 !== e.indexOf("/") || n || (e = (a && a.protocol || "http") + "://mce_host" + e), /^[\w\-]*:?\/\//.test(e) || (r = this.settings.base_uri ? this.settings.base_uri.path : new rv(document.location.href).directory, e = this.settings.base_uri && "" == this.settings.base_uri.protocol ? "//mce_host" + u.toAbsPath(r, e) : (o = /([^#?]*)([#?]?.*)/.exec(e), (a && a.protocol || "http") + "://mce_host" + u.toAbsPath(r, o[1]) + o[2])), e = e.replace(/@@/g, "(mce_at)"), i = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(e), Jh(Zh, function(e, t) {
            var n = (n = i[t]) && n.replace(/\(mce_at\)/g, "@@");
            u[e] = n
        }), a && (u.protocol || (u.protocol = a.protocol), u.userInfo || (u.userInfo = a.userInfo), u.port || "mce_host" !== u.host || (u.port = a.port), u.host && "mce_host" !== u.host || (u.host = a.host), u.source = ""), n && (u.protocol = ""))
    }

    function ov(e, t, n) {
        for (var r = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g, o = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g, i = e.getShortEndedElements(), a = 1, u = n; 0 !== a;)
            for (r.lastIndex = u;;) {
                var s = r.exec(t);
                if (null === s) return u;
                if ("!" === s[1]) {
                    u = Ge(s[2], "--") ? sv(t, !1, s.index + "!--".length) : sv(t, !0, s.index + 1);
                    break
                }
                o.lastIndex = r.lastIndex;
                var c = o.exec(t);
                if (!l(c) && c.index === r.lastIndex) {
                    "/" === s[1] ? --a : Ee(i, s[2]) || (a += 1), u = r.lastIndex + c[0].length;
                    break
                }
            }
        return u
    }

    function iv(q, $) {
        void 0 === $ && ($ = oo()), q = q || {};
        var W = uv(),
            K = W.createElement("form");

        function n(s, e) {
            void 0 === e && (e = "html");
            for (var t, i, n, c, r, o, a, l, u, f, d, m, g, p, h, v, b, y, C, x = s.html, w = 0, S = [], N = 0, E = Zo.decode, k = Nt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), _ = "html" === e ? 0 : 1, A = function(e) {
                    for (var t, n = S.length; n-- && S[n].name !== e;);
                    if (0 <= n) {
                        for (t = S.length - 1; n <= t; t--)(e = S[t]).valid && Q(e.name);
                        S.length = n
                    }
                }, R = function(e, t) {
                    return G($h(e, s), t)
                }, D = function(e) {
                    "" !== e && (">" === e.charAt(0) && (e = " " + e), q.allow_conditional_comments || "[if" !== e.substr(0, 3).toLowerCase() || (e = " " + e), X($h(e, s)))
                }, T = function(e, t) {
                    var n = e || "",
                        r = !Ge(n, "--"),
                        o = sv(x, r, t);
                    return e = x.substr(t, o - t), D(r ? n + e : e), o + 1
                }, O = new RegExp("<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|(?:!(--)?)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_:.]*)(\\s(?:[^'\">]+(?:\"[^\"]*\"|'[^']*'))*[^\"'>]*(?:\"[^\">]*|'[^'>]*)?|\\s*|\\/)>))", "g"), B = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g, P = $.getShortEndedElements(), L = q.self_closing_elements || $.getSelfClosingElements(), I = $.getBoolAttrs(), M = q.validate, F = q.remove_internals, U = q.fix_self_closing, z = $.getSpecialElements(), H = x + ">"; t = O.exec(H);) {
                var j = t[0];
                if (w < t.index && R(E(x.substr(w, t.index - w))), i = t[7]) A(i = ":" === (i = i.toLowerCase()).charAt(0) ? i.substr(1) : i);
                else if (i = t[8]) {
                    if (t.index + j.length > x.length) {
                        R(E(x.substr(t.index))), w = t.index + j.length;
                        continue
                    }
                    u = (i = ":" === (i = i.toLowerCase()).charAt(0) ? i.substr(1) : i) in P, U && L[i] && 0 < S.length && S[S.length - 1].name === i && A(i);
                    var V = function(e, t) {
                        var n = e.exec(t);
                        if (n) {
                            var r = n[1],
                                o = n[2];
                            return "string" == typeof r && "data-mce-bogus" === r.toLowerCase() ? o : null
                        }
                        return null
                    }(B, t[9]);
                    if (null !== V) {
                        if ("all" === V) {
                            w = ov($, x, O.lastIndex), O.lastIndex = w;
                            continue
                        }
                        d = !1
                    }
                    if (!M || (f = $.getElementRule(i))) {
                        if (d = !0, M && (p = f.attributes, h = f.attributePatterns), (g = t[9]) ? ((l = -1 !== g.indexOf("data-mce-type")) && F && (d = !1), (c = []).map = {}, g.replace(B, function(e, t, n, r, o) {
                                return function(e, t, n, r, o) {
                                    var i;
                                    if (n = $h((t = t.toLowerCase()) in I ? t : E(n || r || o || ""), s), M && !l && 0 == (0 === (i = t).indexOf("data-") || 0 === i.indexOf("aria-"))) {
                                        var a = p[t];
                                        if (!a && h) {
                                            for (var u = h.length; u-- && !(a = h[u]).pattern.test(t);); - 1 === u && (a = null)
                                        }
                                        if (!a) return;
                                        if (a.validValues && !(n in a.validValues)) return
                                    }("name" === t || "id" === t) && e in av && (n in W || n in K) || k[t] && !nv.isDomSafe(n, e, q) || l && (t in k || 0 === t.indexOf("on")) || (c.map[t] = n, c.push({
                                        name: t,
                                        value: n
                                    }))
                                }(i, t, n, r, o), ""
                            })) : (c = []).map = {}, M && !l) {
                            if (v = f.attributesRequired, b = f.attributesDefault, y = f.attributesForced, f.removeEmptyAttrs && !c.length && (d = !1), y)
                                for (r = y.length; r--;) a = (m = y[r]).name, "{$uid}" === (C = m.value) && (C = "mce_" + N++), c.map[a] = C, c.push({
                                    name: a,
                                    value: C
                                });
                            if (b)
                                for (r = b.length; r--;)(a = (m = b[r]).name) in c.map || ("{$uid}" === (C = m.value) && (C = "mce_" + N++), c.map[a] = C, c.push({
                                    name: a,
                                    value: C
                                }));
                            if (v) {
                                for (r = v.length; r-- && !(v[r] in c.map);); - 1 === r && (d = !1)
                            }
                            if (m = c.map["data-mce-bogus"]) {
                                if ("all" === m) {
                                    w = ov($, x, O.lastIndex), O.lastIndex = w;
                                    continue
                                }
                                d = !1
                            }
                        }
                        d && J(i, c, u)
                    } else d = !1;
                    if (n = z[i]) {
                        n.lastIndex = w = t.index + j.length, w = (t = n.exec(x)) ? (d && (o = x.substr(w, t.index - w)), t.index + t[0].length) : (o = x.substr(w), x.length), d && (0 < o.length && R(o, !0), Q(i)), O.lastIndex = w;
                        continue
                    }
                    u || (g && g.indexOf("/") === g.length - 1 ? d && Q(i) : S.push({
                        name: i,
                        valid: d
                    }))
                } else if (i = t[1]) D(i);
                else if (i = t[2]) {
                    if (!(1 == _ || q.preserve_cdata || 0 < S.length && $.isValidChild(S[S.length - 1].name, "#cdata"))) {
                        w = T("", t.index + 2), O.lastIndex = w;
                        continue
                    }
                    Y(i)
                } else if (i = t[3]) ee(i);
                else {
                    if ((i = t[4]) || "<!" === j) {
                        w = T(i, t.index + j.length), O.lastIndex = w;
                        continue
                    }
                    if (i = t[5]) {
                        if (1 != _) {
                            w = T("?", t.index + 2), O.lastIndex = w;
                            continue
                        }
                        Z(i, t[6])
                    }
                }
                w = t.index + j.length
            }
            for (w < x.length && R(E(x.substr(w))), r = S.length - 1; 0 <= r; r--)(i = S[r]).valid && Q(i.name)
        }!1 !== q.fix_self_closing && (q.fix_self_closing = !0);
        var X = q.comment || te,
            Y = q.cdata || te,
            G = q.text || te,
            J = q.start || te,
            Q = q.end || te,
            Z = q.pi || te,
            ee = q.doctype || te;
        return {
            parse: function(e, t) {
                void 0 === t && (t = "html"), n(function(e) {
                    for (var t, n = /data:[^;<"'\s]+;base64,([a-z0-9\+\/=\s]+)/gi, r = [], o = {}, i = wu("img"), a = 0, u = 0; t = n.exec(e);) {
                        var s = t[0],
                            c = i + "_" + u++;
                        o[c] = s, a < t.index && r.push(e.substr(a, t.index - a)), r.push(c), a = t.index + s.length
                    }
                    var l = new RegExp(i + "_[0-9]+", "g");
                    return 0 === a ? {
                        prefix: i,
                        uris: o,
                        html: e,
                        re: l
                    } : (a < e.length && r.push(e.substr(a)), {
                        prefix: i,
                        uris: o,
                        html: r.join(""),
                        re: l
                    })
                }(e), t)
            }
        }
    }
    var av = Nt.makeMap("button,fieldset,form,iframe,img,image,input,object,output,select,textarea"),
        uv = Re(function() {
            return document.implementation.createHTMLDocument("parser")
        }),
        sv = function(e, t, n) {
            void 0 === n && (n = 0);
            var r = e.toLowerCase();
            if (-1 !== r.indexOf("[if ", n) && (u = n, /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(r.substr(u)))) {
                var o = r.indexOf("[endif]", n);
                return r.indexOf(">", o)
            }
            if (t) {
                var i = r.indexOf(">", n);
                return -1 !== i ? i : r.length
            }
            var a = /--!?>/g;
            a.lastIndex = n;
            var u, s = a.exec(e);
            return s ? s.index + s[0].length : r.length
        };

    function cv(A, R) {
        void 0 === R && (R = oo());
        var D = {},
            T = [],
            O = {},
            B = {};
        (A = A || {}).validate = !("validate" in A) || A.validate, A.root_name = A.root_name || "body";

        function P(e) {
            var t = e.name;
            t in D && ((r = O[t]) ? r.push(e) : O[t] = [e]);
            for (var n = T.length; n--;) {
                var r, o = T[n].name;
                o in e.attributes.map && ((r = B[o]) ? r.push(e) : B[o] = [e])
            }
            return e
        }
        var e = {
            schema: R,
            addAttributeFilter: function(e, n) {
                Rv(Dv(e), function(e) {
                    for (var t = 0; t < T.length; t++)
                        if (T[t].name === e) return void T[t].callbacks.push(n);
                    T.push({
                        name: e,
                        callbacks: [n]
                    })
                })
            },
            getAttributeFilters: function() {
                return [].concat(T)
            },
            addNodeFilter: function(e, n) {
                Rv(Dv(e), function(e) {
                    var t = D[e];
                    t || (D[e] = t = []), t.push(n)
                })
            },
            getNodeFilters: function() {
                var e, t = [];
                for (e in D) Ee(D, e) && t.push({
                    name: e,
                    callbacks: D[e]
                });
                return t
            },
            filterNode: P,
            parse: function(e, s) {
                var t, n, r, o, i, c, a, l, f = [];

                function d(e) {
                    for (var t = R.getBlockElements(), n = e.prev; n && 3 === n.type;) {
                        var r = n.value.replace(w, "");
                        if (0 < r.length) return n.value = r, 0;
                        var o = n.next;
                        if (o) {
                            if (3 === o.type && o.value.length) {
                                n = n.prev;
                                continue
                            }
                            if (!t[o.name] && "script" !== o.name && "style" !== o.name) {
                                n = n.prev;
                                continue
                            }
                        }
                        var i = n.prev;
                        n.remove(), n = i
                    }
                }
                s = s || {}, O = {}, B = {};

                function m(e, t) {
                    var n, r = new jd(e, t);
                    return e in D && ((n = O[e]) ? n.push(r) : O[e] = [r]), r
                }
                var g = Tv(Av("script,style,head,html,body,title,meta,param"), R.getBlockElements()),
                    p = no(R),
                    h = R.getNonEmptyElements(),
                    v = R.children,
                    b = A.validate,
                    u = ("forced_root_block" in s ? s : A).forced_root_block,
                    y = !1 === u ? "" : !0 === u ? "p" : u,
                    C = R.getWhiteSpaceElements(),
                    x = /^[ \t\r\n]+/,
                    w = /[ \t\r\n]+$/,
                    S = /[ \t\r\n]+/g,
                    N = /^[ \t\r\n]+$/,
                    E = Ee(C, s.context) || Ee(C, A.root_name),
                    k = iv({
                        validate: b,
                        document: A.document,
                        allow_html_data_urls: A.allow_html_data_urls,
                        allow_svg_data_urls: A.allow_svg_data_urls,
                        allow_script_urls: A.allow_script_urls,
                        allow_conditional_comments: A.allow_conditional_comments,
                        preserve_cdata: A.preserve_cdata,
                        self_closing_elements: function(e) {
                            var t, n = {};
                            for (t in e) "li" !== t && "p" !== t && (n[t] = e[t]);
                            return n
                        }(R.getSelfClosingElements()),
                        cdata: function(e) {
                            l.append(m("#cdata", 4)).value = e
                        },
                        text: function(e, t) {
                            var n, r;
                            E || (e = e.replace(S, " "), (r = l.lastChild) && (Ee(g, r.name) || "br" === r.name) && (e = e.replace(x, ""))), 0 !== e.length && ((n = m("#text", 3)).raw = !!t, l.append(n).value = e)
                        },
                        comment: function(e) {
                            l.append(m("#comment", 8)).value = e
                        },
                        pi: function(e, t) {
                            l.append(m(e, 7)).value = t, d(l)
                        },
                        doctype: function(e) {
                            l.append(m("#doctype", 10)).value = e, d(l)
                        },
                        start: function(e, t, n) {
                            var r = b ? R.getElementRule(e) : {};
                            if (r) {
                                var o = m(r.outputName || e, 1);
                                o.attributes = t, o.shortEnded = n, l.append(o);
                                var i = v[l.name];
                                i && v[o.name] && !i[o.name] && f.push(o);
                                for (var a = T.length; a--;) {
                                    var u = T[a].name;
                                    u in t.map && ((c = B[u]) ? c.push(o) : B[u] = [o])
                                }
                                g[e] && d(o), n || (l = o), !E && C[e] && (E = !0)
                            }
                        },
                        end: function(e) {
                            var t, n, r, o, i = b ? R.getElementRule(e) : {};
                            if (i) {
                                if (g[e] && !E) {
                                    if ((t = l.firstChild) && 3 === t.type)
                                        if (0 < (n = t.value.replace(x, "")).length) t.value = n, t = t.next;
                                        else
                                            for (r = t.next, t.remove(), t = r; t && 3 === t.type;) n = t.value, r = t.next, 0 !== n.length && !N.test(n) || (t.remove(), t = r), t = r;
                                    if ((t = l.lastChild) && 3 === t.type)
                                        if (0 < (n = t.value.replace(w, "")).length) t.value = n, t = t.prev;
                                        else
                                            for (r = t.prev, t.remove(), t = r; t && 3 === t.type;) n = t.value, r = t.prev, 0 !== n.length && !N.test(n) || (t.remove(), t = r), t = r
                                }
                                E && C[e] && (E = !1);
                                var a = Kh(R, h, C, l),
                                    u = l.parent;
                                i.paddInEmptyBlock && a && function() {
                                    for (var e = l; V(e);) {
                                        if (e.name in p) return Kh(R, h, C, e);
                                        e = e.parent
                                    }
                                }() ? Wh(A, s, g, l) : i.removeEmpty && a ? g[l.name] ? l.empty().remove() : l.unwrap() : i.paddEmpty && (Gh(o = l, "#text") && o.firstChild.value === wo || a) && Wh(A, s, g, l), l = u
                            }
                        }
                    }, R),
                    _ = l = new jd(s.context || A.root_name, 11);
                if (k.parse(e, s.format), b && f.length && (s.context ? s.invalid = !0 : function(e) {
                        for (var t = Av("tr,td,th,tbody,thead,tfoot,table"), n = R.getNonEmptyElements(), r = R.getWhiteSpaceElements(), o = R.getTextBlockElements(), i = R.getSpecialElements(), a = function(e, t) {
                                if (void 0 === t && (t = e.parent), i[e.name]) e.empty().remove();
                                else {
                                    for (var n = 0, r = e.children(); n < r.length; n++) {
                                        var o = r[n];
                                        R.isValidChild(t.name, o.name) || a(o, t)
                                    }
                                    e.unwrap()
                                }
                            }, u = 0; u < e.length; u++) {
                            var s, c = e[u],
                                l = void 0,
                                f = void 0;
                            if (c.parent && !c.fixed)
                                if (o[c.name] && "li" === c.parent.name) {
                                    for (var d = c.next; d && o[d.name];) d.name = "li", d.fixed = !0, c.parent.insert(d, c.parent), d = d.next;
                                    c.unwrap()
                                } else {
                                    for (var m = [c], l = c.parent; l && !R.isValidChild(l.name, c.name) && !t[l.name]; l = l.parent) m.push(l);
                                    if (l && 1 < m.length)
                                        if (R.isValidChild(l.name, c.name)) {
                                            m.reverse();
                                            for (var g = s = P(m[0].clone()), p = 0; p < m.length - 1; p++) {
                                                R.isValidChild(g.name, m[p].name) ? (f = P(m[p].clone()), g.append(f)) : f = g;
                                                for (var h = m[p].firstChild; h && h !== m[p + 1];) {
                                                    var v = h.next;
                                                    f.append(h), h = v
                                                }
                                                g = f
                                            }
                                            Kh(R, n, r, s) ? l.insert(c, m[0], !0) : (l.insert(s, m[0], !0), l.insert(c, s)), l = m[0], (Kh(R, n, r, l) || Gh(l, "br")) && l.empty().remove()
                                        } else a(c);
                                    else c.parent && ("li" !== c.name ? R.isValidChild(c.parent.name, "div") && R.isValidChild("div", c.name) ? c.wrap(P(new jd("div", 1))) : a(c) : !(d = c.prev) || "ul" !== d.name && "ol" !== d.name ? !(d = c.next) || "ul" !== d.name && "ol" !== d.name ? c.wrap(P(new jd("ul", 1))) : d.insert(c, d.firstChild, !0) : d.append(c))
                                }
                        }
                    }(f)), y && ("body" === _.name || s.isRootContent) && function() {
                        function e(e) {
                            e && ((t = e.firstChild) && 3 === t.type && (t.value = t.value.replace(x, "")), (t = e.lastChild) && 3 === t.type && (t.value = t.value.replace(w, "")))
                        }
                        var t = _.firstChild,
                            n = null;
                        if (R.isValidChild(_.name, y.toLowerCase())) {
                            for (; t;) {
                                var r = t.next;
                                3 === t.type || 1 === t.type && "p" !== t.name && !g[t.name] && !t.attr("data-mce-type") ? (n || ((n = m(y, 1)).attr(A.forced_root_block_attrs), _.insert(n, t)), n.append(t)) : (e(n), n = null), t = r
                            }
                            e(n)
                        }
                    }(), !s.invalid) {
                    for (a in O)
                        if (Ee(O, a)) {
                            for (c = D[a], o = (t = O[a]).length; o--;) t[o].parent || t.splice(o, 1);
                            for (n = 0, r = c.length; n < r; n++) c[n](t, a, s)
                        } for (n = 0, r = T.length; n < r; n++)
                        if ((c = T[n]).name in B) {
                            for (o = (t = B[c.name]).length; o--;) t[o].parent || t.splice(o, 1);
                            for (o = 0, i = c.callbacks.length; o < i; o++) c.callbacks[o](t, c.name, s)
                        }
                }
                return _
            }
        };
        return Xh(e, A), A.inline_styles && Uh(e, A), e
    }

    function lv(e, t, n) {
        -1 === Nt.inArray(t, n) && (e.addAttributeFilter(n, function(e, t) {
            for (var n = e.length; n--;) e[n].attr(t, null)
        }), t.push(n))
    }

    function fv(L, I) {
        var e = ["data-mce-selected"],
            M = I && I.dom ? I.dom : eu.DOM,
            F = I && I.schema ? I.schema : oo(L);
        L.entity_encoding = L.entity_encoding || "named", L.remove_trailing_brs = !("remove_trailing_brs" in L) || L.remove_trailing_brs;
        var t, U = cv(L, F),
            s = L,
            c = M;
        return (t = U).addAttributeFilter("data-mce-tabindex", function(e, t) {
            for (var n = e.length; n--;) {
                var r = e[n];
                r.attr("tabindex", r.attr("data-mce-tabindex")), r.attr(t, null)
            }
        }), t.addAttributeFilter("src,href,style", function(e, t) {
            for (var n = "data-mce-" + t, r = s.url_converter, o = s.url_converter_scope, i = e.length; i--;) {
                var a = e[i],
                    u = a.attr(n);
                void 0 !== u ? (a.attr(t, 0 < u.length ? u : null), a.attr(n, null)) : (u = a.attr(t), "style" === t ? u = c.serializeStyle(c.parseStyle(u), a.name) : r && (u = r.call(o, u, t, a.name)), a.attr(t, 0 < u.length ? u : null))
            }
        }), t.addAttributeFilter("class", function(e) {
            for (var t = e.length; t--;) {
                var n, r = e[t];
                r.attr("class") && (n = r.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), r.attr("class", 0 < n.length ? n : null))
            }
        }), t.addAttributeFilter("data-mce-type", function(e, t, n) {
            for (var r = e.length; r--;) {
                var o = e[r];
                "bookmark" !== o.attr("data-mce-type") || n.cleanup || (ve.from(o.firstChild).exists(function(e) {
                    return !No(e.value)
                }) ? o.unwrap() : o.remove())
            }
        }), t.addNodeFilter("noscript", function(e) {
            for (var t = e.length; t--;) {
                var n = e[t].firstChild;
                n && (n.value = Zo.decode(n.value))
            }
        }), t.addNodeFilter("script,style", function(e, t) {
            for (var n = function(e) {
                    return e.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "")
                }, r = e.length; r--;) {
                var o, i = e[r],
                    a = i.firstChild ? i.firstChild.value : "";
                "script" === t ? ((o = i.attr("type")) && i.attr("type", "mce-no/type" === o ? null : o.replace(/^mce\-/, "")), "xhtml" === s.element_format && 0 < a.length && (i.firstChild.value = "// <![CDATA[\n" + n(a) + "\n// ]]>")) : "xhtml" === s.element_format && 0 < a.length && (i.firstChild.value = "\x3c!--\n" + n(a) + "\n--\x3e")
            }
        }), t.addNodeFilter("#comment", function(e) {
            for (var t = e.length; t--;) {
                var n = e[t];
                s.preserve_cdata && 0 === n.value.indexOf("[CDATA[") ? (n.name = "#cdata", n.type = 4, n.value = c.decode(n.value.replace(/^\[CDATA\[|\]\]$/g, ""))) : 0 === n.value.indexOf("mce:protected ") && (n.name = "#text", n.type = 3, n.raw = !0, n.value = unescape(n.value).substr(14))
            }
        }), t.addNodeFilter("xml:namespace,input", function(e, t) {
            for (var n = e.length; n--;) {
                var r = e[n];
                7 === r.type ? r.remove() : 1 === r.type && ("input" !== t || r.attr("type") || r.attr("type", "text"))
            }
        }), t.addAttributeFilter("data-mce-type", function(e) {
            Y(e, function(e) {
                "format-caret" === e.attr("data-mce-type") && (e.isEmpty(t.schema.getNonEmptyElements()) ? e.remove() : e.unwrap())
            })
        }), t.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", function(e, t) {
            for (var n = e.length; n--;) e[n].attr(t, null)
        }), {
            schema: F,
            addNodeFilter: U.addNodeFilter,
            addAttributeFilter: U.addAttributeFilter,
            serialize: function(e, t) {
                var n, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y, C, x, w, S, N, E, k, _, A, R, D, T = _e({
                        format: "html"
                    }, t = void 0 === t ? {} : t),
                    O = (n = (m = e, N = g = T, (d = I) && d.hasEventListeners("PreProcess") && !N.no_events ? (h = g, x = (p = d).dom, w = m.cloneNode(!0), (S = document.implementation).createHTMLDocument && (b = S.createHTMLDocument(""), Nt.each("BODY" === w.nodeName ? w.childNodes : [w], function(e) {
                        b.body.appendChild(b.importNode(e, !0))
                    }), w = "BODY" !== w.nodeName ? b.body.firstChild : b.body, v = x.doc, x.doc = b), y = p, C = _e(_e({}, h), {
                        node: w
                    }), y.fire("PreProcess", C), v && (x.doc = v), w) : m), o = Eo((r = T).getInner ? n.innerHTML : M.getOuterHTML(n)), r.selection || Co(Et.fromDom(n)) ? o : Nt.trim(o)),
                    B = (i = U, a = O, s = (u = T).selection ? _e({
                        forced_root_block: !1
                    }, u) : u, c = i.parse(a, s), !P(f = c.lastChild) || P(l = f.prev) && (f.remove(), l.remove()), c);

                function P(e) {
                    return e && "br" === e.name
                }
                return "tree" === T.format ? B : (E = I, k = T, _ = B, D = rm(L, F).serialize(_), k.no_events || !E ? D : (A = E, R = _e(_e({}, k), {
                    content: D
                }), A.fire("PostProcess", R).content))
            },
            addRules: F.addValidElements,
            setRules: F.setValidElements,
            addTempAttr: R(lv, U, e),
            getTempAttrs: J(e),
            getNodeFilters: U.getNodeFilters,
            getAttributeFilters: U.getAttributeFilters
        }
    }

    function dv(e, t) {
        var n = fv(e, t);
        return {
            schema: n.schema,
            addNodeFilter: n.addNodeFilter,
            addAttributeFilter: n.addAttributeFilter,
            serialize: n.serialize,
            addRules: n.addRules,
            setRules: n.setRules,
            addTempAttr: n.addTempAttr,
            getTempAttrs: n.getTempAttrs,
            getNodeFilters: n.getNodeFilters,
            getAttributeFilters: n.getAttributeFilters
        }
    }

    function mv(e, t, n) {
        return r = n = void 0 === n ? {} : n, bh(e).editor.setContent(t, r);
        var r
    }

    function gv(e) {
        return ve.from(e).each(function(e) {
            return e.destroy()
        })
    }

    function pv(e, t) {
        var n, r, o, i, a, u, s, c = (n = e, r = U(Pv, function(e) {
                return Ee(n, e)
            }), !1 !== (o = n.forced_root_block) && "" !== o || r.push("forced_root_block (false only)"), W(r)),
            l = (s = Nt.makeMap(t.plugins, " "), W(Ae(Ae([], U(Lv, g), !0), H(Iv, function(e) {
                return g(e) ? [e + " (moving to premium)"] : []
            }), !0))),
            f = 0 < l.length,
            d = 0 < c.length,
            m = "mobile" === t.theme;

        function g(e) {
            return Ee(s, e)
        }(f || d || m) && (i = m ? "\n\nThemes:\n- mobile" : "", a = f ? "\n\nPlugins:\n- " + l.join("\n- ") : "", u = d ? "\n\nSettings:\n- " + c.join("\n- ") : "", console.warn("The following deprecated features are currently enabled, these will be removed in TinyMCE 6.0. See https://www.tiny.cloud/docs/release-notes/6.0-upcoming-changes/ for more information." + i + a + u))
    }

    function hv(e) {
        var t = S(e) ? e.join(" ") : e;
        return U(A(X(t) ? t.split(" ") : [], Je), function(e) {
            return 0 < e.length
        })
    }

    function vv(e, t) {
        return Ee(e.sections(), t)
    }

    function bv(e, t) {
        return ue(e, "toolbar_mode").orThunk(function() {
            return ue(e, "toolbar_drawer").map(function(e) {
                return !1 === e ? "wrap" : e
            })
        }).getOr(t)
    }

    function yv(e, t, n, r) {
        var o, i, a, u, s, c, l, f, d = hv(n.forced_plugins),
            m = hv(r.plugins),
            g = vv(o = t, "mobile") ? o.sections().mobile : {},
            p = g.plugins ? hv(g.plugins) : m,
            h = (i = (u = t, s = m, c = p, (a = e) && (0, f = (l = u).sections(), vv(l, "mobile") && "mobile" === f.mobile.theme) ? U(c, R(T, Hv)) : a && vv(u, "mobile") ? c : s), [].concat(hv(d)).concat(hv(i)));
        if (xt.browser.isIE() && T(h, "rtc")) throw new Error("RTC plugin is not supported on IE 11.");
        return Nt.extend(r, {
            plugins: h.join(" ")
        })
    }

    function Cv(e, t, n, r, o) {
        var i, a, u, s, c, l, f, d, m = e ? {
                mobile: (i = t, a = {
                    resize: !1,
                    toolbar_mode: bv(o.mobile || {}, "scrolling"),
                    toolbar_sticky: !1
                }, _e(_e(_e({}, jv), a), i ? {
                    menubar: !1
                } : {}))
            } : {},
            g = (c = ["mobile"], ie(Bv(m, o), function(e, t) {
                return T(c, t)
            }, oe(l = {}), oe(f = {})), {
                sections: J((d = {
                    t: l,
                    f: f
                }).t),
                settings: J(d.f)
            }),
            p = Nt.extend(n, r, g.settings(), e && vv(g, "mobile") ? function(e) {
                void 0 === e && (e = {});
                var t = ue(g.sections(), "mobile").getOr({});
                return Nt.extend({}, e, t)
            }() : {}, {
                validate: !0,
                external_plugins: (u = r, s = g.settings().external_plugins || {}, u && u.external_plugins ? Nt.extend({}, u.external_plugins, s) : s)
            });
        return yv(e, g, r, p)
    }

    function xv(e, t, n) {
        return ve.from(t.settings[n]).filter(e)
    }

    function wv(e, t) {
        return t.dom[e]
    }

    function Sv(e, t) {
        return parseInt(wn(t, e), 10)
    }

    function Nv(e, t, n) {
        var r, o, i, a, u, s, c = Et.fromDom(e.getBody()),
            l = e.inline ? c : Et.fromDom(Dt(c).dom.documentElement),
            f = (r = e.inline, i = t, a = n, u = (o = l).dom.getBoundingClientRect(), {
                x: i - (r ? u.left + o.dom.clientLeft + Kv(o) : 0),
                y: a - (r ? u.top + o.dom.clientTop + Wv(o) : 0)
            }),
            d = f.x,
            m = f.y,
            g = qv(s = l),
            p = $v(s);
        return 0 <= d && 0 <= m && d <= g && m <= p
    }

    function Ev(o) {
        function i() {
            var e = o.theme;
            return e && e.getNotificationManagerImpl ? e.getNotificationManagerImpl() : {
                open: t,
                close: t,
                reposition: t,
                getArgs: t
            };

            function t() {
                throw new Error("Theme did not provide a NotificationManager implementation.")
            }
        }

        function a() {
            return ve.from(c[0])
        }

        function u() {
            0 < c.length && i().reposition(c)
        }

        function s(t) {
            z(c, function(e) {
                return e === t
            }).each(function(e) {
                c.splice(e, 1)
            })
        }

        function t(n, e) {
            if (void 0 === e && (e = !0), !o.removed && (r = (t = o).inline ? t.getBody() : t.getContentAreaContainer(), ve.from(r).map(Et.fromDom).map(Mn).getOr(!1))) return e && o.fire("BeforeOpenNotification", {
                notification: n
            }), M(c, function(e) {
                return !((t = i().getArgs(e)).type !== n.type || t.text !== n.text || t.progressBar || t.timeout || n.progressBar || n.timeout);
                var t
            }).getOrThunk(function() {
                o.editorManager.setActive(o);
                var e = i().open(n, function() {
                    s(e), u(), a().fold(function() {
                        return o.focus()
                    }, function(e) {
                        return Et.fromDom(e.getEl()).dom.focus()
                    })
                });
                return c.push(e), u(), o.fire("OpenNotification", {
                    notification: _e({}, e)
                }), e
            });
            var t, r
        }
        var n, c = [],
            e = J(c);
        return (n = o).on("SkinLoaded", function() {
            var e = n.getParam("service_message");
            e && t({
                text: e,
                type: "warning",
                timeout: 0
            }, !1), u()
        }), n.on("show ResizeEditor ResizeWindow NodeChange", function() {
            Ar.requestAnimationFrame(u)
        }), n.on("remove", function() {
            Y(c.slice(), function(e) {
                i().close(e)
            })
        }), {
            open: t,
            close: function() {
                a().each(function(e) {
                    i().close(e), s(e), u()
                })
            },
            getNotifications: e
        }
    }
    iv.findEndTag = ov;
    var kv, _v, Av = Nt.makeMap,
        Rv = Nt.each,
        Dv = Nt.explode,
        Tv = Nt.extend,
        Ov = eu.DOM,
        Bv = (kv = function(e, t) {
            return h(e) && h(t) ? Bv(e, t) : t
        }, function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            if (0 === e.length) throw new Error("Can't merge zero objects");
            for (var n = {}, r = 0; r < e.length; r++) {
                var o, i = e[r];
                for (o in i) Ee(i, o) && (n[o] = kv(n[o], i[o]))
            }
            return n
        }),
        Pv = "autoresize_on_init,content_editable_state,convert_fonts_to_spans,inline_styles,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","),
        Lv = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","),
        Iv = "imagetools,toc".split(","),
        Mv = dt().deviceType,
        Fv = Mv.isTouch(),
        Uv = Mv.isPhone(),
        zv = Mv.isTablet(),
        Hv = ["lists", "autolink", "autosave"],
        jv = {
            table_grid: !1,
            object_resizing: !1,
            resize: !1
        },
        Vv = (_v = {}, {
            add: function(e, t) {
                _v[e] = t
            },
            get: function(e) {
                return _v[e] || {
                    icons: {}
                }
            },
            has: function(e) {
                return Ee(_v, e)
            }
        }),
        qv = R(wv, "clientWidth"),
        $v = R(wv, "clientHeight"),
        Wv = R(Sv, "margin-top"),
        Kv = R(Sv, "margin-left"),
        Xv = fu.PluginManager,
        Yv = fu.ThemeManager;

    function Gv(r) {
        function o() {
            var e = r.theme;
            return e && e.getWindowManagerImpl ? e.getWindowManagerImpl() : {
                open: t,
                openUrl: t,
                alert: t,
                confirm: t,
                close: t,
                getParams: t,
                setParams: t
            };

            function t() {
                throw new Error("Theme did not provide a WindowManager implementation.")
            }
        }

        function i(n, r) {
            return function() {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                return r ? r.apply(n, e) : void 0
            }
        }

        function n(t) {
            r.fire("CloseWindow", {
                dialog: t
            }), 0 === (u = U(u, function(e) {
                return e !== t
            })).length && r.focus()
        }

        function a(e) {
            r.editorManager.setActive(r), dd(r);
            var t, n = e();
            return t = n, u.push(t), r.fire("OpenWindow", {
                dialog: t
            }), n
        }
        var u = [];
        return r.on("remove", function() {
            Y(u, function(e) {
                o().close(e)
            })
        }), {
            open: function(e, t) {
                return a(function() {
                    return o().open(e, t, n)
                })
            },
            openUrl: function(e) {
                return a(function() {
                    return o().openUrl(e, n)
                })
            },
            alert: function(e, t, n) {
                var r = o();
                r.alert(e, i(n || r, t))
            },
            confirm: function(e, t, n) {
                var r = o();
                r.confirm(e, i(n || r, t))
            },
            close: function() {
                ve.from(u[u.length - 1]).each(function(e) {
                    o().close(e), n(e)
                })
            }
        }
    }

    function Jv(e, t) {
        e.notificationManager.open({
            type: "error",
            text: t
        })
    }

    function Qv(e, t) {
        e._skinLoaded ? Jv(e, t) : e.on("SkinLoaded", function() {
            Jv(e, t)
        })
    }

    function Zv(e, t, n) {
        Cf(e, t, {
            message: n
        }), console.error(n)
    }

    function eb(e, t, n) {
        return n ? "Failed to load " + e + ": " + n + " from url " + t : "Failed to load " + e + " url: " + t
    }

    function tb(e, t, n) {
        Zv(e, "PluginLoadError", eb("plugin", t, n))
    }

    function nb(e) {
        var t, n;
        e.contentCSS = e.contentCSS.concat(Ey(e, (n = (t = e).getParam("content_css"), X(n) ? A(n.split(","), Je) : S(n) ? n : !1 === n || t.inline ? [] : ["default"])), Ey(e, Bs(e)))
    }

    function rb() {
        function n(e, t) {
            return {
                status: e,
                resultUri: t
            }
        }

        function t(e) {
            return e in r
        }
        var r = {};
        return {
            hasBlobUri: t,
            getResultUri: function(e) {
                var t = r[e];
                return t ? t.resultUri : null
            },
            isPending: function(e) {
                return !!t(e) && 1 === r[e].status
            },
            isUploaded: function(e) {
                return !!t(e) && 2 === r[e].status
            },
            markPending: function(e) {
                r[e] = n(1, null)
            },
            markUploaded: function(e, t) {
                r[e] = n(2, t)
            },
            removeFailed: function(e) {
                delete r[e]
            },
            destroy: function() {
                r = {}
            }
        }
    }

    function ob(e) {
        return e + ky++ + ("s" + (new Date).getTime().toString(36) + t() + t() + t());

        function t() {
            return Math.round(4294967295 * Math.random()).toString(36)
        }
    }

    function ib() {
        function e(e) {
            return M(n, e).getOrUndefined()
        }

        function i(e) {
            if (!e.blob || !e.base64) throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
            var t = e.id || ob("blobid"),
                n = e.name || t,
                r = e.blob;
            return {
                id: J(t),
                name: J(n),
                filename: J(e.filename || n + "." + ({
                    "image/jpeg": "jpg",
                    "image/jpg": "jpg",
                    "image/gif": "gif",
                    "image/png": "png",
                    "image/apng": "apng",
                    "image/avif": "avif",
                    "image/svg+xml": "svg",
                    "image/webp": "webp",
                    "image/bmp": "bmp",
                    "image/tiff": "tiff"
                } [r.type.toLowerCase()] || "dat")),
                blob: J(r),
                base64: J(e.base64),
                blobUri: J(e.blobUri || URL.createObjectURL(r)),
                uri: J(e.uri)
            }
        }

        function t(t) {
            return e(function(e) {
                return e.id() === t
            })
        }
        var n = [];
        return {
            create: function(e, t, n, r, o) {
                if (X(e)) return i({
                    id: e,
                    name: r,
                    filename: o,
                    blob: t,
                    base64: n
                });
                if (h(e)) return i(e);
                throw new Error("Unknown input type")
            },
            add: function(e) {
                t(e.id()) || n.push(e)
            },
            get: t,
            getByUri: function(t) {
                return e(function(e) {
                    return e.blobUri() === t
                })
            },
            getByData: function(t, n) {
                return e(function(e) {
                    return e.base64() === t && e.blob().type === n
                })
            },
            findFirst: e,
            removeByUri: function(t) {
                n = U(n, function(e) {
                    return e.blobUri() !== t || void URL.revokeObjectURL(e.blobUri())
                })
            },
            destroy: function() {
                Y(n, function(e) {
                    URL.revokeObjectURL(e.blobUri())
                }), n = []
            }
        }
    }

    function ab(u, s) {
        function o(e, r, o, t) {
            var i = new XMLHttpRequest;
            i.open("POST", s.url), i.withCredentials = s.credentials, i.upload.onprogress = function(e) {
                t(e.loaded / e.total * 100)
            }, i.onerror = function() {
                o("Image upload failed due to a XHR Transport error. Code: " + i.status)
            }, i.onload = function() {
                var e, t, n;
                i.status < 200 || 300 <= i.status ? o("HTTP Error: " + i.status) : (e = JSON.parse(i.responseText)) && "string" == typeof e.location ? r((t = s.basePath, n = e.location, t ? t.replace(/\/$/, "") + "/" + n.replace(/^\//, "") : n)) : o("Invalid JSON: " + i.responseText)
            };
            var n = new FormData;
            n.append("file", e.blob(), e.filename()), i.send(n)
        }

        function c(e, t) {
            return {
                url: t,
                blobInfo: e,
                status: !0
            }
        }

        function l(e, t, n) {
            return {
                url: "",
                blobInfo: e,
                status: !1,
                error: {
                    message: t,
                    options: n
                }
            }
        }

        function f(e, t) {
            Nt.each(d[e], function(e) {
                e(t)
            }), delete d[e]
        }
        var d = {};
        return !1 === y(s.handler) && (s.handler = o), {
            upload: function(e, t) {
                return s.url || s.handler !== o ? (n = e, r = t, n = Nt.grep(e, function(e) {
                    return !u.isUploaded(e.blobUri())
                }), _r.all(Nt.map(n, function(e) {
                    return u.isPending(e.blobUri()) ? (n = e.blobUri(), new _r(function(e) {
                        d[n] = d[n] || [], d[n].push(e)
                    })) : (i = e, t = s.handler, a = r, u.markPending(i.blobUri()), new _r(function(r) {
                        var n;
                        try {
                            var o = function() {
                                n && n.close()
                            };
                            t(i, function(e) {
                                o(), u.markUploaded(i.blobUri(), e), f(i.blobUri(), c(i, e)), r(c(i, e))
                            }, function(e, t) {
                                var n = t || {};
                                o(), u.removeFailed(i.blobUri()), f(i.blobUri(), l(i, e, n)), r(l(i, e, n))
                            }, function(t) {
                                t < 0 || 100 < t || ve.from(n).orThunk(function() {
                                    return ve.from(a).map(C)
                                }).each(function(e) {
                                    (n = e).progressBar.value(t)
                                })
                            })
                        } catch (e) {
                            r(l(i, e.message, {}))
                        }
                    }));
                    var i, t, a, n
                }))) : new _r(function(e) {
                    e([])
                });
                var n, r
            }
        }
    }

    function ub(e) {
        return function() {
            return e.notificationManager.open({
                text: e.translate("Image uploading..."),
                type: "info",
                timeout: -1,
                progressBar: !0
            })
        }
    }

    function sb(e, t) {
        return ab(t, {
            url: e.getParam("images_upload_url", "", "string"),
            basePath: e.getParam("images_upload_base_path", "", "string"),
            credentials: e.getParam("images_upload_credentials", !1, "boolean"),
            handler: e.getParam("images_upload_handler", null, "function")
        })
    }

    function cb(l) {
        function t(t) {
            return function(e) {
                return l.selection ? t(e) : []
            }
        }

        function r(e, t, n) {
            for (var r = 0; - 1 !== (r = e.indexOf(t, r)) && (e = e.substring(0, r) + n + e.substr(r + t.length), r += n.length - t.length + 1), -1 !== r;);
            return e
        }

        function o(e, t, n) {
            return e = r(e, 'src="' + t + '"', 'src="' + n + '"' + (n === xt.transparentSrc ? ' data-mce-placeholder="1"' : "")), r(e, 'data-mce-src="' + t + '"', 'data-mce-src="' + n + '"')
        }

        function f(t, n) {
            Y(l.undoManager.data, function(e) {
                "fragmented" === e.type ? e.fragments = A(e.fragments, function(e) {
                    return o(e, t, n)
                }) : e.content = o(e.content, t, n)
            })
        }

        function n(n) {
            return u = u || sb(l, g), v().then(t(function(c) {
                var e = A(c, function(e) {
                    return e.blobInfo
                });
                return u.upload(e, ub(l)).then(t(function(e) {
                    var s = [],
                        t = A(e, function(e, t) {
                            var n, r, o, i, a = c[t].blobInfo,
                                u = c[t].image;
                            return e.status && l.getParam("images_replace_blob_uris", !0, "boolean") ? (m.removeByUri(u.src), hh(l) || (r = u, o = e.url, i = l.convertURL(o, "src"), f(r.src, o), l.$(r).attr({
                                src: l.getParam("images_reuse_filename", !1, "boolean") ? o + (-1 === o.indexOf("?") ? "?" : "&") + (new Date).getTime() : o,
                                "data-mce-src": i
                            }))) : e.error && (e.error.options.remove && (f(u.getAttribute("src"), xt.transparentSrc), s.push(u)), n = e.error.message, Qv(l, lu.translate(["Failed to upload image: {0}", n]))), {
                                element: u,
                                status: e.status,
                                uploadUri: e.url,
                                blobInfo: a
                            }
                        });
                    return 0 < t.length && h.fireIfChanged(), 0 < s.length && (hh(l) ? console.error("Removing images on failed uploads is currently unsupported for RTC") : l.undoManager.transact(function() {
                        Y(s, function(e) {
                            l.dom.remove(e), m.removeByUri(e.src)
                        })
                    })), n && n(t), t
                }))
            }))
        }

        function e(e) {
            if (As(l)) return n(e)
        }

        function i(t) {
            return !1 !== j(p, function(e) {
                return e(t)
            }) && (0 !== t.getAttribute("src").indexOf("data:") || l.getParam("images_dataimg_filter", w, "function")(t))
        }

        function a(e) {
            return e.replace(/src="(blob:[^"]+)"/g, function(e, n) {
                var t = g.getResultUri(n);
                if (t) return 'src="' + t + '"';
                var r = (r = m.getByUri(n)) || L(l.editorManager.get(), function(e, t) {
                    return e || t.editorUpload && t.editorUpload.blobCache.getByUri(n)
                }, null);
                return r ? 'src="data:' + r.blob().type + ";base64," + r.base64() + '"' : e
            })
        }
        var u, s, c, d, m = ib(),
            g = rb(),
            p = [],
            h = (d = au(null), (c = l).on("change AddUndo", function(e) {
                d.set(_e({}, e.level))
            }), {
                fireIfChanged: function() {
                    var t = c.undoManager.data;
                    Z(t).filter(function(e) {
                        return !fh(d.get(), e)
                    }).each(function(e) {
                        c.setDirty(!0), c.fire("change", {
                            level: e,
                            lastLevel: G(t, t.length - 2).getOrNull()
                        })
                    })
                }
            }),
            v = function() {
                return (s = s || qh(g, m)).findAll(l.getBody(), i).then(t(function(e) {
                    return e = U(e, function(e) {
                        return "string" != typeof e || void Qv(l, e)
                    }), hh(l) || Y(e, function(e) {
                        f(e.image.src, e.blobInfo.blobUri()), e.image.src = e.blobInfo.blobUri(), e.image.removeAttribute("data-mce-src")
                    }), e
                }))
            };
        return l.on("SetContent", function() {
            (As(l) ? e : v)()
        }), l.on("RawSaveContent", function(e) {
            e.content = a(e.content)
        }), l.on("GetContent", function(e) {
            e.source_view || "raw" === e.format || "tree" === e.format || (e.content = a(e.content))
        }), l.on("PostRender", function() {
            l.parser.addNodeFilter("img", function(e) {
                Y(e, function(e) {
                    var t, n = e.attr("src");
                    m.getByUri(n) || (t = g.getResultUri(n)) && e.attr("src", t)
                })
            })
        }), {
            blobCache: m,
            addFilter: function(e) {
                p.push(e)
            },
            uploadImages: n,
            uploadImagesAuto: e,
            scanForImages: v,
            destroy: function() {
                m.destroy(), g.destroy(), s = u = null
            }
        }
    }

    function lb(e, t) {
        function m(e) {
            o = "string" == typeof e ? {
                name: e,
                classes: [],
                attrs: {}
            } : e;
            var t, n = Ay.create(o.name),
                r = n;
            return (t = o).classes.length && Ay.addClass(r, t.classes.join(" ")), Ay.setAttribs(r, t.attrs), n
        }
        var n, o, r, g = t && t.schema || oo({}),
            p = function(n, e, t) {
                var r, o, i, a, u, s, c, l = 0 < e.length && e[0],
                    f = l && l.name,
                    d = (a = f, u = "string" != typeof(i = n) ? i.nodeName.toLowerCase() : i, !(!(c = (s = g.getElementRule(u)) && s.parentsRequired) || !c.length) && (a && -1 !== Nt.inArray(c, a) ? a : c[0]));
                if (d) f === d ? (o = e[0], e = e.slice(1)) : o = d;
                else if (l) o = e[0], e = e.slice(1);
                else if (!t) return n;
                return o && (r = m(o)).appendChild(n), t && (r || (r = Ay.create("div")).appendChild(n), Nt.each(t, function(e) {
                    var t = m(e);
                    r.insertBefore(t, n)
                })), p(r, e, o && o.siblings)
            };
        return e && e.length ? (n = m(o = e[0]), (r = Ay.create("div")).appendChild(p(n, e.slice(1), o.siblings)), r) : ""
    }

    function fb(e) {
        var t, a = {
            classes: [],
            attrs: {}
        };
        return "*" !== (e = a.selector = Nt.trim(e)) && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function(e, t, n, r, o) {
            switch (t) {
                case "#":
                    a.attrs.id = n;
                    break;
                case ".":
                    a.classes.push(n);
                    break;
                case ":":
                    -1 !== Nt.inArray("checked disabled enabled read-only required".split(" "), n) && (a.attrs[n] = n)
            }
            var i;
            return "[" !== r || (i = o.match(/([\w\-]+)(?:\=\"([^\"]+))?/)) && (a.attrs[i[1]] = i[2]), ""
        })), a.name = t || "div", a
    }

    function db(n, e) {
        var r, t, o = "",
            i = (t = n.getParam("preview_styles", "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"), X(t) ? t : "");
        if ("" === i) return "";

        function a(e) {
            return e.replace(/%(\w+)/g, "")
        }
        if ("string" == typeof e) {
            if (!(e = n.formatter.get(e))) return;
            e = e[0]
        }
        if ("preview" in e) {
            var u = ue(e, "preview");
            if (fn(u, !1)) return "";
            i = u.getOr(i)
        }
        var s, c = e.block || e.inline || "span",
            l = (s = e.selector) && "string" == typeof s ? (s = (s = s.split(/\s*,\s*/)[0]).replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Nt.map(s.split(/(?:>|\s+(?![^\[\]]+\]))/), function(e) {
                var t = Nt.map(e.split(/(?:~\+|~|\+)/), fb),
                    n = t.pop();
                return t.length && (n.siblings = t), n
            }).reverse()) : [],
            f = l.length ? (l[0].name || (l[0].name = c), c = e.selector, lb(l, n)) : lb([c], n),
            d = Ay.select(c, f)[0] || f.firstChild;
        return _y(e.styles, function(e, t) {
            var n = a(e);
            n && Ay.setStyle(d, t, n)
        }), _y(e.attributes, function(e, t) {
            var n = a(e);
            n && Ay.setAttrib(d, t, n)
        }), _y(e.classes, function(e) {
            var t = a(e);
            Ay.hasClass(d, t) || Ay.addClass(d, t)
        }), n.fire("PreviewFormats"), Ay.setStyles(f, {
            position: "absolute",
            left: -65535
        }), n.getBody().appendChild(f), r = Ay.getStyle(n.getBody(), "fontSize", !0), r = /px$/.test(r) ? parseInt(r, 10) : 0, _y(i.split(" "), function(e) {
            var t = Ay.getStyle(d, e, !0);
            if (!("background-color" === e && /transparent|rgba\s*\([^)]+,\s*0\)/.test(t) && (t = Ay.getStyle(n.getBody(), e, !0), "#ffffff" === Ay.toHex(t).toLowerCase()) || "color" === e && "#000000" === Ay.toHex(t).toLowerCase())) {
                if ("font-size" === e && /em|%$/.test(t)) {
                    if (0 === r) return;
                    t = parseFloat(t) / (/%$/.test(t) ? 100 : 1) * r + "px"
                }
                "border" === e && t && (o += "padding:0 2px;"), o += e + ":" + t + ";"
            }
        }), n.fire("AfterPreviewFormats"), Ay.remove(f), o
    }

    function mb(c) {
        var e, r, t, n, o, i, a = (n = {}, (o = function(e, t) {
                e && (X(e) ? (Y(t = !S(t) ? [t] : t, function(e) {
                    b(e.deep) && (e.deep = !gl(e)), b(e.split) && (e.split = !gl(e) || pl(e)), b(e.remove) && gl(e) && !pl(e) && (e.remove = "none"), gl(e) && pl(e) && (e.mixed = !0, e.block_expand = !0), X(e.classes) && (e.classes = e.classes.split(/\s+/))
                }), n[e] = t) : ne(e, function(e, t) {
                    o(t, e)
                }))
            })((r = (e = c).dom, t = {
                valigntop: [{
                    selector: "td,th",
                    styles: {
                        verticalAlign: "top"
                    }
                }],
                valignmiddle: [{
                    selector: "td,th",
                    styles: {
                        verticalAlign: "middle"
                    }
                }],
                valignbottom: [{
                    selector: "td,th",
                    styles: {
                        verticalAlign: "bottom"
                    }
                }],
                alignleft: [{
                    selector: "figure.image",
                    collapsed: !1,
                    classes: "align-left",
                    ceFalseOverride: !0,
                    preview: "font-family font-size"
                }, {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                    styles: {
                        textAlign: "left"
                    },
                    inherit: !1,
                    preview: !1,
                    defaultBlock: "div"
                }, {
                    selector: "img,table,audio,video",
                    collapsed: !1,
                    styles: {
                        float: "left"
                    },
                    preview: "font-family font-size"
                }],
                aligncenter: [{
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                    styles: {
                        textAlign: "center"
                    },
                    inherit: !1,
                    preview: "font-family font-size",
                    defaultBlock: "div"
                }, {
                    selector: "figure.image",
                    collapsed: !1,
                    classes: "align-center",
                    ceFalseOverride: !0,
                    preview: "font-family font-size"
                }, {
                    selector: "img,audio,video",
                    collapsed: !1,
                    styles: {
                        display: "block",
                        marginLeft: "auto",
                        marginRight: "auto"
                    },
                    preview: !1
                }, {
                    selector: "table",
                    collapsed: !1,
                    styles: {
                        marginLeft: "auto",
                        marginRight: "auto"
                    },
                    preview: "font-family font-size"
                }],
                alignright: [{
                    selector: "figure.image",
                    collapsed: !1,
                    classes: "align-right",
                    ceFalseOverride: !0,
                    preview: "font-family font-size"
                }, {
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                    styles: {
                        textAlign: "right"
                    },
                    inherit: !1,
                    preview: "font-family font-size",
                    defaultBlock: "div"
                }, {
                    selector: "img,table,audio,video",
                    collapsed: !1,
                    styles: {
                        float: "right"
                    },
                    preview: "font-family font-size"
                }],
                alignjustify: [{
                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                    styles: {
                        textAlign: "justify"
                    },
                    inherit: !1,
                    defaultBlock: "div",
                    preview: "font-family font-size"
                }],
                bold: [{
                    inline: "strong",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }, {
                    inline: "span",
                    styles: {
                        fontWeight: "bold"
                    }
                }, {
                    inline: "b",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }],
                italic: [{
                    inline: "em",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }, {
                    inline: "span",
                    styles: {
                        fontStyle: "italic"
                    }
                }, {
                    inline: "i",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }],
                underline: [{
                    inline: "span",
                    styles: {
                        textDecoration: "underline"
                    },
                    exact: !0
                }, {
                    inline: "u",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }],
                strikethrough: [{
                    inline: "span",
                    styles: {
                        textDecoration: "line-through"
                    },
                    exact: !0
                }, {
                    inline: "strike",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }, {
                    inline: "s",
                    remove: "all",
                    preserve_attributes: ["class", "style"]
                }],
                forecolor: {
                    inline: "span",
                    styles: {
                        color: "%value"
                    },
                    links: !0,
                    remove_similar: !0,
                    clear_child_styles: !0
                },
                hilitecolor: {
                    inline: "span",
                    styles: {
                        backgroundColor: "%value"
                    },
                    links: !0,
                    remove_similar: !0,
                    clear_child_styles: !0
                },
                fontname: {
                    inline: "span",
                    toggle: !1,
                    styles: {
                        fontFamily: "%value"
                    },
                    clear_child_styles: !0
                },
                fontsize: {
                    inline: "span",
                    toggle: !1,
                    styles: {
                        fontSize: "%value"
                    },
                    clear_child_styles: !0
                },
                lineheight: {
                    selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
                    defaultBlock: "p",
                    styles: {
                        lineHeight: "%value"
                    }
                },
                fontsize_class: {
                    inline: "span",
                    attributes: {
                        class: "%value"
                    }
                },
                blockquote: {
                    block: "blockquote",
                    wrapper: !0,
                    remove: "all"
                },
                subscript: {
                    inline: "sub"
                },
                superscript: {
                    inline: "sup"
                },
                code: {
                    inline: "code"
                },
                link: {
                    inline: "a",
                    selector: "a",
                    remove: "all",
                    split: !0,
                    deep: !0,
                    onmatch: function(e, t, n) {
                        return Hn(e) && e.hasAttribute("href")
                    },
                    onformat: function(n, e, t) {
                        Nt.each(t, function(e, t) {
                            r.setAttrib(n, t, e)
                        })
                    }
                },
                lang: {
                    inline: "span",
                    clear_child_styles: !0,
                    remove_similar: !0,
                    attributes: {
                        lang: "%value",
                        "data-mce-lang": function(e) {
                            var t;
                            return null !== (t = null == e ? void 0 : e.customValue) && void 0 !== t ? t : null
                        }
                    }
                },
                removeformat: [{
                    selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
                    remove: "all",
                    split: !0,
                    expand: !1,
                    block_expand: !0,
                    deep: !0
                }, {
                    selector: "span",
                    attributes: ["style", "class"],
                    remove: "empty",
                    split: !0,
                    expand: !1,
                    deep: !0
                }, {
                    selector: "*",
                    attributes: ["style", "class"],
                    split: !1,
                    expand: !1,
                    deep: !0
                }]
            }, Nt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), function(e) {
                t[e] = {
                    block: e,
                    remove: "all"
                }
            }), t)), o(e.getParam("formats")), {
                get: function(e) {
                    return V(e) ? n[e] : n
                },
                has: function(e) {
                    return Ee(n, e)
                },
                register: o,
                unregister: function(e) {
                    return e && n[e] && delete n[e], n
                }
            }),
            l = au(null);
        return function(e) {
            e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
            for (var t = 1; t <= 6; t++) e.addShortcut("access+" + t, "", ["FormatBlock", !1, "h" + t]);
            e.addShortcut("access+7", "", ["FormatBlock", !1, "p"]), e.addShortcut("access+8", "", ["FormatBlock", !1, "div"]), e.addShortcut("access+9", "", ["FormatBlock", !1, "address"])
        }(c), (i = c).on("mouseup keydown", function(e) {
            var t = i,
                n = e.keyCode,
                r = t.selection,
                o = t.getBody();
            Hg(t, null, !1), 8 !== n && 46 !== n || !r.isCollapsed() || r.getStart().innerHTML !== Cp || Hg(t, qc(o, r.getStart())), 37 !== n && 39 !== n || Hg(t, qc(o, r.getStart()))
        }), {
            get: a.get,
            has: a.has,
            register: a.register,
            unregister: a.unregister,
            apply: function(e, t, n) {
                var r = e,
                    o = t,
                    i = n;
                yh(c).formatter.apply(r, o, i)
            },
            remove: function(e, t, n, r) {
                var o = e,
                    i = t,
                    a = n,
                    u = r;
                yh(c).formatter.remove(o, i, a, u)
            },
            toggle: function(e, t, n) {
                var r = e,
                    o = t,
                    i = n;
                yh(c).formatter.toggle(r, o, i)
            },
            match: function(e, t, n, r) {
                return o = e, i = t, a = n, u = r, yh(c).formatter.match(o, i, a, u);
                var o, i, a, u
            },
            closest: function(e) {
                return t = e, yh(c).formatter.closest(t);
                var t
            },
            matchAll: function(e, t) {
                return n = e, r = t, yh(c).formatter.matchAll(n, r);
                var n, r
            },
            matchNode: function(e, t, n, r) {
                return o = e, i = t, a = n, u = r, yh(c).formatter.matchNode(o, i, a, u);
                var o, i, a, u
            },
            canApply: function(e) {
                return t = e, yh(c).formatter.canApply(t);
                var t
            },
            formatChanged: function(e, t, n, r) {
                return o = l, i = e, a = t, u = n, s = r, yh(c).formatter.formatChanged(o, i, a, u, s);
                var o, i, a, u, s
            },
            getCssText: R(db, c)
        }
    }

    function gb(e) {
        switch (e.toLowerCase()) {
            case "undo":
            case "redo":
            case "mcerepaint":
            case "mcefocus":
                return 1;
            default:
                return
        }
    }

    function pb(s) {
        var e, n, r, o, i, c = du(),
            l = au(0),
            f = au(0),
            d = {
                data: [],
                typing: !1,
                beforeChange: function() {
                    var e = l,
                        t = c;
                    yh(s).undoManager.beforeChange(e, t)
                },
                add: function(e, t) {
                    return n = d, r = f, o = l, i = c, a = e, u = t, yh(s).undoManager.add(n, r, o, i, a, u);
                    var n, r, o, i, a, u
                },
                undo: function() {
                    return e = d, t = l, n = f, yh(s).undoManager.undo(e, t, n);
                    var e, t, n
                },
                redo: function() {
                    return e = f, t = d.data, yh(s).undoManager.redo(e, t);
                    var e, t
                },
                clear: function() {
                    var e = d,
                        t = f;
                    yh(s).undoManager.clear(e, t)
                },
                reset: function() {
                    var e = d;
                    yh(s).undoManager.reset(e)
                },
                hasUndo: function() {
                    return e = d, t = f, yh(s).undoManager.hasUndo(e, t);
                    var e, t
                },
                hasRedo: function() {
                    return e = d, t = f, yh(s).undoManager.hasRedo(e, t);
                    var e, t
                },
                transact: function(e) {
                    return t = d, n = l, r = e, yh(s).undoManager.transact(t, n, r);
                    var t, n, r
                },
                ignore: function(e) {
                    var t = l,
                        n = e;
                    yh(s).undoManager.ignore(t, n)
                },
                extra: function(e, t) {
                    var n = d,
                        r = f,
                        o = e,
                        i = t;
                    yh(s).undoManager.extra(n, r, o, i)
                }
            };
        return hh(s) || (r = d, o = l, i = au(!1), (n = s).on("init", function() {
            r.add()
        }), n.on("BeforeExecCommand", function(e) {
            gb(e.command) || (gh(r, o), r.beforeChange())
        }), n.on("ExecCommand", function(e) {
            gb(e.command) || a(e)
        }), n.on("ObjectResizeStart cut", function() {
            r.beforeChange()
        }), n.on("SaveContent ObjectResized blur", a), n.on("dragend", a), n.on("keyup", function(e) {
            var t = e.keyCode;
            e.isDefaultPrevented() || ((33 <= t && t <= 36 || 37 <= t && t <= 40 || 45 === t || e.ctrlKey) && (a(), n.nodeChanged()), 46 !== t && 8 !== t || n.nodeChanged(), i.get() && r.typing && !1 === fh(uh(n), r.data[0]) && (!1 === n.isDirty() && (n.setDirty(!0), n.fire("change", {
                level: r.data[0],
                lastLevel: null
            })), n.fire("TypingUndo"), i.set(!1), n.nodeChanged()))
        }), n.on("keydown", function(e) {
            var t, n = e.keyCode;
            e.isDefaultPrevented() || (33 <= n && n <= 36 || 37 <= n && n <= 40 || 45 === n ? r.typing && a(e) : (t = e.ctrlKey && !e.altKey || e.metaKey, !(n < 16 || 20 < n) || 224 === n || 91 === n || r.typing || t || (r.beforeChange(), mh(r, !0, o), r.add({}, e), i.set(!0))))
        }), n.on("mousedown", function(e) {
            r.typing && a(e)
        }), n.on("input", function(e) {
            e.inputType && ("insertReplacementText" === e.inputType || "insertText" === e.inputType && null === e.data || "insertFromPaste" === e.inputType || "insertFromDrop" === e.inputType) && a(e)
        }), n.on("AddUndo Undo Redo ClearUndos", function(e) {
            e.isDefaultPrevented() || n.nodeChanged()
        })), (e = s).addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo"), d;

        function a(e) {
            mh(r, !1, o), r.add({}, e)
        }
    }

    function hb(e) {
        return "keydown" === e.type || "keyup" === e.type
    }

    function vb(e) {
        var t = e.keyCode;
        return t === If.BACKSPACE || t === If.DELETE
    }

    function bb(e, t) {
        return ze(Et.fromDom(t), e.getParam("inline_boundaries_selector", "a[href],code,.mce-annotation", "string"))
    }

    function yb(e, t, n) {
        var r, o, i = (r = e, o = t, U(eu.DOM.getParents(n.container(), "*", o), r));
        return ve.from(i[i.length - 1])
    }

    function Cb(e, t) {
        if (!t) return t;
        var n = t.container(),
            r = t.offset();
        return e ? Ir(n) ? Vn(n.nextSibling) ? cs(n.nextSibling, 0) : cs.after(n) : Ur(t) ? cs(n, r + 1) : t : Ir(n) ? Vn(n.previousSibling) ? cs(n.previousSibling, n.previousSibling.data.length) : cs.before(n) : zr(t) ? cs(n, r - 1) : t
    }

    function xb(e) {
        return po(e) || vo(e)
    }

    function wb(e, t) {
        return Ve(e, t) ? hr(t, xb, (n = e, function(e) {
            return je(n, Et.fromDom(e.dom.parentNode))
        })) : ve.none();
        var n
    }

    function Sb(e) {
        var t, n, r;
        e.dom.isEmpty(e.getBody()) && (e.setContent(""), r = (n = (t = e).getBody()).firstChild && t.dom.isBlock(n.firstChild) ? n.firstChild : n, t.selection.setCursorLocation(r, 0))
    }

    function Nb(e, t) {
        return {
            from: e,
            to: t
        }
    }

    function Eb(e, t) {
        return wb(Et.fromDom(e), Et.fromDom(t.container())).map(function(e) {
            return {
                block: e,
                position: t
            }
        })
    }

    function kb(e) {
        var t, n = z(t = Tn(e), go).fold(J(t), function(e) {
            return t.slice(0, e)
        });
        return Y(n, In), n
    }

    function _b(e, t) {
        return M(ym(t, e).reverse(), function(e) {
            return Kr(e)
        }).each(In)
    }

    function Ab(e, t, n, r) {
        if (Kr(n)) return hm(n), rf(n.dom);
        0 === U(Lt(r), function(e) {
            return !Kr(e)
        }).length && Kr(t) && qt(r, Et.fromTag("br"));
        var o = nf(n.dom, cs.before(r.dom));
        return Y(kb(t), function(e) {
            qt(r, e)
        }), _b(e, t), o
    }

    function Rb(e, t, n) {
        if (Kr(n)) return In(n), Kr(t) && hm(t), rf(t.dom);
        var r = of(n.dom);
        return Y(kb(t), function(e) {
            Ln(n, e)
        }), _b(e, t), r
    }

    function Db(e, t) {
        jc(e, t.dom).map(function(e) {
            return e.getNode()
        }).map(Et.fromDom).filter(Pr).each(In)
    }

    function Tb(e, t, n) {
        return Db(!0, t), Db(!1, n), (Ve(o = n, r = t) ? (i = ym(r, o), ve.from(i[i.length - 1])) : ve.none()).fold(R(Rb, e, t, n), R(Ab, e, t, n));
        var r, o, i
    }

    function Ob(e, t, n, r) {
        return t ? Tb(e, r, n) : Tb(e, n, r)
    }

    function Bb(t, n) {
        var e, r, o, i, a, u, s, c = Et.fromDom(t.getBody()),
            l = (e = c.dom, r = n, ((o = t.selection.getRng()).collapsed ? (a = r, u = Eb(i = e, cs.fromRangeStart(o)), s = u.bind(function(e) {
                return Zl(a, i, e.position).bind(function(e) {
                    return Eb(i, e).map(function(e) {
                        return t = i, n = a, Kn((r = e).position.getNode()) && !1 === Kr(r.block) ? jc(!1, r.block.dom).bind(function(e) {
                            return e.isEqual(r.position) ? Zl(n, t, e).bind(function(e) {
                                return Eb(t, e)
                            }) : ve.some(r)
                        }).getOr(r) : r;
                        var t, n, r
                    })
                })
            }), dn(u, s, Nb).filter(function(e) {
                return !1 === je(e.from.block, e.to.block) && Ot((n = e).from.block).bind(function(t) {
                    return Ot(n.to.block).filter(function(e) {
                        return je(t, e)
                    })
                }).isSome() && !1 === Gn((t = e).from.block.dom) && !1 === Gn(t.to.block.dom);
                var t, n
            })) : ve.none()).bind(function(e) {
                return Ob(c, n, e.from.block, e.to.block)
            }));
        return l.each(function(e) {
            t.selection.setRng(e.toRange())
        }), l.isSome()
    }

    function Pb(e, t) {
        var n = Et.fromDom(t),
            r = R(je, e);
        return pr(n, yo, r).isSome()
    }

    function Lb(e) {
        var n, r, o, t, i, a, u, s, c, l, f = Et.fromDom(e.getBody()),
            d = e.selection.getRng();
        return a = d, c = nf((i = f).dom, cs.fromRangeStart(a)).isNone(), l = tf(i.dom, cs.fromRangeEnd(a)).isNone(), !Pb(u = i, (s = a).startContainer) && !Pb(u, s.endContainer) && c && l ? ((t = e).setContent(""), t.selection.setCursorLocation(), !0) : (n = f, r = e.selection, o = r.getRng(), dn(wb(n, Et.fromDom(o.startContainer)), wb(n, Et.fromDom(o.endContainer)), function(e, t) {
            return !1 === je(e, t) && (o.deleteContents(), Ob(n, !0, e, t).each(function(e) {
                r.setRng(e.toRange())
            }), !0)
        }).getOr(!1))
    }

    function Ib(e, t) {
        return !e.selection.isCollapsed() && Lb(e)
    }

    function Mb(e, t, n, r, o) {
        return ve.from(t._selectionOverrides.showCaret(e, n, r, o))
    }

    function Fb(e, t) {
        var n, r;
        return e.fire("BeforeObjectSelected", {
            target: t
        }).isDefaultPrevented() ? ve.none() : ve.some(((r = (n = t).ownerDocument.createRange()).selectNode(n), r))
    }

    function Ub(e, t, n) {
        var r = nc(1, e.getBody(), t),
            o = cs.fromRangeStart(r),
            i = o.getNode();
        if (Ec(i)) return Mb(1, e, i, !o.isAtEnd(), !1);
        var a = o.getNode(!0);
        if (Ec(a)) return Mb(1, e, a, !1, !1);
        var u = e.dom.getParent(o.getNode(), function(e) {
            return Ly(e) || Py(e)
        });
        return Ec(u) ? Mb(1, e, u, !1, n) : ve.none()
    }

    function zb(e, t, n) {
        return t.collapsed ? Ub(e, t, n).getOr(t) : t
    }

    function Hb(e) {
        return rp(e) || Zg(e)
    }

    function jb(e) {
        return op(e) || ep(e)
    }

    function Vb(n, r, e, t, o, i) {
        var a, u;
        return Mb(t, n, i.getNode(!o), o, !0).each(function(e) {
            var t;
            r.collapsed ? (t = r.cloneRange(), o ? t.setEnd(e.startContainer, e.startOffset) : t.setStart(e.endContainer, e.endOffset), t.deleteContents()) : r.deleteContents(), n.selection.setRng(e)
        }), a = n.dom, Vn(u = e) && 0 === u.data.length && a.remove(u), !0
    }

    function qb(e, t) {
        var n = e.selection.getRng();
        if (!Vn(n.commonAncestorContainer)) return !1;
        var r = t ? sc.Forwards : sc.Backwards,
            o = Mc(e.getBody()),
            i = R(ac, t ? o.next : o.prev),
            a = t ? Hb : jb,
            u = oc(r, e.getBody(), n),
            s = Cb(t, i(u));
        if (!s || !uc(u, s)) return !1;
        if (a(s)) return Vb(e, n, u.getNode(), r, t, s);
        var c = i(s);
        return !!(c && a(c) && uc(s, c)) && Vb(e, n, u.getNode(), r, t, c)
    }

    function $b(l, f, d) {
        return Zl(f, l, d).bind(function(e) {
            return s = e.getNode(), yo(Et.fromDom(s)) || vo(Et.fromDom(s)) || (o = l, u = e, rc(!(i = f), a = d).fold(function() {
                return rc(i, u).fold(D, c)
            }, c)) ? ve.none() : f && Gn(e.getNode()) || !1 === f && Gn(e.getNode(!0)) ? (t = l, n = d, r = e.getNode(!1 === f), wb(Et.fromDom(t), Et.fromDom(n.getNode())).map(function(e) {
                return Kr(e) ? Iy.remove(e.dom) : Iy.moveToElement(r)
            }).orThunk(function() {
                return ve.some(Iy.moveToElement(r))
            })) : f && op(d) || !1 === f && rp(d) ? ve.some(Iy.moveToPosition(e)) : ve.none();
            var t, n, r, o, i, a, u, s;

            function c(e) {
                return Br(Et.fromDom(e)) && !Qs(a, u, o)
            }
        })
    }

    function Wb(e, t) {
        return ve.from(bf(e.getBody(), t))
    }

    function Kb(m, g) {
        var e = m.selection.getNode();
        return Wb(m, e).filter(Gn).fold(function() {
            return s = m.getBody(), l = nc((c = g) ? 1 : -1, s, m.selection.getRng()), f = cs.fromRangeStart(l), d = Et.fromDom(s), (!1 === c && op(f) ? ve.some(Iy.remove(f.getNode(!0))) : c && rp(f) ? ve.some(Iy.remove(f.getNode())) : !1 === c && rp(f) && _m(d, f) ? cp(d, f).map(function(e) {
                return Iy.remove(e.getNode())
            }) : c && op(f) && km(d, f) ? lp(d, f).map(function(e) {
                return Iy.remove(e.getNode())
            }) : (r = s, e = c, a = (o = f).getNode(!1 === (i = e)), u = i ? "after" : "before", Hn(a) && a.getAttribute("data-mce-caret") === u ? (n = o.getNode(!1 === (t = e)), (t && Gn(n.nextSibling) ? ve.some(Iy.moveToElement(n.nextSibling)) : !1 === t && Gn(n.previousSibling) ? ve.some(Iy.moveToElement(n.previousSibling)) : ve.none()).fold(function() {
                return $b(r, e, o)
            }, ve.some)) : $b(r, e, o).bind(function(e) {
                return t = r, n = o, e.fold(function(e) {
                    return ve.some(Iy.remove(e))
                }, function(e) {
                    return ve.some(Iy.moveToElement(e))
                }, function(e) {
                    return Qs(n, e, t) ? ve.none() : ve.some(Iy.moveToPosition(e))
                });
                var t, n
            }))).exists(function(e) {
                return e.fold(function(e) {
                    return o._selectionOverrides.hideFakeCaret(), Qm(o, i, Et.fromDom(e)), !0
                }, (r = i = g, function(e) {
                    var t = r ? cs.before(e) : cs.after(e);
                    return n.selection.setRng(t.toRange()), !0
                }), (t = n = o = m, function(e) {
                    return t.selection.setRng(e.toRange()), !0
                }));
                var t, n, r, o, i
            });
            var r, e, o, t, n, i, a, u, s, c, l, f, d
        }, w)
    }

    function Xb(e, t) {
        var n = e.selection.getNode();
        return !(!Gn(n) || Jn(n)) && Wb(e, n.parentNode).filter(Gn).fold(function() {
            return Y(yu(Et.fromDom(e.getBody()), ".mce-offscreen-selection"), In), Qm(e, t, Et.fromDom(e.selection.getNode())), Sb(e), !0
        }, w)
    }

    function Yb(e) {
        var t, n = e.dom,
            r = e.selection,
            o = bf(e.getBody(), r.getNode());
        return Yn(o) && n.isBlock(o) && n.isEmpty(o) && (t = n.create("br", {
            "data-mce-bogus": "1"
        }), n.setHTML(o, ""), o.appendChild(t), r.setRng(cs.before(t).toRange())), !0
    }

    function Gb(e, t) {
        return (e.selection.isCollapsed() ? Kb : Xb)(e, t)
    }

    function Jb(e, t) {
        return !!e.selection.isCollapsed() && (n = e, r = t, o = cs.fromRangeStart(n.selection.getRng()), Zl(r, n.getBody(), o).filter(function(e) {
            return (r ? Jg : Qg)(e)
        }).bind(function(e) {
            return ve.from(Zs(r ? 0 : -1, e))
        }).exists(function(e) {
            return n.selection.select(e), !0
        }));
        var n, r, o
    }

    function Qb(e) {
        return My(e) && e.data[0] === So
    }

    function Zb(e) {
        return My(e) && e.data[e.data.length - 1] === So
    }

    function ey(e) {
        return e.ownerDocument.createTextNode(So)
    }

    function ty(e, t) {
        return (e ? function(e) {
            if (My(e.previousSibling)) return Zb(e.previousSibling) || e.previousSibling.appendData(So), e.previousSibling;
            if (My(e)) return Qb(e) || e.insertData(0, So), e;
            var t = ey(e);
            return e.parentNode.insertBefore(t, e), t
        } : function(e) {
            if (My(e.nextSibling)) return Qb(e.nextSibling) || e.nextSibling.insertData(0, So), e.nextSibling;
            if (My(e)) return Zb(e) || e.appendData(So), e;
            var t = ey(e);
            return e.nextSibling ? e.parentNode.insertBefore(t, e.nextSibling) : e.parentNode.appendChild(t), t
        })(t)
    }

    function ny(e, t) {
        return Vn(e.container()) ? ty(t, e.container()) : ty(t, e.getNode())
    }

    function ry(e, t) {
        var n = t.get();
        return n && e.container() === n && Ir(n)
    }

    function oy(n, e) {
        return e.fold(function(e) {
            Cc(n.get());
            var t = Fy(e);
            return n.set(t), ve.some(cs(t, t.length - 1))
        }, function(e) {
            return rf(e).map(function(e) {
                if (ry(e, n)) return cs(n.get(), 1);
                Cc(n.get());
                var t = ny(e, !0);
                return n.set(t), cs(t, 1)
            })
        }, function(e) {
            return of(e).map(function(e) {
                if (ry(e, n)) return cs(n.get(), n.get().length - 1);
                Cc(n.get());
                var t = ny(e, !1);
                return n.set(t), cs(t, t.length - 1)
            })
        }, function(e) {
            Cc(n.get());
            var t = Uy(e);
            return n.set(t), ve.some(cs(t, 1))
        })
    }

    function iy(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n].apply(null, t);
            if (r.isSome()) return r
        }
        return ve.none()
    }

    function ay(e, t) {
        return Js(t, e) || e
    }

    function uy(e, t, n) {
        var r = Oy(n),
            o = ay(t, r.container());
        return yb(e, o, r).fold(function() {
            return tf(o, r).bind(R(yb, e, o)).map(function(e) {
                return zy.before(e)
            })
        }, ve.none)
    }

    function sy(e, t) {
        return null === qc(e, t)
    }

    function cy(e, t, n) {
        return yb(e, t, n).filter(R(sy, t))
    }

    function ly(e, t, n) {
        var r = By(n);
        return cy(e, t, r).bind(function(e) {
            return nf(e, r).isNone() ? ve.some(zy.start(e)) : ve.none()
        })
    }

    function fy(e, t, n) {
        var r = Oy(n);
        return cy(e, t, r).bind(function(e) {
            return tf(e, r).isNone() ? ve.some(zy.end(e)) : ve.none()
        })
    }

    function dy(e, t, n) {
        var r = By(n),
            o = ay(t, r.container());
        return yb(e, o, r).fold(function() {
            return nf(o, r).bind(R(yb, e, o)).map(function(e) {
                return zy.after(e)
            })
        }, ve.none)
    }

    function my(e) {
        return !1 === (t = Hy(e), "rtl" === eu.DOM.getStyle(t, "direction", !0) || (n = t.textContent, Ty.test(n)));
        var t, n
    }

    function gy(e, t, n) {
        return iy([uy, ly, fy, dy], [e, t, n]).filter(my)
    }

    function py(e) {
        return e.fold(J("before"), J("start"), J("end"), J("after"))
    }

    function hy(e) {
        return e.fold(zy.before, zy.before, zy.after, zy.after)
    }

    function vy(e) {
        return e.fold(zy.start, zy.start, zy.end, zy.end)
    }

    function by(a, e, u, t, n, s) {
        return dn(yb(e, u, t), yb(e, u, n), function(e, t) {
            return e !== t && (r = t, o = Js(e, n = u), i = Js(r, n), o && o === i) ? zy.after(a ? e : t) : s;
            var n, r, o, i
        }).getOr(s)
    }

    function yy(e, r) {
        return e.fold(w, function(e) {
            return n = r, !(py(t = e) === py(n) && Hy(t) === Hy(n));
            var t, n
        })
    }

    function Cy(e, t) {
        return e ? t.fold(i(ve.some, zy.start), ve.none, i(ve.some, zy.after), ve.none) : t.fold(ve.none, i(ve.some, zy.before), ve.none, i(ve.some, zy.end))
    }

    function xy(e, a, u, s) {
        var t = Cb(e, s),
            c = gy(a, u, t);
        return gy(a, u, t).bind(R(Cy, e)).orThunk(function() {
            return n = a, r = u, o = c, i = Cb(t = e, s), Zl(t, r, i).map(R(Cb, t)).fold(function() {
                return o.map(hy)
            }, function(e) {
                return gy(n, r, e).map(R(by, t, n, r, i, e)).filter(R(yy, o))
            }).filter(my);
            var t, n, r, o, i
        })
    }

    function wy(e) {
        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
        var r = window.console;
        r && (r.error || r.log).apply(r, Ae([e], t, !1))
    }
    var Sy, Ny, Ey = function(t, e) {
            var n = t.editorManager.baseURL + "/skins/content",
                r = "content" + t.editorManager.suffix + ".css",
                o = !0 === t.inline;
            return A(e, function(e) {
                return /^[a-z0-9\-]+$/i.test(e) && !o ? n + "/" + e + "/" + r : t.documentBaseURI.toAbsolute(e)
            })
        },
        ky = 0,
        _y = Nt.each,
        Ay = eu.DOM,
        Ry = [9, 27, If.HOME, If.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, If.DOWN, If.UP, If.LEFT, If.RIGHT].concat(xt.browser.isFirefox() ? [224] : []),
        Dy = "data-mce-placeholder",
        Ty = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/,
        Oy = R(Cb, !0),
        By = R(Cb, !1),
        Py = Yn,
        Ly = Gn,
        Iy = ir([{
            remove: ["element"]
        }, {
            moveToElement: ["element"]
        }, {
            moveToPosition: ["position"]
        }]),
        My = Vn,
        Fy = R(ty, !0),
        Uy = R(ty, !1),
        zy = ir([{
            before: ["element"]
        }, {
            start: ["element"]
        }, {
            end: ["element"]
        }, {
            after: ["element"]
        }]),
        Hy = function(e) {
            return e.fold(u, u, u, u)
        };

    function jy(e, t, n) {
        var r = e ? 1 : -1;
        return t.setRng(cs(n.container(), n.offset() + r).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0
    }

    function Vy(e, t) {
        return e === sc.Backwards ? q(t) : t
    }

    function qy(e, t, n, r) {
        for (var o, i, a, u, s = Mc(n), c = r, l = []; c;) {
            var f = (a = s, u = c, t === sc.Forwards ? a.next(u) : a.prev(u));
            if (!f) break;
            if (Kn(f.getNode(!1))) return t === sc.Forwards ? {
                positions: Vy(t, l).concat([f]),
                breakType: Sy.Br,
                breakAt: ve.some(f)
            } : {
                positions: Vy(t, l),
                breakType: Sy.Br,
                breakAt: ve.some(f)
            };
            if (f.isVisible()) {
                if (e(c, f)) {
                    var d = (o = c, Kn((i = f).getNode(t === sc.Forwards)) ? Sy.Br : !1 === Qs(o, i) ? Sy.Block : Sy.Wrap);
                    return {
                        positions: Vy(t, l),
                        breakType: d,
                        breakAt: ve.some(f)
                    }
                }
                l.push(f), c = f
            } else c = f
        }
        return {
            positions: Vy(t, l),
            breakType: Sy.Eol,
            breakAt: ve.none()
        }
    }

    function $y(n, r, o, e) {
        return r(o, e).breakAt.map(function(e) {
            var t = r(o, e).positions;
            return n === sc.Backwards ? t.concat(e) : [e].concat(t)
        }).getOr([])
    }

    function Wy(e, i) {
        return L(e, function(e, o) {
            return e.fold(function() {
                return ve.some(o)
            }, function(r) {
                return dn(Q(r.getClientRects()), Q(o.getClientRects()), function(e, t) {
                    var n = Math.abs(i - e.left);
                    return Math.abs(i - t.left) <= n ? o : r
                }).or(e)
            })
        }, ve.none())
    }

    function Ky(t, e) {
        return Q(e.getClientRects()).bind(function(e) {
            return Wy(t, e.left)
        })
    }

    function Xy(n) {
        function e(e) {
            return A(e, function(e) {
                var t = Ru(e);
                return t.node = n, t
            })
        }
        if (Hn(n)) return e(n.getClientRects());
        if (Vn(n)) {
            var t = n.ownerDocument.createRange();
            return t.setStart(n, 0), t.setEnd(n, n.data.length), e(t.getClientRects())
        }
    }

    function Yy(e) {
        return H(e, Xy)
    }
    R(xy, !1), R(xy, !0), (Ny = Sy = {})[Ny.Br = 0] = "Br", Ny[Ny.Block = 1] = "Block", Ny[Ny.Wrap = 2] = "Wrap", Ny[Ny.Eol = 3] = "Eol";
    var Gy, Jy, Qy = R(qy, cs.isAbove, -1),
        Zy = R(qy, cs.isBelow, 1),
        e0 = R($y, -1, Qy),
        t0 = R($y, 1, Zy);

    function n0(o, i, a, e, u, t) {
        function n(e) {
            var t = Yy([e]); - 1 === o && (t = t.reverse());
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (!a(r, l)) {
                    if (0 < c.length && i(r, pe(c)) && s++, r.line = s, u(r)) return !0;
                    c.push(r)
                }
            }
        }
        var s = 0,
            c = [],
            l = pe(t.getClientRects());
        if (!l) return c;
        var r = t.getNode();
        return n(r),
            function(e, t, n, r) {
                for (; r = Gs(r, e, qr, t);)
                    if (n(r)) return
            }(o, e, n, r), c
    }

    function r0(t) {
        return function(e) {
            return e.line > t
        }
    }

    function o0(t) {
        return function(e) {
            return e.line === t
        }
    }

    function i0(e, t) {
        return Math.abs(e.left - t)
    }

    function a0(e, t) {
        return Math.abs(e.right - t)
    }

    function u0(e, t) {
        return e >= t.left && e <= t.right
    }

    function s0(e, t) {
        return e >= t.top && e <= t.bottom
    }

    function c0(e, o, i) {
        return void 0 === i && (i = w), me(e, function(e, t) {
            if (u0(o, t)) return i(t) ? t : e;
            if (u0(o, e)) return i(e) ? e : t;
            var n = Math.min(i0(e, o), a0(e, o)),
                r = Math.min(i0(t, o), a0(t, o));
            return r === n && se(t, "node") && ZC(t.node) || r < n ? t : e
        })
    }

    function l0(e, t, n, r, o) {
        var i = e1(r, e, qr, t, !o);
        do {
            if (!i || n(i)) return
        } while (i = e1(i, e, qr, t))
    }

    function f0(e, t, n) {
        function r(e) {
            return !cn(e.node) && !Qn(e.node)
        }
        var o, i, a, u = Yy(U(xe(e.getElementsByTagName("*")), Xs)),
            s = U(u, R(s0, n));
        if ((a = c0(s, t, r)) && ((a = c0(function(e, r, t) {
                function n(t, e) {
                    var n = U(Yy([e]), function(e) {
                        return !t(e, r)
                    });
                    return o = o.concat(n), 0 === n.length
                }
                void 0 === t && (t = !0);
                var o = [];
                return o.push(r), l0(Gy.Up, e, R(n, Ou), r.node, t), l0(Gy.Down, e, R(n, Bu), r.node, t), o
            }(e, a, r(a)), t, r)) && Xs(a.node))) return {
            node: (o = a).node,
            before: i0(o, i = t) < a0(o, i)
        };
        return null
    }

    function d0(e, t) {
        e.selection.setRng(t), nd(e, e.selection.getRng())
    }

    function m0(e, t, n) {
        return ve.some(zb(e, t, n))
    }

    function g0(e, t, n, r, o, i) {
        var a = t === sc.Forwards,
            u = Mc(e.getBody()),
            s = R(ac, a ? u.next : u.prev),
            c = a ? r : o;
        if (!n.collapsed) {
            var l = Lu(n);
            if (i(l)) return Mb(t, e, l, t === sc.Backwards, !1)
        }
        var f = oc(t, e.getBody(), n);
        if (c(f)) return Fb(e, f.getNode(!a));
        var d = Cb(a, s(f)),
            m = jr(n);
        if (!d) return m ? ve.some(n) : ve.none();
        if (c(d)) return Mb(t, e, d.getNode(!a), a, !1);
        var g = s(d);
        return g && c(g) && uc(d, g) ? Mb(t, e, g.getNode(!a), a, !1) : m ? m0(e, d.toRange(), !1) : ve.none()
    }

    function p0(t, e, n, r, o, i) {
        var a = oc(e, t.getBody(), n),
            u = pe(a.getClientRects()),
            s = e === Gy.Down;
        if (!u) return ve.none();
        var c, l = U((s ? QC : JC)(t.getBody(), r0(1), a), o0(1)),
            f = u.left,
            d = c0(l, f);
        if (d && i(d.node)) {
            var m = Math.abs(f - d.left),
                g = Math.abs(f - d.right);
            return Mb(e, t, d.node, m < g, !1)
        }
        if (c = r(a) ? a.getNode() : o(a) ? a.getNode(!0) : Lu(n)) {
            var p = function(e, t, n, r) {
                    function o(e) {
                        return pe(e.getClientRects())
                    }
                    var i, a, u, s = Mc(t),
                        c = [],
                        l = 0,
                        f = 1 === e ? (i = s.next, a = Bu, u = Ou, cs.after(r)) : (i = s.prev, a = Ou, u = Bu, cs.before(r)),
                        d = o(f);
                    do {
                        if (f.isVisible()) {
                            var m = o(f);
                            if (!u(m, d)) {
                                0 < c.length && a(m, pe(c)) && l++;
                                var g = Ru(m);
                                if (g.position = f, g.line = l, n(g)) return c;
                                c.push(g)
                            }
                        }
                    } while (f = i(f));
                    return c
                }(e, t.getBody(), r0(1), c),
                h = c0(U(p, o0(1)), f);
            if (h) return m0(t, h.position.toRange(), !1);
            if (h = pe(U(p, o0(0)))) return m0(t, h.position.toRange(), !1)
        }
        return 0 === l.length ? t1(t, s).filter(s ? o : r).map(function(e) {
            return zb(t, e.toRange(), !1)
        }) : ve.none()
    }

    function h0(t, e, n) {
        return t1(t, e).filter(n).exists(function(e) {
            return t.selection.setRng(e.toRange()), !0
        })
    }

    function v0(e, t) {
        var n = e.dom.createRng();
        n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n)
    }

    function b0(e, t) {
        e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected")
    }

    function y0(t, e, n) {
        return oy(e, n).map(function(e) {
            return v0(t, e), n
        })
    }

    function C0(e, t, n) {
        return !!Ms(e) && (o = t, i = n, a = (r = e).getBody(), u = cs.fromRangeStart(r.selection.getRng()), xy(i, R(bb, r), a, u).bind(function(e) {
            return y0(r, o, e)
        }).isSome());
        var r, o, i, a, u
    }

    function x0(e, t, n) {
        return !!Ms(t) && (r = e, i = (o = t).selection.getRng(), a = r ? cs.fromRangeEnd(i) : cs.fromRangeStart(i), !!y(o.selection.getSel().modify) && (r && Ur(a) ? jy(!0, o.selection, a) : !(r || !zr(a)) && jy(!1, o.selection, a)));
        var r, o, i, a
    }

    function w0(g) {
        var p = au(null),
            h = R(bb, g);
        return g.on("NodeChange", function(e) {
            var n, r, o, t, i, a, u, s, c, l, f, d, m;
            !Ms(g) || xt.browser.isIE() && e.initial || (i = h, a = g.dom, u = e.parents, Y($(s = U(A(yu(Et.fromDom(a.getRoot()), '*[data-mce-selected="inline-boundary"]'), function(e) {
                return e.dom
            }), i), c = U(u, i)), R(b0, !1)), Y($(c, s), R(b0, !0)), f = p, (l = g).selection.isCollapsed() && !0 !== l.composing && f.get() && (d = cs.fromRangeStart(l.selection.getRng()), cs.isTextPosition(d) && !1 === (Ur(m = d) || zr(m)) && (v0(l, qs(f.get(), d)), f.set(null))), n = h, r = g, o = p, t = e.parents, r.selection.isCollapsed() && Y(U(t, n), function(e) {
                var t = cs.fromRangeStart(r.selection.getRng());
                gy(n, r.getBody(), t).bind(function(e) {
                    return y0(r, o, e)
                })
            }))
        }), p
    }

    function S0(n, t, r) {
        if (Ms(n)) {
            var e = t1(n, t).getOrThunk(function() {
                var e = n.selection.getRng();
                return t ? cs.fromRangeEnd(e) : cs.fromRangeStart(e)
            });
            return gy(R(bb, n), n.getBody(), e).exists(function(e) {
                var t = hy(e);
                return oy(r, t).exists(function(e) {
                    return v0(n, e), !0
                })
            })
        }
        return !1
    }

    function N0(t, n) {
        return function(e) {
            return oy(n, e).exists(function(e) {
                return v0(t, e), !0
            })
        }
    }

    function E0(r, o, i, a) {
        var u = r.getBody(),
            s = R(bb, r);
        r.undoManager.ignore(function() {
            var e, t, n;
            r.selection.setRng((e = i, t = a, (n = document.createRange()).setStart(e.container(), e.offset()), n.setEnd(t.container(), t.offset()), n)), r.execCommand("Delete"), gy(s, u, cs.fromRangeStart(r.selection.getRng())).map(vy).map(N0(r, o))
        }), r.nodeChanged()
    }

    function k0(e, t, n) {
        if (e.selection.isCollapsed() && Ms(e)) {
            var r = cs.fromRangeStart(e.selection.getRng());
            return o = t, a = n, u = r, s = (i = e).getBody(), c = Js(u.container(), s) || s, l = R(bb, i), (f = gy(l, c, u)).bind(function(e) {
                return a ? e.fold(J(ve.some(vy(e))), ve.none, J(ve.some(hy(e))), ve.none) : e.fold(ve.none, J(ve.some(hy(e))), ve.none, J(ve.some(vy(e))))
            }).map(N0(i, o)).getOrThunk(function() {
                var t = Hc(a, c, u),
                    e = t.bind(function(e) {
                        return gy(l, c, e)
                    });
                return dn(f, e, function() {
                    return yb(l, c, u).exists(function(e) {
                        return !!dn(rf(o = e), of(o), function(e, t) {
                            var n = Cb(!0, e),
                                r = Cb(!1, t);
                            return tf(o, n).forall(function(e) {
                                return e.isEqual(r)
                            })
                        }).getOr(!0) && (Qm(i, a, Et.fromDom(e)), !0);
                        var o
                    })
                }).orThunk(function() {
                    return e.bind(function(e) {
                        return t.map(function(e) {
                            return a ? E0(i, o, u, e) : E0(i, o, e, u), !0
                        })
                    })
                }).getOr(!1)
            })
        }
        var i, o, a, u, s, c, l, f;
        return !1
    }

    function _0(e) {
        return 1 === zt(e)
    }

    function A0(g, p) {
        var t, e = Et.fromDom(g.getBody()),
            n = Et.fromDom(g.selection.getStart()),
            h = U(z(t = ym(n, e), go).fold(J(t), function(e) {
                return t.slice(0, e)
            }), _0);
        return Z(h).exists(function(e) {
            var t, n, r, o, i, a, u, s, c, l = cs.fromRangeStart(g.selection.getRng()),
                f = p,
                d = l,
                m = e.dom;
            return !(!dn(rf(m), of(m), function(e, t) {
                var n = Cb(!0, e),
                    r = Cb(!1, t),
                    o = Cb(!1, d);
                return f ? tf(m, o).exists(function(e) {
                    return e.isEqual(r) && d.isEqual(n)
                }) : nf(m, o).exists(function(e) {
                    return e.isEqual(n) && d.isEqual(r)
                })
            }).getOr(!0) || Vc((t = e).dom) && Mg(t.dom) || (n = p, o = e, 0 === (c = A(U(h, R(Wg, r = g)), function(e) {
                return e.dom
            })).length ? Qm(r, n, o) : (a = o.dom, s = Vg(c, (u = Ug(!1)).dom), qt(Et.fromDom(a), u), In(Et.fromDom(a)), i = cs(s, 0), r.selection.setRng(i.toRange())), 0))
        })
    }

    function R0(e, t) {
        return !!e.selection.isCollapsed() && A0(e, t)
    }

    function D0(e, t, n) {
        return e._selectionOverrides.hideFakeCaret(), Qm(e, t, Et.fromDom(n)), !0
    }

    function T0(e, t) {
        return e.selection.isCollapsed() ? (i = e, u = (a = t) ? Zg : ep, s = a ? sc.Forwards : sc.Backwards, c = oc(s, i.getBody(), i.selection.getRng()), u(c) ? D0(i, a, c.getNode(!a)) : ve.from(Cb(a, c)).filter(function(e) {
            return u(e) && uc(c, e)
        }).exists(function(e) {
            return D0(i, a, e.getNode(!a))
        })) : (r = t, o = (n = e).selection.getNode(), !!Qn(o) && D0(n, r, o));
        var n, r, o, i, a, u, s, c
    }

    function O0(e) {
        var t = parseInt(e, 10);
        return isNaN(t) ? 0 : t
    }

    function B0(e, t) {
        return (e || "table" === kt(t) ? "margin" : "padding") + ("rtl" === wn(t, "direction") ? "-right" : "-left")
    }

    function P0(e) {
        var n, t = o1(e);
        return !e.mode.isReadOnly() && (1 < t.length || (n = e, j(t, function(e) {
            var t = Sn(e, B0(Os(n), e)).map(O0).getOr(0);
            return "false" !== n.dom.getContentEditable(e.dom) && 0 < t
        })))
    }

    function L0(e) {
        return ho(e) || vo(e)
    }

    function I0(e, s) {
        var c = e.dom,
            t = e.selection,
            n = e.formatter,
            r = e.getParam("indentation", "40px", "string"),
            l = /[a-z%]+$/i.exec(r)[0],
            f = parseInt(r, 10),
            d = Os(e),
            o = ks(e);
        e.queryCommandState("InsertUnorderedList") || e.queryCommandState("InsertOrderedList") || "" !== o || c.getParent(t.getNode(), c.isBlock) || n.apply("div"), Y(o1(e), function(e) {
            var t, n = c,
                r = s,
                o = f,
                i = l,
                a = e.dom,
                u = B0(d, Et.fromDom(a));
            "outdent" === r ? (t = Math.max(0, O0(a.style[u]) - o), n.setStyle(a, u, t ? t + i : "")) : (t = O0(a.style[u]) + o + i, n.setStyle(a, u, t))
        })
    }

    function M0(e, t) {
        if (e.selection.isCollapsed() && P0(e)) {
            var n = e.dom,
                r = e.selection.getRng(),
                o = cs.fromRangeStart(r),
                i = n.getParent(r.startContainer, n.isBlock);
            if (null !== i && ip(Et.fromDom(i), o)) return I0(e, "outdent"), !0
        }
        return !1
    }

    function F0(e, t) {
        e.getDoc().execCommand(t, !1, null)
    }

    function U0(e) {
        return void 0 === e.touches || 1 !== e.touches.length ? ve.none() : ve.some(e.touches[0])
    }

    function z0(e, t) {
        return Ee(e, t.nodeName)
    }

    function H0(e) {
        var t, n, r, o = e.dom,
            i = e.selection,
            a = e.schema,
            u = a.getBlockElements(),
            s = i.getStart(),
            c = e.getBody(),
            l = ks(e);
        if (s && Hn(s) && l) {
            var f = c.nodeName.toLowerCase();
            if (a.isValidChild(f, l.toLowerCase()) && (d = u, m = c, g = s, !F(bm(Et.fromDom(g), Et.fromDom(m)), function(e) {
                    return z0(d, e.dom)
                }))) {
                for (var d, m, g, p, h, v = i.getRng(), b = v.startContainer, y = v.startOffset, C = v.endContainer, x = v.endOffset, w = Cd(e), s = c.firstChild; s;) p = u, Vn(h = s) || Hn(h) && !z0(p, h) && !Qc(h) ? function(e, t) {
                    if (Vn(t)) {
                        if (0 === t.nodeValue.length) return 1;
                        if (/^\s+$/.test(t.nodeValue) && (!t.nextSibling || z0(e, t.nextSibling))) return 1
                    }
                }(u, s) ? (s = (n = s).nextSibling, o.remove(n)) : (t || (t = o.create(l, _s(e)), s.parentNode.insertBefore(t, s), r = !0), s = (n = s).nextSibling, t.appendChild(n)) : (t = null, s = s.nextSibling);
                r && w && (v.setStart(b, y), v.setEnd(C, x), i.setRng(v), e.nodeChanged())
            }
        }
    }

    function j0(e, t) {
        t.hasAttribute("data-mce-caret") && (Hr(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t))
    }

    function V0(e, t) {
        var n = br(Et.fromDom(e.getBody()), "*[data-mce-caret]").map(function(e) {
            return e.dom
        }).getOrNull();
        if (n) return "compositionstart" === t.type ? (t.preventDefault(), t.stopPropagation(), void j0(e, n)) : void(Fr(n) && (j0(e, n), e.undoManager.add()))
    }

    function q0(e, t, n) {
        var r, o, i, a = Mc(e.getBody()),
            u = R(ac, 1 === t ? a.next : a.prev);
        !n.collapsed || "" === ks(e) || (r = e.dom.getParent(n.startContainer, "PRE")) && (u(cs.fromRangeStart(n)) || (i = e.dom.create(ks(e)), (!xt.ie || 11 <= xt.ie) && (i.innerHTML = '<br data-mce-bogus="1">'), o = i, 1 === t ? e.$(r).after(o) : e.$(r).before(o), e.selection.select(o, !0), e.selection.collapse()))
    }

    function $0(t, e) {
        return n = t, r = e ? sc.Forwards : sc.Backwards, o = n.selection.getRng(), g0(n, r, o, rp, op, i1).orThunk(function() {
            return q0(n, r, o), ve.none()
        }).exists(function(e) {
            return d0(t, e), !0
        });
        var n, r, o
    }

    function W0(t, e) {
        return r = e ? 1 : -1, o = (n = t).selection.getRng(), p0(n, r, o, function(e) {
            return rp(e) || tp(e)
        }, function(e) {
            return op(e) || np(e)
        }, i1).orThunk(function() {
            return q0(n, r, o), ve.none()
        }).exists(function(e) {
            return d0(t, e), !0
        });
        var n, r, o
    }

    function K0(e, t) {
        return h0(e, t, t ? op : rp)
    }

    function X0(e) {
        return T(["figcaption"], kt(e))
    }

    function Y0(e) {
        var t = document.createRange();
        return t.setStartBefore(e.dom), t.setEndBefore(e.dom), t
    }

    function G0(e, t, n) {
        (n ? Ln : Wt)(e, t)
    }

    function J0(h, v) {
        var b = Et.fromDom(h.getBody()),
            y = cs.fromRangeStart(h.selection.getRng()),
            C = ks(h),
            x = _s(h),
            e = y,
            t = R(je, b);
        return hr(Et.fromDom(e.container()), go, t).filter(X0).exists(function() {
            if (d = b, m = y, v ? (p = d.dom, Zy(p, m).breakAt.isNone()) : (g = d.dom, Qy(g, m).breakAt.isNone())) {
                var e = (t = b, r = x, o = v, "" === (n = C) ? (l = o, G0(t, f = Et.fromTag("br"), l), Y0(f)) : (i = t, a = o, u = r, s = Et.fromTag(n), c = Et.fromTag("br"), hn(s, u), Ln(s, c), G0(i, s, a), Y0(c)));
                return h.selection.setRng(e), !0
            }
            var t, n, r, o, i, a, u, s, c, l, f, d, m, g, p;
            return !1
        })
    }

    function Q0(e, t) {
        return !!e.selection.isCollapsed() && J0(e, t)
    }

    function Z0(e) {
        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
        return function() {
            return e.apply(null, t)
        }
    }

    function eC(e, t) {
        return M((n = t, H(A(e, function(e) {
            return _e({
                shiftKey: !1,
                altKey: !1,
                ctrlKey: !1,
                metaKey: !1,
                keyCode: 0,
                action: te
            }, e)
        }), function(e) {
            return n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey ? [e] : []
        })), function(e) {
            return e.action()
        });
        var n
    }

    function tC(t, e) {
        var n = e ? sc.Forwards : sc.Backwards,
            r = t.selection.getRng();
        return g0(t, n, r, Zg, ep, Qn).exists(function(e) {
            return d0(t, e), !0
        })
    }

    function nC(t, e) {
        var n = e ? 1 : -1,
            r = t.selection.getRng();
        return p0(t, n, r, Zg, ep, Qn).exists(function(e) {
            return d0(t, e), !0
        })
    }

    function rC(e, t) {
        return h0(e, t, t ? ep : Zg)
    }

    function oC(e, t, n, r, o) {
        var i, a = yu(Et.fromDom(n), "td,th,caption").map(function(e) {
                return e.dom
            }),
            u = U((i = e, H(a, function(e) {
                var t, n = {
                    left: (t = Ru(e.getBoundingClientRect())).left - -1,
                    top: t.top - -1,
                    right: t.right + -2,
                    bottom: t.bottom + -2,
                    width: t.width + -1,
                    height: t.height + -1
                };
                return [{
                    x: n.left,
                    y: i(n),
                    cell: e
                }, {
                    x: n.right,
                    y: i(n),
                    cell: e
                }]
            })), function(e) {
                return t(e, o)
            }),
            s = r,
            c = o;
        return L(u, function(e, r) {
            return e.fold(function() {
                return ve.some(r)
            }, function(e) {
                var t = Math.sqrt(Math.abs(e.x - s) + Math.abs(e.y - c)),
                    n = Math.sqrt(Math.abs(r.x - s) + Math.abs(r.y - c));
                return ve.some(n < t ? r : e)
            })
        }, ve.none()).map(function(e) {
            return e.cell
        })
    }

    function iC(e, t, n) {
        var r, o, i = e(t, n);
        return i.breakType === Sy.Wrap && 0 === i.positions.length || !Kn(n.getNode()) && i.breakType === Sy.Br && 1 === i.positions.length ? (r = e, o = t, !i.breakAt.exists(function(e) {
            return r(o, e).breakAt.isSome()
        })) : i.breakAt.isNone()
    }

    function aC(t, e, n, r) {
        var o, i, a, u = t.selection.getRng(),
            s = e ? 1 : -1;
        return !(!Ks() || (o = e, i = n, a = cs.fromRangeStart(u), !jc(!o, i).exists(function(e) {
            return e.isEqual(a)
        })) || (Mb(s, t, n, !e, !1).each(function(e) {
            d0(t, e)
        }), 0))
    }

    function uC(u, s, c) {
        var e, t, n = (e = !!s, t = c.getNode(e), Hn(t) && "TABLE" === t.nodeName ? ve.some(t) : ve.none()),
            r = !1 === s;
        n.fold(function() {
            return d0(u, c.toRange())
        }, function(a) {
            return jc(r, u.getBody()).filter(function(e) {
                return e.isEqual(c)
            }).fold(function() {
                return d0(u, c.toRange())
            }, function(e) {
                var n, r, o = s,
                    i = a,
                    t = c;
                (r = ks(n = u)) ? n.undoManager.transact(function() {
                    var e = Et.fromTag(r);
                    hn(e, _s(n)), Ln(e, Et.fromTag("br")), (o ? $t : qt)(Et.fromDom(i), e);
                    var t = n.dom.createRng();
                    t.setStart(e.dom, 0), t.setEnd(e.dom, 0), d0(n, t)
                }): d0(n, t.toRange())
            })
        })
    }

    function sC(e, t, n, r) {
        var o, i, a, u, s, c, l, f, d, m, g = e.selection.getRng(),
            p = cs.fromRangeStart(g),
            h = e.getBody();
        if (t || !s1(r, p)) return !(!t || !c1(r, p)) && (o = h, d = i = n, uC(e, t, v = Z((m = a = p).getClientRects()).bind(function(e) {
            return u1(d, e.left, e.top)
        }).bind(function(e) {
            return Ky(rf(t = e).map(function(e) {
                return [e].concat(Zy(t, e).positions)
            }).getOr([]), m);
            var t
        }).orThunk(function() {
            return Q(a.getClientRects()).bind(function(e) {
                return Wy(t0(o, cs.after(i)), e.left)
            })
        }).getOr(cs.after(i))), !0);
        var v = (u = h, l = s = n, Q((f = c = p).getClientRects()).bind(function(e) {
            return a1(l, e.left, e.top)
        }).bind(function(e) {
            return Ky(of(t = e).map(function(e) {
                return Qy(t, e).positions.concat(e)
            }).getOr([]), f);
            var t
        }).orThunk(function() {
            return Q(c.getClientRects()).bind(function(e) {
                return Wy(e0(u, cs.before(s)), e.left)
            })
        }).getOr(cs.before(s)));
        return uC(e, t, v), !0
    }

    function cC(n, r, o) {
        return ve.from(n.dom.getParent(n.selection.getNode(), "td,th")).bind(function(t) {
            return ve.from(n.dom.getParent(t, "table")).map(function(e) {
                return o(n, r, e, t)
            })
        }).getOr(!1)
    }

    function lC(e, t) {
        return cC(e, t, aC)
    }

    function fC(e, t) {
        return cC(e, t, sC)
    }

    function dC(e, t) {
        var n, r, o = t,
            i = e.dom,
            a = e.schema.getMoveCaretBeforeOnEnterElements();
        if (t) {
            !/^(LI|DT|DD)$/.test(t.nodeName) || (r = function(e) {
                for (; e;) {
                    if (1 === e.nodeType || 3 === e.nodeType && e.data && /[\r\n\s]/.test(e.data)) return e;
                    e = e.nextSibling
                }
            }(t.firstChild)) && /^(UL|OL|DL)$/.test(r.nodeName) && t.insertBefore(i.doc.createTextNode(wo), t.firstChild);
            var u = i.createRng();
            if (t.normalize(), t.hasChildNodes()) {
                for (var s = new Dr(t, t); n = s.current();) {
                    if (Vn(n)) {
                        u.setStart(n, 0), u.setEnd(n, 0);
                        break
                    }
                    if (a[n.nodeName.toLowerCase()]) {
                        u.setStartBefore(n), u.setEndBefore(n);
                        break
                    }
                    o = n, n = s.next()
                }
                n || (u.setStart(o, 0), u.setEnd(o, 0))
            } else Kn(t) ? t.nextSibling && i.isBlock(t.nextSibling) ? (u.setStartBefore(t), u.setEndBefore(t)) : (u.setStartAfter(t), u.setEndAfter(t)) : (u.setStart(t, 0), u.setEnd(t, 0));
            e.selection.setRng(u), nd(e, u)
        }
    }

    function mC(e) {
        return ve.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock))
    }

    function gC(e, t) {
        return e && e.parentNode && e.parentNode.nodeName === t
    }

    function pC(e) {
        return e && /^(OL|UL|LI)$/.test(e.nodeName)
    }

    function hC(e) {
        var t = e.parentNode;
        return /^(LI|DT|DD)$/.test(t.nodeName) ? t : e
    }

    function vC(e, t, n) {
        for (var r = e[n ? "firstChild" : "lastChild"]; r && !Hn(r);) r = r[n ? "nextSibling" : "previousSibling"];
        return r === t
    }

    function bC(e) {
        e.innerHTML = '<br data-mce-bogus="1">'
    }

    function yC(e, t) {
        return e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t
    }

    function CC(e, t) {
        return t && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && "true" !== e.getContentEditable(t)
    }

    function xC(e, t, n) {
        return !1 === Vn(t) ? n : e ? 1 === n && t.data.charAt(n - 1) === So ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === So ? t.data.length : n
    }

    function wC(e, t) {
        for (var n, r = e.getRoot(), o = t; o !== r && "false" !== e.getContentEditable(o);) "true" === e.getContentEditable(o) && (n = o), o = o.parentNode;
        return o !== r ? n : r
    }

    function SC(e, t) {
        var n = ks(e);
        n && n.toLowerCase() === t.tagName.toLowerCase() && function(e, o, t) {
            var i = e.dom;
            ve.from(t.style).map(i.parseStyle).each(function(e) {
                var t = Nn(Et.fromDom(o)),
                    n = _e(_e({}, t), e);
                i.setStyles(o, n)
            }), dn(ve.from(t.class).map(function(e) {
                return e.split(/\s+/)
            }), ve.from(o.className).map(function(e) {
                return U(e.split(/\s+/), function(e) {
                    return "" !== e
                })
            }), function(t, e) {
                var n = U(e, function(e) {
                        return !T(t, e)
                    }),
                    r = Ae(Ae([], t, !0), n, !0);
                i.setAttrib(o, "class", r.join(" "))
            });
            var n = ["style", "class"],
                r = ae(t, function(e, t) {
                    return !T(n, t)
                });
            i.setAttribs(o, r)
        }(e, t, _s(e))
    }

    function NC(a, e) {
        function t(e) {
            var t, n = m,
                r = l.getTextInlineElements(),
                o = e || "TABLE" === C || "HR" === C ? c.create(e || p) : b.cloneNode(!1),
                i = o;
            if (!1 === a.getParam("keep_styles", !0)) c.setAttrib(o, "style", null), c.setAttrib(o, "class", null);
            else
                for (; r[n.nodeName] && (Vc(n) || Qc(n) || (t = n.cloneNode(!1), c.setAttrib(t, "id", ""), o.hasChildNodes() ? t.appendChild(o.firstChild) : i = t, o.appendChild(t))), (n = n.parentNode) && n !== F;);
            return SC(a, o), bC(i), o
        }

        function n(e) {
            var t, n, r = xC(e, m, g);
            if (!Vn(m) || !(e ? 0 < r : r < m.nodeValue.length)) {
                if (m.parentNode === b && s && !e) return 1;
                if (e && Hn(m) && m === b.firstChild) return 1;
                if (yC(m, "TABLE") || yC(m, "HR")) return s && !e || !s && e;
                var o = new Dr(m, b);
                for (Vn(m) && (e && 0 === r ? o.prev() : e || r !== m.nodeValue.length || o.next()); t = o.current();) {
                    if (Hn(t)) {
                        if (!t.getAttribute("data-mce-bogus") && (n = t.nodeName.toLowerCase(), f[n] && "br" !== n)) return
                    } else if (Vn(t) && !$r(t.nodeValue)) return;
                    e ? o.prev() : o.next()
                }
                return 1
            }
        }

        function r() {
            u = /^(H[1-6]|PRE|FIGURE)$/.test(C) && "HGROUP" !== x ? t(p) : t(), a.getParam("end_container_on_empty_block", !1) && CC(c, y) && c.isEmpty(b) ? u = c.split(y, b) : c.insertAfter(u, b), dC(a, u)
        }
        var o, u, i, s, c = a.dom,
            l = a.schema,
            f = l.getNonEmptyElements(),
            d = a.selection.getRng();
        Of(c, d).each(function(e) {
            d.setStart(e.startContainer, e.startOffset), d.setEnd(e.endContainer, e.endOffset)
        });
        var m = d.startContainer,
            g = d.startOffset,
            p = ks(a),
            h = !(!e || !e.shiftKey),
            v = !(!e || !e.ctrlKey);
        Hn(m) && m.hasChildNodes() && (s = g > m.childNodes.length - 1, m = m.childNodes[Math.min(g, m.childNodes.length - 1)] || m, g = s && Vn(m) ? m.nodeValue.length : 0);
        var b, y, C, x, w, S, p, N, E, k, _, A, R, D, T, O, B, P, L, I, M, F = wC(c, m);
        F && ((p && !h || !p && h) && (m = function(e, t, n, r) {
            var o, i, a, u, s, c, l = p || "P",
                f = e.dom,
                d = wC(f, n),
                m = f.getParent(n, f.isBlock);
            if (!m || !CC(f, m)) {
                if (s = ((m = m || d) === e.getBody() || (c = m) && /^(TD|TH|CAPTION)$/.test(c.nodeName) ? m : m.parentNode).nodeName.toLowerCase(), !m.hasChildNodes()) return SC(e, o = f.create(l)), m.appendChild(o), t.setStart(o, 0), t.setEnd(o, 0), o;
                for (a = n; a.parentNode !== m;) a = a.parentNode;
                for (; a && !f.isBlock(a);) a = (i = a).previousSibling;
                if (i && e.schema.isValidChild(s, l.toLowerCase())) {
                    for (SC(e, o = f.create(l)), i.parentNode.insertBefore(o, i), a = i; a && !f.isBlock(a);) u = a.nextSibling, o.appendChild(a), a = u;
                    t.setStart(n, r), t.setEnd(n, r)
                }
            }
            return n
        }(a, d, m, g)), y = (b = c.getParent(m, c.isBlock)) ? c.getParent(b.parentNode, c.isBlock) : null, C = b ? b.nodeName.toUpperCase() : "", "LI" !== (x = y ? y.nodeName.toUpperCase() : "") || v || (y = (b = y).parentNode, C = x), /^(LI|DT|DD)$/.test(C) && c.isEmpty(b) ? (E = t, k = y, _ = b, A = p, I = (N = a).dom, M = N.selection.getRng(), k !== N.getBody() && (D = (A = pC(R = k) && pC(R.parentNode) ? "LI" : A) ? E(A) : I.create("BR"), vC(k, _, !0) && vC(k, _, !1) ? gC(k, "LI") ? (T = hC(k), I.insertAfter(D, T), (null === (L = (P = k).parentNode) || void 0 === L ? void 0 : L.firstChild) === P ? I.remove(T) : I.remove(k)) : I.replace(D, k) : (vC(k, _, !0) ? gC(k, "LI") ? (I.insertAfter(D, hC(k)), D.appendChild(I.doc.createTextNode(" ")), D.appendChild(k)) : k.parentNode.insertBefore(D, k) : vC(k, _, !1) ? I.insertAfter(D, hC(k)) : (k = hC(k), (O = M.cloneRange()).setStartAfter(_), O.setEndAfter(k), B = O.extractContents(), "LI" === A && (B.firstChild && "LI" === B.firstChild.nodeName) ? (D = B.firstChild, I.insertAfter(B, k)) : (I.insertAfter(B, k), I.insertAfter(D, k))), I.remove(_)), dC(N, D))) : p && b === a.getBody() || (p = p || "P", Lr(b) ? (u = Hr(b), c.isEmpty(b) && bC(b), SC(a, u), dC(a, u)) : n() ? r() : n(!0) ? (u = b.parentNode.insertBefore(t(), b), dC(a, yC(b, "HR") ? u : b)) : ((S = (w = d).cloneRange()).setStart(w.startContainer, xC(!0, w.startContainer, w.startOffset)), S.setEnd(w.endContainer, xC(!1, w.endContainer, w.endOffset)), (o = S.cloneRange()).setEndAfter(b), i = o.extractContents(), Y(qu(Et.fromDom(i), An), function(e) {
            var t = e.dom;
            t.nodeValue = Eo(t.nodeValue)
        }), function(e) {
            for (; Vn(e) && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, "")), e = e.firstChild;);
        }(i), u = i.firstChild, c.insertAfter(i, b), function(e, t) {
            var n, r, o = u,
                i = [];
            if (o) {
                for (; o = o.firstChild;) {
                    if (e.isBlock(o)) return;
                    Hn(o) && !t[o.nodeName.toLowerCase()] && i.push(o)
                }
                for (n = i.length; n--;) !(o = i[n]).hasChildNodes() || o.firstChild === o.lastChild && "" === o.firstChild.nodeValue ? e.remove(o) : (r = o) && "A" === r.nodeName && e.isEmpty(r) && e.remove(o)
            }
        }(c, f), function(e, t) {
            t.normalize();
            var n = t.lastChild;
            n && !/^(left|right)$/gi.test(e.getStyle(n, "float", !0)) || e.add(t, "br")
        }(c, b), c.isEmpty(b) && bC(b), u.normalize(), c.isEmpty(u) ? (c.remove(u), r()) : (SC(a, u), dC(a, u))), c.setAttrib(u, "id", ""), a.fire("NewBlock", {
            newBlock: u
        })))
    }

    function EC(e, t, n) {
        var r = e.dom.createRng();
        n ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)), e.selection.setRng(r), nd(e, r)
    }

    function kC(e, t) {
        var n = Et.fromTag("br");
        qt(Et.fromDom(t), n), e.undoManager.add()
    }

    function _C(e, t) {
        l1(e.getBody(), t) || $t(Et.fromDom(t), Et.fromTag("br"));
        var n = Et.fromTag("br");
        $t(Et.fromDom(t), n), EC(e, n.dom, !1), e.undoManager.add()
    }

    function AC(e) {
        return e && "A" === e.nodeName && "href" in e
    }

    function RC(e) {
        return e.fold(D, AC, AC, D)
    }

    function DC(e, t) {
        t.fold(te, R(kC, e), R(_C, e), te)
    }

    function TC(e, t) {
        var n, r, o, i = (r = R(bb, n = e), o = cs.fromRangeStart(n.selection.getRng()), gy(r, n.getBody(), o).filter(RC));
        i.isSome() ? i.each(R(DC, e)) : function(e, t) {
            var n, r, o = e.selection,
                i = e.dom,
                a = o.getRng();
            Of(i, a).each(function(e) {
                a.setStart(e.startContainer, e.startOffset), a.setEnd(e.endContainer, e.endOffset)
            });
            var u, s = a.startOffset,
                c = a.startContainer;
            1 === c.nodeType && c.hasChildNodes() && (u = s > c.childNodes.length - 1, c = c.childNodes[Math.min(s, c.childNodes.length - 1)] || c, s = u && 3 === c.nodeType ? c.nodeValue.length : 0);
            var l = i.getParent(c, i.isBlock),
                f = l ? i.getParent(l.parentNode, i.isBlock) : null,
                d = f ? f.nodeName.toUpperCase() : "",
                m = !(!t || !t.ctrlKey);
            "LI" !== d || m || (l = f), c && 3 === c.nodeType && s >= c.nodeValue.length && ! function(e) {
                for (var t, n = new Dr(c, l), r = e.getNonEmptyElements(); t = n.next();)
                    if (r[t.nodeName.toLowerCase()] || 0 < t.length) return 1
            }(e.schema) && (n = i.create("br"), a.insertNode(n), a.setStartAfter(n), a.setEndAfter(n), r = !0), n = i.create("br"), fs(i, a, n), EC(e, n, r), e.undoManager.add()
        }(e, t)
    }

    function OC(e, t) {
        return mC(e).filter(function(e) {
            return 0 < t.length && ze(Et.fromDom(e), t)
        }).isSome()
    }

    function BC(e, t) {
        return OC(e, e.getParam("no_newline_selector", ""))
    }

    function PC(n) {
        return function(e, t) {
            return "" === ks(e) === n
        }
    }

    function LC(n) {
        return function(e, t) {
            return mC(e).filter(function(e) {
                return vo(Et.fromDom(e))
            }).isSome() === n
        }
    }

    function IC(n, r) {
        return function(e, t) {
            return mC(e).fold(J(""), function(e) {
                return e.nodeName.toUpperCase()
            }) === n.toUpperCase() === r
        }
    }

    function MC(e) {
        return IC("pre", e)
    }

    function FC(n) {
        return function(e, t) {
            return e.getParam("br_in_pre", !0) === n
        }
    }

    function UC(e, t) {
        return OC(e, e.getParam("br_newline_selector", ".mce-toc h2,figcaption,caption"))
    }

    function zC(e, t) {
        return t
    }

    function HC(e) {
        var t = ks(e),
            n = function(e, t) {
                for (var n, r = e.getRoot(), o = t; o !== r && "false" !== e.getContentEditable(o);) "true" === e.getContentEditable(o) && (n = o), o = o.parentNode;
                return o !== r ? n : r
            }(e.dom, e.selection.getStart());
        return n && e.schema.isValidChild(n.nodeName, t || "P")
    }

    function jC(e, t) {
        return function(n, r) {
            return L(e, function(e, t) {
                return e && t(n, r)
            }, !0) ? ve.some(t) : ve.none()
        }
    }

    function VC(e, t) {
        var n, r;
        n = e, r = t, iy([jC([BC], f1.none()), jC([IC("summary", !0)], f1.br()), jC([MC(!0), FC(!1), zC], f1.br()), jC([MC(!0), FC(!1)], f1.block()), jC([MC(!0), FC(!0), zC], f1.block()), jC([MC(!0), FC(!0)], f1.br()), jC([LC(!0), zC], f1.br()), jC([LC(!0)], f1.block()), jC([PC(!0), zC, HC], f1.block()), jC([PC(!0)], f1.br()), jC([UC], f1.br()), jC([PC(!1), zC], f1.br()), jC([HC], f1.block())], [n, !(!r || !r.shiftKey)]).getOr(f1.none()).fold(function() {
            TC(e, t)
        }, function() {
            NC(e, t)
        }, te)
    }

    function qC(e) {
        return e.stopImmediatePropagation()
    }

    function $C(e) {
        return e.keyCode === If.PAGE_UP || e.keyCode === If.PAGE_DOWN
    }

    function WC(e, t, n) {
        n && !e.get() ? t.on("NodeChange", qC, !0) : !n && e.get() && t.off("NodeChange", qC), e.set(n)
    }

    function KC(n, r) {
        var e = r.container(),
            t = r.offset();
        return Vn(e) ? (e.insertData(t, n), ve.some(cs(e, t + n.length))) : ic(r).map(function(e) {
            var t = Et.fromText(n);
            return (r.isAtEnd() ? $t : qt)(e, t), cs(t.dom, n.length)
        })
    }

    function XC(i, a) {
        return function(e) {
            return r = i, (!Om(o = e) && (n = o, nf((t = r).dom, n).isNone() || tf(t.dom, n).isNone() || ip(t, n) || ap(t, n) || _m(t, n) || km(t, n) || Dm(r, o) || Tm(r, o)) ? g1 : p1)(a);
            var t, n, r, o
        }
    }

    function YC(e) {
        var t, n, r = cs.fromRangeStart(e.selection.getRng()),
            o = Et.fromDom(e.getBody());
        if (e.selection.isCollapsed()) {
            var i = R(bb, e),
                a = cs.fromRangeStart(e.selection.getRng());
            return gy(i, e.getBody(), a).bind((n = o, function(e) {
                return e.fold(function(e) {
                    return nf(n.dom, cs.before(e))
                }, function(e) {
                    return rf(e)
                }, function(e) {
                    return of(e)
                }, function(e) {
                    return tf(n.dom, cs.after(e))
                })
            })).bind(XC(o, r)).exists((t = e, function(e) {
                return t.selection.setRng(e.toRange()), t.nodeChanged(), !0
            }))
        }
        return !1
    }

    function GC(e) {
        var o, i, a, u, s, t, n, r, c, l, f, d, m, g, p = w0(e);
        return e.on("keyup compositionstart", R(V0, e)), g = p, (m = e).on("keydown", function(e) {
            var t, n, r, o;
            !1 === e.isDefaultPrevented() && (t = m, n = g, r = e, o = dt().os, eC([{
                keyCode: If.RIGHT,
                action: Z0($0, t, !0)
            }, {
                keyCode: If.LEFT,
                action: Z0($0, t, !1)
            }, {
                keyCode: If.UP,
                action: Z0(W0, t, !1)
            }, {
                keyCode: If.DOWN,
                action: Z0(W0, t, !0)
            }, {
                keyCode: If.RIGHT,
                action: Z0(lC, t, !0)
            }, {
                keyCode: If.LEFT,
                action: Z0(lC, t, !1)
            }, {
                keyCode: If.UP,
                action: Z0(fC, t, !1)
            }, {
                keyCode: If.DOWN,
                action: Z0(fC, t, !0)
            }, {
                keyCode: If.RIGHT,
                action: Z0(tC, t, !0)
            }, {
                keyCode: If.LEFT,
                action: Z0(tC, t, !1)
            }, {
                keyCode: If.UP,
                action: Z0(nC, t, !1)
            }, {
                keyCode: If.DOWN,
                action: Z0(nC, t, !0)
            }, {
                keyCode: If.RIGHT,
                action: Z0(C0, t, n, !0)
            }, {
                keyCode: If.LEFT,
                action: Z0(C0, t, n, !1)
            }, {
                keyCode: If.RIGHT,
                ctrlKey: !o.isOSX(),
                altKey: o.isOSX(),
                action: Z0(n1, t, n)
            }, {
                keyCode: If.LEFT,
                ctrlKey: !o.isOSX(),
                altKey: o.isOSX(),
                action: Z0(r1, t, n)
            }, {
                keyCode: If.UP,
                action: Z0(Q0, t, !1)
            }, {
                keyCode: If.DOWN,
                action: Z0(Q0, t, !0)
            }], r).each(function(e) {
                r.preventDefault()
            }))
        }), d = p, (f = e).on("keydown", function(e) {
            var t, n, r;
            !1 === e.isDefaultPrevented() && (n = d, r = e, eC([{
                keyCode: If.BACKSPACE,
                action: Z0(M0, t = f, !1)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(Gb, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(Gb, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(qb, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(qb, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(k0, t, n, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(k0, t, n, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(yg, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(yg, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(Jb, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(Jb, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(T0, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(T0, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(Ib, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(Ib, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(Bb, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(Bb, t, !0)
            }, {
                keyCode: If.BACKSPACE,
                action: Z0(R0, t, !1)
            }, {
                keyCode: If.DELETE,
                action: Z0(R0, t, !0)
            }], r).each(function(e) {
                r.preventDefault()
            }))
        }), f.on("keyup", function(e) {
            var t, n;
            !1 === e.isDefaultPrevented() && (n = e, eC([{
                keyCode: If.BACKSPACE,
                action: Z0(Yb, t = f)
            }, {
                keyCode: If.DELETE,
                action: Z0(Yb, t)
            }], n))
        }), (l = e).on("keydown", function(e) {
            var t, n, r;
            e.keyCode === If.ENTER && (t = l, (n = e).isDefaultPrevented() || (n.preventDefault(), (r = t.undoManager).typing && (r.typing = !1, r.add()), t.undoManager.transact(function() {
                !1 === t.selection.isCollapsed() && t.execCommand("Delete"), VC(t, n)
            })))
        }), (c = e).on("keydown", function(e) {
            var t;
            !1 === e.isDefaultPrevented() && (t = e, eC([{
                keyCode: If.SPACEBAR,
                action: Z0(YC, c)
            }], t).each(function(e) {
                t.preventDefault()
            }))
        }), n = t = e, r = mu(function() {
            n.composing || Um(n)
        }, 0), d1.isIE() && (n.on("keypress", function(e) {
            r.throttle()
        }), n.on("remove", function(e) {
            r.cancel()
        })), t.on("input", function(e) {
            !1 === e.isComposing && Um(t)
        }), s = p, (u = e).on("keydown", function(e) {
            var t, n, r;
            !1 === e.isDefaultPrevented() && (n = s, r = e, eC([{
                keyCode: If.END,
                action: Z0(K0, t = u, !0)
            }, {
                keyCode: If.HOME,
                action: Z0(K0, t, !1)
            }, {
                keyCode: If.END,
                action: Z0(rC, t, !0)
            }, {
                keyCode: If.HOME,
                action: Z0(rC, t, !1)
            }, {
                keyCode: If.END,
                action: Z0(S0, t, !0, n)
            }, {
                keyCode: If.HOME,
                action: Z0(S0, t, !1, n)
            }], r).each(function(e) {
                r.preventDefault()
            }))
        }), o = e, i = p, m1.os.isOSX() || (a = au(!1), o.on("keydown", function(e) {
            $C(e) && WC(a, o, !0)
        }), o.on("keyup", function(e) {
            var t, n, r;
            !1 === e.isDefaultPrevented() && (r = e, eC([{
                keyCode: If.PAGE_UP,
                action: Z0(S0, t = o, !1, n = i)
            }, {
                keyCode: If.PAGE_DOWN,
                action: Z0(S0, t, !0, n)
            }], r)), $C(e) && a.get() && (WC(a, o, !1), o.nodeChanged())
        })), p
    }(Jy = Gy = Gy || {})[Jy.Up = -1] = "Up", Jy[Jy.Down = 1] = "Down";
    var JC = R(n0, Gy.Up, Ou, Bu),
        QC = R(n0, Gy.Down, Bu, Ou),
        ZC = Gn,
        e1 = Gs,
        t1 = function(e, t) {
            var n = e.selection.getRng(),
                r = e.getBody();
            if (t) {
                var o = cs.fromRangeEnd(n),
                    i = Zy(r, o);
                return Z(i.positions)
            }
            return o = cs.fromRangeStart(n), Q((i = Qy(r, o)).positions)
        },
        n1 = R(x0, !0),
        r1 = R(x0, !1),
        o1 = function(e) {
            return U(A(e.selection.getSelectedBlocks(), Et.fromDom), function(e) {
                return !L0(e) && !Ot(e).exists(L0) && hr(e, function(e) {
                    return Yn(e.dom) || Gn(e.dom)
                }).exists(function(e) {
                    return Yn(e.dom)
                })
            })
        },
        i1 = Gn,
        a1 = R(oC, function(e) {
            return e.bottom
        }, function(e, t) {
            return e.y < t
        }),
        u1 = R(oC, function(e) {
            return e.top
        }, function(e, t) {
            return e.y > t
        }),
        s1 = R(iC, Qy),
        c1 = R(iC, Zy),
        l1 = function(e, t) {
            return n = cs.after(t), !!Kn(n.getNode()) || tf(e, cs.after(t)).map(function(e) {
                return Kn(e.getNode())
            }).getOr(!1);
            var n
        },
        f1 = ir([{
            br: []
        }, {
            block: []
        }, {
            none: []
        }]),
        d1 = dt().browser,
        m1 = dt(),
        g1 = R(KC, wo),
        p1 = R(KC, " "),
        h1 = (v1.prototype.nodeChanged = function(e) {
            var t, n, r, o = this.editor.selection;
            this.editor.initialized && o && !this.editor.getParam("disable_nodechange") && !this.editor.mode.isReadOnly() && (r = this.editor.getBody(), (t = o.getStart(!0) || r).ownerDocument === this.editor.getDoc() && this.editor.dom.isChildOf(t, r) || (t = r), n = [], this.editor.dom.getParent(t, function(e) {
                return e === r || void n.push(e)
            }), (e = e || {}).element = t, e.parents = n, this.editor.fire("NodeChange", e))
        }, v1.prototype.isSameElementPath = function(e) {
            var t, n = this.editor.$(e).parentsUntil(this.editor.getBody()).add(e);
            if (n.length === this.lastPath.length) {
                for (t = n.length; 0 <= t && n[t] === this.lastPath[t]; t--);
                if (-1 === t) return this.lastPath = n, !0
            }
            return this.lastPath = n, !1
        }, v1);

    function v1(r) {
        var o;
        this.lastPath = [], this.editor = r;
        var t = this;
        "onselectionchange" in r.getDoc() || r.on("NodeChange click mouseup keyup focus", function(e) {
            var t = r.selection.getRng(),
                n = {
                    startContainer: t.startContainer,
                    startOffset: t.startOffset,
                    endContainer: t.endContainer,
                    endOffset: t.endOffset
                };
            "nodechange" !== e.type && kf(n, o) || r.fire("SelectionChange"), o = n
        }), r.on("contextmenu", function() {
            r.fire("SelectionChange")
        }), r.on("SelectionChange", function() {
            var e = r.selection.getStart(!0);
            !e || !xt.range && r.selection.isCollapsed() || Pl(r) && !t.isSameElementPath(e) && r.dom.isChildOf(e, r.getBody()) && r.nodeChanged({
                selectionChange: !0
            })
        }), r.on("mouseup", function(e) {
            !e.isDefaultPrevented() && Pl(r) && ("IMG" === r.selection.getNode().nodeName ? Ar.setEditorTimeout(r, function() {
                r.nodeChanged()
            }) : r.nodeChanged())
        })
    }

    function b1(e) {
        return Hn(e) && po(Et.fromDom(e))
    }

    function y1(e) {
        var t = e.getBoundingClientRect(),
            n = e.ownerDocument,
            r = n.documentElement,
            o = n.defaultView;
        return {
            top: t.top + o.pageYOffset - r.clientTop,
            left: t.left + o.pageXOffset - r.clientLeft
        }
    }

    function C1(e) {
        e && e.parentNode && e.parentNode.removeChild(e)
    }

    function x1(e, S) {
        var N = Ar.throttle(function(e, t) {
            S._selectionOverrides.hideFakeCaret(), S.selection.placeCaretAt(e, t)
        }, 0);
        return S.on("remove", N.stop),
            function(w) {
                return e.on(function(e) {
                    var t, n, r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y, C, x = Math.max(Math.abs(w.screenX - e.screenX), Math.abs(w.screenY - e.screenY));
                    if (!e.dragging && 10 < x) {
                        if (S.fire("dragstart", {
                                target: e.element
                            }).isDefaultPrevented()) return;
                        e.dragging = !0, S.focus()
                    }
                    e.dragging && (d = e, t = {
                        pageX: (p = w, h = (g = S).inline ? y1(g.getBody()) : {
                            left: 0,
                            top: 0
                        }, C = (y = g).getBody(), v = y.inline ? {
                            left: C.scrollLeft,
                            top: C.scrollTop
                        } : {
                            left: 0,
                            top: 0
                        }, (m = {
                            pageX: (b = function(e, t) {
                                if (t.target.ownerDocument === e.getDoc()) return {
                                    left: t.pageX,
                                    top: t.pageY
                                };
                                var n, r, o, i, a, u = y1(e.getContentAreaContainer()),
                                    s = (r = (n = e).getBody(), o = n.getDoc().documentElement, i = {
                                        left: r.scrollLeft,
                                        top: r.scrollTop
                                    }, a = {
                                        left: r.scrollLeft || o.scrollLeft,
                                        top: r.scrollTop || o.scrollTop
                                    }, n.inline ? i : a);
                                return {
                                    left: t.pageX - u.left + s.left,
                                    top: t.pageY - u.top + s.top
                                }
                            }(g, p)).left - h.left + v.left,
                            pageY: b.top - h.top + v.top
                        }).pageX - d.relX),
                        pageY: m.pageY + 5
                    }, l = e.ghost, f = S.getBody(), l.parentNode !== f && f.appendChild(l), n = e.ghost, o = e.width, i = e.height, a = e.maxX, u = e.maxY, c = s = 0, n.style.left = (r = t).pageX + "px", n.style.top = r.pageY + "px", u < r.pageY + i && (c = r.pageY + i - u), n.style.width = o - (s = a < r.pageX + o ? r.pageX + o - a : s) + "px", n.style.height = i - c + "px", N(w.clientX, w.clientY))
                })
            }
    }

    function w1(e) {
        function t(e) {
            var t, n, r, o, i, a;
            0 === e.button && (t = M(c.dom.getParents(e.target), function() {
                for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
                return function(e) {
                    for (var t = 0; t < n.length; t++)
                        if (n[t](e)) return !0;
                    return !1
                }
            }(K1, X1)).getOr(null), i = c.getBody(), K1(a = t) && a !== i && (n = c.dom.getPos(t), r = c.getBody(), o = c.getDoc().documentElement, u.set({
                element: t,
                dragging: !1,
                screenX: e.screenX,
                screenY: e.screenY,
                maxX: (c.inline ? r.scrollWidth : o.offsetWidth) - 2,
                maxY: (c.inline ? r.scrollHeight : o.offsetHeight) - 2,
                relX: e.pageX - n.x,
                relY: e.pageY - n.y,
                width: t.offsetWidth,
                height: t.offsetHeight,
                ghost: function(e, t, n) {
                    var r = c.dom,
                        o = e.cloneNode(!0);
                    r.setStyles(o, {
                        width: t,
                        height: n
                    }), r.setAttrib(o, "data-mce-selected", null);
                    var i = r.create("div", {
                        class: "mce-drag-container",
                        "data-mce-bogus": "all",
                        unselectable: "on",
                        contenteditable: "false"
                    });
                    return r.setStyles(i, {
                        position: "absolute",
                        opacity: .5,
                        overflow: "hidden",
                        border: 0,
                        padding: 0,
                        margin: 0,
                        width: t,
                        height: n
                    }), r.setStyles(o, {
                        margin: 0,
                        boxSizing: "border-box"
                    }), i.appendChild(o), i
                }(t, t.offsetWidth, t.offsetHeight)
            })))
        }

        function n(u) {
            i.on(function(e) {
                var t, n, r, o, i, a;
                e.dragging && ((o = 3 === (a = (r = s).selection.getSel().getRangeAt(0).startContainer).nodeType ? a.parentNode : a) === (i = e.element) || r.dom.isChildOf(o, i) || K1(o) || ((n = e.element.cloneNode(!0)).removeAttribute("data-mce-selected"), t = n, s.fire("drop", {
                    clientX: u.clientX,
                    clientY: u.clientY
                }).isDefaultPrevented() || s.undoManager.transact(function() {
                    C1(e.element), s.insertContent(s.dom.getOuterHTML(t)), s._selectionOverrides.hideFakeCaret()
                })), s.fire("dragend"))
            }), Y1(i)
        }
        var r, o, i, s, u, c, a = du(),
            l = eu.DOM,
            f = document,
            d = x1(u = a, c = e),
            m = (r = i = a, function() {
                r.on(function(e) {
                    e.dragging && o.fire("dragend")
                }), Y1(r)
            });
        (o = s = e).on("mousedown", t), e.on("mousemove", d), e.on("mouseup", n), l.bind(f, "mousemove", d), l.bind(f, "mouseup", m), e.on("remove", function() {
            l.unbind(f, "mousemove", d), l.unbind(f, "mouseup", m)
        }), e.on("keydown", function(e) {
            e.keyCode === If.ESC && m()
        })
    }

    function S1(e) {
        var n, i;

        function a(e) {
            var t;
            e.isDefaultPrevented() || (t = e.dataTransfer) && (T(t.types, "Files") || 0 < t.files.length) && (e.preventDefault(), "drop" === e.type && Qv(i, "Dropped file type is not supported"))
        }

        function u(e) {
            pd(i, e.target) && a(e)
        }

        function t() {
            var t = eu.DOM,
                n = i.dom,
                r = document,
                o = i.inline ? i.getBody() : i.getDoc(),
                e = ["drop", "dragover"];
            Y(e, function(e) {
                t.bind(r, e, u), n.bind(o, e, a)
            }), i.on("remove", function() {
                Y(e, function(e) {
                    t.unbind(r, e, u), n.unbind(o, e, a)
                })
            })
        }
        w1(e), (n = e).on("drop", function(e) {
            var t = void 0 !== e.clientX ? n.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
            !K1(t) && "false" !== n.dom.getContentEditableParent(t) || e.preventDefault()
        }), e.getParam("block_unsupported_drop", !0, "boolean") && (i = e).on("init", function() {
            Ar.setEditorTimeout(i, t, 0)
        })
    }

    function N1(e, t) {
        return bf(e.getBody(), t)
    }

    function E1(l) {
        function f(e) {
            return e !== x && (J1(e) || Qn(e)) && y.isChildOf(e, x)
        }

        function c(e) {
            return rp(e) || op(e) || Zg(e) || ep(e)
        }

        function d(e) {
            e && b.setRng(e)
        }

        function m(e, t, n, r) {
            return void 0 === r && (r = !0), l.fire("ShowCaret", {
                target: t,
                direction: e,
                before: n
            }).isDefaultPrevented() ? null : (r && b.scrollIntoView(t, -1 === e), i.show(n, t))
        }

        function t(e) {
            return Mr(e) || Ao(e) || Ro(e)
        }

        function g(e) {
            return t(e.startContainer) || t(e.endContainer)
        }

        function p(e, t) {
            if (!e) return null;
            if (e.collapsed) {
                if (!g(e)) {
                    var n = t ? 1 : -1,
                        r = oc(n, x, e),
                        o = r.getNode(!t);
                    if (Xs(o)) return m(n, o, !!t && !r.isAtEnd(), !1);
                    var i = r.getNode(t);
                    if (Xs(i)) return m(n, i, !t && !r.isAtEnd(), !1)
                }
                return null
            }
            var a = e.startContainer,
                u = e.startOffset,
                s = e.endOffset;
            if (3 === a.nodeType && 0 === u && J1(a.parentNode) && (a = a.parentNode, u = y.nodeIndex(a), a = a.parentNode), 1 !== a.nodeType) return null;
            if (s === u + 1 && a === e.endContainer) {
                var c = a.childNodes[u];
                if (f(c)) return function(e) {
                    var t = e.cloneNode(!0),
                        n = l.fire("ObjectSelected", {
                            target: e,
                            targetClone: t
                        });
                    if (n.isDefaultPrevented()) return null;
                    var r = function(e, t, n) {
                            var r = l.$,
                                o = br(Et.fromDom(l.getBody()), "#" + w).fold(function() {
                                    return r([])
                                }, function(e) {
                                    return r([e.dom])
                                });
                            0 === o.length && (o = r('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr("id", w)).appendTo(l.getBody());
                            var i = y.createRng();
                            t === n && xt.ie ? (o.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xa0</p>').append(t), i.setStartAfter(o[0].firstChild.firstChild), i.setEndAfter(t)) : (o.empty().append(wo).append(t).append(wo), i.setStart(o[0].firstChild, 1), i.setEnd(o[0].lastChild, 0)), o.css({
                                top: y.getPos(e, l.getBody()).y
                            }), o[0].focus();
                            var a = b.getSel();
                            return a.removeAllRanges(), a.addRange(i), i
                        }(e, n.targetClone, t),
                        o = Et.fromDom(e);
                    return Y(yu(Et.fromDom(l.getBody()), "*[data-mce-selected]"), function(e) {
                        je(o, e) || Cn(e, S)
                    }), y.getAttrib(e, S) || e.setAttribute(S, "1"), v = e, N(), r
                }(c)
            }
            return null
        }

        function h() {
            v && v.removeAttribute(S), br(Et.fromDom(l.getBody()), "#" + w).each(In), v = null
        }
        var v, n, e, o, b = l.selection,
            y = l.dom,
            C = y.isBlock,
            x = l.getBody(),
            i = Ws(l, x, C, function() {
                return Cd(l)
            }),
            w = "sel-" + y.uniqueId(),
            S = "data-mce-selected",
            r = b.getRng,
            N = function() {
                i.hide()
            };
        return xt.ceFalse && !hh(l) && (l.on("mouseup", function(e) {
            var t = r();
            t.collapsed && Nv(l, e.clientX, e.clientY) && Ub(l, t, !1).each(d)
        }), l.on("click", function(e) {
            var t = N1(l, e.target);
            t && (J1(t) && (e.preventDefault(), l.focus()), G1(t) && y.isChildOf(t, b.getNode()) && h())
        }), l.on("blur NewBlock", h), l.on("ResizeWindow FullscreenStateChanged", i.reposition), l.on("tap", function(e) {
            var t = e.target,
                n = N1(l, t);
            J1(n) ? (e.preventDefault(), Fb(l, n).each(p)) : f(t) && Fb(l, t).each(p)
        }, !0), l.on("mousedown", function(e) {
            var t, n, r, o, i, a, u, s = e.target;
            s !== x && "HTML" !== s.nodeName && !y.isChildOf(s, x) || !1 === Nv(l, e.clientX, e.clientY) || ((t = N1(l, s)) ? J1(t) ? (e.preventDefault(), Fb(l, t).each(p)) : (h(), G1(t) && e.shiftKey || yf(e.clientX, e.clientY, b.getRng()) || (N(), b.placeCaretAt(e.clientX, e.clientY))) : f(s) ? Fb(l, s).each(p) : !1 === Xs(s) && (h(), N(), (n = f0(x, e.clientX, e.clientY)) && (r = s, o = n.node, a = y.getParent(r, C), u = y.getParent(o, C), !K(a) && (r !== u && y.isChildOf(a, u) && !1 === J1(N1(l, a)) || !y.isChildOf(u, a) && (i = u, y.getParent(a, C) !== y.getParent(i, C)) && function(e) {
                var t = e.firstChild;
                if (!K(t)) {
                    var n = cs.before(t);
                    if (Kn(n.getNode()) && 1 === e.childNodes.length) return !c(n);
                    var r = Mc(e).next(n);
                    return r && !c(r)
                }
            }(a)) || (e.preventDefault(), d(m(1, n.node, n.before, !1)), l.getBody().focus()))))
        }), l.on("keypress", function(e) {
            If.modifierPressed(e) || J1(b.getNode()) && e.preventDefault()
        }), l.on("GetSelectionRange", function(e) {
            var t = e.range;
            v && (v.parentNode ? ((t = t.cloneRange()).selectNode(v), e.range = t) : v = null)
        }), l.on("SetSelectionRange", function(e) {
            var t, n, r, o, i, a, u;
            e.range = (t = e.range, n = l.schema.getShortEndedElements(), r = y.createRng(), o = t.startContainer, i = t.startOffset, a = t.endContainer, u = t.endOffset, Ee(n, o.nodeName.toLowerCase()) ? 0 === i ? r.setStartBefore(o) : r.setStartAfter(o) : r.setStart(o, i), Ee(n, a.nodeName.toLowerCase()) ? 0 === u ? r.setEndBefore(a) : r.setEndAfter(a) : r.setEnd(a, u), r);
            var s = p(e.range, e.forward);
            s && (e.range = s)
        }), l.on("AfterSetSelectionRange", function(e) {
            var t = e.range,
                n = t.startContainer.parentNode;
            g(t) || "mcepastebin" === n.id || N(), y.hasClass(n, "mce-offscreen-selection") || h()
        }), l.on("copy", function(e) {
            var t, n, r = e.clipboardData;
            e.isDefaultPrevented() || !e.clipboardData || xt.ie || (t = (n = y.get(w)) && n.getElementsByTagName("*")[0]) && (e.preventDefault(), r.clearData(), r.setData("text/html", t.outerHTML), r.setData("text/plain", t.outerText || t.innerText))
        }), S1(l), e = mu(function() {
            var e, t;
            n.removed || !n.getBody().contains(document.activeElement) || (e = n.selection.getRng()).collapsed && (t = zb(n, e, !1), n.selection.setRng(t))
        }, 0), (n = l).on("focus", function() {
            e.throttle()
        }), n.on("blur", function() {
            e.cancel()
        }), (o = l).on("init", function() {
            o.on("focusin", function(e) {
                var t, n, r = e.target;
                Qn(r) && (t = bf(o.getBody(), r), n = Gn(t) ? t : r, o.selection.getNode() !== n && Fb(o, n).each(function(e) {
                    return o.selection.setRng(e)
                }))
            })
        })), {
            showCaret: m,
            showBlockCaretContainer: function(e) {
                e.hasAttribute("data-mce-caret") && (Hr(e), d(r()), b.scrollIntoView(e))
            },
            hideFakeCaret: N,
            destroy: function() {
                i.destroy(), v = null
            }
        }
    }

    function k1(a) {
        function e(e, t) {
            try {
                a.getDoc().execCommand(e, !1, t)
            } catch (e) {}
        }

        function u(e) {
            return e.isDefaultPrevented()
        }

        function t() {
            a.shortcuts.add("meta+a", null, "SelectAll")
        }

        function n() {
            a.inline || b.bind(a.getDoc(), "mousedown mouseup", function(e) {
                var t;
                e.target === a.getDoc().documentElement && (t = y.getRng(), a.getBody().focus(), "mousedown" === e.type ? Mr(t.startContainer) || y.placeCaretAt(e.clientX, e.clientY) : y.setRng(t))
            })
        }

        function r() {
            Range.prototype.getClientRects || a.on("mousedown", function(e) {
                var t;
                u(e) || "HTML" !== e.target.nodeName || ((t = a.getBody()).blur(), Ar.setEditorTimeout(a, function() {
                    t.focus()
                }))
            })
        }

        function o() {
            a.on("click", function(e) {
                var t = e.target;
                /^(IMG|HR)$/.test(t.nodeName) && "false" !== b.getContentEditableParent(t) && (e.preventDefault(), a.selection.select(t), a.nodeChanged()), "A" === t.nodeName && b.hasClass(t, "mce-item-anchor") && (e.preventDefault(), y.select(t))
            })
        }

        function i() {
            a.on("keydown", function(e) {
                if (!u(e) && e.keyCode === h && y.isCollapsed() && 0 === y.getRng().startOffset) {
                    var t = y.getNode().previousSibling;
                    if (t && t.nodeName && "table" === t.nodeName.toLowerCase()) return e.preventDefault(), !1
                }
            })
        }

        function s() {
            a.getParam("readonly") || a.on("BeforeExecCommand mousedown", function() {
                e("StyleWithCSS", !1), e("enableInlineTableEditing", !1), Ps(a) || e("enableObjectResizing", !1)
            })
        }

        function c() {
            a.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}")
        }

        function l() {
            a.inline || a.on("keydown", function() {
                document.activeElement === document.body && a.getWin().focus()
            })
        }

        function f() {
            a.inline || (a.contentStyles.push("body {min-height: 150px}"), a.on("click", function(e) {
                var t;
                "HTML" === e.target.nodeName && (11 < xt.ie ? a.getBody().focus() : (t = a.selection.getRng(), a.getBody().focus(), a.selection.setRng(t), a.selection.normalize(), a.nodeChanged()))
            }))
        }

        function d() {
            xt.mac && a.on("keydown", function(e) {
                !If.metaKeyPressed(e) || e.shiftKey || 37 !== e.keyCode && 39 !== e.keyCode || (e.preventDefault(), a.selection.getSel().modify("move", 37 === e.keyCode ? "backward" : "forward", "lineboundary"))
            })
        }

        function m() {
            a.on("click", function(e) {
                var t = e.target;
                do {
                    if ("A" === t.tagName) return void e.preventDefault()
                } while (t = t.parentNode)
            }), a.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}")
        }

        function g() {
            a.on("init", function() {
                a.dom.bind(a.getBody(), "submit", function(e) {
                    e.preventDefault()
                })
            })
        }
        var p = Nt.each,
            h = If.BACKSPACE,
            v = If.DELETE,
            b = a.dom,
            y = a.selection,
            C = a.parser,
            x = xt.gecko,
            w = xt.ie,
            S = xt.webkit,
            N = "data:text/mce-internal,",
            E = w ? "Text" : "URL",
            k = te;
        return hh(a) ? (S && (n(), o(), g(), t(), xt.iOS && (l(), f(), m())), x && (r(), s(), c(), d())) : (a.on("keydown", function(e) {
            if (!u(e) && e.keyCode === If.BACKSPACE) {
                var t, n = (t = y.getRng()).startContainer,
                    r = t.startOffset,
                    o = b.getRoot(),
                    i = n;
                if (t.collapsed && 0 === r) {
                    for (; i && i.parentNode && i.parentNode.firstChild === i && i.parentNode !== o;) i = i.parentNode;
                    "BLOCKQUOTE" === i.tagName && (a.formatter.toggle("blockquote", null, i), (t = b.createRng()).setStart(n, 0), t.setEnd(n, 0), y.setRng(t))
                }
            }
        }), a.on("keydown", function(e) {
            var t, n, r, o, i = e.keyCode;
            u(e) || i !== v && i !== h || (t = a.selection.isCollapsed(), n = a.getBody(), t && !b.isEmpty(n) || !t && (r = R(a.selection.getRng()), (o = b.createRng()).selectNode(a.getBody()), r !== R(o)) || (e.preventDefault(), a.setContent(""), n.firstChild && b.isBlock(n.firstChild) ? a.selection.setCursorLocation(n.firstChild, 0) : a.selection.setCursorLocation(n, 0), a.nodeChanged()))
        }), xt.windowsPhone || a.on("keyup focusin mouseup", function(e) {
            If.modifierPressed(e) || y.normalize()
        }, !0), S && (n(), o(), ks(a) && a.on("init", function() {
            e("DefaultParagraphSeparator", ks(a))
        }), g(), i(), C.addNodeFilter("br", function(e) {
            for (var t = e.length; t--;) "Apple-interchange-newline" === e[t].attr("class") && e[t].remove()
        }), xt.iOS ? (l(), f(), m()) : t()), 11 <= xt.ie && (f(), i()), xt.ie && (t(), e("AutoUrlDetect", !1), a.on("dragstart", function(e) {
            var t, n, r;
            (t = e).dataTransfer && (a.selection.isCollapsed() && "IMG" === t.target.tagName && y.select(t.target), 0 < (n = a.selection.getContent()).length && (r = N + escape(a.id) + "," + escape(n), t.dataTransfer.setData(E, r)))
        }), a.on("drop", function(e) {
            var t, n, r, o;
            u(e) || (t = e.dataTransfer && (o = e.dataTransfer.getData(E)) && 0 <= o.indexOf(N) ? (o = o.substr(N.length).split(","), {
                id: unescape(o[0]),
                html: unescape(o[1])
            }) : null) && t.id !== a.id && (e.preventDefault(), n = Ef(e.x, e.y, a.getDoc()), y.setRng(n), r = t.html, a.queryCommandSupported("mceInsertClipboardContent") ? a.execCommand("mceInsertClipboardContent", !1, {
                content: r,
                internal: !0
            }) : a.execCommand("mceInsertContent", !1, r))
        })), x && (a.on("keydown", function(e) {
            if (!u(e) && e.keyCode === h && a.getBody().getElementsByTagName("hr").length && y.isCollapsed() && 0 === y.getRng().startOffset) {
                var t = y.getNode(),
                    n = t.previousSibling;
                if ("HR" === t.nodeName) return b.remove(t), void e.preventDefault();
                n && n.nodeName && "hr" === n.nodeName.toLowerCase() && (b.remove(n), e.preventDefault())
            }
        }), r(), a.on("keypress", function(e) {
            var t;
            if (!u(e) && (8 === e.keyCode || 46 === e.keyCode) && A()) return t = _(), a.getDoc().execCommand("delete", !1, null), t(), e.preventDefault(), !1
        }), b.bind(a.getDoc(), "cut", function(e) {
            var t;
            !u(e) && A() && (t = _(), Ar.setEditorTimeout(a, function() {
                t()
            }))
        }), s(), a.on("SetContent ExecCommand", function(e) {
            "setcontent" !== e.type && "mceInsertLink" !== e.command || p(b.select("a"), function(e) {
                var t = e.parentNode,
                    n = b.getRoot();
                if (t.lastChild === e) {
                    for (; t && !b.isBlock(t);) {
                        if (t.parentNode.lastChild !== t || t === n) return;
                        t = t.parentNode
                    }
                    b.add(t, "br", {
                        "data-mce-bogus": 1
                    })
                }
            })
        }), c(), d(), i())), {
            refreshContentEditable: k,
            isHidden: function() {
                if (!x || a.removed) return !1;
                var e = a.selection.getSel();
                return !e || !e.rangeCount || 0 === e.rangeCount
            }
        };

        function _() {
            var e = b.getAttribs(y.getStart().cloneNode(!1));
            return function() {
                var t = y.getStart();
                t !== a.getBody() && (b.setAttrib(t, "style", null), p(e, function(e) {
                    t.setAttributeNode(e.cloneNode(!0))
                }))
            }
        }

        function A() {
            return !y.isCollapsed() && b.getParent(y.getStart(), b.isBlock) !== b.getParent(y.getEnd(), b.isBlock)
        }

        function R(e) {
            var t = b.create("body"),
                n = e.cloneContents();
            return t.appendChild(n), y.serializer.serialize(t, {
                format: "html"
            })
        }
    }

    function _1(e) {
        return ae(e, function(e) {
            return !1 === b(e)
        })
    }

    function A1(e) {
        var t = e.settings;
        return _1({
            block_elements: t.block_elements,
            boolean_attributes: t.boolean_attributes,
            custom_elements: t.custom_elements,
            extended_valid_elements: t.extended_valid_elements,
            invalid_elements: t.invalid_elements,
            invalid_styles: t.invalid_styles,
            move_caret_before_on_enter_elements: t.move_caret_before_on_enter_elements,
            non_empty_elements: t.non_empty_elements,
            schema: t.schema,
            self_closing_elements: t.self_closing_elements,
            short_ended_elements: t.short_ended_elements,
            special: t.special,
            text_block_elements: t.text_block_elements,
            text_inline_elements: t.text_inline_elements,
            valid_children: t.valid_children,
            valid_classes: t.valid_classes,
            valid_elements: t.valid_elements,
            valid_styles: t.valid_styles,
            verify_html: t.verify_html,
            whitespace_elements: t.whitespace_elements,
            padd_empty_block_inline_children: t.format_empty_lines
        })
    }

    function R1(e) {
        var t = e.settings,
            n = e.editorUpload.blobCache;
        return _1({
            allow_conditional_comments: t.allow_conditional_comments,
            allow_html_data_urls: t.allow_html_data_urls,
            allow_svg_data_urls: t.allow_svg_data_urls,
            allow_html_in_named_anchor: t.allow_html_in_named_anchor,
            allow_script_urls: t.allow_script_urls,
            allow_unsafe_link_target: t.allow_unsafe_link_target,
            convert_fonts_to_spans: t.convert_fonts_to_spans,
            fix_list_elements: t.fix_list_elements,
            font_size_legacy_values: t.font_size_legacy_values,
            forced_root_block: t.forced_root_block,
            forced_root_block_attrs: t.forced_root_block_attrs,
            padd_empty_with_br: t.padd_empty_with_br,
            preserve_cdata: t.preserve_cdata,
            remove_trailing_brs: t.remove_trailing_brs,
            inline_styles: t.inline_styles,
            root_name: e.inline ? e.getElement().nodeName.toLowerCase() : void 0,
            validate: !0,
            blob_cache: n,
            document: e.getDoc(),
            images_dataimg_filter: t.images_dataimg_filter
        })
    }

    function D1(e) {
        var t, u, n;
        e.bindPendingEventDelegates(), e.initialized = !0, e.fire("Init"), e.focus(!0), n = (u = e).dom.getRoot(), u.inline || Pl(u) && u.selection.getStart(!0) !== n || rf(n).each(function(e) {
            var t, n, r, o, i = e.getNode(),
                a = cn(i) ? rf(i).getOr(e) : e;
            xt.browser.isIE() ? (t = u, n = a.toRange(), r = Et.fromDom(t.getBody()), o = (cd(t) ? ve.from(n) : ve.none()).map(ld).filter(sd(r)), t.bookmark = o.isSome() ? o : t.bookmark) : u.selection.setRng(a.toRange())
        }), e.nodeChanged({
            initial: !0
        }), e.execCallback("init_instance_callback", e), (t = e).settings.auto_focus && Ar.setEditorTimeout(t, function() {
            var e = !0 === t.settings.auto_focus ? t : t.editorManager.get(t.settings.auto_focus);
            e.destroyed || e.focus()
        }, 100)
    }

    function T1(e) {
        return (e.inline ? e.ui : e.dom).styleSheetLoader
    }

    function O1(e) {
        function t() {
            o.unloadAll(a), e.inline || e.ui.styleSheetLoader.unloadAll(i)
        }

        function n() {
            e.removed ? t() : e.on("remove", t)
        }
        var r, o = T1(e),
            i = Bs(e),
            a = e.contentCSS;
        0 < e.contentStyles.length && (r = "", Nt.each(e.contentStyles, function(e) {
            r += e + "\r\n"
        }), e.dom.addStyle(r));
        var u, s, c, l, f, d, m, g, p, h = _r.all((u = e, s = a, c = i, l = [new _r(function(e, t) {
            return T1(u).loadAll(s, e, t)
        })], u.inline ? l : l.concat([new _r(function(e, t) {
            return u.ui.styleSheetLoader.loadAll(c, e, t)
        })]))).then(n).catch(n);
        return e.settings.content_style && (d = (f = e).settings.content_style, m = Et.fromDom(f.getBody()), g = jt(Pn(m)), pn(p = Et.fromTag("style"), "type", "text/css"), Ln(p, Et.fromText(d)), Ln(g, p), f.on("remove", function() {
            In(p)
        })), h
    }

    function B1(e) {
        var t;
        !0 !== e.removed && (hh(t = e) || t.load({
            initial: !0,
            format: "html"
        }), t.startContent = t.getContent({
            format: "raw"
        }), D1(e))
    }

    function P1(t, e) {
        var n = t.settings,
            r = t.getElement(),
            o = t.getDoc();
        n.inline || (t.getElement().style.visibility = t.orgVisibility), e || t.inline || (o.open(), o.write(t.iframeHTML), o.close()), t.inline && (Q1.addClass(r, "mce-content-body"), t.contentDocument = o = document, t.contentWindow = window, t.bodyElement = r, t.contentAreaContainer = r);
        var u, i, a, s, c, l, f, d, m, g, p, h, v = t.getBody();
        v.disabled = !0, t.readonly = !!n.readonly, t.readonly || (t.inline && "static" === Q1.getStyle(v, "position", !0) && (v.style.position = "relative"), v.contentEditable = t.getParam("content_editable_state", !0)), v.disabled = !1, t.editorUpload = cb(t), t.schema = oo(A1(t)), t.dom = eu(o, {
            keep_values: !0,
            url_converter: t.convertURL,
            url_converter_scope: t,
            hex_colors: n.force_hex_style_colors,
            update_styles: !0,
            root_element: t.inline ? t.getBody() : null,
            collect: function() {
                return t.inline
            },
            schema: t.schema,
            contentCssCors: t.getParam("content_css_cors", !1, "boolean"),
            referrerPolicy: Ds(t),
            onSetAttrib: function(e) {
                t.fire("SetAttrib", e)
            }
        }), t.parser = ((i = cv(R1(u = t), u.schema)).addAttributeFilter("src,href,style,tabindex", function(e, t) {
            for (var n, r, o = e.length, i = u.dom, a = "data-mce-" + t; o--;)(r = (n = e[o]).attr(t)) && !n.attr(a) && 0 !== r.indexOf("data:") && 0 !== r.indexOf("blob:") && ("style" === t ? ((r = i.serializeStyle(i.parseStyle(r), n.name)).length || (r = null), n.attr(a, r), n.attr(t, r)) : "tabindex" === t ? (n.attr(a, r), n.attr(t, null)) : n.attr(a, u.convertURL(r, t, n.name)))
        }), i.addNodeFilter("script", function(e) {
            for (var t = e.length; t--;) {
                var n = e[t],
                    r = n.attr("type") || "no/type";
                0 !== r.indexOf("mce-") && n.attr("type", "mce-" + r)
            }
        }), u.settings.preserve_cdata && i.addNodeFilter("#cdata", function(e) {
            for (var t = e.length; t--;) {
                var n = e[t];
                n.type = 8, n.name = "#comment", n.value = "[CDATA[" + u.dom.encode(n.value) + "]]"
            }
        }), i.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(e) {
            for (var t = e.length, n = u.schema.getNonEmptyElements(); t--;) {
                var r = e[t];
                r.isEmpty(n) && 0 === r.getAll("br").length && (r.append(new jd("br", 1)).shortEnded = !0)
            }
        }), i), t.serializer = dv((s = (a = t).settings, _e(_e(_e({}, R1(a)), A1(a)), _1({
            url_converter: s.url_converter,
            url_converter_scope: s.url_converter_scope,
            element_format: s.element_format,
            entities: s.entities,
            entity_encoding: s.entity_encoding,
            indent: s.indent,
            indent_after: s.indent_after,
            indent_before: s.indent_before
        }))), t), t.selection = Fh(t.dom, t.getWin(), t.serializer, t), t.annotator = zl(t), t.formatter = mb(t), t.undoManager = pb(t), t._nodeChangeDispatcher = new h1(t), t._selectionOverrides = E1(t), m = t, g = du(), p = au(!1), h = gu(function(e) {
            m.fire("longpress", _e(_e({}, e), {
                type: "longpress"
            })), p.set(!0)
        }, 400), m.on("touchstart", function(n) {
            U0(n).each(function(e) {
                h.cancel();
                var t = {
                    x: e.clientX,
                    y: e.clientY,
                    target: n.target
                };
                h.throttle(n), p.set(!1), g.set(t)
            })
        }, !0), m.on("touchmove", function(e) {
            h.cancel(), U0(e).each(function(i) {
                g.on(function(e) {
                    var t = i,
                        n = e,
                        r = Math.abs(t.clientX - n.x),
                        o = Math.abs(t.clientY - n.y);
                    (5 < r || 5 < o) && (g.clear(), p.set(!1), m.fire("longpresscancel"))
                })
            })
        }, !0), m.on("touchend touchcancel", function(t) {
            h.cancel(), "touchcancel" !== t.type && g.get().filter(function(e) {
                return e.target.isEqualNode(t.target)
            }).each(function() {
                p.get() ? t.preventDefault() : m.fire("tap", _e(_e({}, t), {
                    type: "tap"
                }))
            })
        }, !0), (f = l = t).on("click", function(e) {
            f.dom.getParent(e.target, "details") && e.preventDefault()
        }), (d = l).parser.addNodeFilter("details", function(e) {
            Y(e, function(e) {
                e.attr("data-mce-open", e.attr("open")), e.attr("open", "open")
            })
        }), d.serializer.addNodeFilter("details", function(e) {
            Y(e, function(e) {
                var t = e.attr("data-mce-open");
                e.attr("open", X(t) ? t : null), e.attr("data-mce-open", null)
            })
        }), hh(t) || (c = t).on("click", function(e) {
            var t, n, r, o, i;
            3 <= e.detail && (r = (t = c).selection.getRng(), o = cs.fromRangeStart(r), i = cs.fromRangeEnd(r), !cs.isElementPosition(o) || b1(n = o.container()) && rf(n).each(function(e) {
                return r.setStart(e.container(), e.offset())
            }), !cs.isElementPosition(i) || b1(n = o.container()) && of(n).each(function(e) {
                return r.setEnd(e.container(), e.offset())
            }), t.selection.setRng(Cg(r)))
        });
        var b, y, C, x, w, S, N, E, k, _ = hh(b = t) ? au(null) : GC(b);
        k = _, (E = t).addCommand("delete", function() {
            var e, t = k;
            M0(e = E) || Gb(e, !1) || qb(e, !1) || k0(e, t, !1) || Bb(e, !1) || yg(e) || Jb(e, !1) || T0(e, !1) || Ib(e) || R0(e, !1) || (F0(e, "Delete"), Sb(e))
        }), E.addCommand("forwardDelete", function() {
            var e, t = k;
            Gb(e = E, !0) || qb(e, !0) || k0(e, t, !0) || Bb(e, !0) || yg(e) || Jb(e, !0) || T0(e, !0) || Ib(e) || R0(e, !0) || F0(e, "ForwardDelete")
        }), ks(y = t) && y.on("NodeChange", R(H0, y)), x = (C = t).dom, w = ks(C), S = C.getParam("placeholder", vc.getAttrib(C.getElement(), "placeholder"), "string"), N = function(e, t) {
            var n, r, o;
            ! function(e) {
                if (hb(e)) {
                    var t = e.keyCode;
                    return !vb(e) && (If.metaKeyPressed(e) || e.altKey || 112 <= t && t <= 123 || T(Ry, t))
                }
            }(e) && (n = C.getBody(), r = !(hb(o = e) && !(vb(o) || "keyup" === o.type && 229 === o.keyCode)) && function(e, t, n) {
                if (Kr(Et.fromDom(t), !1)) {
                    var r = "" === n,
                        o = t.firstElementChild;
                    return !o || !e.getStyle(t.firstElementChild, "padding-left") && !e.getStyle(t.firstElementChild, "padding-right") && (r ? !e.isBlock(o) : n === o.nodeName.toLowerCase())
                }
                return !1
            }(x, n, w), "" !== x.getAttrib(n, Dy) === r && !t || (x.setAttrib(n, Dy, r ? S : null), x.setAttrib(n, "aria-placeholder", r ? S : null), C.fire("PlaceholderToggle", {
                state: r
            }), C.on(r ? "keydown" : "keyup", N), C.off(r ? "keyup" : "keydown", N)))
        }, S && C.on("init", function(e) {
            N(e, !0), C.on("change SetContent ExecCommand", N), C.on("paste", function(e) {
                return Ar.setEditorTimeout(C, function() {
                    return N(e)
                })
            })
        });
        var A = vh(t);
        (function(t) {
            var e = t.settings,
                n = t.getDoc(),
                r = t.getBody();
            t.fire("PreInit"), e.browser_spellcheck || e.gecko_spellcheck || (n.body.spellcheck = !1, Q1.setAttrib(r, "spellcheck", "false")), t.quirks = k1(t), t.fire("PostRender");
            var o = t.getParam("directionality", lu.isRtl() ? "rtl" : void 0);
            void 0 !== o && (r.dir = o), e.protect && t.on("BeforeSetContent", function(t) {
                Nt.each(e.protect, function(e) {
                    t.content = t.content.replace(e, function(e) {
                        return "\x3c!--mce:protected " + escape(e) + "--\x3e"
                    })
                })
            }), t.on("SetContent", function() {
                t.addVisual(t.getBody())
            }), t.on("compositionstart compositionend", function(e) {
                t.composing = "compositionstart" === e.type
            })
        })(t), A.fold(function() {
            O1(t).then(function() {
                return B1(t)
            })
        }, function(e) {
            t.setProgressState(!0), O1(t).then(function() {
                e().then(function(e) {
                    t.setProgressState(!1), B1(t)
                }, function(e) {
                    t.notificationManager.open({
                        type: "error",
                        text: String(e)
                    }), B1(t)
                })
            })
        })
    }

    function L1(e, t) {
        var n, r, o, i, a = e.translate("Rich Text Area"),
            u = (n = e.id, r = a, t.height, o = e.getParam("iframe_attrs", {}), hn(i = Et.fromTag("iframe"), o), hn(i, {
                id: n + "_ifr",
                frameBorder: "0",
                allowTransparency: "true",
                title: r
            }), vu(i, "tox-edit-area__iframe"), i.dom);
        u.onload = function() {
            u.onload = null, e.fire("load")
        };
        var s = function(e, t) {
            if (document.domain !== window.location.hostname && xt.browser.isIE()) {
                var n = ob("mce");
                e[n] = function() {
                    P1(e)
                };
                var r = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinymce.get("' + e.id + '");document.write(ed.iframeHTML);document.close();ed.' + n + "(true);})()";
                return Z1.setAttrib(t, "src", r), !0
            }
            return !1
        }(e, u);
        return e.contentAreaContainer = t.iframeContainer, e.iframeElement = u, e.iframeHTML = function(e) {
            var t = e.getParam("doctype", "<!DOCTYPE html>") + "<html><head>";
            e.getParam("document_base_url", "") !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
            var n = Ns(e, "body_id", "tinymce"),
                r = Ns(e, "body_class", ""),
                o = e.translate(e.getParam("iframe_aria_text", "Rich Text Area. Press ALT-0 for help.", "string"));
            return Es(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + Es(e) + '" />'), t + ('</head><body id="' + n + '" class="mce-content-body ' + r + '" data-id="' + e.id) + '" aria-label="' + o + '"><br></body></html>'
        }(e), Z1.add(t.iframeContainer, u), s
    }

    function I1(e) {
        return e.replace(/^\-/, "")
    }

    function M1(e) {
        return {
            editorContainer: e,
            iframeContainer: e,
            api: {}
        }
    }

    function F1(e) {
        var t, n, r, o, i, a, u, s = e.getElement();
        return e.orgDisplay = s.style.display, X(Is(e)) ? e.theme.renderUI() : y(Is(e)) ? (n = (t = e).getElement(), (r = Is(t)(t, n)).editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || t.id + "_parent"), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || t.id + "_iframecontainer"), r.height = r.iframeHeight || n.offsetHeight, r) : (u = (o = e).getElement(), o.inline ? M1(null) : (i = u, a = ex.create("div"), ex.insertAfter(a, i), M1(a)))
    }

    function U1(e) {
        var n, t, r, o, i, a, u, s;
        e.fire("ScriptsLoaded"), n = e, t = Nt.trim(Rs(n)), r = n.ui.registry.getAll().icons, ne(_e(_e({}, Vv.get("default").icons), Vv.get(t).icons), function(e, t) {
            Ee(r, t) || n.ui.registry.addIcon(t, e)
        }), a = Is(o = e), X(a) ? (o.settings.theme = I1(a), i = Yv.get(a), o.theme = new i(o, Yv.urls[a]), o.theme.init && o.theme.init(o, Yv.urls[a] || o.documentBaseUrl.replace(/\/$/, ""), o.$)) : o.theme = {}, s = [], Nt.each(Fs(u = e).split(/[ ,]/), function(e) {
            tx(u, s, I1(e))
        });
        var c = F1(e),
            l = e,
            f = ve.from(c.api).getOr({}),
            d = {
                show: ve.from(f.show).getOr(te),
                hide: ve.from(f.hide).getOr(te),
                disable: ve.from(f.disable).getOr(te),
                isDisabled: ve.from(f.isDisabled).getOr(D),
                enable: function() {
                    l.mode.isReadOnly() || ve.from(f.enable).map(x)
                }
            };
        l.ui = _e(_e({}, l.ui), d);
        var m, g, p, h = {
            editorContainer: c.editorContainer,
            iframeContainer: c.iframeContainer
        };
        return e.editorContainer = h.editorContainer || null, nb(e), e.inline ? P1(e) : (p = L1(m = e, g = h), g.editorContainer && (Z1.get(g.editorContainer).style.display = m.orgDisplay, m.hidden = Z1.isHidden(g.editorContainer)), m.getElement().style.display = "none", Z1.setAttrib(m.id, "aria-hidden", "true"), void(p || P1(m)))
    }

    function z1(e) {
        return "-" === e.charAt(0)
    }

    function H1(t, e, n) {
        return ve.from(e).filter(function(e) {
            return 0 < e.length && !Vv.has(e)
        }).map(function(e) {
            return {
                url: t.editorManager.baseURL + "/icons/" + e + "/icons" + n + ".js",
                name: ve.some(e)
            }
        })
    }

    function j1(c, l) {
        var e, t, f = ou.ScriptLoader,
            n = f,
            r = l,
            o = function() {
                var r, o, t, n, e, i, a, u, s;
                e = f, u = Ts(i = c), s = i.getParam("language_url", "", "string"), !1 === lu.hasCode(u) && "en" !== u && (a = "" !== s ? s : i.editorManager.baseURL + "/langs/" + u + ".js", e.add(a, te, void 0, function() {
                    Zv(i, "LanguageLoadError", eb("language", a, u))
                })), t = f, Y(function(e) {
                    for (var t = [], n = function(e) {
                            t.push(e)
                        }, r = 0; r < e.length; r++) e[r].each(n);
                    return t
                }([H1(n = c, "default", l), ve.from(n.getParam("icons_url", "", "string")).filter(function(e) {
                    return 0 < e.length
                }).map(function(e) {
                    return {
                        url: e,
                        name: ve.none()
                    }
                }).orThunk(function() {
                    return H1(n, Rs(n), "")
                })]), function(e) {
                    t.add(e.url, te, void 0, function() {
                        Zv(n, "IconsLoadError", eb("icons", e.url, e.name.getOrUndefined()))
                    })
                }), r = c, o = l, Nt.each(r.getParam("external_plugins"), function(e, t) {
                    Xv.load(t, e, te, void 0, function() {
                        tb(r, e, t)
                    }), r.settings.plugins += " " + t
                }), Nt.each(Fs(r).split(/[ ,]/), function(e) {
                    var t, n;
                    (e = Nt.trim(e)) && !Xv.urls[e] && (z1(e) ? (e = e.substr(1, e.length), t = Xv.dependencies(e), Nt.each(t, function(e) {
                        var t = Xv.createUrl({
                            prefix: "plugins/",
                            resource: e,
                            suffix: "/plugin" + o + ".js"
                        }, e);
                        Xv.load(t.resource, t, te, void 0, function() {
                            tb(r, t.prefix + t.resource + t.suffix, t.resource)
                        })
                    })) : (n = {
                        prefix: "plugins/",
                        resource: e,
                        suffix: "/plugin" + o + ".js"
                    }, Xv.load(e, n, te, void 0, function() {
                        tb(r, n.prefix + n.resource + n.suffix, e)
                    })))
                }), f.loadQueue(function() {
                    c.removed || U1(c)
                }, c, function() {
                    c.removed || U1(c)
                })
            },
            i = Is(e = c);
        X(i) ? (z1(i) || Ee(Yv.urls, i) || ((t = e.getParam("theme_url")) ? Yv.load(i, e.documentBaseURI.toAbsolute(t)) : Yv.load(i, "themes/" + i + "/theme" + r + ".js")), n.loadQueue(function() {
            Yv.waitFor(i, o)
        })) : o()
    }

    function V1(a) {
        return function(i, e) {
            return ve.from(e).map(Et.fromDom).filter(_n).bind(function(e) {
                return n = a, t = i, r = e.dom, Tg(Et.fromDom(r), function(e) {
                    return Sn(t = e, n).orThunk(function() {
                        return "font" === kt(t) ? ue(rx, n).bind(function(e) {
                            return bn(t, e)
                        }) : ve.none()
                    });
                    var t
                }, function(e) {
                    return je(Et.fromDom(t), e)
                }).or((o = e.dom, ve.from(eu.DOM.getStyle(o, a, !0))));
                var n, t, r, o
            }).getOr("")
        }
    }

    function q1(e) {
        return rf(e.getBody()).map(function(e) {
            var t = e.container();
            return Vn(t) ? t.parentNode : t
        })
    }

    function $1(e, t) {
        return n = e, r = a(ve.some, t), o = n, ve.from(o.selection.getRng()).bind(function(e) {
            var t = o.getBody();
            return e.startContainer === t && 0 === e.startOffset ? ve.none() : ve.from(o.selection.getStart(!0))
        }).orThunk(R(q1, n)).map(Et.fromDom).filter(_n).bind(r);
        var n, r, o
    }

    function W1(e, t) {
        if (/^[0-9.]+$/.test(t)) {
            var n = parseInt(t, 10);
            if (1 <= n && n <= 7) {
                var r = Nt.explode(e.getParam("font_size_style_values", "xx-small,x-small,small,medium,large,x-large,xx-large")),
                    o = Nt.explode(e.getParam("font_size_classes", ""));
                return o ? o[n - 1] || t : r[n - 1] || t
            }
            return t
        }
        return t
    }
    var K1 = Gn,
        X1 = Yn,
        Y1 = function(e) {
            e.on(function(e) {
                C1(e.ghost)
            }), e.clear()
        },
        G1 = Yn,
        J1 = Gn,
        Q1 = eu.DOM,
        Z1 = eu.DOM,
        ex = eu.DOM,
        tx = function(t, n, r) {
            var o, i, a, u, e = Xv.get(r),
                s = Xv.urls[r] || t.documentBaseUrl.replace(/\/$/, "");
            if (r = Nt.trim(r), e && -1 === Nt.inArray(n, r) && (Nt.each(Xv.dependencies(r), function(e) {
                    tx(t, n, e)
                }), !t.plugins[r])) try {
                var c = new e(t, s, t.$);
                (t.plugins[r] = c).init && (c.init(t, s), n.push(r))
            } catch (e) {
                i = r, a = e, Cf(o = t, "PluginLoadError", {
                    message: u = lu.translate(["Failed to initialize plugin: {0}", i])
                }), wy(u, a), Qv(o, u)
            }
        },
        nx = eu.DOM,
        rx = {
            "font-size": "size",
            "font-family": "face"
        },
        ox = V1("font-size"),
        ix = i(function(e) {
            return e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",")
        }, V1("font-family")),
        ax = Nt.each,
        ux = Nt.map,
        sx = Nt.inArray,
        cx = (lx.prototype.execCommand = function(t, n, r, e) {
            var o, i, a = !1,
                u = this;
            if (!u.editor.removed) {
                if ("mcefocus" !== t.toLowerCase() && (/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(t) || e && e.skip_focus ? md(i = u.editor).each(function(e) {
                        return i.selection.setRng(e)
                    }) : u.editor.focus()), (e = u.editor.fire("BeforeExecCommand", {
                        command: t,
                        ui: n,
                        value: r
                    })).isDefaultPrevented()) return !1;
                var s = t.toLowerCase();
                if (o = u.commands.exec[s]) return o(s, n, r), u.editor.fire("ExecCommand", {
                    command: t,
                    ui: n,
                    value: r
                }), !0;
                if (ax(this.editor.plugins, function(e) {
                        if (e.execCommand && e.execCommand(t, n, r)) return u.editor.fire("ExecCommand", {
                            command: t,
                            ui: n,
                            value: r
                        }), !(a = !0)
                    }), a) return a;
                if (u.editor.theme && u.editor.theme.execCommand && u.editor.theme.execCommand(t, n, r)) return u.editor.fire("ExecCommand", {
                    command: t,
                    ui: n,
                    value: r
                }), !0;
                try {
                    a = u.editor.getDoc().execCommand(t, n, r)
                } catch (e) {}
                return !!a && (u.editor.fire("ExecCommand", {
                    command: t,
                    ui: n,
                    value: r
                }), !0)
            }
        }, lx.prototype.queryCommandState = function(e) {
            var t;
            if (!this.editor.quirks.isHidden() && !this.editor.removed) {
                if (e = e.toLowerCase(), t = this.commands.state[e]) return t(e);
                try {
                    return this.editor.getDoc().queryCommandState(e)
                } catch (e) {}
                return !1
            }
        }, lx.prototype.queryCommandValue = function(e) {
            var t;
            if (!this.editor.quirks.isHidden() && !this.editor.removed) {
                if (e = e.toLowerCase(), t = this.commands.value[e]) return t(e);
                try {
                    return this.editor.getDoc().queryCommandValue(e)
                } catch (e) {}
            }
        }, lx.prototype.addCommands = function(e, n) {
            void 0 === n && (n = "exec");
            var r = this;
            ax(e, function(t, e) {
                ax(e.toLowerCase().split(","), function(e) {
                    r.commands[n][e] = t
                })
            })
        }, lx.prototype.addCommand = function(e, o, i) {
            var a = this;
            e = e.toLowerCase(), this.commands.exec[e] = function(e, t, n, r) {
                return o.call(i || a.editor, t, n, r)
            }
        }, lx.prototype.queryCommandSupported = function(e) {
            if (e = e.toLowerCase(), this.commands.exec[e]) return !0;
            try {
                return this.editor.getDoc().queryCommandSupported(e)
            } catch (e) {}
            return !1
        }, lx.prototype.addQueryStateHandler = function(e, t, n) {
            var r = this;
            e = e.toLowerCase(), this.commands.state[e] = function() {
                return t.call(n || r.editor)
            }
        }, lx.prototype.addQueryValueHandler = function(e, t, n) {
            var r = this;
            e = e.toLowerCase(), this.commands.value[e] = function() {
                return t.call(n || r.editor)
            }
        }, lx.prototype.hasCustomCommand = function(e) {
            return e = e.toLowerCase(), !!this.commands.exec[e]
        }, lx.prototype.execNativeCommand = function(e, t, n) {
            return void 0 === t && (t = !1), void 0 === n && (n = null), this.editor.getDoc().execCommand(e, t, n)
        }, lx.prototype.isFormatMatch = function(e) {
            return this.editor.formatter.match(e)
        }, lx.prototype.toggleFormat = function(e, t) {
            this.editor.formatter.toggle(e, t), this.editor.nodeChanged()
        }, lx.prototype.storeSelection = function(e) {
            this.selectionBookmark = this.editor.selection.getBookmark(e)
        }, lx.prototype.restoreSelection = function() {
            this.editor.selection.moveToBookmark(this.selectionBookmark)
        }, lx.prototype.setupCommands = function(u) {
            var o = this;

            function e(r) {
                return function() {
                    var e = u.selection,
                        t = e.isCollapsed() ? [u.dom.getParent(e.getNode(), u.dom.isBlock)] : e.getSelectedBlocks(),
                        n = ux(t, function(e) {
                            return !!u.formatter.matchNode(e, r)
                        });
                    return -1 !== sx(n, !0)
                }
            }
            this.addCommands({
                "mceResetDesignMode,mceBeginUndoLevel": te,
                "mceEndUndoLevel,mceAddUndoLevel": function() {
                    u.undoManager.add()
                },
                mceFocus: function(e, t, n) {
                    var r, o;
                    o = n, (r = u).removed || (o ? zd : function(t) {
                        var e = t.selection,
                            n = t.getBody(),
                            r = e.getRng();
                        t.quirks.refreshContentEditable(), void 0 !== t.bookmark && !1 === Cd(t) && md(t).each(function(e) {
                            t.selection.setRng(e), r = e
                        });
                        var o, i, a = (o = t, i = e.getNode(), o.dom.getParent(i, function(e) {
                            return "true" === o.dom.getContentEditable(e)
                        }));
                        if (t.$.contains(n, a)) return yd(a), bd(t, r), zd(t);
                        t.inline || (xt.opera || yd(n), t.getWin().focus()), (xt.gecko || t.inline) && (yd(n), bd(t, r)), zd(t)
                    })(r)
                },
                "Cut,Copy,Paste": function(e) {
                    var t, n, r = u.getDoc();
                    try {
                        o.execNativeCommand(e)
                    } catch (e) {
                        t = !0
                    }!(t = "paste" === e && !r.queryCommandEnabled(e) || t) && r.queryCommandSupported(e) || (n = u.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead."), xt.mac && (n = n.replace(/Ctrl\+/g, "\u2318+")), u.notificationManager.open({
                        text: n,
                        type: "error"
                    }))
                },
                unlink: function() {
                    var e;
                    u.selection.isCollapsed() ? (e = u.dom.getParent(u.selection.getStart(), "a")) && u.dom.remove(e, !0) : u.formatter.remove("link")
                },
                "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone": function(e) {
                    var t = e.substring(7);
                    "full" === t && (t = "justify"), ax("left,center,right,justify".split(","), function(e) {
                        t !== e && u.formatter.remove("align" + e)
                    }), "none" !== t && o.toggleFormat("align" + t)
                },
                "InsertUnorderedList,InsertOrderedList": function(e) {
                    var t;
                    o.execNativeCommand(e);
                    var n = u.dom.getParent(u.selection.getNode(), "ol,ul");
                    n && (t = n.parentNode, /^(H[1-6]|P|ADDRESS|PRE)$/.test(t.nodeName) && (o.storeSelection(), u.dom.split(t, n), o.restoreSelection()))
                },
                "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(e) {
                    o.toggleFormat(e)
                },
                "ForeColor,HiliteColor": function(e, t, n) {
                    o.toggleFormat(e, {
                        value: n
                    })
                },
                FontName: function(e, t, n) {
                    var r, o;
                    o = W1(r = u, n), r.formatter.toggle("fontname", {
                        value: A(o.split(/\s*,\s*/), function(e) {
                            return -1 === e.indexOf(" ") || Ge(e, '"') || Ge(e, "'") ? e : "'" + e + "'"
                        }).join(",")
                    }), r.nodeChanged()
                },
                FontSize: function(e, t, n) {
                    var r;
                    (r = u).formatter.toggle("fontsize", {
                        value: W1(r, n)
                    }), r.nodeChanged()
                },
                LineHeight: function(e, t, n) {
                    var r;
                    (r = u).formatter.toggle("lineheight", {
                        value: String(n)
                    }), r.nodeChanged()
                },
                Lang: function(e, t, n) {
                    o.toggleFormat(e, {
                        value: n.code,
                        customValue: n.customCode
                    })
                },
                RemoveFormat: function(e) {
                    u.formatter.remove(e)
                },
                mceBlockQuote: function() {
                    o.toggleFormat("blockquote")
                },
                FormatBlock: function(e, t, n) {
                    return o.toggleFormat(n || "p")
                },
                mceCleanup: function() {
                    var e = u.selection.getBookmark();
                    u.setContent(u.getContent()), u.selection.moveToBookmark(e)
                },
                mceRemoveNode: function(e, t, n) {
                    var r = n || u.selection.getNode();
                    r !== u.getBody() && (o.storeSelection(), u.dom.remove(r, !0), o.restoreSelection())
                },
                mceSelectNodeDepth: function(e, t, n) {
                    var r = 0;
                    u.dom.getParent(u.selection.getNode(), function(e) {
                        if (1 === e.nodeType && r++ === n) return u.selection.select(e), !1
                    }, u.getBody())
                },
                mceSelectNode: function(e, t, n) {
                    u.selection.select(n)
                },
                mceInsertContent: function(e, t, n) {
                    var r, o, i, a;
                    r = u, o = function(e) {
                        if ("string" == typeof e) return {
                            content: e,
                            details: {}
                        };
                        var t = Nt.extend({
                            paste: e.paste,
                            data: {
                                paste: e.paste
                            }
                        }, e);
                        return {
                            content: e.content,
                            details: t
                        }
                    }(n), i = o.content, a = o.details, bh(r).editor.insertContent(i, a)
                },
                mceInsertRawHTML: function(e, t, n) {
                    u.selection.setContent("tiny_mce_marker");
                    var r = u.getContent();
                    u.setContent(r.replace(/tiny_mce_marker/g, function() {
                        return n
                    }))
                },
                mceInsertNewLine: function(e, t, n) {
                    VC(u, n)
                },
                mceToggleFormat: function(e, t, n) {
                    o.toggleFormat(n)
                },
                mceSetContent: function(e, t, n) {
                    u.setContent(n)
                },
                "Indent,Outdent": function(e) {
                    I0(u, e)
                },
                mceRepaint: te,
                InsertHorizontalRule: function() {
                    u.execCommand("mceInsertContent", !1, "<hr />")
                },
                mceToggleVisualAid: function() {
                    u.hasVisual = !u.hasVisual, u.addVisual()
                },
                mceReplaceContent: function(e, t, n) {
                    u.execCommand("mceInsertContent", !1, n.replace(/\{\$selection\}/g, u.selection.getContent({
                        format: "text"
                    })))
                },
                mceInsertLink: function(e, t, n) {
                    "string" == typeof n && (n = {
                        href: n
                    });
                    var r = u.dom.getParent(u.selection.getNode(), "a");
                    n.href = n.href.replace(/ /g, "%20"), r && n.href || u.formatter.remove("link"), n.href && u.formatter.apply("link", n, r)
                },
                selectAll: function() {
                    var e, t = u.dom.getParent(u.selection.getStart(), Yn);
                    t && ((e = u.dom.createRng()).selectNodeContents(t), u.selection.setRng(e))
                },
                mceNewDocument: function() {
                    u.setContent("")
                },
                InsertLineBreak: function(e, t, n) {
                    return TC(u, n), !0
                }
            }), o.addCommands({
                JustifyLeft: e("alignleft"),
                JustifyCenter: e("aligncenter"),
                JustifyRight: e("alignright"),
                JustifyFull: e("alignjustify"),
                "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(e) {
                    return o.isFormatMatch(e)
                },
                mceBlockQuote: function() {
                    return o.isFormatMatch("blockquote")
                },
                Outdent: function() {
                    return P0(u)
                },
                "InsertUnorderedList,InsertOrderedList": function(e) {
                    var t = u.dom.getParent(u.selection.getNode(), "ul,ol");
                    return t && ("insertunorderedlist" === e && "UL" === t.tagName || "insertorderedlist" === e && "OL" === t.tagName)
                }
            }, "state"), o.addCommands({
                Undo: function() {
                    u.undoManager.undo()
                },
                Redo: function() {
                    u.undoManager.redo()
                }
            }), o.addQueryValueHandler("FontName", function() {
                return $1(t = u, function(e) {
                    return ix(t.getBody(), e.dom)
                }).getOr("");
                var t
            }, this), o.addQueryValueHandler("FontSize", function() {
                return $1(t = u, function(e) {
                    return ox(t.getBody(), e.dom)
                }).getOr("");
                var t
            }, this), o.addQueryValueHandler("LineHeight", function() {
                return $1(t = u, function(n) {
                    var e = Et.fromDom(t.getBody());
                    return Tg(n, function(e) {
                        return Sn(e, "line-height")
                    }, R(je, e)).getOrThunk(function() {
                        var e = parseFloat(wn(n, "line-height")),
                            t = parseFloat(wn(n, "font-size"));
                        return String(e / t)
                    })
                }).getOr("");
                var t
            }, this)
        }, lx);

    function lx(e) {
        this.commands = {
            state: {},
            exec: {},
            value: {}
        }, this.editor = e, this.setupCommands(e)
    }

    function fx(e, t, n) {
        var r, o, i, a, u, s;
        bu(e, t) && !1 === n ? (o = t, hu(r = e) ? r.dom.classList.remove(o) : (u = o, 0 < (s = U(pu(a = r, "class"), function(e) {
            return e !== u
        })).length ? pn(a, "class", s.join(" ")) : Cn(a, "class")), 0 === (hu(i = r) ? i.dom.classList : pu(i, "class")).length && Cn(i, "class")) : n && vu(e, t)
    }

    function dx(e, t, n) {
        try {
            e.getDoc().execCommand(t, !1, String(n))
        } catch (e) {}
    }

    function mx(e, t) {
        e.dom.contentEditable = t ? "true" : "false"
    }

    function gx(e, t) {
        var n, r, o = Et.fromDom(e.getBody());
        fx(o, "mce-content-readonly", t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), ve.from(e.selection.getNode()).each(function(e) {
            e.removeAttribute("data-mce-selected")
        }), mx(o, !(e.readonly = !0)), Y(yu(o, '*[contenteditable="true"]'), function(e) {
            pn(e, vx, "true"), mx(e, !1)
        })) : (mx(o, !(e.readonly = !1)), Y(yu(o, "*[" + vx + '="true"]'), function(e) {
            Cn(e, vx), mx(e, !0)
        }), dx(e, "StyleWithCSS", !1), dx(e, "enableInlineTableEditing", !1), dx(e, "enableObjectResizing", !1), (Cd(n = e) || (r = n, od(Pn(Et.fromDom(r.getElement()))).filter(function(e) {
            return !(void 0 !== (t = e.dom.classList) && (t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body"))) && pd(r, e.dom);
            var t
        }).isSome())) && e.focus(), e.selection.setRng(e.selection.getRng()), e.nodeChanged())
    }

    function px(e) {
        return e.readonly
    }

    function hx(t) {
        t.parser.addAttributeFilter("contenteditable", function(e) {
            px(t) && Y(e, function(e) {
                e.attr(vx, e.attr("contenteditable")), e.attr("contenteditable", "false")
            })
        }), t.serializer.addAttributeFilter(vx, function(e) {
            px(t) && Y(e, function(e) {
                e.attr("contenteditable", e.attr(vx))
            })
        }), t.serializer.addTempAttr(vx)
    }
    var vx = "data-mce-contenteditable",
        bx = Nt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " "),
        yx = (Cx.isNative = function(e) {
            return !!bx[e.toLowerCase()]
        }, Cx.prototype.fire = function(e, t) {
            var n = e.toLowerCase(),
                r = so(n, t || {}, this.scope);
            this.settings.beforeFire && this.settings.beforeFire(r);
            var o = this.bindings[n];
            if (o)
                for (var i = 0, a = o.length; i < a; i++) {
                    var u = o[i];
                    if (!u.removed) {
                        if (u.once && this.off(n, u.func), r.isImmediatePropagationStopped()) return r;
                        if (!1 === u.func.call(this.scope, r)) return r.preventDefault(), r
                    }
                }
            return r
        }, Cx.prototype.on = function(e, t, n, r) {
            if (t = !1 === t ? D : t) {
                var o = {
                    func: t,
                    removed: !1
                };
                r && Nt.extend(o, r);
                for (var i = e.toLowerCase().split(" "), a = i.length; a--;) {
                    var u = i[a],
                        s = this.bindings[u];
                    s || (s = [], this.toggleEvent(u, !0)), s = n ? Ae([o], s, !0) : Ae(Ae([], s, !0), [o], !1), this.bindings[u] = s
                }
            }
            return this
        }, Cx.prototype.off = function(e, t) {
            var n = this;
            if (e)
                for (var r = e.toLowerCase().split(" "), o = r.length; o--;) {
                    var i, a = r[o],
                        u = this.bindings[a];
                    if (!a) return ne(this.bindings, function(e, t) {
                        n.toggleEvent(t, !1), delete n.bindings[t]
                    }), this;
                    u && (t ? (u = (i = B(u, function(e) {
                        return e.func === t
                    })).fail, this.bindings[a] = u, Y(i.pass, function(e) {
                        e.removed = !0
                    })) : u.length = 0, u.length || (this.toggleEvent(e, !1), delete this.bindings[a]))
                } else ne(this.bindings, function(e, t) {
                    n.toggleEvent(t, !1)
                }), this.bindings = {};
            return this
        }, Cx.prototype.once = function(e, t, n) {
            return this.on(e, t, n, {
                once: !0
            })
        }, Cx.prototype.has = function(e) {
            return e = e.toLowerCase(), !(!this.bindings[e] || 0 === this.bindings[e].length)
        }, Cx);

    function Cx(e) {
        this.bindings = {}, this.settings = e || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || D
    }

    function xx(n) {
        return n._eventDispatcher || (n._eventDispatcher = new yx({
            scope: n,
            toggleEvent: function(e, t) {
                yx.isNative(e) && n.toggleNativeEvent && n.toggleNativeEvent(e, t)
            }
        })), n._eventDispatcher
    }

    function wx(e, t) {
        if ("selectionchange" === t) return e.getDoc();
        if (!e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(t)) return e.getDoc().documentElement;
        var n = Ls(e);
        return n ? (e.eventRoot || (e.eventRoot = Rx.select(n)[0]), e.eventRoot) : e.getBody()
    }

    function Sx(e, t, n) {
        var r, o, i, a;
        e.hidden || px(e) ? px(e) && (r = e, "click" !== (o = n).type || If.metaKeyPressed(o) || (i = Et.fromDom(o.target), a = r, yr(i, "a", function(e) {
            return je(e, Et.fromDom(a.getBody()))
        }).bind(function(e) {
            return bn(e, "href")
        }).each(function(e) {
            var t, n;
            o.preventDefault(), /^#/.test(e) ? (t = r.dom.select(e + ',[name="' + (Ge(n = e, "#") ? n.substring("#".length) : n) + '"]')).length && r.selection.scrollIntoView(t[0], !0) : window.open(e, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes")
        }))) : e.fire(t, n)
    }

    function Nx(i, a) {
        var e, t;
        i.delegates || (i.delegates = {}), i.delegates[a] || i.removed || (t = wx(i, a), Ls(i) ? (_x || (_x = {}, i.editorManager.on("removeEditor", function() {
            i.editorManager.activeEditor || _x && (ne(_x, function(e, t) {
                i.dom.unbind(wx(i, t))
            }), _x = null)
        })), _x[a] || (_x[a] = e = function(e) {
            for (var t = e.target, n = i.editorManager.get(), r = n.length; r--;) {
                var o = n[r].getBody();
                o !== t && !Rx.isChildOf(t, o) || Sx(n[r], a, e)
            }
        }, Rx.bind(t, a, e))) : (Rx.bind(t, a, e = function(e) {
            Sx(i, a, e)
        }), i.delegates[a] = e))
    }

    function Ex(e, t, n, r) {
        var o = n[t.get()],
            i = n[r];
        try {
            i.activate()
        } catch (e) {
            return void console.error("problem while activating editor mode " + r + ":", e)
        }
        o.deactivate(), o.editorReadOnly !== i.editorReadOnly && gx(e, i.editorReadOnly), t.set(r), e.fire("SwitchMode", {
            mode: r
        })
    }

    function kx(e) {
        var t, n = {};
        Ox(Bx(e.toLowerCase(), "+"), function(e) {
            e in Lx ? n[e] = !0 : /^[0-9]{2,}$/.test(e) ? n.keyCode = parseInt(e, 10) : (n.charCode = e.charCodeAt(0), n.keyCode = Px[e] || e.toUpperCase().charCodeAt(0))
        });
        var r = [n.keyCode];
        for (t in Lx) n[t] ? r.push(t) : n[t] = !1;
        return n.id = r.join(","), n.access && (n.alt = !0, xt.mac ? n.ctrl = !0 : n.shift = !0), n.meta && (xt.mac ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n
    }
    var _x, Ax = {
            fire: function(e, t, n) {
                if (this.removed && "remove" !== e && "detach" !== e) return t;
                var r = xx(this).fire(e, t);
                if (!1 !== n && this.parent)
                    for (var o = this.parent(); o && !r.isPropagationStopped();) o.fire(e, r, !1), o = o.parent();
                return r
            },
            on: function(e, t, n) {
                return xx(this).on(e, t, n)
            },
            off: function(e, t) {
                return xx(this).off(e, t)
            },
            once: function(e, t) {
                return xx(this).once(e, t)
            },
            hasEventListeners: function(e) {
                return xx(this).has(e)
            }
        },
        Rx = eu.DOM,
        Dx = _e(_e({}, Ax), {
            bindPendingEventDelegates: function() {
                var t = this;
                Nt.each(t._pendingNativeEvents, function(e) {
                    Nx(t, e)
                })
            },
            toggleNativeEvent: function(e, t) {
                var n = this;
                "focus" !== e && "blur" !== e && (n.removed || (t ? n.initialized ? Nx(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [e] : n.initialized && (n.dom.unbind(wx(n, e), e, n.delegates[e]), delete n.delegates[e])))
            },
            unbindAllNativeEvents: function() {
                var n = this,
                    e = n.getBody(),
                    t = n.dom;
                n.delegates && (ne(n.delegates, function(e, t) {
                    n.dom.unbind(wx(n, t), t, e)
                }), delete n.delegates), !n.inline && e && t && (e.onload = null, t.unbind(n.getWin()), t.unbind(n.getDoc())), t && (t.unbind(e), t.unbind(n.getContainer()))
            }
        }),
        Tx = ["design", "readonly"],
        Ox = Nt.each,
        Bx = Nt.explode,
        Px = {
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123
        },
        Lx = Nt.makeMap("alt,ctrl,shift,meta,access"),
        Ix = (Mx.prototype.add = function(e, n, t, r) {
            var o = this,
                i = o.normalizeCommandFunc(t);
            return Ox(Bx(Nt.trim(e)), function(e) {
                var t = o.createShortcut(e, n, i, r);
                o.shortcuts[t.id] = t
            }), !0
        }, Mx.prototype.remove = function(e) {
            var t = this.createShortcut(e);
            return !!this.shortcuts[t.id] && (delete this.shortcuts[t.id], !0)
        }, Mx.prototype.normalizeCommandFunc = function(e) {
            var t = this,
                n = e;
            return "string" == typeof n ? function() {
                t.editor.execCommand(n, !1, null)
            } : Nt.isArray(n) ? function() {
                t.editor.execCommand(n[0], n[1], n[2])
            } : n
        }, Mx.prototype.createShortcut = function(e, t, n, r) {
            var o = Nt.map(Bx(e, ">"), kx);
            return o[o.length - 1] = Nt.extend(o[o.length - 1], {
                func: n,
                scope: r || this.editor
            }), Nt.extend(o[0], {
                desc: this.editor.translate(t),
                subpatterns: o.slice(1)
            })
        }, Mx.prototype.hasModifier = function(e) {
            return e.altKey || e.ctrlKey || e.metaKey
        }, Mx.prototype.isFunctionKey = function(e) {
            return "keydown" === e.type && 112 <= e.keyCode && e.keyCode <= 123
        }, Mx.prototype.matchShortcut = function(e, t) {
            return !!t && t.ctrl === e.ctrlKey && t.meta === e.metaKey && t.alt === e.altKey && t.shift === e.shiftKey && !!(e.keyCode === t.keyCode || e.charCode && e.charCode === t.charCode) && (e.preventDefault(), !0)
        }, Mx.prototype.executeShortcutAction = function(e) {
            return e.func ? e.func.call(e.scope) : null
        }, Mx);

    function Mx(e) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = e;
        var n = this;
        e.on("keyup keypress keydown", function(t) {
            !n.hasModifier(t) && !n.isFunctionKey(t) || t.isDefaultPrevented() || (Ox(n.shortcuts, function(e) {
                if (n.matchShortcut(t, e)) return n.pendingPatterns = e.subpatterns.slice(0), "keydown" === t.type && n.executeShortcutAction(e), !0
            }), n.matchShortcut(t, n.pendingPatterns[0]) && (1 === n.pendingPatterns.length && "keydown" === t.type && n.executeShortcutAction(n.pendingPatterns[0]), n.pendingPatterns.shift()))
        })
    }
    var Fx = eu.DOM,
        Ux = Nt.extend,
        zx = Nt.each,
        Hx = Nt.resolve,
        jx = xt.ie,
        Vx = (qx.prototype.render = function() {
            ! function(t) {
                var e = t.id;
                lu.setCode(Ts(t));
                var n, r, o, i, a = function() {
                    nx.unbind(window, "ready", a), t.render()
                };
                ci.Event.domLoaded ? t.getElement() && xt.contentEditable && (n = Et.fromDom(t.getElement()), r = L(n.dom.attributes, function(e, t) {
                    return e[t.name] = t.value, e
                }, {}), t.on("remove", function() {
                    O(n.dom.attributes, function(e) {
                        return Cn(n, e.name), 0
                    }), hn(n, r)
                }), t.ui.styleSheetLoader = Rr.forElement(n, {
                    contentCssCors: (o = t).getParam("content_css_cors"),
                    referrerPolicy: Ds(o)
                }), t.getParam("inline") ? t.inline = !0 : (t.orgVisibility = t.getElement().style.visibility, t.getElement().style.visibility = "hidden"), (i = t.getElement().form || nx.getParent(e, "form")) && (t.formElement = i, t.getParam("hidden_input") && !jn(t.getElement()) && (nx.insertAfter(nx.create("input", {
                    type: "hidden",
                    name: e
                }), e), t.hasHiddenInput = !0), t.formEventDelegate = function(e) {
                    t.fire(e.type, e)
                }, nx.bind(i, "submit reset", t.formEventDelegate), t.on("reset", function() {
                    t.resetContent()
                }), !t.getParam("submit_patch") || i.submit.nodeType || i.submit.length || i._mceOldSubmit || (i._mceOldSubmit = i.submit, i.submit = function() {
                    return t.editorManager.triggerSave(), t.setDirty(!1), i._mceOldSubmit(i)
                })), t.windowManager = Gv(t), t.notificationManager = Ev(t), "xml" === t.getParam("encoding") && t.on("GetContent", function(e) {
                    e.save && (e.content = nx.encode(e.content))
                }), t.getParam("add_form_submit_trigger") && t.on("submit", function() {
                    t.initialized && t.save()
                }), t.getParam("add_unload_trigger") && (t._beforeUnload = function() {
                    !t.initialized || t.destroyed || t.isHidden() || t.save({
                        format: "raw",
                        no_events: !0,
                        set_dirty: !1
                    })
                }, t.editorManager.on("BeforeUnload", t._beforeUnload)), t.editorManager.add(t), j1(t, t.suffix)) : nx.bind(window, "ready", a)
            }(this)
        }, qx.prototype.focus = function(e) {
            this.execCommand("mceFocus", !1, e)
        }, qx.prototype.hasFocus = function() {
            return Cd(this)
        }, qx.prototype.execCallback = function(e) {
            for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            var r, o = this.settings[e];
            if (o) return this.callbackLookup && (r = this.callbackLookup[e]) && (o = r.func, r = r.scope), "string" == typeof o && (r = (r = o.replace(/\.\w+$/, "")) ? Hx(r) : 0, o = Hx(o), this.callbackLookup = this.callbackLookup || {}, this.callbackLookup[e] = {
                func: o,
                scope: r
            }), o.apply(r || this, t)
        }, qx.prototype.translate = function(e) {
            return lu.translate(e)
        }, qx.prototype.getParam = function(e, t, n) {
            return i = t, a = n, l = (o = e) in(r = this).settings ? r.settings[o] : i, "hash" === a ? (c = {}, "string" == typeof(s = l) ? Y(0 < s.indexOf("=") ? s.split(/[;,](?![^=;,]*(?:[;,]|$))/) : s.split(","), function(e) {
                var t = e.split("=");
                1 < t.length ? c[Nt.trim(t[0])] = Nt.trim(t[1]) : c[Nt.trim(t[0])] = Nt.trim(t[0])
            }) : c = s, c) : "string" === a ? xv(X, r, o).getOr(i) : "number" === a ? xv(N, r, o).getOr(i) : "boolean" === a ? xv(v, r, o).getOr(i) : "object" === a ? xv(h, r, o).getOr(i) : "array" === a ? xv(S, r, o).getOr(i) : "string[]" === a ? xv((u = X, function(e) {
                return S(e) && j(e, u)
            }), r, o).getOr(i) : "function" === a ? xv(y, r, o).getOr(i) : l;
            var r, o, i, a, u, s, c, l
        }, qx.prototype.hasPlugin = function(e, t) {
            return !(!T(Fs(this).split(/[ ,]/), e) || t && void 0 === Xv.get(e))
        }, qx.prototype.nodeChanged = function(e) {
            this._nodeChangeDispatcher.nodeChanged(e)
        }, qx.prototype.addCommand = function(e, t, n) {
            this.editorCommands.addCommand(e, t, n)
        }, qx.prototype.addQueryStateHandler = function(e, t, n) {
            this.editorCommands.addQueryStateHandler(e, t, n)
        }, qx.prototype.addQueryValueHandler = function(e, t, n) {
            this.editorCommands.addQueryValueHandler(e, t, n)
        }, qx.prototype.addShortcut = function(e, t, n, r) {
            this.shortcuts.add(e, t, n, r)
        }, qx.prototype.execCommand = function(e, t, n, r) {
            return this.editorCommands.execCommand(e, t, n, r)
        }, qx.prototype.queryCommandState = function(e) {
            return this.editorCommands.queryCommandState(e)
        }, qx.prototype.queryCommandValue = function(e) {
            return this.editorCommands.queryCommandValue(e)
        }, qx.prototype.queryCommandSupported = function(e) {
            return this.editorCommands.queryCommandSupported(e)
        }, qx.prototype.show = function() {
            this.hidden && (this.hidden = !1, this.inline ? this.getBody().contentEditable = "true" : (Fx.show(this.getContainer()), Fx.hide(this.id)), this.load(), this.fire("show"))
        }, qx.prototype.hide = function() {
            var e = this,
                t = e.getDoc();
            e.hidden || (jx && t && !e.inline && t.execCommand("SelectAll"), e.save(), e.inline ? (e.getBody().contentEditable = "false", e === e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) : (Fx.hide(e.getContainer()), Fx.setStyle(e.id, "display", e.orgDisplay)), e.hidden = !0, e.fire("hide"))
        }, qx.prototype.isHidden = function() {
            return !!this.hidden
        }, qx.prototype.setProgressState = function(e, t) {
            this.fire("ProgressState", {
                state: e,
                time: t
            })
        }, qx.prototype.load = function(e) {
            var t = this.getElement();
            if (this.removed) return "";
            if (t) {
                (e = e || {}).load = !0;
                var n = jn(t) ? t.value : t.innerHTML,
                    r = this.setContent(n, e);
                return e.element = t, e.no_events || this.fire("LoadContent", e), e.element = t = null, r
            }
        }, qx.prototype.save = function(e) {
            var t, n, r = this,
                o = r.getElement();
            if (o && r.initialized && !r.removed) return (e = e || {}).save = !0, e.element = o, e.content = r.getContent(e), e.no_events || r.fire("SaveContent", e), "raw" === e.format && r.fire("RawSaveContent", e), t = e.content, jn(o) ? o.value = t : (!e.is_removing && r.inline || (o.innerHTML = t), (n = Fx.getParent(r.id, "form")) && zx(n.elements, function(e) {
                if (e.name === r.id) return e.value = t, !1
            })), e.element = o = null, !1 !== e.set_dirty && r.setDirty(!1), t
        }, qx.prototype.setContent = function(e, t) {
            return mv(this, e, t)
        }, qx.prototype.getContent = function(e) {
            return t = this, r = (n = void 0 === (n = e) ? {} : n).format || "html", o = n, bh(t).editor.getContent(o, r);
            var t, n, r, o
        }, qx.prototype.insertContent = function(e, t) {
            t && (e = Ux({
                content: e
            }, t)), this.execCommand("mceInsertContent", !1, e)
        }, qx.prototype.resetContent = function(e) {
            void 0 === e ? mv(this, this.startContent, {
                format: "raw"
            }) : mv(this, e), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged()
        }, qx.prototype.isDirty = function() {
            return !this.isNotDirty
        }, qx.prototype.setDirty = function(e) {
            var t = !this.isNotDirty;
            this.isNotDirty = !e, e && e !== t && this.fire("dirty")
        }, qx.prototype.getContainer = function() {
            return this.container || (this.container = Fx.get(this.editorContainer || this.id + "_parent")), this.container
        }, qx.prototype.getContentAreaContainer = function() {
            return this.contentAreaContainer
        }, qx.prototype.getElement = function() {
            return this.targetElm || (this.targetElm = Fx.get(this.id)), this.targetElm
        }, qx.prototype.getWin = function() {
            var e;
            return this.contentWindow || (e = this.iframeElement) && (this.contentWindow = e.contentWindow), this.contentWindow
        }, qx.prototype.getDoc = function() {
            var e;
            return this.contentDocument || (e = this.getWin()) && (this.contentDocument = e.document), this.contentDocument
        }, qx.prototype.getBody = function() {
            var e = this.getDoc();
            return this.bodyElement || (e ? e.body : null)
        }, qx.prototype.convertURL = function(e, t, n) {
            var r = this.settings;
            return r.urlconverter_callback ? this.execCallback("urlconverter_callback", e, n, !0, t) : !r.convert_urls || n && "LINK" === n.nodeName || 0 === e.indexOf("file:") || 0 === e.length ? e : r.relative_urls ? this.documentBaseURI.toRelative(e) : this.documentBaseURI.toAbsolute(e, r.remove_script_host)
        }, qx.prototype.addVisual = function(e) {
            var t;
            t = e, yh(this).editor.addVisual(t)
        }, qx.prototype.remove = function() {
            var e, t, n, r, o;
            (e = this).removed || (t = e._selectionOverrides, n = e.editorUpload, r = e.getBody(), o = e.getElement(), r && e.save({
                is_removing: !0
            }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && o && Ov.remove(o.nextSibling), e.fire("remove"), e.editorManager.remove(e), !e.inline && r && Ov.setStyle(e.id, "display", e.orgDisplay), e.fire("detach"), Ov.remove(e.getContainer()), gv(t), gv(n), e.destroy())
        }, qx.prototype.destroy = function(e) {
            var t, n, r, o, i, a, u;
            n = e, a = (t = this).selection, u = t.dom, t.destroyed || (n || t.removed ? (n || (t.editorManager.off("beforeunload", t._beforeUnload), t.theme && t.theme.destroy && t.theme.destroy(), gv(a), gv(u)), (o = (r = t).formElement) && (o._mceOldSubmit && (o.submit = o._mceOldSubmit, o._mceOldSubmit = null), Ov.unbind(o, "submit reset", r.formEventDelegate)), (i = t).contentAreaContainer = i.formElement = i.container = i.editorContainer = null, i.bodyElement = i.contentDocument = i.contentWindow = null, i.iframeElement = i.targetElm = null, i.selection && (i.selection = i.selection.win = i.selection.dom = i.selection.dom.doc = null), t.destroyed = !0) : t.remove())
        }, qx.prototype.uploadImages = function(e) {
            return this.editorUpload.uploadImages(e)
        }, qx.prototype._scanForImages = function() {
            return this.editorUpload.scanForImages()
        }, qx.prototype.addButton = function() {
            throw new Error("editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead")
        }, qx.prototype.addSidebar = function() {
            throw new Error("editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead")
        }, qx.prototype.addMenuItem = function() {
            throw new Error("editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead")
        }, qx.prototype.addContextToolbar = function() {
            throw new Error("editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead")
        }, qx);

    function qx(e, t, n) {
        var r, o, i, a, u, s, c, l, f, d, m, g, p, h, v, b, y, C, x = this;

        function w(n, r) {
            return function(e, t) {
                return n[e.toLowerCase()] = _e(_e({}, t), {
                    type: r
                })
            }
        }
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.editorManager = n, this.documentBaseUrl = n.documentBaseURL, Ux(this, Dx), this.settings = (d = (f = this).documentBaseUrl, m = n.defaultSettings, p = d, h = Fv, v = f, b = {
            id: e,
            theme: "silver",
            toolbar_mode: bv(g = t, "floating"),
            plugins: "",
            document_base_url: p,
            add_form_submit_trigger: !0,
            submit_patch: !0,
            add_unload_trigger: !0,
            convert_urls: !0,
            relative_urls: !0,
            remove_script_host: !0,
            object_resizing: !0,
            doctype: "<!DOCTYPE html>",
            visual: !0,
            font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
            forced_root_block: "p",
            hidden_input: !0,
            inline_styles: !0,
            convert_fonts_to_spans: !0,
            indent: !0,
            indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            entity_encoding: "named",
            url_converter: v.convertURL,
            url_converter_scope: v
        }, y = _e(_e({}, b), h ? jv : {}), !1 !== (C = Cv(Uv || zv, Uv, y, m, g)).deprecation_warnings && pv(g, C), C), this.settings.suffix && (n.suffix = this.settings.suffix), this.suffix = n.suffix, this.settings.base_url && n._setBaseUrl(this.settings.base_url), this.baseUri = n.baseURI, this.settings.referrer_policy && (ou.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy), eu.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy)), fu.languageLoad = this.settings.language_load, fu.baseURL = n.baseURL, this.id = e, this.setDirty(!1), this.documentBaseURI = new nv(this.settings.document_base_url, {
            base_uri: this.baseUri
        }), this.baseURI = this.baseUri, this.inline = !!this.settings.inline, this.shortcuts = new Ix(this), this.editorCommands = new cx(this), this.settings.cache_suffix && (xt.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, "")), this.ui = {
            registry: {
                addAutocompleter: (u = {}, (r = {
                    addButton: w(o = {}, "button"),
                    addGroupToolbarButton: w(o, "grouptoolbarbutton"),
                    addToggleButton: w(o, "togglebutton"),
                    addMenuButton: w(o, "menubutton"),
                    addSplitButton: w(o, "splitbutton"),
                    addMenuItem: w(i = {}, "menuitem"),
                    addNestedMenuItem: w(i, "nestedmenuitem"),
                    addToggleMenuItem: w(i, "togglemenuitem"),
                    addAutocompleter: w(a = {}, "autocompleter"),
                    addContextMenu: w(s = {}, "contextmenu"),
                    addContextToolbar: w(c = {}, "contexttoolbar"),
                    addContextForm: w(c, "contextform"),
                    addSidebar: w(l = {}, "sidebar"),
                    addIcon: function(e, t) {
                        return u[e.toLowerCase()] = t
                    },
                    getAll: function() {
                        return {
                            buttons: o,
                            menuItems: i,
                            icons: u,
                            popups: a,
                            contextMenus: s,
                            contextToolbars: c,
                            sidebars: l
                        }
                    }
                }).addAutocompleter),
                addButton: r.addButton,
                addContextForm: r.addContextForm,
                addContextMenu: r.addContextMenu,
                addContextToolbar: r.addContextToolbar,
                addIcon: r.addIcon,
                addMenuButton: r.addMenuButton,
                addMenuItem: r.addMenuItem,
                addNestedMenuItem: r.addNestedMenuItem,
                addSidebar: r.addSidebar,
                addSplitButton: r.addSplitButton,
                addToggleButton: r.addToggleButton,
                addGroupToolbarButton: r.addGroupToolbarButton,
                addToggleMenuItem: r.addToggleMenuItem,
                getAll: r.getAll
            },
            styleSheetLoader: void 0,
            show: te,
            hide: te,
            enable: te,
            disable: te,
            isDisabled: D
        };
        var S, N, E, k, _, A = (k = au("design"), _ = au({
            design: {
                activate: te,
                deactivate: te,
                editorReadOnly: !1
            },
            readonly: {
                activate: te,
                deactivate: te,
                editorReadOnly: !0
            }
        }), (N = S = this).serializer ? hx(N) : N.on("PreInit", function() {
            hx(N)
        }), (E = S).on("ShowCaret", function(e) {
            px(E) && e.preventDefault()
        }), E.on("ObjectSelected", function(e) {
            px(E) && e.preventDefault()
        }), {
            isReadOnly: function() {
                return px(S)
            },
            set: function(e) {
                return function(e, t, n, r) {
                    if (r !== n.get()) {
                        if (!Ee(t, r)) throw new Error("Editor mode '" + r + "' is invalid");
                        e.initialized ? Ex(e, n, t, r) : e.on("init", function() {
                            return Ex(e, n, t, r)
                        })
                    }
                }(S, _.get(), k, e)
            },
            get: function() {
                return k.get()
            },
            register: function(e, t) {
                _.set(function(e, t, n) {
                    var r;
                    if (T(Tx, t)) throw new Error("Cannot override default mode " + t);
                    return _e(_e({}, e), ((r = {})[t] = _e(_e({}, n), {
                        deactivate: function() {
                            try {
                                n.deactivate()
                            } catch (e) {
                                console.error("problem while deactivating editor mode " + t + ":", e)
                            }
                        }
                    }), r))
                }(_.get(), e, t))
            }
        });
        this.mode = A, this.setMode = A.set, n.fire("SetupEditor", {
            editor: this
        }), this.execCallback("setup", this), this.$ = Ya.overrideDefaults(function() {
            return {
                context: x.inline ? x.getBody() : x.getDoc(),
                element: x.getBody()
            }
        })
    }

    function $x(t) {
        var n = t.type;
        Jx(ow.get(), function(e) {
            switch (n) {
                case "scroll":
                    e.fire("ScrollWindow", t);
                    break;
                case "resize":
                    e.fire("ResizeWindow", t)
            }
        })
    }

    function Wx(e) {
        e !== ew && (e ? Ya(window).on("resize scroll", $x) : Ya(window).off("resize scroll", $x), ew = e)
    }

    function Kx(t) {
        var e = nw;
        delete tw[t.id];
        for (var n = 0; n < tw.length; n++)
            if (tw[n] === t) {
                tw.splice(n, 1);
                break
            } return nw = U(nw, function(e) {
            return t !== e
        }), ow.activeEditor === t && (ow.activeEditor = 0 < nw.length ? nw[0] : null), ow.focusedEditor === t && (ow.focusedEditor = null), e.length !== nw.length
    }
    var Xx, Yx = eu.DOM,
        Gx = Nt.explode,
        Jx = Nt.each,
        Qx = Nt.extend,
        Zx = 0,
        ew = !1,
        tw = [],
        nw = [],
        rw = "CSS1Compat" !== document.compatMode,
        ow = _e(_e({}, Ax), {
            baseURI: null,
            baseURL: null,
            defaultSettings: {},
            documentBaseURL: null,
            suffix: null,
            $: Ya,
            majorVersion: "5",
            minorVersion: "10.9",
            releaseDate: "2023-11-15",
            editors: tw,
            i18n: lu,
            activeEditor: null,
            focusedEditor: null,
            settings: {},
            setup: function() {
                var e, t = "",
                    n = nv.getDocumentBaseUrl(document.location);
                /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/"));
                var r = window.tinymce || window.tinyMCEPreInit;
                if (r) e = r.base || r.baseURL, t = r.suffix;
                else {
                    for (var o, i = document.getElementsByTagName("script"), a = 0; a < i.length; a++)
                        if ("" !== (o = i[a].src || "")) {
                            var u = o.substring(o.lastIndexOf("/"));
                            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(o)) {
                                -1 !== u.indexOf(".min") && (t = ".min"), e = o.substring(0, o.lastIndexOf("/"));
                                break
                            }
                        }! e && document.currentScript && (-1 !== (o = document.currentScript.src).indexOf(".min") && (t = ".min"), e = o.substring(0, o.lastIndexOf("/")))
                }
                this.baseURL = new nv(n).toAbsolute(e), this.documentBaseURL = n, this.baseURI = new nv(this.baseURL), this.suffix = t, this.on("AddEditor", R(hd, this)), this.on("RemoveEditor", R(vd, this))
            },
            overrideDefaults: function(e) {
                var t = e.base_url;
                t && this._setBaseUrl(t);
                var n = e.suffix;
                e.suffix && (this.suffix = n);
                var r = (this.defaultSettings = e).plugin_base_urls;
                void 0 !== r && ne(r, function(e, t) {
                    fu.PluginManager.urls[t] = e
                })
            },
            init: function(r) {
                function u(e) {
                    var t = e.id;
                    return t || (t = ue(e, "name").filter(function(e) {
                        return !Yx.get(e)
                    }).getOrThunk(Yx.uniqueId), e.setAttribute("id", t)), t
                }

                function s(e, t) {
                    return t.constructor === RegExp ? t.test(e.className) : Yx.hasClass(e, t)
                }
                var n, c = this,
                    l = Nt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "),
                    f = function(e) {
                        n = e
                    },
                    t = function() {
                        function n(e, t, n) {
                            var r = new Vx(e, t, c);
                            a.push(r), r.on("init", function() {
                                ++i === o.length && f(a)
                            }), r.targetElm = r.targetElm || n, r.render()
                        }
                        var o, e, i = 0,
                            a = [];
                        Yx.unbind(window, "ready", t), (e = r.onpageload) && e.apply(c, []), o = Ya.unique(function(t) {
                            var n = [];
                            if (xt.browser.isIE() && xt.browser.version.major < 11) return wy("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/"), [];
                            if (rw) return wy("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), [];
                            if (t.types) return Jx(t.types, function(e) {
                                n = n.concat(Yx.select(e.selector))
                            }), n;
                            if (t.selector) return Yx.select(t.selector);
                            if (t.target) return [t.target];
                            switch (t.mode) {
                                case "exact":
                                    var e = t.elements || "";
                                    0 < e.length && Jx(Gx(e), function(t) {
                                        var e = Yx.get(t);
                                        e ? n.push(e) : Jx(document.forms, function(e) {
                                            Jx(e.elements, function(e) {
                                                e.name === t && (t = "mce_editor_" + Zx++, Yx.setAttrib(e, "id", t), n.push(e))
                                            })
                                        })
                                    });
                                    break;
                                case "textareas":
                                case "specific_textareas":
                                    Jx(Yx.select("textarea"), function(e) {
                                        t.editor_deselector && s(e, t.editor_deselector) || t.editor_selector && !s(e, t.editor_selector) || n.push(e)
                                    })
                            }
                            return n
                        }(r)), r.types ? Jx(r.types, function(t) {
                            Nt.each(o, function(e) {
                                return !Yx.is(e, t.selector) || (n(u(e), Qx({}, r, t), e), !1)
                            })
                        }) : (Nt.each(o, function(e) {
                            var t;
                            (t = c.get(e.id)) && t.initialized && !(t.getContainer() || t.getBody()).parentNode && (Kx(t), t.unbindAllNativeEvents(), t.destroy(!0), t.removed = !0)
                        }), 0 === (o = Nt.grep(o, function(e) {
                            return !c.get(e.id)
                        })).length ? f([]) : Jx(o, function(e) {
                            var t = e;
                            r.inline && t.tagName.toLowerCase() in l ? wy("Could not initialize inline editor on invalid inline target element", e) : n(u(e), r, e)
                        }))
                    };
                return c.settings = r, Yx.bind(window, "ready", t), new _r(function(t) {
                    n ? t(n) : f = function(e) {
                        t(e)
                    }
                })
            },
            get: function(t) {
                return 0 === arguments.length ? nw.slice(0) : X(t) ? M(nw, function(e) {
                    return e.id === t
                }).getOr(null) : N(t) && nw[t] || null
            },
            add: function(e) {
                var n = this;
                return tw[e.id] === e || (null === n.get(e.id) && ("length" !== e.id && (tw[e.id] = e), tw.push(e), nw.push(e)), Wx(!0), n.activeEditor = e, n.fire("AddEditor", {
                    editor: e
                }), Xx || (Xx = function(e) {
                    var t = n.fire("BeforeUnload");
                    if (t.returnValue) return e.preventDefault(), e.returnValue = t.returnValue, t.returnValue
                }, window.addEventListener("beforeunload", Xx))), e
            },
            createEditor: function(e, t) {
                return this.add(new Vx(e, t, this))
            },
            remove: function(e) {
                var t, n, r = this;
                if (e) {
                    if (!X(e)) return n = e, l(r.get(n.id)) ? null : (Kx(n) && r.fire("RemoveEditor", {
                        editor: n
                    }), 0 === nw.length && window.removeEventListener("beforeunload", Xx), n.remove(), Wx(0 < nw.length), n);
                    Jx(Yx.select(e), function(e) {
                        (n = r.get(e.id)) && r.remove(n)
                    })
                } else
                    for (t = nw.length - 1; 0 <= t; t--) r.remove(nw[t])
            },
            execCommand: function(e, t, n) {
                var r = this.get(n);
                switch (e) {
                    case "mceAddEditor":
                        return this.get(n) || new Vx(n, this.settings, this).render(), !0;
                    case "mceRemoveEditor":
                        return r && r.remove(), !0;
                    case "mceToggleEditor":
                        return r ? r.isHidden() ? r.show() : r.hide() : this.execCommand("mceAddEditor", !1, n), !0
                }
                return !!this.activeEditor && this.activeEditor.execCommand(e, t, n)
            },
            triggerSave: function() {
                Jx(nw, function(e) {
                    e.save()
                })
            },
            addI18n: function(e, t) {
                lu.add(e, t)
            },
            translate: function(e) {
                return lu.translate(e)
            },
            setActive: function(e) {
                var t = this.activeEditor;
                this.activeEditor !== e && (t && t.fire("deactivate", {
                    relatedTarget: e
                }), e.fire("activate", {
                    relatedTarget: t
                })), this.activeEditor = e
            },
            _setBaseUrl: function(e) {
                this.baseURL = new nv(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new nv(this.baseURL)
            }
        });

    function iw(e, t, n) {
        var r = t.x,
            o = t.y,
            i = e.w,
            a = e.h,
            u = t.w,
            s = t.h,
            c = (n || "").split("");
        return "b" === c[0] && (o += s), "r" === c[1] && (r += u), "c" === c[0] && (o += gw(s / 2)), "c" === c[1] && (r += gw(u / 2)), "b" === c[3] && (o -= a), "r" === c[4] && (r -= i), "c" === c[3] && (o -= gw(a / 2)), "c" === c[4] && (r -= gw(i / 2)), uw(r, o, i, a)
    }

    function aw() {}
    ow.setup();

    function uw(e, t, n, r) {
        return {
            x: e,
            y: t,
            w: n,
            h: r
        }
    }
    var sw, cw, lw, fw, dw = Math.min,
        mw = Math.max,
        gw = Math.round,
        pw = {
            inflate: function(e, t, n) {
                return uw(e.x - t, e.y - n, e.w + 2 * t, e.h + 2 * n)
            },
            relativePosition: iw,
            findBestRelativePosition: function(e, t, n, r) {
                for (var o, i = 0; i < r.length; i++)
                    if ((o = iw(e, t, r[i])).x >= n.x && o.x + o.w <= n.w + n.x && o.y >= n.y && o.y + o.h <= n.h + n.y) return r[i];
                return null
            },
            intersect: function(e, t) {
                var n = mw(e.x, t.x),
                    r = mw(e.y, t.y),
                    o = dw(e.x + e.w, t.x + t.w),
                    i = dw(e.y + e.h, t.y + t.h);
                return o - n < 0 || i - r < 0 ? null : uw(n, r, o - n, i - r)
            },
            clamp: function(e, t, n) {
                var r = e.x,
                    o = e.y,
                    i = e.x + e.w,
                    a = e.y + e.h,
                    u = t.x + t.w,
                    s = t.y + t.h,
                    c = mw(0, t.x - r),
                    l = mw(0, t.y - o),
                    f = mw(0, i - u),
                    d = mw(0, a - s);
                return r += c, o += l, n && (i += c, a += l, r -= f, o -= d), uw(r, o, (i -= f) - r, (a -= d) - o)
            },
            create: uw,
            fromClientRect: function(e) {
                return uw(e.left, e.top, e.width, e.height)
            }
        },
        hw = (sw = {}, cw = {}, {
            load: function(r, o) {
                var i = 'Script at URL "' + o + '" failed to load',
                    a = 'Script at URL "' + o + "\" did not call `tinymce.Resource.add('" + r + "', data)` within 1 second";
                if (void 0 !== sw[r]) return sw[r];
                var e = new _r(function(e, t) {
                    var n = function(e, t, n) {
                        function r(n) {
                            return function() {
                                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                                o || (o = !0, null !== i && (clearTimeout(i), i = null), n.apply(null, e))
                            }
                        }
                        void 0 === n && (n = 1e3);
                        var o = !1,
                            i = null,
                            a = r(e),
                            u = r(t);
                        return {
                            start: function() {
                                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                                o || null !== i || (i = setTimeout(function() {
                                    return u.apply(null, e)
                                }, n))
                            },
                            resolve: a,
                            reject: u
                        }
                    }(e, t);
                    cw[r] = n.resolve, ou.ScriptLoader.loadScript(o, function() {
                        return n.start(a)
                    }, function() {
                        return n.reject(i)
                    })
                });
                return sw[r] = e
            },
            add: function(e, t) {
                void 0 !== cw[e] && (cw[e](t), delete cw[e]), sw[e] = _r.resolve(t)
            }
        }),
        vw = Nt.each,
        bw = Nt.extend;
    aw.extend = lw = function(n) {
        function r() {
            var e, t, n;
            if (!fw && (this.init && this.init.apply(this, arguments), t = this.Mixins))
                for (e = t.length; e--;)(n = t[e]).init && n.init.apply(this, arguments)
        }

        function t() {
            return this
        }
        var o = this.prototype;
        fw = !0;
        var i = new this;
        return fw = !1, n.Mixins && (vw(n.Mixins, function(e) {
            for (var t in e) "init" !== t && (n[t] = e[t])
        }), o.Mixins && (n.Mixins = o.Mixins.concat(n.Mixins))), n.Methods && vw(n.Methods.split(","), function(e) {
            n[e] = t
        }), n.Properties && vw(n.Properties.split(","), function(e) {
            var t = "_" + e;
            n[e] = function(e) {
                return void 0 !== e ? (this[t] = e, this) : this[t]
            }
        }), n.Statics && vw(n.Statics, function(e, t) {
            r[t] = e
        }), n.Defaults && o.Defaults && (n.Defaults = bw({}, o.Defaults, n.Defaults)), ne(n, function(e, t) {
            var n, r;
            "function" == typeof e && o[t] ? i[t] = (n = t, r = e, function() {
                var e = this._super;
                this._super = o[n];
                var t = r.apply(this, arguments);
                return this._super = e, t
            }) : i[t] = e
        }), r.prototype = i, (r.constructor = r).extend = lw, r
    };
    var yw, Cw, xw, ww = Math.min,
        Sw = Math.max,
        Nw = Math.round,
        Ew = {
            serialize: function(e) {
                var t = JSON.stringify(e);
                return X(t) ? t.replace(/[\u0080-\uFFFF]/g, function(e) {
                    var t = e.charCodeAt(0).toString(16);
                    return "\\u" + "0000".substring(t.length) + t
                }) : t
            },
            parse: function(e) {
                try {
                    return JSON.parse(e)
                } catch (e) {}
            }
        },
        kw = {
            callbacks: {},
            count: 0,
            send: function(t) {
                var n = this,
                    r = eu.DOM,
                    o = (void 0 !== t.count ? t : n).count,
                    i = "tinymce_jsonp_" + o;
                n.callbacks[o] = function(e) {
                    r.remove(i), delete n.callbacks[o], t.callback(e)
                }, r.add(r.doc.body, "script", {
                    id: i,
                    src: t.url,
                    type: "text/javascript"
                }), n.count++
            }
        },
        _w = _e(_e({}, Ax), {
            send: function(e) {
                var t, n = 0,
                    r = function() {
                        !e.async || 4 === t.readyState || 1e4 < n++ ? (e.success && n < 1e4 && 200 === t.status ? e.success.call(e.success_scope, "" + t.responseText, t, e) : e.error && e.error.call(e.error_scope, 1e4 < n ? "TIMED_OUT" : "GENERAL", t, e), t = null) : Ar.setTimeout(r, 10)
                    };
                if (e.scope = e.scope || this, e.success_scope = e.success_scope || e.scope, e.error_scope = e.error_scope || e.scope, e.async = !1 !== e.async, e.data = e.data || "", _w.fire("beforeInitialize", {
                        settings: e
                    }), (t = new XMLHttpRequest).overrideMimeType && t.overrideMimeType(e.content_type), t.open(e.type || (e.data ? "POST" : "GET"), e.url, e.async), e.crossDomain && (t.withCredentials = !0), e.content_type && t.setRequestHeader("Content-Type", e.content_type), e.requestheaders && Nt.each(e.requestheaders, function(e) {
                        t.setRequestHeader(e.key, e.value)
                    }), t.setRequestHeader("X-Requested-With", "XMLHttpRequest"), (t = _w.fire("beforeSend", {
                        xhr: t,
                        settings: e
                    }).xhr).send(e.data), !e.async) return r();
                Ar.setTimeout(r, 10)
            }
        }),
        Aw = Nt.extend,
        Rw = (Dw.sendRPC = function(e) {
            return (new Dw).send(e)
        }, Dw.prototype.send = function(e) {
            var n = e.error,
                r = e.success,
                o = Aw(this.settings, e);
            o.success = function(e, t) {
                (e = void 0 === (e = Ew.parse(e)) ? {
                    error: "JSON Parse error."
                } : e).error ? n.call(o.error_scope || o.scope, e.error, t) : r.call(o.success_scope || o.scope, e.result)
            }, o.error = function(e, t) {
                n && n.call(o.error_scope || o.scope, e, t)
            }, o.data = Ew.serialize({
                id: e.id || "c" + this.count++,
                method: e.method,
                params: e.params
            }), o.content_type = "application/json", _w.send(o)
        }, Dw);

    function Dw(e) {
        this.settings = Aw({}, e), this.count = 0
    }
    try {
        var Tw, Ow = "__storage_test__";
        (Tw = window.localStorage).setItem(Ow, Ow), Tw.removeItem(Ow)
    } catch (e) {
        yw = {}, Cw = [], xw = {
            getItem: function(e) {
                return yw[e] || null
            },
            setItem: function(e, t) {
                Cw.push(e), yw[e] = String(t)
            },
            key: function(e) {
                return Cw[e]
            },
            removeItem: function(t) {
                Cw = Cw.filter(function(e) {
                    return e === t
                }), delete yw[t]
            },
            clear: function() {
                Cw = [], yw = {}
            },
            length: 0
        }, Object.defineProperty(xw, "length", {
            get: function() {
                return Cw.length
            },
            configurable: !1,
            enumerable: !1
        }), Tw = xw
    }
    var Bw = {
            geom: {
                Rect: pw
            },
            util: {
                Promise: _r,
                Delay: Ar,
                Tools: Nt,
                VK: If,
                URI: nv,
                Class: aw,
                EventDispatcher: yx,
                Observable: Ax,
                I18n: lu,
                XHR: _w,
                JSON: Ew,
                JSONRequest: Rw,
                JSONP: kw,
                LocalStorage: Tw,
                Color: function(e) {
                    function t(e) {
                        var t;
                        return "object" == typeof e ? "r" in e ? (u = e.r, s = e.g, c = e.b) : "v" in e && function(e, t, n) {
                            if (e = (parseInt(e, 10) || 0) % 360, t = parseInt(t, 10) / 100, n = parseInt(n, 10) / 100, t = Sw(0, ww(t, 1)), n = Sw(0, ww(n, 1)), 0 !== t) {
                                var r = e / 60,
                                    o = n * t,
                                    i = o * (1 - Math.abs(r % 2 - 1)),
                                    a = n - o;
                                switch (Math.floor(r)) {
                                    case 0:
                                        u = o, s = i, c = 0;
                                        break;
                                    case 1:
                                        u = i, s = o, c = 0;
                                        break;
                                    case 2:
                                        u = 0, s = o, c = i;
                                        break;
                                    case 3:
                                        u = 0, s = i, c = o;
                                        break;
                                    case 4:
                                        u = i, s = 0, c = o;
                                        break;
                                    case 5:
                                        u = o, s = 0, c = i;
                                        break;
                                    default:
                                        u = s = c = 0
                                }
                                u = Nw(255 * (u + a)), s = Nw(255 * (s + a)), c = Nw(255 * (c + a))
                            } else u = s = c = Nw(255 * n)
                        }(e.h, e.s, e.v) : (t = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(e)) ? (u = parseInt(t[1], 10), s = parseInt(t[2], 10), c = parseInt(t[3], 10)) : (t = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(e)) ? (u = parseInt(t[1], 16), s = parseInt(t[2], 16), c = parseInt(t[3], 16)) : (t = /#([0-F])([0-F])([0-F])/gi.exec(e)) && (u = parseInt(t[1] + t[1], 16), s = parseInt(t[2] + t[2], 16), c = parseInt(t[3] + t[3], 16)), u = u < 0 ? 0 : 255 < u ? 255 : u, s = s < 0 ? 0 : 255 < s ? 255 : s, c = c < 0 ? 0 : 255 < c ? 255 : c, n
                    }
                    var n = {},
                        u = 0,
                        s = 0,
                        c = 0;
                    return e && t(e), n.toRgb = function() {
                        return {
                            r: u,
                            g: s,
                            b: c
                        }
                    }, n.toHsv = function() {
                        return e = u, t = s, n = c, o = 0, (i = ww(e /= 255, ww(t /= 255, n /= 255))) === (a = Sw(e, Sw(t, n))) ? {
                            h: 0,
                            s: 0,
                            v: 100 * (o = i)
                        } : (r = (a - i) / a, {
                            h: Nw(60 * ((e === i ? 3 : n === i ? 1 : 5) - (e === i ? t - n : n === i ? e - t : n - e) / ((o = a) - i))),
                            s: Nw(100 * r),
                            v: Nw(100 * o)
                        });
                        var e, t, n, r, o, i, a
                    }, n.toHex = function() {
                        function e(e) {
                            return 1 < (e = parseInt(e, 10).toString(16)).length ? e : "0" + e
                        }
                        return "#" + e(u) + e(s) + e(c)
                    }, n.parse = t, n
                },
                ImageUploader: function(n) {
                    var e = rb(),
                        r = sb(n, e);
                    return {
                        upload: function(e, t) {
                            return r.upload(e, (t = void 0 === t || t) ? ub(n) : void 0)
                        }
                    }
                }
            },
            dom: {
                EventUtils: ci,
                Sizzle: ca,
                DomQuery: Ya,
                TreeWalker: Dr,
                TextSeeker: Au,
                DOMUtils: eu,
                ScriptLoader: ou,
                RangeUtils: Lf,
                Serializer: dv,
                StyleSheetLoader: Sr,
                ControlSelection: Sf,
                BookmarkManager: Hl,
                Selection: Fh,
                Event: ci.Event
            },
            html: {
                Styles: ao,
                Entities: Zo,
                Node: jd,
                Schema: oo,
                SaxParser: iv,
                DomParser: cv,
                Writer: nm,
                Serializer: rm
            },
            Env: xt,
            AddOnManager: fu,
            Annotator: zl,
            Formatter: mb,
            UndoManager: pb,
            EditorCommands: cx,
            WindowManager: Gv,
            NotificationManager: Ev,
            EditorObservable: Dx,
            Shortcuts: Ix,
            Editor: Vx,
            FocusManager: Fd,
            EditorManager: ow,
            DOM: eu.DOM,
            ScriptLoader: ou.ScriptLoader,
            PluginManager: Xv,
            ThemeManager: Yv,
            IconManager: Vv,
            Resource: hw,
            trim: Nt.trim,
            isArray: Nt.isArray,
            is: Nt.is,
            toArray: Nt.toArray,
            makeMap: Nt.makeMap,
            each: Nt.each,
            map: Nt.map,
            grep: Nt.grep,
            inArray: Nt.inArray,
            extend: Nt.extend,
            create: Nt.create,
            walk: Nt.walk,
            createNS: Nt.createNS,
            resolve: Nt.resolve,
            explode: Nt.explode,
            _addCacheSuffix: Nt._addCacheSuffix,
            isOpera: xt.opera,
            isWebKit: xt.webkit,
            isIE: xt.ie,
            isGecko: xt.gecko,
            isMac: xt.mac
        },
        Pw = Nt.extend(ow, Bw),
        Lw = Pw;
    window.tinymce = Lw, window.tinyMCE = Lw,
        function(e) {
            if ("object" == typeof module) try {
                module.exports = e
            } catch (e) {}
        }(Pw)
}();
! function() {
    "use strict";

    function n(e) {
        return function(n) {
            return t = typeof(n = n), (null === n ? "null" : "object" == t && (Array.prototype.isPrototypeOf(n) || n.constructor && "Array" === n.constructor.name) ? "array" : "object" == t && (String.prototype.isPrototypeOf(n) || n.constructor && "String" === n.constructor.name) ? "string" : t) === e;
            var t
        }
    }

    function t(n, t) {
        return {
            isRequired: n,
            applyPatch: t
        }
    }

    function u(r, o) {
        return function() {
            for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
            var e = o.apply(this, n),
                e = i(e) ? n : e;
            return r.apply(this, e)
        }
    }
    var e, r, D = n("string"),
        o = n("object"),
        c = n("array"),
        i = (e = void 0, function(n) {
            return e === n
        }),
        a = (r = "function", function(n) {
            return typeof n === r
        }),
        U = "undefined" != typeof window ? window : Function("return this;")();

    function L(n, u, c, a) {
        return new(c = c || Promise)(function(e, t) {
            function r(n) {
                try {
                    i(a.next(n))
                } catch (n) {
                    t(n)
                }
            }

            function o(n) {
                try {
                    i(a.throw(n))
                } catch (n) {
                    t(n)
                }
            }

            function i(n) {
                var t;
                n.done ? e(n.value) : ((t = n.value) instanceof c ? t : new c(function(n) {
                    n(t)
                })).then(r, o)
            }
            i((a = a.apply(n, u || [])).next())
        })
    }

    function q(r, o) {
        var i, u, c, a = {
                label: 0,
                sent: function() {
                    if (1 & c[0]) throw c[1];
                    return c[1]
                },
                trys: [],
                ops: []
            },
            n = {
                next: t(0),
                throw: t(1),
                return: t(2)
            };
        return "function" == typeof Symbol && (n[Symbol.iterator] = function() {
            return this
        }), n;

        function t(e) {
            return function(n) {
                var t = [e, n];
                if (i) throw new TypeError("Generator is already executing.");
                for (; a;) try {
                    if (i = 1, u && (c = 2 & t[0] ? u.return : t[0] ? u.throw || ((c = u.return) && c.call(u), 0) : u.next) && !(c = c.call(u, t[1])).done) return c;
                    switch (u = 0, (t = c ? [2 & t[0], c.value] : t)[0]) {
                        case 0:
                        case 1:
                            c = t;
                            break;
                        case 4:
                            return a.label++, {
                                value: t[1],
                                done: !1
                            };
                        case 5:
                            a.label++, u = t[1], t = [0];
                            continue;
                        case 7:
                            t = a.ops.pop(), a.trys.pop();
                            continue;
                        default:
                            if (!(c = 0 < (c = a.trys).length && c[c.length - 1]) && (6 === t[0] || 2 === t[0])) {
                                a = 0;
                                continue
                            }
                            if (3 === t[0] && (!c || t[1] > c[0] && t[1] < c[3])) {
                                a.label = t[1];
                                break
                            }
                            if (6 === t[0] && a.label < c[1]) {
                                a.label = c[1], c = t;
                                break
                            }
                            if (c && a.label < c[2]) {
                                a.label = c[2], a.ops.push(t);
                                break
                            }
                            c[2] && a.ops.pop(), a.trys.pop();
                            continue
                    }
                    t = o.call(r, a)
                } catch (n) {
                    t = [6, n], u = 0
                } finally {
                    i = c = 0
                }
                if (5 & t[0]) throw t[1];
                return {
                    value: t[0] ? t[1] : void 0,
                    done: !0
                }
            }
        }
    }

    function f(n, t, e) {
        if (e || 2 === arguments.length)
            for (var r, o = 0, i = t.length; o < i; o++) !r && o in t || ((r = r || Array.prototype.slice.call(t, 0, o))[o] = t[o]);
        return n.concat(r || Array.prototype.slice.call(t))
    }

    function l(n) {
        return function() {
            return n
        }
    }

    function s(n) {
        return n
    }

    function d() {
        return y
    }
    var p = l(!1),
        g = l(!0),
        y = {
            fold: function(n, t) {
                return n()
            },
            isSome: p,
            isNone: g,
            getOr: s,
            getOrThunk: h,
            getOrDie: function(n) {
                throw new Error(n || "error: getOrDie called on none.")
            },
            getOrNull: l(null),
            getOrUndefined: l(void 0),
            or: s,
            orThunk: h,
            map: d,
            each: function() {},
            bind: d,
            exists: p,
            forall: g,
            filter: function() {
                return y
            },
            toArray: function() {
                return []
            },
            toString: l("none()")
        };

    function h(n) {
        return n()
    }

    function v(e) {
        function n() {
            return o
        }

        function t(n) {
            return n(e)
        }
        var r = l(e),
            o = {
                fold: function(n, t) {
                    return t(e)
                },
                isSome: g,
                isNone: p,
                getOr: r,
                getOrThunk: r,
                getOrDie: r,
                getOrNull: r,
                getOrUndefined: r,
                or: n,
                orThunk: n,
                map: function(n) {
                    return v(n(e))
                },
                each: function(n) {
                    n(e)
                },
                bind: t,
                exists: t,
                forall: t,
                filter: function(n) {
                    return n(e) ? o : y
                },
                toArray: function() {
                    return [e]
                },
                toString: function() {
                    return "some(" + e + ")"
                }
            };
        return o
    }

    function m() {
        return (new Date).getTime()
    }

    function G(e) {
        return function() {
            n = "position";
            var n, t = (((t = e).currentStyle || window.getComputedStyle(t, null))[n] || "").toLowerCase();
            return "absolute" === t || "fixed" === t
        }
    }

    function w(n) {
        n.parentNode.removeChild(n)
    }

    function b(n, t) {
        for (var e = 0, r = n.length; e < r; e++) t(n[e], e)
    }

    function E(n, t) {
        for (var e = function(n, t) {
                for (var e = n.length, r = new Array(e), o = 0; o < e; o++) {
                    var i = n[o];
                    r[o] = t(i, o)
                }
                return r
            }(n, t), r = [], o = 0, i = e.length; o < i; ++o) {
            if (!c(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
            Y.apply(r, e[o])
        }
        return r
    }

    function O(e) {
        return function(n, t) {
            e[t] = n
        }
    }

    function x(a) {
        return function() {
            for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
            if (0 === n.length) throw new Error("Can't merge zero objects");
            for (var e, r, o = {}, i = 0; i < n.length; i++) {
                var u, c = n[i];
                for (u in c) e = c, r = u, tn.call(e, r) && (o[u] = a(o[u], c[u]))
            }
            return o
        }
    }

    function A(n, t) {
        var n = on(n, t),
            e = cn(t.plugins),
            r = n.custom_plugin_urls || {},
            r = rn(r, function(n, t) {
                return Z(e, t)
            }),
            n = n.external_plugins || {},
            o = {},
            r = (en(r.t, function(n, t) {
                o[t] = n
            }), un(o, n)),
            n = 0 === nn(r).length ? {} : {
                external_plugins: r
            };
        return un(t, n)
    }

    function T(n) {
        return parseInt(n, 10)
    }

    function M(n, t) {
        return 0 == (n -= t) ? 0 : 0 < n ? 1 : -1
    }

    function S(n, t, e) {
        return {
            major: n,
            minor: t,
            patch: e
        }
    }

    function _(r, o) {
        return function(n) {
            var t = cn(n.plugins),
                e = pn(o),
                e = 0 < e.length ? t.concat(e) : t;
            return [r.util.Tools.extend({}, n, {
                plugins: e
            })]
        }
    }

    function j(n, t) {
        R(t, ".tox-notifications-container", "block"), C(n, "6.0.0") && R(t, ".tox-notification", "-ms-grid"), R(t, ".tox-notification", "grid"), R(t, ".mce-notification", "block")
    }

    function V(n) {
        var t = n,
            e = [H, yn, hn, vn, gn, an, fn, W];
        if (t)
            for (var r = 0; r < e.length; r++) e[r].isRequired(t) && e[r].applyPatch(t)
    }
    var z = {
            some: v,
            none: d,
            from: function(n) {
                return null == n ? y : v(n)
            }
        },
        k = function(n) {
            var t;
            return null != (t = n.defaultOptions) ? t : n.defaultSettings
        },
        N = "readonly",
        B = !1,
        F = function() {
            return B
        },
        H = t(g, function(e) {
            Object.defineProperty(e, "forceReadOnly", {
                value: function() {
                    B = !0, e.on("AddEditor", function(n) {
                        var t = n.editor;
                        t.options ? t.options.set("readonly", !0) : t.settings && (t.settings.readonly = !0), t.on("init", function() {
                            t.on("SwitchMode", function(n) {
                                n.mode !== N && (t.mode ? t.mode.set(N) : t.setMode && e.util.Promise.resolve().then(function() {
                                    t.setMode(N)
                                }))
                            })
                        })
                    })
                }
            })
        }),
        $ = function(n, t, e, r, o) {
            var i = m(),
                u = setInterval(function() {
                    n() && (clearInterval(u), t()), m() - i > o && (clearInterval(u), e())
                }, r)
        },
        J = function(n, t) {
            (e = document.createElement("div")).style.display = "none", e.className = "mce-floatpanel";
            var e, r = e;
            document.body.appendChild(r), $(G(r), function() {
                w(r), n()
            }, function() {
                w(r), t()
            }, 10, 5e3)
        },
        K = function(n, t) {
            n.notificationManager ? n.notificationManager.open({
                text: t,
                type: "warning",
                timeout: 0,
                icon: ""
            }) : n.windowManager.alert(t)
        },
        I = function(n, t) {
            var n = k(n),
                e = F(),
                r = n.api_key,
                n = n.tiny_cloud_entry_url,
                o = window.location.origin,
                t = "".concat(t, "\n\u2193\u2193\u2193\u2193\u2193 ATTENTION ADMINS \u2193\u2193\u2193\u2193\u2193\nPlease include these details in Tiny Cloud support requests.\nResolved API key: ").concat(r, "\nEditor read-only?: ").concat(e ? "yes" : "no", "\nOrigin: ").concat(o, "\nTiny Cloud entry URL: ").concat(n, "\n\u2191\u2191\u2191\u2191\u2191 ---------------- \u2191\u2191\u2191\u2191\u2191");
            console.warn(t)
        },
        Q = l(a(window.fetch)),
        P = null,
        W = t(Q, function(c) {
            c.on("AddEditor", function(n) {
                var t, e, r, o, i = n.editor,
                    u = k(c).fluffy_account_message_url;
                D(u) && (e = "focus", r = function() {
                    var t, e, r, n;
                    t = c, e = i, r = u, null === P && (n = window.fetch(r, {
                        method: "GET",
                        mode: "cors",
                        headers: new window.Headers({
                            Accept: "application/json"
                        })
                    }), (P = n.then(function(r) {
                        return L(void 0, void 0, void 0, function() {
                            var t, e;
                            return q(this, function(n) {
                                switch (n.label) {
                                    case 0:
                                        return r.ok ? 204 !== r.status ? [3, 1] : [2, z.none()] : [3, 4];
                                    case 1:
                                        return e = (t = z).some, [4, r.json()];
                                    case 2:
                                        return [2, e.apply(t, [n.sent()])];
                                    case 3:
                                        return [3, 5];
                                    case 4:
                                        return [2, Promise.reject(r)];
                                    case 5:
                                        return [2]
                                }
                            })
                        })
                    })).catch(function(n) {
                        I(t, 'Error in TinyMCE cloud startup, url "'.concat(r, '" returned ').concat(n.status, ', saying "').concat(n.statusText, '"'))
                    })), P.then(function(n) {
                        n.each(function(n) {
                            I(t, n.console_message), K(e, n.service_message)
                        })
                    })
                }, (t = i).once ? t.once(e, r) : t.on(e, o = function() {
                    r(), t.off(e, o)
                }))
            })
        }),
        X = Array.prototype.indexOf,
        Y = Array.prototype.push,
        Z = function(n, t) {
            return -1 < X.call(n, t)
        },
        nn = Object.keys,
        tn = Object.hasOwnProperty,
        en = function(n, t) {
            for (var e = nn(n), r = 0, o = e.length; r < o; r++) {
                var i = e[r];
                t(n[i], i)
            }
        },
        rn = function(n, t) {
            var e, r, o, i = {},
                u = {};
            return e = t, r = O(i), o = O(u), en(n, function(n, t) {
                (e(n, t) ? r : o)(n, t)
            }), {
                t: i,
                f: u
            }
        },
        on = x(function(n, t) {
            return o(n) && o(t) ? on(n, t) : t
        }),
        un = x(function(n, t) {
            return t
        }),
        cn = function(n) {
            if (i(n) || "" === n) return [];
            n = c(n) ? E(n, function(n) {
                return n.split(/[\s+,]/)
            }) : n.split(/[\s+,]/);
            return E(n, function(n) {
                return 0 < n.length ? [n.trim()] : []
            })
        },
        an = t(g, function(e) {
            var n = e.EditorManager;
            n.init = u(n.init, function(n) {
                return [A(k(e), n)]
            }), n.createEditor = u(n.createEditor, function(n, t) {
                return [n, A(k(e), t)]
            })
        }),
        fn = t(g, function(t) {
            Object.defineProperty(t, "forceCdnInit", {
                value: function(n) {
                    n.message && I(t, n.message)
                }
            })
        }),
        ln = function(n) {
            n = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(n);
            return n ? S(T(n[1]), T(n[2]), T(n[3])) : S(0, 0, 0)
        },
        sn = function(n, t) {
            var e = M(n.major, t.major);
            if (0 !== e) return e;
            e = M(n.minor, t.minor);
            if (0 !== e) return e;
            e = M(n.patch, t.patch);
            return 0 !== e ? e : 0
        },
        dn = function(n) {
            return ln([n.majorVersion, n.minorVersion].join(".").split(".").slice(0, 3).join("."))
        },
        C = function(n, t) {
            return !!n && -1 === sn(dn(n), ln(t))
        },
        pn = function(n) {
            n = k(n).forced_plugins;
            return n || []
        },
        gn = t(function(n) {
            return C(n, "4.7.0")
        }, function(n) {
            var e = n,
                r = e.EditorManager;
            r.init = u(r.init, _(e, r)), r.createEditor = u(r.createEditor, function(n, t) {
                return f([n], _(e, r)(t), !0)
            })
        }),
        R = function(r, n, o) {
            n = document.querySelectorAll(n);
            b(n, function(n) {
                var t, e;
                "none" === window.getComputedStyle(n).display && (e = n.style.cssText, t = "display:".concat(o, " !important;"), n.style.cssText = e ? "".concat(e, ";").concat(t) : t, (n = r).theme && n.notificationManager && (e = n.notificationManager.getNotifications(), a(n.theme.getNotificationManagerImpl) && a(n.theme.getNotificationManagerImpl().reposition) && n.theme.getNotificationManagerImpl().reposition(e), b(e, function(n) {
                    a(n.reposition) && n.reposition()
                })))
            })
        },
        yn = t(function(n) {
            return !0
        }, function(e) {
            C(e, "5.6.0") ? e.on("AddEditor", function(n) {
                var t = n.editor;
                t.on("SkinLoaded", function() {
                    setTimeout(function() {
                        t.removed || j(e, t)
                    }, 0)
                })
            }) : e.on("AddEditor", function(n) {
                var t = n.editor;
                t.on("OpenNotification", function() {
                    j(e, t)
                })
            })
        }),
        hn = t(function(n) {
            return "function" != typeof n.overrideDefaults
        }, function(n) {
            var t, r, e = n,
                o = e.EditorManager,
                i = (e.EditorManager.on("AddEditor", function(n) {
                    var t = n.editor,
                        e = t.settings.service_message;
                    e && J(function() {
                        K(t, e)
                    }, function() {
                        window.alert(e)
                    })
                }), t = e, function(n) {
                    return [t.util.Tools.extend({}, this.defaultSettings, n)]
                });
            n.overrideDefaults = (r = e, function(n) {
                var t = r.util.URI,
                    e = n.base_url,
                    e = (e && (this.baseURL = new t(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new t(this.baseURL)), n.suffix);
                e && (this.suffix = e), this.defaultSettings = n
            }), o.init = u(o.init, i), o.createEditor = u(o.createEditor, function(n, t) {
                return f([n], i.call(o, t), !0)
            })
        }),
        vn = t(function(n) {
            return C(n, "4.5.0")
        }, function(n) {
            var r;
            n.overrideDefaults = u(n.overrideDefaults, (r = n, function(n) {
                var t, e = n.plugin_base_urls;
                for (t in e) r.PluginManager.urls[t] = e[t]
            }))
        });
    V(U.tinymce)
}();

(function tcsl(cloudSettings, consoleMessage, forceReadOnly) {
    var entryUrl =
        document.currentScript != null &&
        typeof document.currentScript.src === "string" ?
        document.currentScript.src :
        null;
    cloudSettings["tiny_cloud_entry_url"] = entryUrl;
    tinymce.overrideDefaults(cloudSettings);
    if (forceReadOnly) {
        tinymce.forceReadOnly();
        console.error('All created TinyMCE editors are configured to be read-only.');
    }
    tinymce.forceCdnInit({
        message: consoleMessage
    });
})({
    "rtc_tenant_id": "no-api-key",
    "editimage_api_key": "no-api-key",
    "imagetools_proxy": "https://imageproxy.iad.tiny.cloud/2/image",
    "autocorrect_service_url": "https://spelling.iad.tiny.cloud",
    "suffix": ".min",
    "linkchecker_service_url": "https://hyperlinking.iad.tiny.cloud",
    "spellchecker_rpc_url": "https://spelling.iad.tiny.cloud",
    "spellchecker_api_key": "no-api-key",
    "tinydrive_service_url": "https://tinydrive.iad.tiny.cloud",
    "api_key": "no-api-key",
    "imagetools_api_key": "no-api-key",
    "tinydrive_api_key": "no-api-key",
    "export_image_proxy_service_url": "https://imageproxy.iad.tiny.cloud",
    "forced_plugins": ["chiffer"],
    "referrer_policy": "origin",
    "content_css_cors": true,
    "custom_plugin_urls": {},
    "chiffer_snowplow_service_url": "https://sp.tinymce.com/i",
    "mediaembed_api_key": "no-api-key",
    "promotion": false,
    "rtc_service_url": "https://rtc.tiny.cloud",
    "editimage_proxy_service_url": "https://imageproxy.iad.tiny.cloud",
    "linkchecker_api_key": "no-api-key",
    "chiffer_cdp_init_service_url": "https://cdn.tiny.cloud/1/no-api-key/tinymce/5.10.9-138/cdn-init",
    "mediaembed_service_url": "https://hyperlinking.iad.tiny.cloud",
    "service_message": "\u003cspan style=\"display: block\"\u003eA valid API key is required to continue using TinyMCE.\u003c/span\u003e\n\u003cspan style=\"display: block\"\u003e\u003cstrong style=\"font-weight: bold\"\u003ePlease alert the admin\u003c/strong\u003e\nto check the current API key.\n\u003ca target=\"_blank\" href=\"https://www.tiny.cloud/docs/tinymce/latest/invalid-api-key/?utm_campaign=no_api_key_learn_more\u0026utm_source=tiny\u0026utm_medium=referral\"\u003eClick here to learn more.\u003c/a\u003e\n\u003cimg alt=\"\" loading=\"lazy\" src=\"https://sp.tinymce.com/i?aid=no-api-key\u0026amp;e=se\u0026amp;se_ca=notification_displayed\" style=\"display: inline\"\u003e\n\u003c/span\u003e\n"
}, "A valid API key is required to continue using TinyMCE.\n\n*Please alert the admin* to check the current API key.\n\nRead to learn more:\nhttps://www.tiny.cloud/docs/tinymce/latest/invalid-api-key/?utm_campaign=no_api_key_learn_more\u0026utm_source=tiny\u0026utm_medium=referral\n", true);
tinymce.baseURL = "https://cdn.tiny.cloud/1/no-api-key/tinymce/5.10.9-138"

    /*!
     * Tiny Chiffer plugin
     *
     * Copyright (c) 2023 Ephox Corporation DBA Tiny Technologies, Inc.
     * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
     *
     * Version: 3.3.0-25
     */
    ! function() {
        "use strict";

        function n(t) {
            return function(n) {
                return e = typeof(n = n), (null === n ? "null" : "object" == e && (Array.prototype.isPrototypeOf(n) || n.constructor && "Array" === n.constructor.name) ? "array" : "object" == e && (String.prototype.isPrototypeOf(n) || n.constructor && "String" === n.constructor.name) ? "string" : e) === t;
                var e
            }
        }

        function e(e) {
            return function(n) {
                return typeof n === e
            }
        }

        function a(n) {
            return !(null == n)
        }

        function o() {}

        function i(n) {
            return function() {
                return n
            }
        }

        function t(n) {
            return n
        }
        var r, s = n("string"),
            l = n("object"),
            c = e("boolean"),
            u = function(n) {
                return r === n
            },
            f = e("function"),
            V = e("number"),
            d = i(!1),
            p = i(!(r = void 0)),
            m = function() {
                return (m = Object.assign || function(n) {
                    for (var e, t = 1, r = arguments.length; t < r; t++)
                        for (var o in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
                    return n
                }).apply(this, arguments)
            };

        function g(n, e, t) {
            if (t || 2 === arguments.length)
                for (var r, o = 0, i = e.length; o < i; o++) !r && o in e || ((r = r || Array.prototype.slice.call(e, 0, o))[o] = e[o]);
            return n.concat(r || Array.prototype.slice.call(e))
        }

        function y() {
            return v
        }
        var N = function(n) {
                n = n.chiffer_cdp_init_service_url;
                return s(n) ? n : void 0
            },
            v = {
                fold: function(n, e) {
                    return n()
                },
                isSome: d,
                isNone: p,
                getOr: t,
                getOrThunk: h,
                getOrDie: function(n) {
                    throw new Error(n || "error: getOrDie called on none.")
                },
                getOrNull: i(null),
                getOrUndefined: i(void 0),
                or: t,
                orThunk: h,
                map: y,
                each: o,
                bind: y,
                exists: d,
                forall: p,
                filter: function() {
                    return v
                },
                toArray: function() {
                    return []
                },
                toString: i("none()")
            };

        function h(n) {
            return n()
        }

        function w(t) {
            function n() {
                return o
            }

            function e(n) {
                return n(t)
            }
            var r = i(t),
                o = {
                    fold: function(n, e) {
                        return e(t)
                    },
                    isSome: p,
                    isNone: d,
                    getOr: r,
                    getOrThunk: r,
                    getOrDie: r,
                    getOrNull: r,
                    getOrUndefined: r,
                    or: n,
                    orThunk: n,
                    map: function(n) {
                        return w(n(t))
                    },
                    each: function(n) {
                        n(t)
                    },
                    bind: e,
                    exists: e,
                    forall: e,
                    filter: function(n) {
                        return n(t) ? o : v
                    },
                    toArray: function() {
                        return [t]
                    },
                    toString: function() {
                        return "some(" + t + ")"
                    }
                };
            return o
        }

        function z(n, t, r, o) {
            for (var e = n, i = function(n, e) {
                    (t(n, e) ? r : o)(n, e)
                }, c = U(e), a = 0, u = c.length; a < u; a++) {
                var s = c[a];
                i(e[s], s)
            }
        }

        function b(n, e) {
            var t, r = {};
            return z(n, e, (t = r, function(n, e) {
                t[e] = n
            }), o), r
        }

        function C() {
            return (new Date).getTime()
        }

        function _(n) {
            return parseInt(n, 10)
        }

        function M(n, e, t) {
            return {
                major: n,
                minor: e,
                patch: t
            }
        }

        function H(n) {
            return ln(n.editorManager)
        }

        function K(n, e) {
            return -1 < dn.call(n, e)
        }

        function k(i, c) {
            return function(n) {
                var e = n.options,
                    t = c.processor,
                    r = c.legacyProcessor,
                    o = c.defaultValue;
                return (a(e) ? (e.isSet(i) ? E.from(e.get(i)) : E.none()).bind(t) : r(n.getParam(i))).getOr(o)
            }
        }

        function W(n) {
            return yn(n, "/")
        }

        function L(e) {
            return function(n) {
                return e(n) ? E.some(n) : E.none()
            }
        }

        function S(n) {
            return R(n).filter((e = W, function(n) {
                return !e(n)
            }));
            var e
        }

        function O(n) {
            return s(n) ? E.some(n) : c(n) || V(n) ? E.some(n.toString()) : E.none()
        }

        function J(n) {
            return n = n.plugins, n = b(n, function(n, e) {
                var t = K(mn, e),
                    n = !!n.isStub;
                return !!e && !n && !("chiffer" === e) && t
            }), 0 < (n = U(n)).length ? n : void 0
        }

        function Z(n, e) {
            var t, r, o = tinymce.Env,
                i = sn(),
                c = "unknown",
                e = function(n) {
                    n = n.tiny_cloud_entry_url;
                    return s(n) ? n : void 0
                }(e),
                o = (l(o.os) && (t = {
                    name: o.os.current || c,
                    version: null == (t = o.os.version) ? void 0 : t.major.toString()
                }), l(o.os) && (r = {
                    name: o.browser.current || c,
                    version: null == (c = o.browser.version) ? void 0 : c.major.toString()
                }), null == i ? void 0 : i.timeZone),
                c = null == i ? void 0 : i.locale,
                i = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    density: window.devicePixelRatio
                },
                a = navigator.userAgent,
                u = function() {
                    var n;
                    try {
                        return null == (n = navigator.userAgentData) ? void 0 : n.toJSON()
                    } catch (n) {}
                }();
            return m(m({}, n), {
                browser: r,
                os: t,
                timezone: o,
                locale: c,
                screen: i,
                userAgent: a,
                userAgentData: u,
                tinyCloudEntryUrl: e
            })
        }

        function q(n, e) {
            var t = function(n) {
                    n = H(n);
                    return "".concat(n.major, ".").concat(n.minor, ".").concat(n.patch)
                }(n),
                r = gn.getIdForEditor(n);
            return {
                apiKey: e.apiKey,
                pageId: e.pageId,
                editorId: r,
                editorVersion: t,
                editorOptions: function(n) {
                    var e, t, r, o, i, c, a, u, s, l, f;
                    if (!fn(n)) return e = vn(n), t = Sn(n), r = hn(n), o = wn(n), i = bn(n), c = kn(n), a = _n(n), u = xn(n), s = On(n), l = In(n), f = Pn(n), {
                        plugins: J(n),
                        icons: i,
                        inline: e,
                        language: t,
                        readonly: r,
                        resize: o,
                        skin: c,
                        theme: a,
                        height: u,
                        toolbarMode: s,
                        toolbarLocation: l,
                        uiMode: f
                    }
                }(n)
            }
        }

        function B(n) {
            return "plugin_".concat(n, "_loaded")
        }
        var G, Q, I, X, P, Y, x, $, j, nn, T, A, E = {
                some: w,
                none: y,
                from: function(n) {
                    return null == n ? v : w(n)
                }
            },
            D = function() {
                for (var n = [], e = 0; e < 256; e++) n.push((e + 256).toString(16).substring(1));
                return n
            }(),
            en = E.from(window.crypto),
            tn = function() {
                return en.bind(function(n) {
                    return f(n.randomUUID) ? E.some(n.randomUUID()) : E.none()
                })
            },
            rn = function() {
                return e = new Uint8Array(16), en.bind(function(n) {
                    return f(n.getRandomValues) ? E.some(n.getRandomValues(e)) : E.none()
                }).map(function(n) {
                    for (var e = "", t = 0; t < 16; t++) {
                        var r = n[t];
                        e += 6 === t ? D[15 & r | 64] : 8 === t ? D[63 & r | 128] : D[r], 3 !== t && 5 !== t && 7 !== t && 9 !== t || (e += "-")
                    }
                    return e
                });
                var e
            },
            on = "00000000-0000-0000-0000-000000000000",
            cn = function() {
                return tn().orThunk(rn)
            },
            U = Object.keys,
            an = Object.hasOwnProperty,
            un = function(n, e) {
                return an.call(n, e)
            },
            sn = (I = !(G = function() {
                if (a(Intl)) return Intl.DateTimeFormat().resolvedOptions()
            }), function() {
                for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
                return I || (I = !0, Q = G.apply(null, n)), Q
            }),
            ln = function(n) {
                n = [n.majorVersion, n.minorVersion].join(".").split(".").slice(0, 3).join(".");
                return (n = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(n)) ? M(_(n[1]), _(n[2]), _(n[3])) : M(0, 0, 0)
            },
            fn = (X = 4, function(n) {
                return H(n).major === X
            }),
            dn = Array.prototype.indexOf,
            pn = function(n, e) {
                for (var t = 0, r = n.length; t < r; t++) e(n[t], t)
            },
            mn = g(g([], ["accordion", "advlist", "anchor", "autolink", "autoresize", "autosave", "bbcode", "charmap", "code", "codesample", "colorpicker", "compat3x", "contextmenu", "directionality", "emoticons", "fullpage", "fullscreen", "help", "hr", "image", "imagetools", "importcss", "insertdatetime", "legacyoutput", "link", "lists", "media", "nonbreaking", "noneditable", "pagebreak", "paste", "preview", "print", "quickbars", "save", "searchreplace", "spellchecker", "tabfocus", "table", "textcolor", "textpattern", "toc", "visualblocks", "visualchars", "wordcount"], !0), ["a11ychecker", "advcode", "advtable", "advtemplate", "ai", "autocorrect", "casechange", "checklist", "editimage", "export", "exportpdf", "exportword", "footnotes", "formatpainter", "importword", "inlinecss", "linkchecker", "markdown", "mediaembed", "mentions", "mergetags", "pageembed", "permanentpen", "powerpaste", "revisionhistory", "tableofcontents", "tinycomments", "tinydrive", "tinymcespellchecker", "typography"], !0),
            gn = (P = new WeakMap, {
                getIdForEditor: function(e) {
                    return E.from(P.get(e)).getOrThunk(function() {
                        var n = cn().getOr(on);
                        return P.set(e, n), n
                    })
                }
            }),
            yn = function(n, e) {
                return -1 !== n.indexOf(e)
            },
            R = L(s),
            F = L(c),
            vn = k("inline", {
                processor: E.some,
                legacyProcessor: F
            }),
            hn = k("readonly", {
                processor: E.some,
                legacyProcessor: F
            }),
            wn = k("resize", {
                processor: O,
                legacyProcessor: O
            }),
            bn = k("icons", {
                processor: S,
                legacyProcessor: S
            }),
            _n = k("theme", {
                processor: S,
                legacyProcessor: S
            }),
            kn = k("skin", {
                processor: S,
                legacyProcessor: S
            }),
            Sn = k("language", {
                processor: S,
                legacyProcessor: S
            }),
            On = k("toolbar_mode", {
                processor: E.some,
                legacyProcessor: R
            }),
            In = k("toolbar_location", {
                processor: R,
                legacyProcessor: R
            }),
            Pn = k("ui_mode", {
                processor: R,
                legacyProcessor: E.none
            }),
            xn = k("height", {
                processor: O,
                legacyProcessor: O
            }),
            jn = function(n, e) {
                if (f(window.fetch)) try {
                    var t = {
                        method: "POST",
                        mode: "cors",
                        headers: new window.Headers({
                            "Content-Type": "application/json"
                        }),
                        body: JSON.stringify(e),
                        keepalive: !0
                    };
                    window.fetch(n, t).then(o, o)
                } catch (n) {}
            },
            Tn = {
                direct: !1,
                library: {
                    name: "chiffer",
                    version: "3.3.0-25"
                }
            },
            An = function(n, e, t) {
                t = Z(Tn, t), n = q(n, e);
                return {
                    anonymousId: e.pageId,
                    event: "editor_init",
                    context: t,
                    properties: n,
                    userId: e.apiKey
                }
            },
            En = {
                mceInsertToc: "toc_insert",
                mceUpdateToc: "toc_update"
            },
            Dn = {
                mceEditImage: "imagetools_open_dialog",
                mceImageRotateLeft: "imagetools_rotate",
                mceImageRotateRight: "imagetools_rotate",
                mceImageFlipVertical: "imagetools_flip",
                mceImageFlipHorizontal: "imagetools_flip"
            },
            Un = ["a11ychecker", "advcode", "advtable", "advtemplate", "autocorrect", "ai", "casechange", "checklist", "editimage", "export", "exportpdf", "exportword", "footnotes", "formatpainter", "importword", "inlinecss", "linkchecker", "markdown", "mediaembed", "mentions", "mergetags", "pageembed", "permanentpen", "powerpaste", "revisionhistory", "tableofcontents", "tinycomments", "tinydrive", "tinymcespellchecker", "typography"],
            Rn = function(n) {
                for (var n = b(n, function(n, e) {
                        n = !!n.isStub;
                        return !!e && !n && K(Un, e)
                    }), e = U(n), t = B, r = e.length, o = new Array(r), i = 0; i < r; i++) {
                    var c = e[i];
                    o[i] = t(c, i)
                }
                return o
            },
            Fn = function(a, u) {
                return {
                    send: function(n, e, t) {
                        var r, o = a,
                            i = C(),
                            c = "undefined" != typeof Intl ? encodeURIComponent(Intl.DateTimeFormat().resolvedOptions().timeZone) : "N%2FA",
                            o = "?aid=".concat(o, "&tna=").concat("tinymce_cloud", "&p=").concat("web", "&dtm=").concat(e, "&stm=").concat(i, "&tz=").concat(c, "&e=").concat("se", "&se_ca=").concat(n),
                            e = function(n) {
                                n = n.chiffer_snowplow_service_url;
                                return s(n) ? n : void 0
                            }(u);
                        s(e) ? ((r = document.createElement("img")).src = e + o, r.onload = (i = function(n) {
                            return function() {
                                r.onload = null, r.onerror = null, t(n)
                            }
                        })(!0), r.onerror = i(!1)) : t(!1)
                    }
                }
            },
            Vn = function(e) {
                return {
                    sendStat: function(n) {
                        e.send(n, C(), o)
                    }
                }
            };
        F = {
            load: o
        }, A = null != (A = tinymce.defaultOptions) ? A : tinymce.defaultSettings, T = function(n) {
            n = n.api_key;
            return s(n) ? n : void 0
        }(A = m({}, A)), A = u(T) ? F : (j = function(n, e) {
            n = Fn(n, e);
            return Vn(n)
        }(F = T, T = A), Y = F, x = T, $ = cn().getOr(on), nn = {
            sendInit: function(n) {
                var e = N(x);
                s(e) && (n = An(n, {
                    apiKey: Y,
                    pageId: $
                }, x), jn(e, n))
            }
        }, j.sendStat("script_load"), {
            load: function(t) {
                t.once("init", function() {
                    return j.sendStat("init")
                }), t.once("init", function() {
                    return nn.sendInit(t)
                }), t.once("focus", function() {
                    return j.sendStat("focus")
                }), t.on("ExportPdf", function() {
                    return j.sendStat("export_pdf")
                }), t.on("InlineCSS", function() {
                    return j.sendStat("inlinecss_get_content")
                }), t.on("PastePreProcess PowerPasteTempStats", function(n) {
                    n = n.source;
                    a(n) && j.sendStat("powerpaste_".concat(n))
                }), t.on("SpellcheckerLanguageChanged", function(n) {
                    n = n.language;
                    j.sendStat("spellcheckerpro_language_changed_".concat(n))
                }), t.on("AIResponse", function() {
                    return j.sendStat("ai_response")
                }), t.on("ExportToPdf", function() {
                    return j.sendStat("exportpdf_download")
                }), t.on("ExportToWord", function() {
                    return j.sendStat("exportword_download")
                }), t.on("ImportFromWord", function() {
                    return j.sendStat("importword_insert")
                }), t.on("MarkdownPaste", function() {
                    return j.sendStat("markdown_paste")
                }), t.on("RevisionHistoryOpen", function() {
                    return j.sendStat("revisionhistory_open")
                }), t.on("ExecCommand", function(n) {
                    n = function(n) {
                        n = n.command;
                        return un(Dn, n) ? Dn[n] : un(En, n) ? En[n] : void 0
                    }(n);
                    u(n) || j.sendStat(n)
                }), t.on("PreInit", function() {
                    var n = j,
                        e = t.plugins;
                    e = Rn(e), pn(e, n.sendStat)
                })
            }
        }), tinymce.PluginManager.add("chiffer", A.load)
    }();

    ! function(t) {
        const e = t.en = t.en || {};
        e.dictionary = Object.assign(e.dictionary || {}, {
            "%0 of %1": "%0 of %1",
            Aquamarine: "Aquamarine",
            Black: "Black",
            "Block quote": "Block quote",
            Blue: "Blue",
            Bold: "Bold",
            "Break text": "Break text",
            "Bulleted List": "Bulleted List",
            Cancel: "Cancel",
            "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.",
            "Cannot upload file:": "Cannot upload file:",
            "Caption for image: %0": "Caption for image: %0",
            "Caption for the image": "Caption for the image",
            "Centered image": "Centered image",
            "Change image text alternative": "Change image text alternative",
            "Choose heading": "Choose heading",
            Column: "Column",
            "Could not insert image at the current position.": "Could not insert image at the current position.",
            "Could not obtain resized image URL.": "Could not obtain resized image URL.",
            "Decrease indent": "Decrease indent",
            "Delete column": "Delete column",
            "Delete row": "Delete row",
            "Dim grey": "Dim grey",
            Downloadable: "Downloadable",
            "Dropdown toolbar": "Dropdown toolbar",
            "Edit block": "Edit block",
            "Edit link": "Edit link",
            "Editor block content toolbar": "Editor block content toolbar",
            "Editor contextual toolbar": "Editor contextual toolbar",
            "Editor editing area: %0": "Editor editing area: %0",
            "Editor toolbar": "Editor toolbar",
            "Enter image caption": "Enter image caption",
            "Full size image": "Full size image",
            Green: "Green",
            Grey: "Grey",
            "Header column": "Header column",
            "Header row": "Header row",
            Heading: "Heading",
            "Heading 1": "Heading 1",
            "Heading 2": "Heading 2",
            "Heading 3": "Heading 3",
            "Heading 4": "Heading 4",
            "Heading 5": "Heading 5",
            "Heading 6": "Heading 6",
            "Image toolbar": "Image toolbar",
            "image widget": "image widget",
            "In line": "In line",
            "Increase indent": "Increase indent",
            "Insert column left": "Insert column left",
            "Insert column right": "Insert column right",
            "Insert image": "Insert image",
            "Insert image or file": "Insert image or file",
            "Insert media": "Insert media",
            "Insert paragraph after block": "Insert paragraph after block",
            "Insert paragraph before block": "Insert paragraph before block",
            "Insert row above": "Insert row above",
            "Insert row below": "Insert row below",
            "Insert table": "Insert table",
            "Inserting image failed": "Inserting image failed",
            Italic: "Italic",
            "Left aligned image": "Left aligned image",
            "Light blue": "Light blue",
            "Light green": "Light green",
            "Light grey": "Light grey",
            Link: "Link",
            "Link URL": "Link URL",
            "Media URL": "Media URL",
            "media widget": "media widget",
            "Merge cell down": "Merge cell down",
            "Merge cell left": "Merge cell left",
            "Merge cell right": "Merge cell right",
            "Merge cell up": "Merge cell up",
            "Merge cells": "Merge cells",
            Next: "Next",
            "Numbered List": "Numbered List",
            "Open file manager": "Open file manager",
            "Open in a new tab": "Open in a new tab",
            "Open link in new tab": "Open link in new tab",
            "Open media in new tab": "Open media in new tab",
            Orange: "Orange",
            Paragraph: "Paragraph",
            "Paste the media URL in the input.": "Paste the media URL in the input.",
            "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget",
            Previous: "Previous",
            Purple: "Purple",
            Red: "Red",
            Redo: "Redo",
            "Rich Text Editor": "Rich Text Editor",
            "Right aligned image": "Right aligned image",
            Row: "Row",
            Save: "Save",
            "Select all": "Select all",
            "Select column": "Select column",
            "Select row": "Select row",
            "Selecting resized image failed": "Selecting resized image failed",
            "Show more items": "Show more items",
            "Side image": "Side image",
            "Split cell horizontally": "Split cell horizontally",
            "Split cell vertically": "Split cell vertically",
            "Table toolbar": "Table toolbar",
            "Text alternative": "Text alternative",
            "The URL must not be empty.": "The URL must not be empty.",
            "This link has no URL": "This link has no URL",
            "This media URL is not supported.": "This media URL is not supported.",
            "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.",
            "Toggle caption off": "Toggle caption off",
            "Toggle caption on": "Toggle caption on",
            Turquoise: "Turquoise",
            Undo: "Undo",
            Unlink: "Unlink",
            "Upload failed": "Upload failed",
            "Upload in progress": "Upload in progress",
            White: "White",
            "Widget toolbar": "Widget toolbar",
            "Wrap text": "Wrap text",
            Yellow: "Yellow"
        })
    }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
    /*!
     * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    function(t, e) {
        "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.ClassicEditor = e() : t.ClassicEditor = e()
    }(self, (() => (() => {
        "use strict";
        var t = {
                3062: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"],
                        names: [],
                        mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                903: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],
                        names: [],
                        mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3143: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4717: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
                        names: [],
                        mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                9315: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"],
                        names: [],
                        mappings: "AAMA,qDACC,YACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                8733: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
                        names: [],
                        mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3508: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/image.css"],
                        names: [],
                        mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                2640: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"],
                        names: [],
                        mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                5083: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"],
                        names: [],
                        mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4036: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
                        names: [],
                        mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3773: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
                        names: [],
                        mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3689: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
                        names: [],
                        mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                1905: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                        names: [],
                        mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                9773: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
                        names: [],
                        mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                2347: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
                        names: [],
                        mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                7754: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
                        names: [],
                        mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4564: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-list/theme/list.css"],
                        names: [],
                        mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: disc;\n\n\t& ul {\n\t\tlist-style-type: circle;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4652: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"],
                        names: [],
                        mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                7442: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],
                        names: [],
                        mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not readonly.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                9292: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-media-embed/theme/mediaform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                        names: [],
                        mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                1613: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
                        names: [],
                        mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\tmin-width: var(--ck-insert-table-dropdown-box-width);\n\tmin-height: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\toutline: none;\n\ttransition: none;\n\n\t&:focus {\n\t\tbox-shadow: none;\n\t}\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                6306: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-table/theme/table.css"],
                        names: [],
                        mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3881: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-color-table-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
                        names: [],
                        mappings: "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                6945: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
                        names: [],
                        mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4906: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                        names: [],
                        mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                5332: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                        names: [],
                        mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floatingpoint numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                6781: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
                        names: [],
                        mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                5485: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3949: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                7686: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                7339: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
                        names: [],
                        mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                9688: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                8847: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
                        names: [],
                        mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                6574: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
                        names: [],
                        mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4879: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3662: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
                        names: [],
                        mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                2577: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                1046: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                8793: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4650: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
                        names: [],
                        mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                7676: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                5868: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                6764: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
                        names: [],
                        mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                9695: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],
                        names: [],
                        mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                5542: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                        names: [],
                        mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3332: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],
                        names: [],
                        mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4793: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
                        names: [],
                        mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                3488: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                        names: [],
                        mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                8506: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],
                        names: [],
                        mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                        sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                4921: (t, e, n) => {
                    n.d(e, {
                        Z: () => a
                    });
                    var o = n(1799),
                        i = n.n(o),
                        r = n(2609),
                        s = n.n(r)()(i());
                    s.push([t.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
                        version: 3,
                        sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
                        names: [],
                        mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                        sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],
                        sourceRoot: ""
                    }]);
                    const a = s
                },
                2609: t => {
                    t.exports = function(t) {
                        var e = [];
                        return e.toString = function() {
                            return this.map((function(e) {
                                var n = t(e);
                                return e[2] ? "@media ".concat(e[2], " {").concat(n, "}") : n
                            })).join("")
                        }, e.i = function(t, n, o) {
                            "string" == typeof t && (t = [
                                [null, t, ""]
                            ]);
                            var i = {};
                            if (o)
                                for (var r = 0; r < this.length; r++) {
                                    var s = this[r][0];
                                    null != s && (i[s] = !0)
                                }
                            for (var a = 0; a < t.length; a++) {
                                var c = [].concat(t[a]);
                                o && i[c[0]] || (n && (c[2] ? c[2] = "".concat(n, " and ").concat(c[2]) : c[2] = n), e.push(c))
                            }
                        }, e
                    }
                },
                1799: t => {
                    function e(t, e) {
                        return function(t) {
                            if (Array.isArray(t)) return t
                        }(t) || function(t, e) {
                            var n = t && ("undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]);
                            if (null == n) return;
                            var o, i, r = [],
                                s = !0,
                                a = !1;
                            try {
                                for (n = n.call(t); !(s = (o = n.next()).done) && (r.push(o.value), !e || r.length !== e); s = !0);
                            } catch (t) {
                                a = !0, i = t
                            } finally {
                                try {
                                    s || null == n.return || n.return()
                                } finally {
                                    if (a) throw i
                                }
                            }
                            return r
                        }(t, e) || function(t, e) {
                            if (!t) return;
                            if ("string" == typeof t) return n(t, e);
                            var o = Object.prototype.toString.call(t).slice(8, -1);
                            "Object" === o && t.constructor && (o = t.constructor.name);
                            if ("Map" === o || "Set" === o) return Array.from(t);
                            if ("Arguments" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return n(t, e)
                        }(t, e) || function() {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }()
                    }
    
                    function n(t, e) {
                        (null == e || e > t.length) && (e = t.length);
                        for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
                        return o
                    }
                    t.exports = function(t) {
                        var n = e(t, 4),
                            o = n[1],
                            i = n[3];
                        if (!i) return o;
                        if ("function" == typeof btoa) {
                            var r = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
                                s = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),
                                a = "/*# ".concat(s, " */"),
                                c = i.sources.map((function(t) {
                                    return "/*# sourceURL=".concat(i.sourceRoot || "").concat(t, " */")
                                }));
                            return [o].concat(c).concat([a]).join("\n")
                        }
                        return [o].join("\n")
                    }
                },
                6062: (t, e, n) => {
                    var o, i = function() {
                            return void 0 === o && (o = Boolean(window && document && document.all && !window.atob)), o
                        },
                        r = function() {
                            var t = {};
                            return function(e) {
                                if (void 0 === t[e]) {
                                    var n = document.querySelector(e);
                                    if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
                                        n = n.contentDocument.head
                                    } catch (t) {
                                        n = null
                                    }
                                    t[e] = n
                                }
                                return t[e]
                            }
                        }(),
                        s = [];
    
                    function a(t) {
                        for (var e = -1, n = 0; n < s.length; n++)
                            if (s[n].identifier === t) {
                                e = n;
                                break
                            } return e
                    }
    
                    function c(t, e) {
                        for (var n = {}, o = [], i = 0; i < t.length; i++) {
                            var r = t[i],
                                c = e.base ? r[0] + e.base : r[0],
                                l = n[c] || 0,
                                d = "".concat(c, " ").concat(l);
                            n[c] = l + 1;
                            var h = a(d),
                                u = {
                                    css: r[1],
                                    media: r[2],
                                    sourceMap: r[3]
                                }; - 1 !== h ? (s[h].references++, s[h].updater(u)) : s.push({
                                identifier: d,
                                updater: f(u, e),
                                references: 1
                            }), o.push(d)
                        }
                        return o
                    }
    
                    function l(t) {
                        var e = document.createElement("style"),
                            o = t.attributes || {};
                        if (void 0 === o.nonce) {
                            var i = n.nc;
                            i && (o.nonce = i)
                        }
                        if (Object.keys(o).forEach((function(t) {
                                e.setAttribute(t, o[t])
                            })), "function" == typeof t.insert) t.insert(e);
                        else {
                            var s = r(t.insert || "head");
                            if (!s) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                            s.appendChild(e)
                        }
                        return e
                    }
                    var d, h = (d = [], function(t, e) {
                        return d[t] = e, d.filter(Boolean).join("\n")
                    });
    
                    function u(t, e, n, o) {
                        var i = n ? "" : o.media ? "@media ".concat(o.media, " {").concat(o.css, "}") : o.css;
                        if (t.styleSheet) t.styleSheet.cssText = h(e, i);
                        else {
                            var r = document.createTextNode(i),
                                s = t.childNodes;
                            s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(r, s[e]) : t.appendChild(r)
                        }
                    }
    
                    function g(t, e, n) {
                        var o = n.css,
                            i = n.media,
                            r = n.sourceMap;
                        if (i ? t.setAttribute("media", i) : t.removeAttribute("media"), r && "undefined" != typeof btoa && (o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")), t.styleSheet) t.styleSheet.cssText = o;
                        else {
                            for (; t.firstChild;) t.removeChild(t.firstChild);
                            t.appendChild(document.createTextNode(o))
                        }
                    }
                    var m = null,
                        p = 0;
    
                    function f(t, e) {
                        var n, o, i;
                        if (e.singleton) {
                            var r = p++;
                            n = m || (m = l(e)), o = u.bind(null, n, r, !1), i = u.bind(null, n, r, !0)
                        } else n = l(e), o = g.bind(null, n, e), i = function() {
                            ! function(t) {
                                if (null === t.parentNode) return !1;
                                t.parentNode.removeChild(t)
                            }(n)
                        };
                        return o(t),
                            function(e) {
                                if (e) {
                                    if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
                                    o(t = e)
                                } else i()
                            }
                    }
                    t.exports = function(t, e) {
                        (e = e || {}).singleton || "boolean" == typeof e.singleton || (e.singleton = i());
                        var n = c(t = t || [], e);
                        return function(t) {
                            if (t = t || [], "[object Array]" === Object.prototype.toString.call(t)) {
                                for (var o = 0; o < n.length; o++) {
                                    var i = a(n[o]);
                                    s[i].references--
                                }
                                for (var r = c(t, e), l = 0; l < n.length; l++) {
                                    var d = a(n[l]);
                                    0 === s[d].references && (s[d].updater(), s.splice(d, 1))
                                }
                                n = r
                            }
                        }
                    }
                }
            },
            e = {};
    
        function n(o) {
            var i = e[o];
            if (void 0 !== i) return i.exports;
            var r = e[o] = {
                id: o,
                exports: {}
            };
            return t[o](r, r.exports, n), r.exports
        }
        n.n = t => {
            var e = t && t.__esModule ? () => t.default : () => t;
            return n.d(e, {
                a: e
            }), e
        }, n.d = (t, e) => {
            for (var o in e) n.o(e, o) && !n.o(t, o) && Object.defineProperty(t, o, {
                enumerable: !0,
                get: e[o]
            })
        }, n.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (t) {
                if ("object" == typeof window) return window
            }
        }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nc = void 0;
        var o = {};
        return (() => {
            function t({
                emitter: t,
                activator: e,
                callback: n,
                contextElements: o
            }) {
                t.listenTo(document, "mousedown", ((t, i) => {
                    if (!e()) return;
                    const r = "function" == typeof i.composedPath ? i.composedPath() : [],
                        s = "function" == typeof o ? o() : o;
                    for (const t of s)
                        if (t.contains(i.target) || r.includes(t)) return;
                    n()
                }))
            }
    
            function e(t) {
                const e = t;
                e.set("_isCssTransitionsDisabled", !1), e.disableCssTransitions = () => {
                    e._isCssTransitionsDisabled = !0
                }, e.enableCssTransitions = () => {
                    e._isCssTransitionsDisabled = !1
                }, e.extendTemplate({
                    attributes: {
                        class: [e.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]
                    }
                })
            }
    
            function i({
                view: t
            }) {
                t.listenTo(t.element, "submit", ((e, n) => {
                    n.preventDefault(), t.fire("submit")
                }), {
                    useCapture: !0
                })
            }
            n.d(o, {
                default: () => Wv
            });
            const r = function() {
                    try {
                        return navigator.userAgent.toLowerCase()
                    } catch (t) {
                        return ""
                    }
                }(),
                s = {
                    isMac: c(r),
                    isWindows: function(t) {
                        return t.indexOf("windows") > -1
                    }(r),
                    isGecko: function(t) {
                        return !!t.match(/gecko\/\d+/)
                    }(r),
                    isSafari: function(t) {
                        return t.indexOf(" applewebkit/") > -1 && -1 === t.indexOf("chrome")
                    }(r),
                    isiOS: function(t) {
                        return !!t.match(/iphone|ipad/i) || c(t) && navigator.maxTouchPoints > 0
                    }(r),
                    isAndroid: function(t) {
                        return t.indexOf("android") > -1
                    }(r),
                    isBlink: function(t) {
                        return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
                    }(r),
                    features: {
                        isRegExpUnicodePropertySupported: function() {
                            let t = !1;
                            try {
                                t = 0 === "".search(new RegExp("[\\p{L}]", "u"))
                            } catch (t) {}
                            return t
                        }()
                    }
                },
                a = s;
    
            function c(t) {
                return t.indexOf("macintosh") > -1
            }
    
            function l(t, e, n, o) {
                n = n || function(t, e) {
                    return t === e
                };
                const i = Array.isArray(t) ? t : Array.prototype.slice.call(t),
                    r = Array.isArray(e) ? e : Array.prototype.slice.call(e),
                    s = function(t, e, n) {
                        const o = d(t, e, n);
                        if (-1 === o) return {
                            firstIndex: -1,
                            lastIndexOld: -1,
                            lastIndexNew: -1
                        };
                        const i = h(t, o),
                            r = h(e, o),
                            s = d(i, r, n),
                            a = t.length - s,
                            c = e.length - s;
                        return {
                            firstIndex: o,
                            lastIndexOld: a,
                            lastIndexNew: c
                        }
                    }(i, r, n),
                    a = o ? function(t, e) {
                        const {
                            firstIndex: n,
                            lastIndexOld: o,
                            lastIndexNew: i
                        } = t;
                        if (-1 === n) return Array(e).fill("equal");
                        let r = [];
                        n > 0 && (r = r.concat(Array(n).fill("equal")));
                        i - n > 0 && (r = r.concat(Array(i - n).fill("insert")));
                        o - n > 0 && (r = r.concat(Array(o - n).fill("delete")));
                        i < e && (r = r.concat(Array(e - i).fill("equal")));
                        return r
                    }(s, r.length) : function(t, e) {
                        const n = [],
                            {
                                firstIndex: o,
                                lastIndexOld: i,
                                lastIndexNew: r
                            } = e;
                        r - o > 0 && n.push({
                            index: o,
                            type: "insert",
                            values: t.slice(o, r)
                        });
                        i - o > 0 && n.push({
                            index: o + (r - o),
                            type: "delete",
                            howMany: i - o
                        });
                        return n
                    }(r, s);
                return a
            }
    
            function d(t, e, n) {
                for (let o = 0; o < Math.max(t.length, e.length); o++)
                    if (void 0 === t[o] || void 0 === e[o] || !n(t[o], e[o])) return o;
                return -1
            }
    
            function h(t, e) {
                return t.slice(e).reverse()
            }
    
            function u(t, e, n) {
                n = n || function(t, e) {
                    return t === e
                };
                const o = t.length,
                    i = e.length;
                if (o > 200 || i > 200 || o + i > 300) return u.fastDiff(t, e, n, !0);
                let r, s;
                if (i < o) {
                    const n = t;
                    t = e, e = n, r = "delete", s = "insert"
                } else r = "insert", s = "delete";
                const a = t.length,
                    c = e.length,
                    l = c - a,
                    d = {},
                    h = {};
    
                function g(o) {
                    const i = (void 0 !== h[o - 1] ? h[o - 1] : -1) + 1,
                        l = void 0 !== h[o + 1] ? h[o + 1] : -1,
                        u = i > l ? -1 : 1;
                    d[o + u] && (d[o] = d[o + u].slice(0)), d[o] || (d[o] = []), d[o].push(i > l ? r : s);
                    let g = Math.max(i, l),
                        m = g - o;
                    for (; m < a && g < c && n(t[m], e[g]);) m++, g++, d[o].push("equal");
                    return g
                }
                let m, p = 0;
                do {
                    for (m = -p; m < l; m++) h[m] = g(m);
                    for (m = l + p; m > l; m--) h[m] = g(m);
                    h[l] = g(l), p++
                } while (h[l] !== c);
                return d[l].slice(1)
            }
    
            function g(t, ...e) {
                e.forEach((e => {
                    const n = Object.getOwnPropertyNames(e),
                        o = Object.getOwnPropertySymbols(e);
                    n.concat(o).forEach((n => {
                        if (n in t.prototype) return;
                        if ("function" == typeof e && ("length" == n || "name" == n || "prototype" == n)) return;
                        const o = Object.getOwnPropertyDescriptor(e, n);
                        o.enumerable = !1, Object.defineProperty(t.prototype, n, o)
                    }))
                }))
            }
            u.fastDiff = l;
            const m = function() {
                return function t() {
                    t.called = !0
                }
            };
            class p {
                constructor(t, e) {
                    this.source = t, this.name = e, this.path = [], this.stop = m(), this.off = m()
                }
            }
            const f = new Array(256).fill("").map(((t, e) => ("0" + e.toString(16)).slice(-2)));
    
            function k() {
                const t = 4294967296 * Math.random() >>> 0,
                    e = 4294967296 * Math.random() >>> 0,
                    n = 4294967296 * Math.random() >>> 0,
                    o = 4294967296 * Math.random() >>> 0;
                return "e" + f[t >> 0 & 255] + f[t >> 8 & 255] + f[t >> 16 & 255] + f[t >> 24 & 255] + f[e >> 0 & 255] + f[e >> 8 & 255] + f[e >> 16 & 255] + f[e >> 24 & 255] + f[n >> 0 & 255] + f[n >> 8 & 255] + f[n >> 16 & 255] + f[n >> 24 & 255] + f[o >> 0 & 255] + f[o >> 8 & 255] + f[o >> 16 & 255] + f[o >> 24 & 255]
            }
            const b = {
                get(t = "normal") {
                    return "number" != typeof t ? this[t] || this.normal : t
                },
                highest: 1e5,
                high: 1e3,
                normal: 0,
                low: -1e3,
                lowest: -1e5
            };
    
            function w(t, e) {
                const n = b.get(e.priority);
                for (let o = 0; o < t.length; o++)
                    if (b.get(t[o].priority) < n) return void t.splice(o, 0, e);
                t.push(e)
            }
            const _ = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
            class A extends Error {
                constructor(t, e, n) {
                    super(function(t, e) {
                        const n = new WeakSet,
                            o = (t, e) => {
                                if ("object" == typeof e && null !== e) {
                                    if (n.has(e)) return `[object ${e.constructor.name}]`;
                                    n.add(e)
                                }
                                return e
                            },
                            i = e ? ` ${JSON.stringify(e,o)}` : "",
                            r = y(t);
                        return t + i + r
                    }(t, n)), this.name = "CKEditorError", this.context = e, this.data = n
                }
                is(t) {
                    return "CKEditorError" === t
                }
                static rethrowUnexpectedError(t, e) {
                    if (t.is && t.is("CKEditorError")) throw t;
                    const n = new A(t.message, e);
                    throw n.stack = t.stack, n
                }
            }
    
            function C(t, e) {
                console.warn(...x(t, e))
            }
    
            function v(t, e) {
                console.error(...x(t, e))
            }
    
            function y(t) {
                return `\nRead more: ${_}#error-${t}`
            }
    
            function x(t, e) {
                const n = y(t);
                return e ? [t, e, n] : [t, n]
            }
            const E = "36.0.1",
                D = "object" == typeof window ? window : n.g;
            if (D.CKEDITOR_VERSION) throw new A("ckeditor-duplicated-modules", null);
            D.CKEDITOR_VERSION = E;
            const I = Symbol("listeningTo"),
                T = Symbol("emitterId"),
                M = Symbol("delegations"),
                S = N(Object);
    
            function N(t) {
                if (!t) return S;
                return class extends t {
                    on(t, e, n) {
                        this.listenTo(this, t, e, n)
                    }
                    once(t, e, n) {
                        let o = !1;
                        this.listenTo(this, t, ((t, ...n) => {
                            o || (o = !0, t.off(), e.call(this, t, ...n))
                        }), n)
                    }
                    off(t, e) {
                        this.stopListening(this, t, e)
                    }
                    listenTo(t, e, n, o = {}) {
                        let i, r;
                        this[I] || (this[I] = {});
                        const s = this[I];
                        P(t) || B(t);
                        const a = P(t);
                        (i = s[a]) || (i = s[a] = {
                            emitter: t,
                            callbacks: {}
                        }), (r = i.callbacks[e]) || (r = i.callbacks[e] = []), r.push(n),
                            function(t, e, n, o, i) {
                                e._addEventListener ? e._addEventListener(n, o, i) : t._addEventListener.call(e, n, o, i)
                            }(this, t, e, n, o)
                    }
                    stopListening(t, e, n) {
                        const o = this[I];
                        let i = t && P(t);
                        const r = o && i ? o[i] : void 0,
                            s = r && e ? r.callbacks[e] : void 0;
                        if (!(!o || t && !r || e && !s))
                            if (n) {
                                j(this, t, e, n); - 1 !== s.indexOf(n) && (1 === s.length ? delete r.callbacks[e] : j(this, t, e, n))
                            } else if (s) {
                            for (; n = s.pop();) j(this, t, e, n);
                            delete r.callbacks[e]
                        } else if (r) {
                            for (e in r.callbacks) this.stopListening(t, e);
                            delete o[i]
                        } else {
                            for (i in o) this.stopListening(o[i].emitter);
                            delete this[I]
                        }
                    }
                    fire(t, ...e) {
                        try {
                            const n = t instanceof p ? t : new p(this, t),
                                o = n.name;
                            let i = O(this, o);
                            if (n.path.push(this), i) {
                                const t = [n, ...e];
                                i = Array.from(i);
                                for (let e = 0; e < i.length && (i[e].callback.apply(this, t), n.off.called && (delete n.off.called, this._removeEventListener(o, i[e].callback)), !n.stop.called); e++);
                            }
                            const r = this[M];
                            if (r) {
                                const t = r.get(o),
                                    i = r.get("*");
                                t && R(t, n, e), i && R(i, n, e)
                            }
                            return n.return
                        } catch (t) {
                            A.rethrowUnexpectedError(t, this)
                        }
                    }
                    delegate(...t) {
                        return {
                            to: (e, n) => {
                                this[M] || (this[M] = new Map), t.forEach((t => {
                                    const o = this[M].get(t);
                                    o ? o.set(e, n) : this[M].set(t, new Map([
                                        [e, n]
                                    ]))
                                }))
                            }
                        }
                    }
                    stopDelegating(t, e) {
                        if (this[M])
                            if (t)
                                if (e) {
                                    const n = this[M].get(t);
                                    n && n.delete(e)
                                } else this[M].delete(t);
                        else this[M].clear()
                    }
                    _addEventListener(t, e, n) {
                        ! function(t, e) {
                            const n = z(t);
                            if (n[e]) return;
                            let o = e,
                                i = null;
                            const r = [];
                            for (;
                                "" !== o && !n[o];) n[o] = {
                                callbacks: [],
                                childEvents: []
                            }, r.push(n[o]), i && n[o].childEvents.push(i), i = o, o = o.substr(0, o.lastIndexOf(":"));
                            if ("" !== o) {
                                for (const t of r) t.callbacks = n[o].callbacks.slice();
                                n[o].childEvents.push(i)
                            }
                        }(this, t);
                        const o = L(this, t),
                            i = {
                                callback: e,
                                priority: b.get(n.priority)
                            };
                        for (const t of o) w(t, i)
                    }
                    _removeEventListener(t, e) {
                        const n = L(this, t);
                        for (const t of n)
                            for (let n = 0; n < t.length; n++) t[n].callback == e && (t.splice(n, 1), n--)
                    }
                }
            }
    
            function B(t, e) {
                t[T] || (t[T] = e || k())
            }
    
            function P(t) {
                return t[T]
            }
    
            function z(t) {
                return t._events || Object.defineProperty(t, "_events", {
                    value: {}
                }), t._events
            }
    
            function L(t, e) {
                const n = z(t)[e];
                if (!n) return [];
                let o = [n.callbacks];
                for (let e = 0; e < n.childEvents.length; e++) {
                    const i = L(t, n.childEvents[e]);
                    o = o.concat(i)
                }
                return o
            }
    
            function O(t, e) {
                let n;
                return t._events && (n = t._events[e]) && n.callbacks.length ? n.callbacks : e.indexOf(":") > -1 ? O(t, e.substr(0, e.lastIndexOf(":"))) : null
            }
    
            function R(t, e, n) {
                for (let [o, i] of t) {
                    i ? "function" == typeof i && (i = i(e.name)) : i = e.name;
                    const t = new p(e.source, i);
                    t.path = [...e.path], o.fire(t, ...n)
                }
            }
    
            function j(t, e, n, o) {
                e._removeEventListener ? e._removeEventListener(n, o) : t._removeEventListener.call(e, n, o)
            } ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
                N[t] = S.prototype[t]
            }));
            const F = function(t) {
                    var e = typeof t;
                    return null != t && ("object" == e || "function" == e)
                },
                V = Symbol("observableProperties"),
                H = Symbol("boundObservables"),
                U = Symbol("boundProperties"),
                W = Symbol("decoratedMethods"),
                q = Symbol("decoratedOriginal"),
                G = $(N());
    
            function $(t) {
                if (!t) return G;
                return class extends t {
                    set(t, e) {
                        if (F(t)) return void Object.keys(t).forEach((e => {
                            this.set(e, t[e])
                        }), this);
                        Y(this);
                        const n = this[V];
                        if (t in this && !n.has(t)) throw new A("observable-set-cannot-override", this);
                        Object.defineProperty(this, t, {
                            enumerable: !0,
                            configurable: !0,
                            get: () => n.get(t),
                            set(e) {
                                const o = n.get(t);
                                let i = this.fire(`set:${t}`, t, e, o);
                                void 0 === i && (i = e), o === i && n.has(t) || (n.set(t, i), this.fire(`change:${t}`, t, i, o))
                            }
                        }), this[t] = e
                    }
                    bind(...t) {
                        if (!t.length || !Z(t)) throw new A("observable-bind-wrong-properties", this);
                        if (new Set(t).size !== t.length) throw new A("observable-bind-duplicate-properties", this);
                        Y(this);
                        const e = this[U];
                        t.forEach((t => {
                            if (e.has(t)) throw new A("observable-bind-rebind", this)
                        }));
                        const n = new Map;
                        return t.forEach((t => {
                            const o = {
                                property: t,
                                to: []
                            };
                            e.set(t, o), n.set(t, o)
                        })), {
                            to: K,
                            toMany: Q,
                            _observable: this,
                            _bindProperties: t,
                            _to: [],
                            _bindings: n
                        }
                    }
                    unbind(...t) {
                        if (!this[V]) return;
                        const e = this[U],
                            n = this[H];
                        if (t.length) {
                            if (!Z(t)) throw new A("observable-unbind-wrong-properties", this);
                            t.forEach((t => {
                                const o = e.get(t);
                                o && (o.to.forEach((([t, e]) => {
                                    const i = n.get(t),
                                        r = i[e];
                                    r.delete(o), r.size || delete i[e], Object.keys(i).length || (n.delete(t), this.stopListening(t, "change"))
                                })), e.delete(t))
                            }))
                        } else n.forEach(((t, e) => {
                            this.stopListening(e, "change")
                        })), n.clear(), e.clear()
                    }
                    decorate(t) {
                        Y(this);
                        const e = this[t];
                        if (!e) throw new A("observablemixin-cannot-decorate-undefined", this, {
                            object: this,
                            methodName: t
                        });
                        this.on(t, ((t, n) => {
                            t.return = e.apply(this, n)
                        })), this[t] = function(...e) {
                            return this.fire(t, e)
                        }, this[t][q] = e, this[W] || (this[W] = []), this[W].push(t)
                    }
                    stopListening(t, e, n) {
                        if (!t && this[W]) {
                            for (const t of this[W]) this[t] = this[t][q];
                            delete this[W]
                        }
                        super.stopListening(t, e, n)
                    }
                }
            }
    
            function Y(t) {
                t[V] || (Object.defineProperty(t, V, {
                    value: new Map
                }), Object.defineProperty(t, H, {
                    value: new Map
                }), Object.defineProperty(t, U, {
                    value: new Map
                }))
            }
    
            function K(...t) {
                const e = function(...t) {
                        if (!t.length) throw new A("observable-bind-to-parse-error", null);
                        const e = {
                            to: []
                        };
                        let n;
                        "function" == typeof t[t.length - 1] && (e.callback = t.pop());
                        return t.forEach((t => {
                            if ("string" == typeof t) n.properties.push(t);
                            else {
                                if ("object" != typeof t) throw new A("observable-bind-to-parse-error", null);
                                n = {
                                    observable: t,
                                    properties: []
                                }, e.to.push(n)
                            }
                        })), e
                    }(...t),
                    n = Array.from(this._bindings.keys()),
                    o = n.length;
                if (!e.callback && e.to.length > 1) throw new A("observable-bind-to-no-callback", this);
                if (o > 1 && e.callback) throw new A("observable-bind-to-extra-callback", this);
                var i;
                e.to.forEach((t => {
                        if (t.properties.length && t.properties.length !== o) throw new A("observable-bind-to-properties-length", this);
                        t.properties.length || (t.properties = this._bindProperties)
                    })), this._to = e.to, e.callback && (this._bindings.get(n[0]).callback = e.callback), i = this._observable, this._to.forEach((t => {
                        const e = i[H];
                        let n;
                        e.get(t.observable) || i.listenTo(t.observable, "change", ((o, r) => {
                            n = e.get(t.observable)[r], n && n.forEach((t => {
                                J(i, t.property)
                            }))
                        }))
                    })),
                    function(t) {
                        let e;
                        t._bindings.forEach(((n, o) => {
                            t._to.forEach((i => {
                                e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)], n.to.push([i.observable, e]),
                                    function(t, e, n, o) {
                                        const i = t[H],
                                            r = i.get(n),
                                            s = r || {};
                                        s[o] || (s[o] = new Set);
                                        s[o].add(e), r || i.set(n, s)
                                    }(t._observable, n, i.observable, e)
                            }))
                        }))
                    }(this), this._bindProperties.forEach((t => {
                        J(this._observable, t)
                    }))
            }
    
            function Q(t, e, n) {
                if (this._bindings.size > 1) throw new A("observable-bind-to-many-not-one-binding", this);
                this.to(... function(t, e) {
                    const n = t.map((t => [t, e]));
                    return Array.prototype.concat.apply([], n)
                }(t, e), n)
            }
    
            function Z(t) {
                return t.every((t => "string" == typeof t))
            }
    
            function J(t, e) {
                const n = t[U].get(e);
                let o;
                n.callback ? o = n.callback.apply(t, n.to.map((t => t[0][t[1]]))) : (o = n.to[0], o = o[0][o[1]]), Object.prototype.hasOwnProperty.call(t, e) ? t[e] = o : t.set(e, o)
            } ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
                $[t] = G.prototype[t]
            }));
            class X {
                constructor() {
                    this._replacedElements = []
                }
                replace(t, e) {
                    this._replacedElements.push({
                        element: t,
                        newElement: e
                    }), t.style.display = "none", e && t.parentNode.insertBefore(e, t.nextSibling)
                }
                restore() {
                    this._replacedElements.forEach((({
                        element: t,
                        newElement: e
                    }) => {
                        t.style.display = "", e && e.remove()
                    })), this._replacedElements = []
                }
            }
    
            function tt(t) {
                let e = 0;
                for (const n of t) e++;
                return e
            }
    
            function et(t, e) {
                const n = Math.min(t.length, e.length);
                for (let o = 0; o < n; o++)
                    if (t[o] != e[o]) return o;
                return t.length == e.length ? "same" : t.length < e.length ? "prefix" : "extension"
            }
    
            function nt(t) {
                return !(!t || !t[Symbol.iterator])
            }
            const ot = "object" == typeof global && global && global.Object === Object && global;
            var it = "object" == typeof self && self && self.Object === Object && self;
            const rt = ot || it || Function("return this")();
            const st = rt.Symbol;
            var at = Object.prototype,
                ct = at.hasOwnProperty,
                lt = at.toString,
                dt = st ? st.toStringTag : void 0;
            const ht = function(t) {
                var e = ct.call(t, dt),
                    n = t[dt];
                try {
                    t[dt] = void 0;
                    var o = !0
                } catch (t) {}
                var i = lt.call(t);
                return o && (e ? t[dt] = n : delete t[dt]), i
            };
            var ut = Object.prototype.toString;
            const gt = function(t) {
                return ut.call(t)
            };
            var mt = "[object Null]",
                pt = "[object Undefined]",
                ft = st ? st.toStringTag : void 0;
            const kt = function(t) {
                return null == t ? void 0 === t ? pt : mt : ft && ft in Object(t) ? ht(t) : gt(t)
            };
            const bt = Array.isArray;
            const wt = function(t) {
                return null != t && "object" == typeof t
            };
            var _t = "[object String]";
            const At = function(t) {
                return "string" == typeof t || !bt(t) && wt(t) && kt(t) == _t
            };
    
            function Ct(t, e, n = {}, o = []) {
                const i = n && n.xmlns,
                    r = i ? t.createElementNS(i, e) : t.createElement(e);
                for (const t in n) r.setAttribute(t, n[t]);
                !At(o) && nt(o) || (o = [o]);
                for (let e of o) At(e) && (e = t.createTextNode(e)), r.appendChild(e);
                return r
            }
            const vt = function(t, e) {
                return function(n) {
                    return t(e(n))
                }
            };
            const yt = vt(Object.getPrototypeOf, Object);
            var xt = "[object Object]",
                Et = Function.prototype,
                Dt = Object.prototype,
                It = Et.toString,
                Tt = Dt.hasOwnProperty,
                Mt = It.call(Object);
            const St = function(t) {
                if (!wt(t) || kt(t) != xt) return !1;
                var e = yt(t);
                if (null === e) return !0;
                var n = Tt.call(e, "constructor") && e.constructor;
                return "function" == typeof n && n instanceof n && It.call(n) == Mt
            };
            const Nt = function() {
                this.__data__ = [], this.size = 0
            };
            const Bt = function(t, e) {
                return t === e || t != t && e != e
            };
            const Pt = function(t, e) {
                for (var n = t.length; n--;)
                    if (Bt(t[n][0], e)) return n;
                return -1
            };
            var zt = Array.prototype.splice;
            const Lt = function(t) {
                var e = this.__data__,
                    n = Pt(e, t);
                return !(n < 0) && (n == e.length - 1 ? e.pop() : zt.call(e, n, 1), --this.size, !0)
            };
            const Ot = function(t) {
                var e = this.__data__,
                    n = Pt(e, t);
                return n < 0 ? void 0 : e[n][1]
            };
            const Rt = function(t) {
                return Pt(this.__data__, t) > -1
            };
            const jt = function(t, e) {
                var n = this.__data__,
                    o = Pt(n, t);
                return o < 0 ? (++this.size, n.push([t, e])) : n[o][1] = e, this
            };
    
            function Ft(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var o = t[e];
                    this.set(o[0], o[1])
                }
            }
            Ft.prototype.clear = Nt, Ft.prototype.delete = Lt, Ft.prototype.get = Ot, Ft.prototype.has = Rt, Ft.prototype.set = jt;
            const Vt = Ft;
            const Ht = function() {
                this.__data__ = new Vt, this.size = 0
            };
            const Ut = function(t) {
                var e = this.__data__,
                    n = e.delete(t);
                return this.size = e.size, n
            };
            const Wt = function(t) {
                return this.__data__.get(t)
            };
            const qt = function(t) {
                return this.__data__.has(t)
            };
            var Gt = "[object AsyncFunction]",
                $t = "[object Function]",
                Yt = "[object GeneratorFunction]",
                Kt = "[object Proxy]";
            const Qt = function(t) {
                if (!F(t)) return !1;
                var e = kt(t);
                return e == $t || e == Yt || e == Gt || e == Kt
            };
            const Zt = rt["__core-js_shared__"];
            var Jt = function() {
                var t = /[^.]+$/.exec(Zt && Zt.keys && Zt.keys.IE_PROTO || "");
                return t ? "Symbol(src)_1." + t : ""
            }();
            const Xt = function(t) {
                return !!Jt && Jt in t
            };
            var te = Function.prototype.toString;
            const ee = function(t) {
                if (null != t) {
                    try {
                        return te.call(t)
                    } catch (t) {}
                    try {
                        return t + ""
                    } catch (t) {}
                }
                return ""
            };
            var ne = /^\[object .+?Constructor\]$/,
                oe = Function.prototype,
                ie = Object.prototype,
                re = oe.toString,
                se = ie.hasOwnProperty,
                ae = RegExp("^" + re.call(se).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            const ce = function(t) {
                return !(!F(t) || Xt(t)) && (Qt(t) ? ae : ne).test(ee(t))
            };
            const le = function(t, e) {
                return null == t ? void 0 : t[e]
            };
            const de = function(t, e) {
                var n = le(t, e);
                return ce(n) ? n : void 0
            };
            const he = de(rt, "Map");
            const ue = de(Object, "create");
            const ge = function() {
                this.__data__ = ue ? ue(null) : {}, this.size = 0
            };
            const me = function(t) {
                var e = this.has(t) && delete this.__data__[t];
                return this.size -= e ? 1 : 0, e
            };
            var pe = "__lodash_hash_undefined__",
                fe = Object.prototype.hasOwnProperty;
            const ke = function(t) {
                var e = this.__data__;
                if (ue) {
                    var n = e[t];
                    return n === pe ? void 0 : n
                }
                return fe.call(e, t) ? e[t] : void 0
            };
            var be = Object.prototype.hasOwnProperty;
            const we = function(t) {
                var e = this.__data__;
                return ue ? void 0 !== e[t] : be.call(e, t)
            };
            var _e = "__lodash_hash_undefined__";
            const Ae = function(t, e) {
                var n = this.__data__;
                return this.size += this.has(t) ? 0 : 1, n[t] = ue && void 0 === e ? _e : e, this
            };
    
            function Ce(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var o = t[e];
                    this.set(o[0], o[1])
                }
            }
            Ce.prototype.clear = ge, Ce.prototype.delete = me, Ce.prototype.get = ke, Ce.prototype.has = we, Ce.prototype.set = Ae;
            const ve = Ce;
            const ye = function() {
                this.size = 0, this.__data__ = {
                    hash: new ve,
                    map: new(he || Vt),
                    string: new ve
                }
            };
            const xe = function(t) {
                var e = typeof t;
                return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
            };
            const Ee = function(t, e) {
                var n = t.__data__;
                return xe(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
            };
            const De = function(t) {
                var e = Ee(this, t).delete(t);
                return this.size -= e ? 1 : 0, e
            };
            const Ie = function(t) {
                return Ee(this, t).get(t)
            };
            const Te = function(t) {
                return Ee(this, t).has(t)
            };
            const Me = function(t, e) {
                var n = Ee(this, t),
                    o = n.size;
                return n.set(t, e), this.size += n.size == o ? 0 : 1, this
            };
    
            function Se(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.clear(); ++e < n;) {
                    var o = t[e];
                    this.set(o[0], o[1])
                }
            }
            Se.prototype.clear = ye, Se.prototype.delete = De, Se.prototype.get = Ie, Se.prototype.has = Te, Se.prototype.set = Me;
            const Ne = Se;
            var Be = 200;
            const Pe = function(t, e) {
                var n = this.__data__;
                if (n instanceof Vt) {
                    var o = n.__data__;
                    if (!he || o.length < Be - 1) return o.push([t, e]), this.size = ++n.size, this;
                    n = this.__data__ = new Ne(o)
                }
                return n.set(t, e), this.size = n.size, this
            };
    
            function ze(t) {
                var e = this.__data__ = new Vt(t);
                this.size = e.size
            }
            ze.prototype.clear = Ht, ze.prototype.delete = Ut, ze.prototype.get = Wt, ze.prototype.has = qt, ze.prototype.set = Pe;
            const Le = ze;
            const Oe = function(t, e) {
                for (var n = -1, o = null == t ? 0 : t.length; ++n < o && !1 !== e(t[n], n, t););
                return t
            };
            const Re = function() {
                try {
                    var t = de(Object, "defineProperty");
                    return t({}, "", {}), t
                } catch (t) {}
            }();
            const je = function(t, e, n) {
                "__proto__" == e && Re ? Re(t, e, {
                    configurable: !0,
                    enumerable: !0,
                    value: n,
                    writable: !0
                }) : t[e] = n
            };
            var Fe = Object.prototype.hasOwnProperty;
            const Ve = function(t, e, n) {
                var o = t[e];
                Fe.call(t, e) && Bt(o, n) && (void 0 !== n || e in t) || je(t, e, n)
            };
            const He = function(t, e, n, o) {
                var i = !n;
                n || (n = {});
                for (var r = -1, s = e.length; ++r < s;) {
                    var a = e[r],
                        c = o ? o(n[a], t[a], a, n, t) : void 0;
                    void 0 === c && (c = t[a]), i ? je(n, a, c) : Ve(n, a, c)
                }
                return n
            };
            const Ue = function(t, e) {
                for (var n = -1, o = Array(t); ++n < t;) o[n] = e(n);
                return o
            };
            var We = "[object Arguments]";
            const qe = function(t) {
                return wt(t) && kt(t) == We
            };
            var Ge = Object.prototype,
                $e = Ge.hasOwnProperty,
                Ye = Ge.propertyIsEnumerable;
            const Ke = qe(function() {
                return arguments
            }()) ? qe : function(t) {
                return wt(t) && $e.call(t, "callee") && !Ye.call(t, "callee")
            };
            const Qe = function() {
                return !1
            };
            var Ze = "object" == typeof exports && exports && !exports.nodeType && exports,
                Je = Ze && "object" == typeof module && module && !module.nodeType && module,
                Xe = Je && Je.exports === Ze ? rt.Buffer : void 0;
            const tn = (Xe ? Xe.isBuffer : void 0) || Qe;
            var en = 9007199254740991,
                nn = /^(?:0|[1-9]\d*)$/;
            const on = function(t, e) {
                var n = typeof t;
                return !!(e = null == e ? en : e) && ("number" == n || "symbol" != n && nn.test(t)) && t > -1 && t % 1 == 0 && t < e
            };
            var rn = 9007199254740991;
            const sn = function(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= rn
            };
            var an = {};
            an["[object Float32Array]"] = an["[object Float64Array]"] = an["[object Int8Array]"] = an["[object Int16Array]"] = an["[object Int32Array]"] = an["[object Uint8Array]"] = an["[object Uint8ClampedArray]"] = an["[object Uint16Array]"] = an["[object Uint32Array]"] = !0, an["[object Arguments]"] = an["[object Array]"] = an["[object ArrayBuffer]"] = an["[object Boolean]"] = an["[object DataView]"] = an["[object Date]"] = an["[object Error]"] = an["[object Function]"] = an["[object Map]"] = an["[object Number]"] = an["[object Object]"] = an["[object RegExp]"] = an["[object Set]"] = an["[object String]"] = an["[object WeakMap]"] = !1;
            const cn = function(t) {
                return wt(t) && sn(t.length) && !!an[kt(t)]
            };
            const ln = function(t) {
                return function(e) {
                    return t(e)
                }
            };
            var dn = "object" == typeof exports && exports && !exports.nodeType && exports,
                hn = dn && "object" == typeof module && module && !module.nodeType && module,
                un = hn && hn.exports === dn && ot.process;
            const gn = function() {
                try {
                    var t = hn && hn.require && hn.require("util").types;
                    return t || un && un.binding && un.binding("util")
                } catch (t) {}
            }();
            var mn = gn && gn.isTypedArray;
            const pn = mn ? ln(mn) : cn;
            var fn = Object.prototype.hasOwnProperty;
            const kn = function(t, e) {
                var n = bt(t),
                    o = !n && Ke(t),
                    i = !n && !o && tn(t),
                    r = !n && !o && !i && pn(t),
                    s = n || o || i || r,
                    a = s ? Ue(t.length, String) : [],
                    c = a.length;
                for (var l in t) !e && !fn.call(t, l) || s && ("length" == l || i && ("offset" == l || "parent" == l) || r && ("buffer" == l || "byteLength" == l || "byteOffset" == l) || on(l, c)) || a.push(l);
                return a
            };
            var bn = Object.prototype;
            const wn = function(t) {
                var e = t && t.constructor;
                return t === ("function" == typeof e && e.prototype || bn)
            };
            const _n = vt(Object.keys, Object);
            var An = Object.prototype.hasOwnProperty;
            const Cn = function(t) {
                if (!wn(t)) return _n(t);
                var e = [];
                for (var n in Object(t)) An.call(t, n) && "constructor" != n && e.push(n);
                return e
            };
            const vn = function(t) {
                return null != t && sn(t.length) && !Qt(t)
            };
            const yn = function(t) {
                return vn(t) ? kn(t) : Cn(t)
            };
            const xn = function(t, e) {
                return t && He(e, yn(e), t)
            };
            const En = function(t) {
                var e = [];
                if (null != t)
                    for (var n in Object(t)) e.push(n);
                return e
            };
            var Dn = Object.prototype.hasOwnProperty;
            const In = function(t) {
                if (!F(t)) return En(t);
                var e = wn(t),
                    n = [];
                for (var o in t)("constructor" != o || !e && Dn.call(t, o)) && n.push(o);
                return n
            };
            const Tn = function(t) {
                return vn(t) ? kn(t, !0) : In(t)
            };
            const Mn = function(t, e) {
                return t && He(e, Tn(e), t)
            };
            var Sn = "object" == typeof exports && exports && !exports.nodeType && exports,
                Nn = Sn && "object" == typeof module && module && !module.nodeType && module,
                Bn = Nn && Nn.exports === Sn ? rt.Buffer : void 0,
                Pn = Bn ? Bn.allocUnsafe : void 0;
            const zn = function(t, e) {
                if (e) return t.slice();
                var n = t.length,
                    o = Pn ? Pn(n) : new t.constructor(n);
                return t.copy(o), o
            };
            const Ln = function(t, e) {
                var n = -1,
                    o = t.length;
                for (e || (e = Array(o)); ++n < o;) e[n] = t[n];
                return e
            };
            const On = function(t, e) {
                for (var n = -1, o = null == t ? 0 : t.length, i = 0, r = []; ++n < o;) {
                    var s = t[n];
                    e(s, n, t) && (r[i++] = s)
                }
                return r
            };
            const Rn = function() {
                return []
            };
            var jn = Object.prototype.propertyIsEnumerable,
                Fn = Object.getOwnPropertySymbols;
            const Vn = Fn ? function(t) {
                return null == t ? [] : (t = Object(t), On(Fn(t), (function(e) {
                    return jn.call(t, e)
                })))
            } : Rn;
            const Hn = function(t, e) {
                return He(t, Vn(t), e)
            };
            const Un = function(t, e) {
                for (var n = -1, o = e.length, i = t.length; ++n < o;) t[i + n] = e[n];
                return t
            };
            const Wn = Object.getOwnPropertySymbols ? function(t) {
                for (var e = []; t;) Un(e, Vn(t)), t = yt(t);
                return e
            } : Rn;
            const qn = function(t, e) {
                return He(t, Wn(t), e)
            };
            const Gn = function(t, e, n) {
                var o = e(t);
                return bt(t) ? o : Un(o, n(t))
            };
            const $n = function(t) {
                return Gn(t, yn, Vn)
            };
            const Yn = function(t) {
                return Gn(t, Tn, Wn)
            };
            const Kn = de(rt, "DataView");
            const Qn = de(rt, "Promise");
            const Zn = de(rt, "Set");
            const Jn = de(rt, "WeakMap");
            var Xn = "[object Map]",
                to = "[object Promise]",
                eo = "[object Set]",
                no = "[object WeakMap]",
                oo = "[object DataView]",
                io = ee(Kn),
                ro = ee(he),
                so = ee(Qn),
                ao = ee(Zn),
                co = ee(Jn),
                lo = kt;
            (Kn && lo(new Kn(new ArrayBuffer(1))) != oo || he && lo(new he) != Xn || Qn && lo(Qn.resolve()) != to || Zn && lo(new Zn) != eo || Jn && lo(new Jn) != no) && (lo = function(t) {
                var e = kt(t),
                    n = "[object Object]" == e ? t.constructor : void 0,
                    o = n ? ee(n) : "";
                if (o) switch (o) {
                    case io:
                        return oo;
                    case ro:
                        return Xn;
                    case so:
                        return to;
                    case ao:
                        return eo;
                    case co:
                        return no
                }
                return e
            });
            const ho = lo;
            var uo = Object.prototype.hasOwnProperty;
            const go = function(t) {
                var e = t.length,
                    n = new t.constructor(e);
                return e && "string" == typeof t[0] && uo.call(t, "index") && (n.index = t.index, n.input = t.input), n
            };
            const mo = rt.Uint8Array;
            const po = function(t) {
                var e = new t.constructor(t.byteLength);
                return new mo(e).set(new mo(t)), e
            };
            const fo = function(t, e) {
                var n = e ? po(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.byteLength)
            };
            var ko = /\w*$/;
            const bo = function(t) {
                var e = new t.constructor(t.source, ko.exec(t));
                return e.lastIndex = t.lastIndex, e
            };
            var wo = st ? st.prototype : void 0,
                _o = wo ? wo.valueOf : void 0;
            const Ao = function(t) {
                return _o ? Object(_o.call(t)) : {}
            };
            const Co = function(t, e) {
                var n = e ? po(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.length)
            };
            var vo = "[object Boolean]",
                yo = "[object Date]",
                xo = "[object Map]",
                Eo = "[object Number]",
                Do = "[object RegExp]",
                Io = "[object Set]",
                To = "[object String]",
                Mo = "[object Symbol]",
                So = "[object ArrayBuffer]",
                No = "[object DataView]",
                Bo = "[object Float32Array]",
                Po = "[object Float64Array]",
                zo = "[object Int8Array]",
                Lo = "[object Int16Array]",
                Oo = "[object Int32Array]",
                Ro = "[object Uint8Array]",
                jo = "[object Uint8ClampedArray]",
                Fo = "[object Uint16Array]",
                Vo = "[object Uint32Array]";
            const Ho = function(t, e, n) {
                var o = t.constructor;
                switch (e) {
                    case So:
                        return po(t);
                    case vo:
                    case yo:
                        return new o(+t);
                    case No:
                        return fo(t, n);
                    case Bo:
                    case Po:
                    case zo:
                    case Lo:
                    case Oo:
                    case Ro:
                    case jo:
                    case Fo:
                    case Vo:
                        return Co(t, n);
                    case xo:
                        return new o;
                    case Eo:
                    case To:
                        return new o(t);
                    case Do:
                        return bo(t);
                    case Io:
                        return new o;
                    case Mo:
                        return Ao(t)
                }
            };
            var Uo = Object.create;
            const Wo = function() {
                function t() {}
                return function(e) {
                    if (!F(e)) return {};
                    if (Uo) return Uo(e);
                    t.prototype = e;
                    var n = new t;
                    return t.prototype = void 0, n
                }
            }();
            const qo = function(t) {
                return "function" != typeof t.constructor || wn(t) ? {} : Wo(yt(t))
            };
            var Go = "[object Map]";
            const $o = function(t) {
                return wt(t) && ho(t) == Go
            };
            var Yo = gn && gn.isMap;
            const Ko = Yo ? ln(Yo) : $o;
            var Qo = "[object Set]";
            const Zo = function(t) {
                return wt(t) && ho(t) == Qo
            };
            var Jo = gn && gn.isSet;
            const Xo = Jo ? ln(Jo) : Zo;
            var ti = 1,
                ei = 2,
                ni = 4,
                oi = "[object Arguments]",
                ii = "[object Function]",
                ri = "[object GeneratorFunction]",
                si = "[object Object]",
                ai = {};
            ai[oi] = ai["[object Array]"] = ai["[object ArrayBuffer]"] = ai["[object DataView]"] = ai["[object Boolean]"] = ai["[object Date]"] = ai["[object Float32Array]"] = ai["[object Float64Array]"] = ai["[object Int8Array]"] = ai["[object Int16Array]"] = ai["[object Int32Array]"] = ai["[object Map]"] = ai["[object Number]"] = ai[si] = ai["[object RegExp]"] = ai["[object Set]"] = ai["[object String]"] = ai["[object Symbol]"] = ai["[object Uint8Array]"] = ai["[object Uint8ClampedArray]"] = ai["[object Uint16Array]"] = ai["[object Uint32Array]"] = !0, ai["[object Error]"] = ai[ii] = ai["[object WeakMap]"] = !1;
            const ci = function t(e, n, o, i, r, s) {
                var a, c = n & ti,
                    l = n & ei,
                    d = n & ni;
                if (o && (a = r ? o(e, i, r, s) : o(e)), void 0 !== a) return a;
                if (!F(e)) return e;
                var h = bt(e);
                if (h) {
                    if (a = go(e), !c) return Ln(e, a)
                } else {
                    var u = ho(e),
                        g = u == ii || u == ri;
                    if (tn(e)) return zn(e, c);
                    if (u == si || u == oi || g && !r) {
                        if (a = l || g ? {} : qo(e), !c) return l ? qn(e, Mn(a, e)) : Hn(e, xn(a, e))
                    } else {
                        if (!ai[u]) return r ? e : {};
                        a = Ho(e, u, c)
                    }
                }
                s || (s = new Le);
                var m = s.get(e);
                if (m) return m;
                s.set(e, a), Xo(e) ? e.forEach((function(i) {
                    a.add(t(i, n, o, i, e, s))
                })) : Ko(e) && e.forEach((function(i, r) {
                    a.set(r, t(i, n, o, r, e, s))
                }));
                var p = h ? void 0 : (d ? l ? Yn : $n : l ? Tn : yn)(e);
                return Oe(p || e, (function(i, r) {
                    p && (i = e[r = i]), Ve(a, r, t(i, n, o, r, e, s))
                })), a
            };
            var li = 1,
                di = 4;
            const hi = function(t, e) {
                return ci(t, li | di, e = "function" == typeof e ? e : void 0)
            };
            const ui = function(t) {
                return wt(t) && 1 === t.nodeType && !St(t)
            };
            class gi {
                constructor(t, e) {
                    this._config = {}, e && this.define(mi(e)), t && this._setObjectToTarget(this._config, t)
                }
                set(t, e) {
                    this._setToTarget(this._config, t, e)
                }
                define(t, e) {
                    this._setToTarget(this._config, t, e, !0)
                }
                get(t) {
                    return this._getFromSource(this._config, t)
                }* names() {
                    for (const t of Object.keys(this._config)) yield t
                }
                _setToTarget(t, e, n, o = !1) {
                    if (St(e)) return void this._setObjectToTarget(t, e, o);
                    const i = e.split(".");
                    e = i.pop();
                    for (const e of i) St(t[e]) || (t[e] = {}), t = t[e];
                    if (St(n)) return St(t[e]) || (t[e] = {}), t = t[e], void this._setObjectToTarget(t, n, o);
                    o && void 0 !== t[e] || (t[e] = n)
                }
                _getFromSource(t, e) {
                    const n = e.split(".");
                    e = n.pop();
                    for (const e of n) {
                        if (!St(t[e])) {
                            t = null;
                            break
                        }
                        t = t[e]
                    }
                    return t ? mi(t[e]) : void 0
                }
                _setObjectToTarget(t, e, n) {
                    Object.keys(e).forEach((o => {
                        this._setToTarget(t, o, e[o], n)
                    }))
                }
            }
    
            function mi(t) {
                return hi(t, pi)
            }
    
            function pi(t) {
                return ui(t) ? t : void 0
            }
    
            function fi(t) {
                if (t) {
                    if (t.defaultView) return t instanceof t.defaultView.Document;
                    if (t.ownerDocument && t.ownerDocument.defaultView) return t instanceof t.ownerDocument.defaultView.Node
                }
                return !1
            }
    
            function ki(t) {
                const e = Object.prototype.toString.apply(t);
                return "[object Window]" == e || "[object global]" == e
            }
            const bi = wi(N());
    
            function wi(t) {
                if (!t) return bi;
                return class extends t {
                    listenTo(t, e, n, o = {}) {
                        if (fi(t) || ki(t)) {
                            const i = {
                                    capture: !!o.useCapture,
                                    passive: !!o.usePassive
                                },
                                r = this._getProxyEmitter(t, i) || new _i(t, i);
                            this.listenTo(r, e, n, o)
                        } else super.listenTo(t, e, n, o)
                    }
                    stopListening(t, e, n) {
                        if (fi(t) || ki(t)) {
                            const o = this._getAllProxyEmitters(t);
                            for (const t of o) this.stopListening(t, e, n)
                        } else super.stopListening(t, e, n)
                    }
                    _getProxyEmitter(t, e) {
                        return function(t, e) {
                            const n = t[I];
                            return n && n[e] ? n[e].emitter : null
                        }(this, Ai(t, e))
                    }
                    _getAllProxyEmitters(t) {
                        return [{
                            capture: !1,
                            passive: !1
                        }, {
                            capture: !1,
                            passive: !0
                        }, {
                            capture: !0,
                            passive: !1
                        }, {
                            capture: !0,
                            passive: !0
                        }].map((e => this._getProxyEmitter(t, e))).filter((t => !!t))
                    }
                }
            } ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => {
                wi[t] = bi.prototype[t]
            }));
            class _i extends(N()) {
                constructor(t, e) {
                    super(), B(this, Ai(t, e)), this._domNode = t, this._options = e
                }
                attach(t) {
                    if (this._domListeners && this._domListeners[t]) return;
                    const e = this._createDomListener(t);
                    this._domNode.addEventListener(t, e, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t] = e
                }
                detach(t) {
                    let e;
                    !this._domListeners[t] || (e = this._events[t]) && e.callbacks.length || this._domListeners[t].removeListener()
                }
                _addEventListener(t, e, n) {
                    this.attach(t), N().prototype._addEventListener.call(this, t, e, n)
                }
                _removeEventListener(t, e) {
                    N().prototype._removeEventListener.call(this, t, e), this.detach(t)
                }
                _createDomListener(t) {
                    const e = e => {
                        this.fire(t, e)
                    };
                    return e.removeListener = () => {
                        this._domNode.removeEventListener(t, e, this._options), delete this._domListeners[t]
                    }, e
                }
            }
    
            function Ai(t, e) {
                let n = function(t) {
                    return t["data-ck-expando"] || (t["data-ck-expando"] = k())
                }(t);
                for (const t of Object.keys(e).sort()) e[t] && (n += "-" + t);
                return n
            }
            let Ci;
            try {
                Ci = {
                    window,
                    document
                }
            } catch (t) {
                Ci = {
                    window: {},
                    document: {}
                }
            }
            const vi = Ci;
    
            function yi(t) {
                const e = [];
                let n = t;
                for (; n && n.nodeType != Node.DOCUMENT_NODE;) e.unshift(n), n = n.parentNode;
                return e
            }
    
            function xi(t) {
                return "[object Text]" == Object.prototype.toString.call(t)
            }
    
            function Ei(t) {
                return "[object Range]" == Object.prototype.toString.apply(t)
            }
    
            function Di(t) {
                const e = t.ownerDocument.defaultView.getComputedStyle(t);
                return {
                    top: parseInt(e.borderTopWidth, 10),
                    right: parseInt(e.borderRightWidth, 10),
                    bottom: parseInt(e.borderBottomWidth, 10),
                    left: parseInt(e.borderLeftWidth, 10)
                }
            }
            const Ii = ["top", "right", "bottom", "left", "width", "height"];
            class Ti {
                constructor(t) {
                    const e = Ei(t);
                    if (Object.defineProperty(this, "_source", {
                            value: t._source || t,
                            writable: !0,
                            enumerable: !1
                        }), Ni(t) || e)
                        if (e) {
                            const e = Ti.getDomRangeRects(t);
                            Mi(this, Ti.getBoundingRect(e))
                        } else Mi(this, t.getBoundingClientRect());
                    else if (ki(t)) {
                        const {
                            innerWidth: e,
                            innerHeight: n
                        } = t;
                        Mi(this, {
                            top: 0,
                            right: e,
                            bottom: n,
                            left: 0,
                            width: e,
                            height: n
                        })
                    } else Mi(this, t)
                }
                clone() {
                    return new Ti(this)
                }
                moveTo(t, e) {
                    return this.top = e, this.right = t + this.width, this.bottom = e + this.height, this.left = t, this
                }
                moveBy(t, e) {
                    return this.top += e, this.right += t, this.left += t, this.bottom += e, this
                }
                getIntersection(t) {
                    const e = {
                        top: Math.max(this.top, t.top),
                        right: Math.min(this.right, t.right),
                        bottom: Math.min(this.bottom, t.bottom),
                        left: Math.max(this.left, t.left),
                        width: 0,
                        height: 0
                    };
                    return e.width = e.right - e.left, e.height = e.bottom - e.top, e.width < 0 || e.height < 0 ? null : new Ti(e)
                }
                getIntersectionArea(t) {
                    const e = this.getIntersection(t);
                    return e ? e.getArea() : 0
                }
                getArea() {
                    return this.width * this.height
                }
                getVisible() {
                    const t = this._source;
                    let e = this.clone();
                    if (!Si(t)) {
                        let n = t.parentNode || t.commonAncestorContainer;
                        for (; n && !Si(n);) {
                            const t = new Ti(n),
                                o = e.getIntersection(t);
                            if (!o) return null;
                            o.getArea() < e.getArea() && (e = o), n = n.parentNode
                        }
                    }
                    return e
                }
                isEqual(t) {
                    for (const e of Ii)
                        if (this[e] !== t[e]) return !1;
                    return !0
                }
                contains(t) {
                    const e = this.getIntersection(t);
                    return !(!e || !e.isEqual(t))
                }
                excludeScrollbarsAndBorders() {
                    const t = this._source;
                    let e, n, o;
                    if (ki(t)) e = t.innerWidth - t.document.documentElement.clientWidth, n = t.innerHeight - t.document.documentElement.clientHeight, o = t.getComputedStyle(t.document.documentElement).direction;
                    else {
                        const i = Di(t);
                        e = t.offsetWidth - t.clientWidth - i.left - i.right, n = t.offsetHeight - t.clientHeight - i.top - i.bottom, o = t.ownerDocument.defaultView.getComputedStyle(t).direction, this.left += i.left, this.top += i.top, this.right -= i.right, this.bottom -= i.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top
                    }
                    return this.width -= e, "ltr" === o ? this.right -= e : this.left += e, this.height -= n, this.bottom -= n, this
                }
                static getDomRangeRects(t) {
                    const e = [],
                        n = Array.from(t.getClientRects());
                    if (n.length)
                        for (const t of n) e.push(new Ti(t));
                    else {
                        let n = t.startContainer;
                        xi(n) && (n = n.parentNode);
                        const o = new Ti(n.getBoundingClientRect());
                        o.right = o.left, o.width = 0, e.push(o)
                    }
                    return e
                }
                static getBoundingRect(t) {
                    const e = {
                        left: Number.POSITIVE_INFINITY,
                        top: Number.POSITIVE_INFINITY,
                        right: Number.NEGATIVE_INFINITY,
                        bottom: Number.NEGATIVE_INFINITY,
                        width: 0,
                        height: 0
                    };
                    let n = 0;
                    for (const o of t) n++, e.left = Math.min(e.left, o.left), e.top = Math.min(e.top, o.top), e.right = Math.max(e.right, o.right), e.bottom = Math.max(e.bottom, o.bottom);
                    return 0 == n ? null : (e.width = e.right - e.left, e.height = e.bottom - e.top, new Ti(e))
                }
            }
    
            function Mi(t, e) {
                for (const n of Ii) t[n] = e[n]
            }
    
            function Si(t) {
                return !!Ni(t) && t === t.ownerDocument.body
            }
    
            function Ni(t) {
                return null !== t && "object" == typeof t && 1 === t.nodeType && "function" == typeof t.getBoundingClientRect
            }
            class Bi {
                constructor(t, e) {
                    Bi._observerInstance || Bi._createObserver(), this._element = t, this._callback = e, Bi._addElementCallback(t, e), Bi._observerInstance.observe(t)
                }
                destroy() {
                    Bi._deleteElementCallback(this._element, this._callback)
                }
                static _addElementCallback(t, e) {
                    Bi._elementCallbacks || (Bi._elementCallbacks = new Map);
                    let n = Bi._elementCallbacks.get(t);
                    n || (n = new Set, Bi._elementCallbacks.set(t, n)), n.add(e)
                }
                static _deleteElementCallback(t, e) {
                    const n = Bi._getElementCallbacks(t);
                    n && (n.delete(e), n.size || (Bi._elementCallbacks.delete(t), Bi._observerInstance.unobserve(t))), Bi._elementCallbacks && !Bi._elementCallbacks.size && (Bi._observerInstance = null, Bi._elementCallbacks = null)
                }
                static _getElementCallbacks(t) {
                    return Bi._elementCallbacks ? Bi._elementCallbacks.get(t) : null
                }
                static _createObserver() {
                    Bi._observerInstance = new vi.window.ResizeObserver((t => {
                        for (const e of t) {
                            const t = Bi._getElementCallbacks(e.target);
                            if (t)
                                for (const n of t) n(e)
                        }
                    }))
                }
            }
    
            function Pi(t, e) {
                t instanceof HTMLTextAreaElement && (t.value = e), t.innerHTML = e
            }
    
            function zi(t) {
                return e => e + t
            }
    
            function Li(t) {
                let e = 0;
                for (; t.previousSibling;) t = t.previousSibling, e++;
                return e
            }
    
            function Oi(t, e, n) {
                t.insertBefore(n, t.childNodes[e] || null)
            }
    
            function Ri(t) {
                return t && t.nodeType === Node.COMMENT_NODE
            }
    
            function ji(t) {
                return !!(t && t.getClientRects && t.getClientRects().length)
            }
    
            function Fi({
                element: t,
                target: e,
                positions: n,
                limiter: o,
                fitInViewport: i,
                viewportOffsetConfig: r
            }) {
                Qt(e) && (e = e()), Qt(o) && (o = o());
                const s = function(t) {
                        return t && t.parentNode ? t.offsetParent === vi.document.body ? null : t.offsetParent : null
                    }(t),
                    a = new Ti(t),
                    c = new Ti(e);
                let l;
                const d = i && function(t) {
                        t = Object.assign({
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0
                        }, t);
                        const e = new Ti(vi.window);
                        return e.top += t.top, e.height -= t.top, e.bottom -= t.bottom, e.height -= t.bottom, e
                    }(r) || null,
                    h = {
                        targetRect: c,
                        elementRect: a,
                        positionedElementAncestor: s,
                        viewportRect: d
                    };
                if (o || i) {
                    const t = o && new Ti(o).getVisible();
                    Object.assign(h, {
                        limiterRect: t,
                        viewportRect: d
                    }), l = function(t, e) {
                        const {
                            elementRect: n
                        } = e, o = n.getArea(), i = t.map((t => new Hi(t, e))).filter((t => !!t.name));
                        let r = 0,
                            s = null;
                        for (const t of i) {
                            const {
                                limiterIntersectionArea: e,
                                viewportIntersectionArea: n
                            } = t;
                            if (e === o) return t;
                            const i = n ** 2 + e ** 2;
                            i > r && (r = i, s = t)
                        }
                        return s
                    }(n, h) || new Hi(n[0], h)
                } else l = new Hi(n[0], h);
                return l
            }
    
            function Vi(t) {
                const {
                    scrollX: e,
                    scrollY: n
                } = vi.window;
                return t.clone().moveBy(e, n)
            }
            Bi._observerInstance = null, Bi._elementCallbacks = null;
            class Hi {
                constructor(t, e) {
                    const n = t(e.targetRect, e.elementRect, e.viewportRect);
                    if (!n) return;
                    const {
                        left: o,
                        top: i,
                        name: r,
                        config: s
                    } = n;
                    this.name = r, this.config = s, this._positioningFunctionCorrdinates = {
                        left: o,
                        top: i
                    }, this._options = e
                }
                get left() {
                    return this._absoluteRect.left
                }
                get top() {
                    return this._absoluteRect.top
                }
                get limiterIntersectionArea() {
                    const t = this._options.limiterRect;
                    if (t) {
                        const e = this._options.viewportRect;
                        if (!e) return t.getIntersectionArea(this._rect);
                        {
                            const n = t.getIntersection(e);
                            if (n) return n.getIntersectionArea(this._rect)
                        }
                    }
                    return 0
                }
                get viewportIntersectionArea() {
                    const t = this._options.viewportRect;
                    return t ? t.getIntersectionArea(this._rect) : 0
                }
                get _rect() {
                    return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect
                }
                get _absoluteRect() {
                    return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Vi(this._rect), this._options.positionedElementAncestor && function(t, e) {
                        const n = Vi(new Ti(e)),
                            o = Di(e);
                        let i = 0,
                            r = 0;
                        i -= n.left, r -= n.top, i += e.scrollLeft, r += e.scrollTop, i -= o.left, r -= o.top, t.moveBy(i, r)
                    }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect
                }
            }
    
            function Ui(t) {
                const e = t.parentNode;
                e && e.removeChild(t)
            }
    
            function Wi(t, e, n) {
                const o = e.clone().moveBy(0, n),
                    i = e.clone().moveBy(0, -n),
                    r = new Ti(t).excludeScrollbarsAndBorders();
                if (![i, o].every((t => r.contains(t)))) {
                    let {
                        scrollX: s,
                        scrollY: a
                    } = t;
                    $i(i, r) ? a -= r.top - e.top + n : Gi(o, r) && (a += e.bottom - r.bottom + n), Yi(e, r) ? s -= r.left - e.left + n : Ki(e, r) && (s += e.right - r.right + n), t.scrollTo(s, a)
                }
            }
    
            function qi(t, e) {
                const n = Qi(t);
                let o, i;
                for (; t != n.document.body;) i = e(), o = new Ti(t).excludeScrollbarsAndBorders(), o.contains(i) || ($i(i, o) ? t.scrollTop -= o.top - i.top : Gi(i, o) && (t.scrollTop += i.bottom - o.bottom), Yi(i, o) ? t.scrollLeft -= o.left - i.left : Ki(i, o) && (t.scrollLeft += i.right - o.right)), t = t.parentNode
            }
    
            function Gi(t, e) {
                return t.bottom > e.bottom
            }
    
            function $i(t, e) {
                return t.top < e.top
            }
    
            function Yi(t, e) {
                return t.left < e.left
            }
    
            function Ki(t, e) {
                return t.right > e.right
            }
    
            function Qi(t) {
                return Ei(t) ? t.startContainer.ownerDocument.defaultView : t.ownerDocument.defaultView
            }
    
            function Zi(t) {
                if (Ei(t)) {
                    let e = t.commonAncestorContainer;
                    return xi(e) && (e = e.parentNode), e
                }
                return t.parentNode
            }
    
            function Ji(t, e) {
                const n = Qi(t),
                    o = new Ti(t);
                if (n === e) return o;
                {
                    let t = n;
                    for (; t != e;) {
                        const e = t.frameElement,
                            n = new Ti(e).excludeScrollbarsAndBorders();
                        o.moveBy(n.left, n.top), t = t.parent
                    }
                }
                return o
            }
            const Xi = {
                    ctrl: "",
                    cmd: "",
                    alt: "",
                    shift: ""
                },
                tr = {
                    ctrl: "Ctrl+",
                    alt: "Alt+",
                    shift: "Shift+"
                },
                er = function() {
                    const t = {
                        arrowleft: 37,
                        arrowup: 38,
                        arrowright: 39,
                        arrowdown: 40,
                        backspace: 8,
                        delete: 46,
                        enter: 13,
                        space: 32,
                        esc: 27,
                        tab: 9,
                        ctrl: 1114112,
                        shift: 2228224,
                        alt: 4456448,
                        cmd: 8912896
                    };
                    for (let e = 65; e <= 90; e++) {
                        t[String.fromCharCode(e).toLowerCase()] = e
                    }
                    for (let e = 48; e <= 57; e++) t[e - 48] = e;
                    for (let e = 112; e <= 123; e++) t["f" + (e - 111)] = e;
                    for (const e of "`-=[];',./\\") t[e] = e.charCodeAt(0);
                    return t
                }(),
                nr = Object.fromEntries(Object.entries(er).map((([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)])));
    
            function or(t) {
                let e;
                if ("string" == typeof t) {
                    if (e = er[t.toLowerCase()], !e) throw new A("keyboard-unknown-key", null, {
                        key: t
                    })
                } else e = t.keyCode + (t.altKey ? er.alt : 0) + (t.ctrlKey ? er.ctrl : 0) + (t.shiftKey ? er.shift : 0) + (t.metaKey ? er.cmd : 0);
                return e
            }
    
            function ir(t) {
                return "string" == typeof t && (t = function(t) {
                    return t.split("+").map((t => t.trim()))
                }(t)), t.map((t => "string" == typeof t ? function(t) {
                    if (t.endsWith("!")) return or(t.slice(0, -1));
                    const e = or(t);
                    return a.isMac && e == er.ctrl ? er.cmd : e
                }(t) : t)).reduce(((t, e) => e + t), 0)
            }
    
            function rr(t) {
                let e = ir(t);
                return Object.entries(a.isMac ? Xi : tr).reduce(((t, [n, o]) => (0 != (e & er[n]) && (e &= ~er[n], t += o), t)), "") + (e ? nr[e] : "")
            }
    
            function sr(t, e) {
                const n = "ltr" === e;
                switch (t) {
                    case er.arrowleft:
                        return n ? "left" : "right";
                    case er.arrowright:
                        return n ? "right" : "left";
                    case er.arrowup:
                        return "up";
                    case er.arrowdown:
                        return "down"
                }
            }
    
            function ar(t) {
                return Array.isArray(t) ? t : [t]
            }
    
            function cr(t, e, n = 1) {
                if ("number" != typeof n) throw new A("translation-service-quantity-not-a-number", null, {
                    quantity: n
                });
                const o = Object.keys(vi.window.CKEDITOR_TRANSLATIONS).length;
                1 === o && (t = Object.keys(vi.window.CKEDITOR_TRANSLATIONS)[0]);
                const i = e.id || e.string;
                if (0 === o || ! function(t, e) {
                        return !!vi.window.CKEDITOR_TRANSLATIONS[t] && !!vi.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
                    }(t, i)) return 1 !== n ? e.plural : e.string;
                const r = vi.window.CKEDITOR_TRANSLATIONS[t].dictionary,
                    s = vi.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => 1 === t ? 0 : 1),
                    a = r[i];
                if ("string" == typeof a) return a;
                return a[Number(s(n))]
            }
            vi.window.CKEDITOR_TRANSLATIONS || (vi.window.CKEDITOR_TRANSLATIONS = {});
            const lr = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
    
            function dr(t) {
                return lr.includes(t) ? "rtl" : "ltr"
            }
            class hr {
                constructor({
                    uiLanguage: t = "en",
                    contentLanguage: e
                } = {}) {
                    this.uiLanguage = t, this.contentLanguage = e || this.uiLanguage, this.uiLanguageDirection = dr(this.uiLanguage), this.contentLanguageDirection = dr(this.contentLanguage), this.t = (t, e) => this._t(t, e)
                }
                get language() {
                    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage
                }
                _t(t, e = []) {
                    e = ar(e), "string" == typeof t && (t = {
                        string: t
                    });
                    const n = !!t.plural ? e[0] : 1;
                    return function(t, e) {
                        return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t))
                    }(cr(this.uiLanguage, t, n), e)
                }
            }
            class ur extends(N()) {
                constructor(t = {}, e = {}) {
                    super();
                    const n = nt(t);
                    if (n || (e = t), this._items = [], this._itemMap = new Map, this._idProperty = e.idProperty || "id", this._bindToExternalToInternalMap = new WeakMap, this._bindToInternalToExternalMap = new WeakMap, this._skippedIndexesFromExternal = [], n)
                        for (const e of t) this._items.push(e), this._itemMap.set(this._getItemIdBeforeAdding(e), e)
                }
                get length() {
                    return this._items.length
                }
                get first() {
                    return this._items[0] || null
                }
                get last() {
                    return this._items[this.length - 1] || null
                }
                add(t, e) {
                    return this.addMany([t], e)
                }
                addMany(t, e) {
                    if (void 0 === e) e = this._items.length;
                    else if (e > this._items.length || e < 0) throw new A("collection-add-item-invalid-index", this);
                    let n = 0;
                    for (const o of t) {
                        const t = this._getItemIdBeforeAdding(o),
                            i = e + n;
                        this._items.splice(i, 0, o), this._itemMap.set(t, o), this.fire("add", o, i), n++
                    }
                    return this.fire("change", {
                        added: t,
                        removed: [],
                        index: e
                    }), this
                }
                get(t) {
                    let e;
                    if ("string" == typeof t) e = this._itemMap.get(t);
                    else {
                        if ("number" != typeof t) throw new A("collection-get-invalid-arg", this);
                        e = this._items[t]
                    }
                    return e || null
                }
                has(t) {
                    if ("string" == typeof t) return this._itemMap.has(t);
                    {
                        const e = t[this._idProperty];
                        return e && this._itemMap.has(e)
                    }
                }
                getIndex(t) {
                    let e;
                    return e = "string" == typeof t ? this._itemMap.get(t) : t, e ? this._items.indexOf(e) : -1
                }
                remove(t) {
                    const [e, n] = this._remove(t);
                    return this.fire("change", {
                        added: [],
                        removed: [e],
                        index: n
                    }), e
                }
                map(t, e) {
                    return this._items.map(t, e)
                }
                find(t, e) {
                    return this._items.find(t, e)
                }
                filter(t, e) {
                    return this._items.filter(t, e)
                }
                clear() {
                    this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
                    const t = Array.from(this._items);
                    for (; this.length;) this._remove(0);
                    this.fire("change", {
                        added: [],
                        removed: t,
                        index: 0
                    })
                }
                bindTo(t) {
                    if (this._bindToCollection) throw new A("collection-bind-to-rebind", this);
                    return this._bindToCollection = t, {
                        as: t => {
                            this._setUpBindToBinding((e => new t(e)))
                        },
                        using: t => {
                            "function" == typeof t ? this._setUpBindToBinding(t) : this._setUpBindToBinding((e => e[t]))
                        }
                    }
                }
                _setUpBindToBinding(t) {
                    const e = this._bindToCollection,
                        n = (n, o, i) => {
                            const r = e._bindToCollection == this,
                                s = e._bindToInternalToExternalMap.get(o);
                            if (r && s) this._bindToExternalToInternalMap.set(o, s), this._bindToInternalToExternalMap.set(s, o);
                            else {
                                const n = t(o);
                                if (!n) return void this._skippedIndexesFromExternal.push(i);
                                let r = i;
                                for (const t of this._skippedIndexesFromExternal) i > t && r--;
                                for (const t of e._skippedIndexesFromExternal) r >= t && r++;
                                this._bindToExternalToInternalMap.set(o, n), this._bindToInternalToExternalMap.set(n, o), this.add(n, r);
                                for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) r <= e._skippedIndexesFromExternal[t] && e._skippedIndexesFromExternal[t]++
                            }
                        };
                    for (const t of e) n(0, t, e.getIndex(t));
                    this.listenTo(e, "add", n), this.listenTo(e, "remove", ((t, e, n) => {
                        const o = this._bindToExternalToInternalMap.get(e);
                        o && this.remove(o), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => (n < e && t.push(e - 1), n > e && t.push(e), t)), [])
                    }))
                }
                _getItemIdBeforeAdding(t) {
                    const e = this._idProperty;
                    let n;
                    if (e in t) {
                        if (n = t[e], "string" != typeof n) throw new A("collection-add-invalid-id", this);
                        if (this.get(n)) throw new A("collection-add-item-already-exists", this)
                    } else t[e] = n = k();
                    return n
                }
                _remove(t) {
                    let e, n, o, i = !1;
                    const r = this._idProperty;
                    if ("string" == typeof t ? (n = t, o = this._itemMap.get(n), i = !o, o && (e = this._items.indexOf(o))) : "number" == typeof t ? (e = t, o = this._items[e], i = !o, o && (n = o[r])) : (o = t, n = o[r], e = this._items.indexOf(o), i = -1 == e || !this._itemMap.get(n)), i) throw new A("collection-remove-404", this);
                    this._items.splice(e, 1), this._itemMap.delete(n);
                    const s = this._bindToInternalToExternalMap.get(o);
                    return this._bindToInternalToExternalMap.delete(o), this._bindToExternalToInternalMap.delete(s), this.fire("remove", o, e), [o, e]
                } [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
            }
    
            function gr(t) {
                const e = t.next();
                return e.done ? null : e.value
            }
            class mr extends(wi($())) {
                constructor() {
                    super(), this._elements = new Set, this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null)
                }
                add(t) {
                    if (this._elements.has(t)) throw new A("focustracker-add-element-already-exist", this);
                    this.listenTo(t, "focus", (() => this._focus(t)), {
                        useCapture: !0
                    }), this.listenTo(t, "blur", (() => this._blur()), {
                        useCapture: !0
                    }), this._elements.add(t)
                }
                remove(t) {
                    t === this.focusedElement && this._blur(), this._elements.has(t) && (this.stopListening(t), this._elements.delete(t))
                }
                destroy() {
                    this.stopListening()
                }
                _focus(t) {
                    clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t, this.isFocused = !0
                }
                _blur() {
                    clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout((() => {
                        this.focusedElement = null, this.isFocused = !1
                    }), 0)
                }
            }
            class pr {
                constructor() {
                    this._listener = new(wi())
                }
                listenTo(t) {
                    this._listener.listenTo(t, "keydown", ((t, e) => {
                        this._listener.fire("_keydown:" + or(e), e)
                    }))
                }
                set(t, e, n = {}) {
                    const o = ir(t),
                        i = n.priority;
                    this._listener.listenTo(this._listener, "_keydown:" + o, ((t, n) => {
                        e(n, (() => {
                            n.preventDefault(), n.stopPropagation(), t.stop()
                        })), t.return = !0
                    }), {
                        priority: i
                    })
                }
                press(t) {
                    return !!this._listener.fire("_keydown:" + or(t), t)
                }
                destroy() {
                    this._listener.stopListening()
                }
            }
    
            function fr(t) {
                return nt(t) ? new Map(t) : function(t) {
                    const e = new Map;
                    for (const n in t) e.set(n, t[n]);
                    return e
                }(t)
            }
            const kr = 1e4;
    
            function br(t, e) {
                return !!(n = t.charAt(e - 1)) && 1 == n.length && /[\ud800-\udbff]/.test(n) && function(t) {
                    return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t)
                }(t.charAt(e));
                var n
            }
    
            function wr(t, e) {
                return !!(n = t.charAt(e)) && 1 == n.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n);
                var n
            }
            const _r = function() {
                const t = /\p{Regional_Indicator}{2}/u.source,
                    e = "(?:" + [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u].map((t => t.source)).join("|") + ")";
                return new RegExp(`${t}|${e}(?:${e})*`, "ug")
            }();
    
            function Ar(t, e) {
                const n = String(t).matchAll(_r);
                return Array.from(n).some((t => t.index < e && e < t.index + t[0].length))
            }
            class Cr extends ur {
                constructor(t = []) {
                    super(t, {
                        idProperty: "viewUid"
                    }), this.on("add", ((t, e, n) => {
                        this._renderViewIntoCollectionParent(e, n)
                    })), this.on("remove", ((t, e) => {
                        e.element && this._parentElement && e.element.remove()
                    })), this._parentElement = null
                }
                destroy() {
                    this.map((t => t.destroy()))
                }
                setParent(t) {
                    this._parentElement = t;
                    for (const t of this) this._renderViewIntoCollectionParent(t)
                }
                delegate(...t) {
                    if (!t.length || !t.every((t => "string" == typeof t))) throw new A("ui-viewcollection-delegate-wrong-events", this);
                    return {
                        to: e => {
                            for (const n of this)
                                for (const o of t) n.delegate(o).to(e);
                            this.on("add", ((n, o) => {
                                for (const n of t) o.delegate(n).to(e)
                            })), this.on("remove", ((n, o) => {
                                for (const n of t) o.stopDelegating(n, e)
                            }))
                        }
                    }
                }
                _renderViewIntoCollectionParent(t, e) {
                    t.isRendered || t.render(), t.element && this._parentElement && this._parentElement.insertBefore(t.element, this._parentElement.children[e])
                }
            }
            var vr = n(6062),
                yr = n.n(vr),
                xr = n(4793),
                Er = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(xr.Z, Er);
            xr.Z.locals;
            class Dr extends(wi($())) {
                constructor(t) {
                    super(), this.element = null, this.isRendered = !1, this.locale = t, this.t = t && t.t, this._viewCollections = new ur, this._unboundChildren = this.createCollection(), this._viewCollections.on("add", ((e, n) => {
                        n.locale = t, n.t = t && t.t
                    })), this.decorate("render")
                }
                get bindTemplate() {
                    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Ir.bind(this, this)
                }
                createCollection(t) {
                    const e = new Cr(t);
                    return this._viewCollections.add(e), e
                }
                registerChild(t) {
                    nt(t) || (t = [t]);
                    for (const e of t) this._unboundChildren.add(e)
                }
                deregisterChild(t) {
                    nt(t) || (t = [t]);
                    for (const e of t) this._unboundChildren.remove(e)
                }
                setTemplate(t) {
                    this.template = new Ir(t)
                }
                extendTemplate(t) {
                    Ir.extend(this.template, t)
                }
                render() {
                    if (this.isRendered) throw new A("ui-view-render-already-rendered", this);
                    this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0
                }
                destroy() {
                    this.stopListening(), this._viewCollections.map((t => t.destroy())), this.template && this.template._revertData && this.template.revert(this.element)
                }
            }
            class Ir extends(N()) {
                constructor(t) {
                    super(), Object.assign(this, Rr(Or(t))), this._isRendered = !1, this._revertData = null
                }
                render() {
                    const t = this._renderNode({
                        intoFragment: !0
                    });
                    return this._isRendered = !0, t
                }
                apply(t) {
                    return this._revertData = {
                        children: [],
                        bindings: [],
                        attributes: {}
                    }, this._renderNode({
                        node: t,
                        intoFragment: !1,
                        isApplying: !0,
                        revertData: this._revertData
                    }), t
                }
                revert(t) {
                    if (!this._revertData) throw new A("ui-template-revert-not-applied", [this, t]);
                    this._revertTemplateFromNode(t, this._revertData)
                }* getViews() {
                    yield* function* t(e) {
                        if (e.children)
                            for (const n of e.children) Wr(n) ? yield n: qr(n) && (yield* t(n))
                    }(this)
                }
                static bind(t, e) {
                    return {
                        to: (n, o) => new Mr({
                            eventNameOrFunction: n,
                            attribute: n,
                            observable: t,
                            emitter: e,
                            callback: o
                        }),
                        if: (n, o, i) => new Sr({
                            observable: t,
                            emitter: e,
                            attribute: n,
                            valueIfTrue: o,
                            callback: i
                        })
                    }
                }
                static extend(t, e) {
                    if (t._isRendered) throw new A("template-extend-render", [this, t]);
                    Hr(t, Rr(Or(e)))
                }
                _renderNode(t) {
                    let e;
                    if (e = t.node ? this.tag && this.text : this.tag ? this.text : !this.text, e) throw new A("ui-template-wrong-syntax", this);
                    return this.text ? this._renderText(t) : this._renderElement(t)
                }
                _renderElement(t) {
                    let e = t.node;
                    return e || (e = t.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t), this._renderElementChildren(t), this._setUpListeners(t), e
                }
                _renderText(t) {
                    let e = t.node;
                    return e ? t.revertData.text = e.textContent : e = t.node = document.createTextNode(""), Nr(this.text) ? this._bindToObservable({
                        schema: this.text,
                        updater: Pr(e),
                        data: t
                    }) : e.textContent = this.text.join(""), e
                }
                _renderAttributes(t) {
                    if (!this.attributes) return;
                    const e = t.node,
                        n = t.revertData;
                    for (const o in this.attributes) {
                        const i = e.getAttribute(o),
                            r = this.attributes[o];
                        n && (n.attributes[o] = i);
                        const s = $r(r) ? r[0].ns : null;
                        if (Nr(r)) {
                            const a = $r(r) ? r[0].value : r;
                            n && Yr(o) && a.unshift(i), this._bindToObservable({
                                schema: a,
                                updater: zr(e, o, s),
                                data: t
                            })
                        } else if ("style" == o && "string" != typeof r[0]) this._renderStyleAttribute(r[0], t);
                        else {
                            n && i && Yr(o) && r.unshift(i);
                            const t = r.map((t => t && t.value || t)).reduce(((t, e) => t.concat(e)), []).reduce(Fr, "");
                            Ur(t) || e.setAttributeNS(s, o, t)
                        }
                    }
                }
                _renderStyleAttribute(t, e) {
                    const n = e.node;
                    for (const o in t) {
                        const i = t[o];
                        Nr(i) ? this._bindToObservable({
                            schema: [i],
                            updater: Lr(n, o),
                            data: e
                        }) : n.style[o] = i
                    }
                }
                _renderElementChildren(t) {
                    const e = t.node,
                        n = t.intoFragment ? document.createDocumentFragment() : e,
                        o = t.isApplying;
                    let i = 0;
                    for (const r of this.children)
                        if (Gr(r)) {
                            if (!o) {
                                r.setParent(e);
                                for (const t of r) n.appendChild(t.element)
                            }
                        } else if (Wr(r)) o || (r.isRendered || r.render(), n.appendChild(r.element));
                    else if (fi(r)) n.appendChild(r);
                    else if (o) {
                        const e = {
                            children: [],
                            bindings: [],
                            attributes: {}
                        };
                        t.revertData.children.push(e), r._renderNode({
                            intoFragment: !1,
                            node: n.childNodes[i++],
                            isApplying: !0,
                            revertData: e
                        })
                    } else n.appendChild(r.render());
                    t.intoFragment && e.appendChild(n)
                }
                _setUpListeners(t) {
                    if (this.eventListeners)
                        for (const e in this.eventListeners) {
                            const n = this.eventListeners[e].map((n => {
                                const [o, i] = e.split("@");
                                return n.activateDomEventListener(o, i, t)
                            }));
                            t.revertData && t.revertData.bindings.push(n)
                        }
                }
                _bindToObservable({
                    schema: t,
                    updater: e,
                    data: n
                }) {
                    const o = n.revertData;
                    Br(t, e, n);
                    const i = t.filter((t => !Ur(t))).filter((t => t.observable)).map((o => o.activateAttributeListener(t, e, n)));
                    o && o.bindings.push(i)
                }
                _revertTemplateFromNode(t, e) {
                    for (const t of e.bindings)
                        for (const e of t) e();
                    if (e.text) return void(t.textContent = e.text);
                    const n = t;
                    for (const t in e.attributes) {
                        const o = e.attributes[t];
                        null === o ? n.removeAttribute(t) : n.setAttribute(t, o)
                    }
                    for (let t = 0; t < e.children.length; ++t) this._revertTemplateFromNode(n.childNodes[t], e.children[t])
                }
            }
            class Tr {
                constructor(t) {
                    this.attribute = t.attribute, this.observable = t.observable, this.emitter = t.emitter, this.callback = t.callback
                }
                getValue(t) {
                    const e = this.observable[this.attribute];
                    return this.callback ? this.callback(e, t) : e
                }
                activateAttributeListener(t, e, n) {
                    const o = () => Br(t, e, n);
                    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, o), () => {
                        this.emitter.stopListening(this.observable, `change:${this.attribute}`, o)
                    }
                }
            }
            class Mr extends Tr {
                constructor(t) {
                    super(t), this.eventNameOrFunction = t.eventNameOrFunction
                }
                activateDomEventListener(t, e, n) {
                    const o = (t, n) => {
                        e && !n.target.matches(e) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n) : this.observable.fire(this.eventNameOrFunction, n))
                    };
                    return this.emitter.listenTo(n.node, t, o), () => {
                        this.emitter.stopListening(n.node, t, o)
                    }
                }
            }
            class Sr extends Tr {
                constructor(t) {
                    super(t), this.valueIfTrue = t.valueIfTrue
                }
                getValue(t) {
                    return !Ur(super.getValue(t)) && (this.valueIfTrue || !0)
                }
            }
    
            function Nr(t) {
                return !!t && (t.value && (t = t.value), Array.isArray(t) ? t.some(Nr) : t instanceof Tr)
            }
    
            function Br(t, e, {
                node: n
            }) {
                const o = function(t, e) {
                    return t.map((t => t instanceof Tr ? t.getValue(e) : t))
                }(t, n);
                let i;
                i = 1 == t.length && t[0] instanceof Sr ? o[0] : o.reduce(Fr, ""), Ur(i) ? e.remove() : e.set(i)
            }
    
            function Pr(t) {
                return {
                    set(e) {
                        t.textContent = e
                    },
                    remove() {
                        t.textContent = ""
                    }
                }
            }
    
            function zr(t, e, n) {
                return {
                    set(o) {
                        t.setAttributeNS(n, e, o)
                    },
                    remove() {
                        t.removeAttributeNS(n, e)
                    }
                }
            }
    
            function Lr(t, e) {
                return {
                    set(n) {
                        t.style[e] = n
                    },
                    remove() {
                        t.style[e] = null
                    }
                }
            }
    
            function Or(t) {
                return hi(t, (t => {
                    if (t && (t instanceof Tr || qr(t) || Wr(t) || Gr(t))) return t
                }))
            }
    
            function Rr(t) {
                if ("string" == typeof t ? t = function(t) {
                        return {
                            text: [t]
                        }
                    }(t) : t.text && function(t) {
                        t.text = ar(t.text)
                    }(t), t.on && (t.eventListeners = function(t) {
                        for (const e in t) jr(t, e);
                        return t
                    }(t.on), delete t.on), !t.text) {
                    t.attributes && function(t) {
                        for (const e in t) t[e].value && (t[e].value = ar(t[e].value)), jr(t, e)
                    }(t.attributes);
                    const e = [];
                    if (t.children)
                        if (Gr(t.children)) e.push(t.children);
                        else
                            for (const n of t.children) qr(n) || Wr(n) || fi(n) ? e.push(n) : e.push(new Ir(n));
                    t.children = e
                }
                return t
            }
    
            function jr(t, e) {
                t[e] = ar(t[e])
            }
    
            function Fr(t, e) {
                return Ur(e) ? t : Ur(t) ? e : `${t} ${e}`
            }
    
            function Vr(t, e) {
                for (const n in e) t[n] ? t[n].push(...e[n]) : t[n] = e[n]
            }
    
            function Hr(t, e) {
                if (e.attributes && (t.attributes || (t.attributes = {}), Vr(t.attributes, e.attributes)), e.eventListeners && (t.eventListeners || (t.eventListeners = {}), Vr(t.eventListeners, e.eventListeners)), e.text && t.text.push(...e.text), e.children && e.children.length) {
                    if (t.children.length != e.children.length) throw new A("ui-template-extend-children-mismatch", t);
                    let n = 0;
                    for (const o of e.children) Hr(t.children[n++], o)
                }
            }
    
            function Ur(t) {
                return !t && 0 !== t
            }
    
            function Wr(t) {
                return t instanceof Dr
            }
    
            function qr(t) {
                return t instanceof Ir
            }
    
            function Gr(t) {
                return t instanceof Cr
            }
    
            function $r(t) {
                return F(t[0]) && t[0].ns
            }
    
            function Yr(t) {
                return "class" == t || "style" == t
            }
            class Kr extends Cr {
                constructor(t, e = []) {
                    super(e), this.locale = t
                }
                attachToDom() {
                    this._bodyCollectionContainer = new Ir({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                            dir: this.locale.uiLanguageDirection
                        },
                        children: this
                    }).render();
                    let t = document.querySelector(".ck-body-wrapper");
                    t || (t = Ct(document, "div", {
                        class: "ck-body-wrapper"
                    }), document.body.appendChild(t)), t.appendChild(this._bodyCollectionContainer)
                }
                detachFromDom() {
                    super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
                    const t = document.querySelector(".ck-body-wrapper");
                    t && 0 == t.childElementCount && t.remove()
                }
            }
            var Qr = n(6574),
                Zr = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Qr.Z, Zr);
            Qr.Z.locals;
            class Jr extends Dr {
                constructor() {
                    super();
                    const t = this.bindTemplate;
                    this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({
                        tag: "svg",
                        ns: "http://www.w3.org/2000/svg",
                        attributes: {
                            class: ["ck", "ck-icon", "ck-reset_all-excluded", t.if("isColorInherited", "ck-icon_inherit-color")],
                            viewBox: t.to("viewBox")
                        }
                    })
                }
                render() {
                    super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", (() => {
                        this._updateXMLContent(), this._colorFillPaths()
                    })), this.on("change:fillColor", (() => {
                        this._colorFillPaths()
                    }))
                }
                _updateXMLContent() {
                    if (this.content) {
                        const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"),
                            e = t.getAttribute("viewBox");
                        e && (this.viewBox = e);
                        for (const {
                                name: e,
                                value: n
                            }
                            of Array.from(t.attributes)) Jr.presentationalAttributeNames.includes(e) && this.element.setAttribute(e, n);
                        for (; this.element.firstChild;) this.element.removeChild(this.element.firstChild);
                        for (; t.childNodes.length > 0;) this.element.appendChild(t.childNodes[0])
                    }
                }
                _colorFillPaths() {
                    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t => {
                        t.style.fill = this.fillColor
                    }))
                }
            }
            Jr.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
            var Xr = n(4906),
                ts = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Xr.Z, ts);
            Xr.Z.locals;
            class es extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate,
                        n = k();
                    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(n), this.iconView = new Jr, this.iconView.extendTemplate({
                        attributes: {
                            class: "ck-button__icon"
                        }
                    }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                    const o = {
                        tag: "button",
                        attributes: {
                            class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                            type: e.to("type", (t => t || "button")),
                            tabindex: e.to("tabindex"),
                            "aria-labelledby": `ck-editor__aria-label_${n}`,
                            "aria-disabled": e.if("isEnabled", !0, (t => !t)),
                            "aria-pressed": e.to("isOn", (t => !!this.isToggleable && String(!!t))),
                            "data-cke-tooltip-text": e.to("_tooltipString"),
                            "data-cke-tooltip-position": e.to("tooltipPosition")
                        },
                        children: this.children,
                        on: {
                            click: e.to((t => {
                                this.isEnabled ? this.fire("execute") : t.preventDefault()
                            }))
                        }
                    };
                    a.isSafari && (o.on.mousedown = e.to((t => {
                        this.focus(), t.preventDefault()
                    }))), this.setTemplate(o)
                }
                render() {
                    super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView)
                }
                focus() {
                    this.element.focus()
                }
                _createLabelView(t) {
                    const e = new Dr,
                        n = this.bindTemplate;
                    return e.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__label"],
                            style: n.to("labelStyle"),
                            id: `ck-editor__aria-label_${t}`
                        },
                        children: [{
                            text: this.bindTemplate.to("label")
                        }]
                    }), e
                }
                _createKeystrokeView() {
                    const t = new Dr;
                    return t.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__keystroke"]
                        },
                        children: [{
                            text: this.bindTemplate.to("keystroke", (t => rr(t)))
                        }]
                    }), t
                }
                _getTooltipString(t, e, n) {
                    return t ? "string" == typeof t ? t : (n && (n = rr(n)), t instanceof Function ? t(e, n) : `${e}${n?` (${n})`:""}`) : ""
                }
            }
            var ns = n(5332),
                os = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(ns.Z, os);
            ns.Z.locals;
            class is extends es {
                constructor(t) {
                    super(t), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({
                        attributes: {
                            class: "ck-switchbutton"
                        }
                    })
                }
                render() {
                    super.render(), this.children.add(this.toggleSwitchView)
                }
                _createToggleView() {
                    const t = new Dr;
                    return t.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__toggle"]
                        },
                        children: [{
                            tag: "span",
                            attributes: {
                                class: ["ck", "ck-button__toggle__inner"]
                            }
                        }]
                    }), t
                }
            }
            var rs = n(6781),
                ss = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(rs.Z, ss);
            rs.Z.locals;
            class as {
                constructor(t) {
                    this.editor = t, this._components = new Map
                }* names() {
                    for (const t of this._components.values()) yield t.originalName
                }
                add(t, e) {
                    this._components.set(cs(t), {
                        callback: e,
                        originalName: t
                    })
                }
                create(t) {
                    if (!this.has(t)) throw new A("componentfactory-item-missing", this, {
                        name: t
                    });
                    return this._components.get(cs(t)).callback(this.editor.locale)
                }
                has(t) {
                    return this._components.has(cs(t))
                }
            }
    
            function cs(t) {
                return String(t).toLowerCase()
            }
            var ls = n(5485),
                ds = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(ls.Z, ds);
            ls.Z.locals;
            class hs extends Dr {
                constructor(t, e, n) {
                    super(t);
                    const o = this.bindTemplate;
                    this.buttonView = e, this.panelView = n, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new pr, this.focusTracker = new mr, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dropdown", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t))],
                            id: o.to("id"),
                            "aria-describedby": o.to("ariaDescribedById")
                        },
                        children: [e, n]
                    }), e.extendTemplate({
                        attributes: {
                            class: ["ck-dropdown__button"],
                            "data-cke-tooltip-disabled": o.to("isOpen")
                        }
                    })
                }
                render() {
                    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", (() => {
                        this.isOpen = !this.isOpen
                    })), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", ((t, e, n) => {
                        n && ("auto" === this.panelPosition ? this.panelView.position = hs._getOptimalPosition({
                            element: this.panelView.element,
                            target: this.buttonView.element,
                            fitInViewport: !0,
                            positions: this._panelPositions
                        }).name : this.panelView.position = this.panelPosition)
                    })), this.keystrokes.listenTo(this.element);
                    const t = (t, e) => {
                        this.isOpen && (this.isOpen = !1, e())
                    };
                    this.keystrokes.set("arrowdown", ((t, e) => {
                        this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, e())
                    })), this.keystrokes.set("arrowright", ((t, e) => {
                        this.isOpen && e()
                    })), this.keystrokes.set("arrowleft", t), this.keystrokes.set("esc", t)
                }
                focus() {
                    this.buttonView.focus()
                }
                get _panelPositions() {
                    const {
                        south: t,
                        north: e,
                        southEast: n,
                        southWest: o,
                        northEast: i,
                        northWest: r,
                        southMiddleEast: s,
                        southMiddleWest: a,
                        northMiddleEast: c,
                        northMiddleWest: l
                    } = hs.defaultPanelPositions;
                    return "rtl" !== this.locale.uiLanguageDirection ? [n, o, s, a, t, i, r, c, l, e] : [o, n, a, s, t, r, i, l, c, e]
                }
            }
            hs.defaultPanelPositions = {
                south: (t, e) => ({
                    top: t.bottom,
                    left: t.left - (e.width - t.width) / 2,
                    name: "s"
                }),
                southEast: t => ({
                    top: t.bottom,
                    left: t.left,
                    name: "se"
                }),
                southWest: (t, e) => ({
                    top: t.bottom,
                    left: t.left - e.width + t.width,
                    name: "sw"
                }),
                southMiddleEast: (t, e) => ({
                    top: t.bottom,
                    left: t.left - (e.width - t.width) / 4,
                    name: "sme"
                }),
                southMiddleWest: (t, e) => ({
                    top: t.bottom,
                    left: t.left - 3 * (e.width - t.width) / 4,
                    name: "smw"
                }),
                north: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left - (e.width - t.width) / 2,
                    name: "n"
                }),
                northEast: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left,
                    name: "ne"
                }),
                northWest: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left - e.width + t.width,
                    name: "nw"
                }),
                northMiddleEast: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left - (e.width - t.width) / 4,
                    name: "nme"
                }),
                northMiddleWest: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left - 3 * (e.width - t.width) / 4,
                    name: "nmw"
                })
            }, hs._getOptimalPosition = Fi;
            const us = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
            class gs extends es {
                constructor(t) {
                    super(t), this.arrowView = this._createArrowView(), this.extendTemplate({
                        attributes: {
                            "aria-haspopup": !0,
                            "aria-expanded": this.bindTemplate.to("isOn", (t => String(t)))
                        }
                    }), this.delegate("execute").to(this, "open")
                }
                render() {
                    super.render(), this.children.add(this.arrowView)
                }
                _createArrowView() {
                    const t = new Jr;
                    return t.content = us, t.extendTemplate({
                        attributes: {
                            class: "ck-dropdown__arrow"
                        }
                    }), t
                }
            }
            var ms = n(7686),
                ps = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(ms.Z, ps);
            ms.Z.locals;
            class fs extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new pr, this.focusTracker = new mr, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-splitbutton", e.to("class"), e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]
                        },
                        children: this.children
                    })
                }
                render() {
                    super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", ((t, e) => {
                        this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e())
                    })), this.keystrokes.set("arrowleft", ((t, e) => {
                        this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e())
                    }))
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                focus() {
                    this.actionView.focus()
                }
                _createActionView() {
                    const t = new es;
                    return t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({
                        attributes: {
                            class: "ck-splitbutton__action"
                        }
                    }), t.delegate("execute").to(this), t
                }
                _createArrowView() {
                    const t = new es,
                        e = t.bindTemplate;
                    return t.icon = us, t.extendTemplate({
                        attributes: {
                            class: ["ck-splitbutton__arrow"],
                            "data-cke-tooltip-disabled": e.to("isOn"),
                            "aria-haspopup": !0,
                            "aria-expanded": e.to("isOn", (t => String(t)))
                        }
                    }), t.bind("isEnabled").to(this), t.bind("label").to(this), t.bind("tooltip").to(this), t.delegate("execute").to(this, "open"), t
                }
            }
            class ks extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")]
                        },
                        children: this.children,
                        on: {
                            selectstart: e.to((t => t.preventDefault()))
                        }
                    })
                }
                focus() {
                    if (this.children.length) {
                        const t = this.children.first;
                        "function" == typeof t.focus ? t.focus() : C("ui-dropdown-panel-focus-child-missing-focus", {
                            childView: this.children.first,
                            dropdownPanel: this
                        })
                    }
                }
                focusLast() {
                    if (this.children.length) {
                        const t = this.children.last;
                        "function" == typeof t.focusLast ? t.focusLast() : t.focus()
                    }
                }
            }
            class bs {
                constructor(t) {
                    if (this.focusables = t.focusables, this.focusTracker = t.focusTracker, this.keystrokeHandler = t.keystrokeHandler, this.actions = t.actions, t.actions && t.keystrokeHandler)
                        for (const e in t.actions) {
                            let n = t.actions[e];
                            "string" == typeof n && (n = [n]);
                            for (const o of n) t.keystrokeHandler.set(o, ((t, n) => {
                                this[e](), n()
                            }))
                        }
                }
                get first() {
                    return this.focusables.find(ws) || null
                }
                get last() {
                    return this.focusables.filter(ws).slice(-1)[0] || null
                }
                get next() {
                    return this._getFocusableItem(1)
                }
                get previous() {
                    return this._getFocusableItem(-1)
                }
                get current() {
                    let t = null;
                    return null === this.focusTracker.focusedElement ? null : (this.focusables.find(((e, n) => {
                        const o = e.element === this.focusTracker.focusedElement;
                        return o && (t = n), o
                    })), t)
                }
                focusFirst() {
                    this._focus(this.first)
                }
                focusLast() {
                    this._focus(this.last)
                }
                focusNext() {
                    this._focus(this.next)
                }
                focusPrevious() {
                    this._focus(this.previous)
                }
                _focus(t) {
                    t && t.focus()
                }
                _getFocusableItem(t) {
                    const e = this.current,
                        n = this.focusables.length;
                    if (!n) return null;
                    if (null === e) return this[1 === t ? "first" : "last"];
                    let o = (e + n + t) % n;
                    do {
                        const e = this.focusables.get(o);
                        if (ws(e)) return e;
                        o = (o + n + t) % n
                    } while (o !== e);
                    return null
                }
            }
    
            function ws(t) {
                return !(!t.focus || !ji(t.element))
            }
            class _s extends Dr {
                constructor(t) {
                    super(t), this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-toolbar__separator"]
                        }
                    })
                }
            }
            class As extends Dr {
                constructor(t) {
                    super(t), this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-toolbar__line-break"]
                        }
                    })
                }
            }
    
            function Cs(t) {
                return Array.isArray(t) ? {
                    items: t,
                    removeItems: []
                } : t ? Object.assign({
                    items: [],
                    removeItems: []
                }, t) : {
                    items: [],
                    removeItems: []
                }
            }
            class vs extends($()) {
                constructor(t) {
                    super(), this.editor = t, this.set("isEnabled", !0), this._disableStack = new Set
                }
                forceDisabled(t) {
                    this._disableStack.add(t), 1 == this._disableStack.size && (this.on("set:isEnabled", ys, {
                        priority: "highest"
                    }), this.isEnabled = !1)
                }
                clearForceDisabled(t) {
                    this._disableStack.delete(t), 0 == this._disableStack.size && (this.off("set:isEnabled", ys), this.isEnabled = !0)
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return !1
                }
            }
    
            function ys(t) {
                t.return = !1, t.stop()
            }
            class xs extends($()) {
                constructor(t) {
                    super(), this.editor = t, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._disableStack = new Set, this.decorate("execute"), this.listenTo(this.editor.model.document, "change", (() => {
                        this.refresh()
                    })), this.on("execute", (t => {
                        this.isEnabled || t.stop()
                    }), {
                        priority: "high"
                    }), this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                        n && this.affectsData ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
                    }))
                }
                get affectsData() {
                    return this._affectsData
                }
                set affectsData(t) {
                    this._affectsData = t
                }
                refresh() {
                    this.isEnabled = !0
                }
                forceDisabled(t) {
                    this._disableStack.add(t), 1 == this._disableStack.size && (this.on("set:isEnabled", Es, {
                        priority: "highest"
                    }), this.isEnabled = !1)
                }
                clearForceDisabled(t) {
                    this._disableStack.delete(t), 0 == this._disableStack.size && (this.off("set:isEnabled", Es), this.refresh())
                }
                execute(...t) {}
                destroy() {
                    this.stopListening()
                }
            }
    
            function Es(t) {
                t.return = !1, t.stop()
            }
            class Ds extends xs {
                constructor(t) {
                    super(t), this._childCommandsDefinitions = []
                }
                refresh() {}
                execute(...t) {
                    const e = this._getFirstEnabledCommand();
                    return !!e && e.execute(t)
                }
                registerChildCommand(t, e = {}) {
                    w(this._childCommandsDefinitions, {
                        command: t,
                        priority: e.priority || "normal"
                    }), t.on("change:isEnabled", (() => this._checkEnabled())), this._checkEnabled()
                }
                _checkEnabled() {
                    this.isEnabled = !!this._getFirstEnabledCommand()
                }
                _getFirstEnabledCommand() {
                    const t = this._childCommandsDefinitions.find((({
                        command: t
                    }) => t.isEnabled));
                    return t && t.command
                }
            }
            class Is extends(N()) {
                constructor(t, e = [], n = []) {
                    super(), this._context = t, this._plugins = new Map, this._availablePlugins = new Map;
                    for (const t of e) t.pluginName && this._availablePlugins.set(t.pluginName, t);
                    this._contextPlugins = new Map;
                    for (const [t, e] of n) this._contextPlugins.set(t, e), this._contextPlugins.set(e, t), t.pluginName && this._availablePlugins.set(t.pluginName, t)
                }*[Symbol.iterator]() {
                    for (const t of this._plugins) "function" == typeof t[0] && (yield t)
                }
                get(t) {
                    const e = this._plugins.get(t);
                    if (!e) {
                        let e = t;
                        throw "function" == typeof t && (e = t.pluginName || t.name), new A("plugincollection-plugin-not-loaded", this._context, {
                            plugin: e
                        })
                    }
                    return e
                }
                has(t) {
                    return this._plugins.has(t)
                }
                init(t, e = [], n = []) {
                    const o = this,
                        i = this._context;
                    ! function t(e, n = new Set) {
                        e.forEach((e => {
                            a(e) && (n.has(e) || (n.add(e), e.pluginName && !o._availablePlugins.has(e.pluginName) && o._availablePlugins.set(e.pluginName, e), e.requires && t(e.requires, n)))
                        }))
                    }(t), h(t);
                    const r = [... function t(e, n = new Set) {
                        return e.map((t => a(t) ? t : o._availablePlugins.get(t))).reduce(((e, o) => n.has(o) ? e : (n.add(o), o.requires && (h(o.requires, o), t(o.requires, n).forEach((t => e.add(t)))), e.add(o))), new Set)
                    }(t.filter((t => !l(t, e))))];
                    ! function(t, e) {
                        for (const n of e) {
                            if ("function" != typeof n) throw new A("plugincollection-replace-plugin-invalid-type", null, {
                                pluginItem: n
                            });
                            const e = n.pluginName;
                            if (!e) throw new A("plugincollection-replace-plugin-missing-name", null, {
                                pluginItem: n
                            });
                            if (n.requires && n.requires.length) throw new A("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {
                                pluginName: e
                            });
                            const i = o._availablePlugins.get(e);
                            if (!i) throw new A("plugincollection-plugin-for-replacing-not-exist", null, {
                                pluginName: e
                            });
                            const r = t.indexOf(i);
                            if (-1 === r) {
                                if (o._contextPlugins.has(i)) return;
                                throw new A("plugincollection-plugin-for-replacing-not-loaded", null, {
                                    pluginName: e
                                })
                            }
                            if (i.requires && i.requires.length) throw new A("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                                pluginName: e
                            });
                            t.splice(r, 1, n), o._availablePlugins.set(e, n)
                        }
                    }(r, n);
                    const s = function(t) {
                        return t.map((t => {
                            let e = o._contextPlugins.get(t);
                            return e = e || new t(i), o._add(t, e), e
                        }))
                    }(r);
                    return u(s, "init").then((() => u(s, "afterInit"))).then((() => s));
    
                    function a(t) {
                        return "function" == typeof t
                    }
    
                    function c(t) {
                        return a(t) && t.isContextPlugin
                    }
    
                    function l(t, e) {
                        return e.some((e => e === t || (d(t) === e || d(e) === t)))
                    }
    
                    function d(t) {
                        return a(t) ? t.pluginName || t.name : t
                    }
    
                    function h(t, n = null) {
                        t.map((t => a(t) ? t : o._availablePlugins.get(t) || t)).forEach((t => {
                            ! function(t, e) {
                                if (a(t)) return;
                                if (e) throw new A("plugincollection-soft-required", i, {
                                    missingPlugin: t,
                                    requiredBy: d(e)
                                });
                                throw new A("plugincollection-plugin-not-found", i, {
                                    plugin: t
                                })
                            }(t, n),
                            function(t, e) {
                                if (!c(e)) return;
                                if (c(t)) return;
                                throw new A("plugincollection-context-required", i, {
                                    plugin: d(t),
                                    requiredBy: d(e)
                                })
                            }(t, n),
                            function(t, n) {
                                if (!n) return;
                                if (!l(t, e)) return;
                                throw new A("plugincollection-required", i, {
                                    plugin: d(t),
                                    requiredBy: d(n)
                                })
                            }(t, n)
                        }))
                    }
    
                    function u(t, e) {
                        return t.reduce(((t, n) => n[e] ? o._contextPlugins.has(n) ? t : t.then(n[e].bind(n)) : t), Promise.resolve())
                    }
                }
                destroy() {
                    const t = [];
                    for (const [, e] of this) "function" != typeof e.destroy || this._contextPlugins.has(e) || t.push(e.destroy());
                    return Promise.all(t)
                }
                _add(t, e) {
                    this._plugins.set(t, e);
                    const n = t.pluginName;
                    if (n) {
                        if (this._plugins.has(n)) throw new A("plugincollection-plugin-name-conflict", null, {
                            pluginName: n,
                            plugin1: this._plugins.get(n).constructor,
                            plugin2: t
                        });
                        this._plugins.set(n, e)
                    }
                }
            }
            class Ts {
                constructor(t) {
                    this.config = new gi(t, this.constructor.defaultConfig);
                    const e = this.constructor.builtinPlugins;
                    this.config.define("plugins", e), this.plugins = new Is(this, e);
                    const n = this.config.get("language") || {};
                    this.locale = new hr({
                        uiLanguage: "string" == typeof n ? n : n.ui,
                        contentLanguage: this.config.get("language.content")
                    }), this.t = this.locale.t, this.editors = new ur, this._contextOwner = null
                }
                initPlugins() {
                    const t = this.config.get("plugins") || [],
                        e = this.config.get("substitutePlugins") || [];
                    for (const n of t.concat(e)) {
                        if ("function" != typeof n) throw new A("context-initplugins-constructor-only", null, {
                            Plugin: n
                        });
                        if (!0 !== n.isContextPlugin) throw new A("context-initplugins-invalid-plugin", null, {
                            Plugin: n
                        })
                    }
                    return this.plugins.init(t, [], e)
                }
                destroy() {
                    return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy()))
                }
                _addEditor(t, e) {
                    if (this._contextOwner) throw new A("context-addeditor-private-context");
                    this.editors.add(t), e && (this._contextOwner = t)
                }
                _removeEditor(t) {
                    return this.editors.has(t) && this.editors.remove(t), this._contextOwner === t ? this.destroy() : Promise.resolve()
                }
                _getEditorConfig() {
                    const t = {};
                    for (const e of this.config.names())["plugins", "removePlugins", "extraPlugins"].includes(e) || (t[e] = this.config.get(e));
                    return t
                }
                static create(t) {
                    return new Promise((e => {
                        const n = new this(t);
                        e(n.initPlugins().then((() => n)))
                    }))
                }
            }
            class Ms extends($()) {
                constructor(t) {
                    super(), this.context = t
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return !0
                }
            }
            var Ss = n(4717),
                Ns = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Ss.Z, Ns);
            Ss.Z.locals;
            const Bs = new WeakMap;
    
            function Ps(t) {
                const {
                    view: e,
                    element: n,
                    text: o,
                    isDirectHost: i = !0,
                    keepOnFocus: r = !1
                } = t, s = e.document;
                Bs.has(s) || (Bs.set(s, new Map), s.registerPostFixer((t => Ls(s, t))), s.on("change:isComposing", (() => {
                    e.change((t => Ls(s, t)))
                }), {
                    priority: "high"
                })), Bs.get(s).set(n, {
                    text: o,
                    isDirectHost: i,
                    keepOnFocus: r,
                    hostElement: i ? n : null
                }), e.change((t => Ls(s, t)))
            }
    
            function zs(t, e) {
                return !!e.hasClass("ck-placeholder") && (t.removeClass("ck-placeholder", e), !0)
            }
    
            function Ls(t, e) {
                const n = Bs.get(t),
                    o = [];
                let i = !1;
                for (const [t, r] of n) r.isDirectHost && (o.push(t), Os(e, t, r) && (i = !0));
                for (const [t, r] of n) {
                    if (r.isDirectHost) continue;
                    const n = Rs(t);
                    n && (o.includes(n) || (r.hostElement = n, Os(e, t, r) && (i = !0)))
                }
                return i
            }
    
            function Os(t, e, n) {
                const {
                    text: o,
                    isDirectHost: i,
                    hostElement: r
                } = n;
                let s = !1;
                r.getAttribute("data-placeholder") !== o && (t.setAttribute("data-placeholder", o, r), s = !0);
                return (i || 1 == e.childCount) && function(t, e) {
                    if (!t.isAttached()) return !1;
                    const n = Array.from(t.getChildren()).some((t => !t.is("uiElement")));
                    if (n) return !1;
                    const o = t.document,
                        i = o.selection.anchor;
                    return !(o.isComposing && i && i.parent === t || !e && o.isFocused && (!i || i.parent === t))
                }(r, n.keepOnFocus) ? function(t, e) {
                    return !e.hasClass("ck-placeholder") && (t.addClass("ck-placeholder", e), !0)
                }(t, r) && (s = !0) : zs(t, r) && (s = !0), s
            }
    
            function Rs(t) {
                if (t.childCount) {
                    const e = t.getChild(0);
                    if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) return e
                }
                return null
            }
            class js {
                is() {
                    throw new Error("is() method is abstract")
                }
            }
            var Fs = 4;
            const Vs = function(t) {
                return ci(t, Fs)
            };
            class Hs extends(N(js)) {
                constructor(t) {
                    super(), this.document = t, this.parent = null
                }
                get index() {
                    let t;
                    if (!this.parent) return null;
                    if (-1 == (t = this.parent.getChildIndex(this))) throw new A("view-node-not-found-in-parent", this);
                    return t
                }
                get nextSibling() {
                    const t = this.index;
                    return null !== t && this.parent.getChild(t + 1) || null
                }
                get previousSibling() {
                    const t = this.index;
                    return null !== t && this.parent.getChild(t - 1) || null
                }
                get root() {
                    let t = this;
                    for (; t.parent;) t = t.parent;
                    return t
                }
                isAttached() {
                    return this.root.is("rootElement")
                }
                getPath() {
                    const t = [];
                    let e = this;
                    for (; e.parent;) t.unshift(e.index), e = e.parent;
                    return t
                }
                getAncestors(t = {}) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return e
                }
                getCommonAncestor(t, e = {}) {
                    const n = this.getAncestors(e),
                        o = t.getAncestors(e);
                    let i = 0;
                    for (; n[i] == o[i] && n[i];) i++;
                    return 0 === i ? null : n[i - 1]
                }
                isBefore(t) {
                    if (this == t) return !1;
                    if (this.root !== t.root) return !1;
                    const e = this.getPath(),
                        n = t.getPath(),
                        o = et(e, n);
                    switch (o) {
                        case "prefix":
                            return !0;
                        case "extension":
                            return !1;
                        default:
                            return e[o] < n[o]
                    }
                }
                isAfter(t) {
                    return this != t && (this.root === t.root && !this.isBefore(t))
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _fireChange(t, e) {
                    this.fire(`change:${t}`, e), this.parent && this.parent._fireChange(t, e)
                }
                toJSON() {
                    const t = Vs(this);
                    return delete t.parent, t
                }
            }
            Hs.prototype.is = function(t) {
                return "node" === t || "view:node" === t
            };
            class Us extends Hs {
                constructor(t, e) {
                    super(t), this._textData = e
                }
                get data() {
                    return this._textData
                }
                get _data() {
                    return this.data
                }
                set _data(t) {
                    this._fireChange("text", this), this._textData = t
                }
                isSimilar(t) {
                    return t instanceof Us && (this === t || this.data === t.data)
                }
                _clone() {
                    return new Us(this.document, this.data)
                }
            }
            Us.prototype.is = function(t) {
                return "$text" === t || "view:$text" === t || "text" === t || "view:text" === t || "node" === t || "view:node" === t
            };
            class Ws extends js {
                constructor(t, e, n) {
                    if (super(), this.textNode = t, e < 0 || e > t.data.length) throw new A("view-textproxy-wrong-offsetintext", this);
                    if (n < 0 || e + n > t.data.length) throw new A("view-textproxy-wrong-length", this);
                    this.data = t.data.substring(e, e + n), this.offsetInText = e
                }
                get offsetSize() {
                    return this.data.length
                }
                get isPartial() {
                    return this.data.length !== this.textNode.data.length
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                get document() {
                    return this.textNode.document
                }
                getAncestors(t = {}) {
                    const e = [];
                    let n = t.includeSelf ? this.textNode : this.parent;
                    for (; null !== n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return e
                }
            }
            Ws.prototype.is = function(t) {
                return "$textProxy" === t || "view:$textProxy" === t || "textProxy" === t || "view:textProxy" === t
            };
            class qs {
                constructor(...t) {
                    this._patterns = [], this.add(...t)
                }
                add(...t) {
                    for (let e of t)("string" == typeof e || e instanceof RegExp) && (e = {
                        name: e
                    }), this._patterns.push(e)
                }
                match(...t) {
                    for (const e of t)
                        for (const t of this._patterns) {
                            const n = Gs(e, t);
                            if (n) return {
                                element: e,
                                pattern: t,
                                match: n
                            }
                        }
                    return null
                }
                matchAll(...t) {
                    const e = [];
                    for (const n of t)
                        for (const t of this._patterns) {
                            const o = Gs(n, t);
                            o && e.push({
                                element: n,
                                pattern: t,
                                match: o
                            })
                        }
                    return e.length > 0 ? e : null
                }
                getElementName() {
                    if (1 !== this._patterns.length) return null;
                    const t = this._patterns[0],
                        e = t.name;
                    return "function" == typeof t || !e || e instanceof RegExp ? null : e
                }
            }
    
            function Gs(t, e) {
                if ("function" == typeof e) return e(t);
                const n = {};
                return e.name && (n.name = function(t, e) {
                    if (t instanceof RegExp) return !!e.match(t);
                    return t === e
                }(e.name, t.name), !n.name) || e.attributes && (n.attributes = function(t, e) {
                    const n = new Set(e.getAttributeKeys());
                    St(t) ? (void 0 !== t.style && C("matcher-pattern-deprecated-attributes-style-key", t), void 0 !== t.class && C("matcher-pattern-deprecated-attributes-class-key", t)) : (n.delete("style"), n.delete("class"));
                    return $s(t, n, (t => e.getAttribute(t)))
                }(e.attributes, t), !n.attributes) || e.classes && (n.classes = function(t, e) {
                    return $s(t, e.getClassNames(), (() => {}))
                }(e.classes, t), !n.classes) || e.styles && (n.styles = function(t, e) {
                    return $s(t, e.getStyleNames(!0), (t => e.getStyle(t)))
                }(e.styles, t), !n.styles) ? null : n
            }
    
            function $s(t, e, n) {
                const o = function(t) {
                        if (Array.isArray(t)) return t.map((t => St(t) ? (void 0 !== t.key && void 0 !== t.value || C("matcher-pattern-missing-key-or-value", t), [t.key, t.value]) : [t, !0]));
                        if (St(t)) return Object.entries(t);
                        return [
                            [t, !0]
                        ]
                    }(t),
                    i = Array.from(e),
                    r = [];
                if (o.forEach((([t, e]) => {
                        i.forEach((o => {
                            (function(t, e) {
                                return !0 === t || t === e || t instanceof RegExp && e.match(t)
                            })(t, o) && function(t, e, n) {
                                if (!0 === t) return !0;
                                const o = n(e);
                                return t === o || t instanceof RegExp && !!String(o).match(t)
                            }(e, o, n) && r.push(o)
                        }))
                    })), o.length && !(r.length < o.length)) return r
            }
            var Ys = "[object Symbol]";
            const Ks = function(t) {
                return "symbol" == typeof t || wt(t) && kt(t) == Ys
            };
            var Qs = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                Zs = /^\w*$/;
            const Js = function(t, e) {
                if (bt(t)) return !1;
                var n = typeof t;
                return !("number" != n && "symbol" != n && "boolean" != n && null != t && !Ks(t)) || (Zs.test(t) || !Qs.test(t) || null != e && t in Object(e))
            };
            var Xs = "Expected a function";
    
            function ta(t, e) {
                if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError(Xs);
                var n = function() {
                    var o = arguments,
                        i = e ? e.apply(this, o) : o[0],
                        r = n.cache;
                    if (r.has(i)) return r.get(i);
                    var s = t.apply(this, o);
                    return n.cache = r.set(i, s) || r, s
                };
                return n.cache = new(ta.Cache || Ne), n
            }
            ta.Cache = Ne;
            const ea = ta;
            var na = 500;
            var oa = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                ia = /\\(\\)?/g,
                ra = function(t) {
                    var e = ea(t, (function(t) {
                            return n.size === na && n.clear(), t
                        })),
                        n = e.cache;
                    return e
                }((function(t) {
                    var e = [];
                    return 46 === t.charCodeAt(0) && e.push(""), t.replace(oa, (function(t, n, o, i) {
                        e.push(o ? i.replace(ia, "$1") : n || t)
                    })), e
                }));
            const sa = ra;
            const aa = function(t, e) {
                for (var n = -1, o = null == t ? 0 : t.length, i = Array(o); ++n < o;) i[n] = e(t[n], n, t);
                return i
            };
            var ca = 1 / 0,
                la = st ? st.prototype : void 0,
                da = la ? la.toString : void 0;
            const ha = function t(e) {
                if ("string" == typeof e) return e;
                if (bt(e)) return aa(e, t) + "";
                if (Ks(e)) return da ? da.call(e) : "";
                var n = e + "";
                return "0" == n && 1 / e == -ca ? "-0" : n
            };
            const ua = function(t) {
                return null == t ? "" : ha(t)
            };
            const ga = function(t, e) {
                return bt(t) ? t : Js(t, e) ? [t] : sa(ua(t))
            };
            const ma = function(t) {
                var e = null == t ? 0 : t.length;
                return e ? t[e - 1] : void 0
            };
            var pa = 1 / 0;
            const fa = function(t) {
                if ("string" == typeof t || Ks(t)) return t;
                var e = t + "";
                return "0" == e && 1 / t == -pa ? "-0" : e
            };
            const ka = function(t, e) {
                for (var n = 0, o = (e = ga(e, t)).length; null != t && n < o;) t = t[fa(e[n++])];
                return n && n == o ? t : void 0
            };
            const ba = function(t, e, n) {
                var o = -1,
                    i = t.length;
                e < 0 && (e = -e > i ? 0 : i + e), (n = n > i ? i : n) < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>= 0;
                for (var r = Array(i); ++o < i;) r[o] = t[o + e];
                return r
            };
            const wa = function(t, e) {
                return e.length < 2 ? t : ka(t, ba(e, 0, -1))
            };
            const _a = function(t, e) {
                return e = ga(e, t), null == (t = wa(t, e)) || delete t[fa(ma(e))]
            };
            const Aa = function(t, e) {
                return null == t || _a(t, e)
            };
            const Ca = function(t, e, n) {
                var o = null == t ? void 0 : ka(t, e);
                return void 0 === o ? n : o
            };
            const va = function(t, e, n) {
                (void 0 !== n && !Bt(t[e], n) || void 0 === n && !(e in t)) && je(t, e, n)
            };
            const ya = function(t) {
                return function(e, n, o) {
                    for (var i = -1, r = Object(e), s = o(e), a = s.length; a--;) {
                        var c = s[t ? a : ++i];
                        if (!1 === n(r[c], c, r)) break
                    }
                    return e
                }
            }();
            const xa = function(t) {
                return wt(t) && vn(t)
            };
            const Ea = function(t, e) {
                if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
            };
            const Da = function(t) {
                return He(t, Tn(t))
            };
            const Ia = function(t, e, n, o, i, r, s) {
                var a = Ea(t, n),
                    c = Ea(e, n),
                    l = s.get(c);
                if (l) va(t, n, l);
                else {
                    var d = r ? r(a, c, n + "", t, e, s) : void 0,
                        h = void 0 === d;
                    if (h) {
                        var u = bt(c),
                            g = !u && tn(c),
                            m = !u && !g && pn(c);
                        d = c, u || g || m ? bt(a) ? d = a : xa(a) ? d = Ln(a) : g ? (h = !1, d = zn(c, !0)) : m ? (h = !1, d = Co(c, !0)) : d = [] : St(c) || Ke(c) ? (d = a, Ke(a) ? d = Da(a) : F(a) && !Qt(a) || (d = qo(c))) : h = !1
                    }
                    h && (s.set(c, d), i(d, c, o, r, s), s.delete(c)), va(t, n, d)
                }
            };
            const Ta = function t(e, n, o, i, r) {
                e !== n && ya(n, (function(s, a) {
                    if (r || (r = new Le), F(s)) Ia(e, n, a, o, t, i, r);
                    else {
                        var c = i ? i(Ea(e, a), s, a + "", e, n, r) : void 0;
                        void 0 === c && (c = s), va(e, a, c)
                    }
                }), Tn)
            };
            const Ma = function(t) {
                return t
            };
            const Sa = function(t, e, n) {
                switch (n.length) {
                    case 0:
                        return t.call(e);
                    case 1:
                        return t.call(e, n[0]);
                    case 2:
                        return t.call(e, n[0], n[1]);
                    case 3:
                        return t.call(e, n[0], n[1], n[2])
                }
                return t.apply(e, n)
            };
            var Na = Math.max;
            const Ba = function(t, e, n) {
                return e = Na(void 0 === e ? t.length - 1 : e, 0),
                    function() {
                        for (var o = arguments, i = -1, r = Na(o.length - e, 0), s = Array(r); ++i < r;) s[i] = o[e + i];
                        i = -1;
                        for (var a = Array(e + 1); ++i < e;) a[i] = o[i];
                        return a[e] = n(s), Sa(t, this, a)
                    }
            };
            const Pa = function(t) {
                return function() {
                    return t
                }
            };
            const za = Re ? function(t, e) {
                return Re(t, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: Pa(e),
                    writable: !0
                })
            } : Ma;
            var La = 800,
                Oa = 16,
                Ra = Date.now;
            const ja = function(t) {
                var e = 0,
                    n = 0;
                return function() {
                    var o = Ra(),
                        i = Oa - (o - n);
                    if (n = o, i > 0) {
                        if (++e >= La) return arguments[0]
                    } else e = 0;
                    return t.apply(void 0, arguments)
                }
            };
            const Fa = ja(za);
            const Va = function(t, e) {
                return Fa(Ba(t, e, Ma), t + "")
            };
            const Ha = function(t, e, n) {
                if (!F(n)) return !1;
                var o = typeof e;
                return !!("number" == o ? vn(n) && on(e, n.length) : "string" == o && e in n) && Bt(n[e], t)
            };
            const Ua = function(t) {
                return Va((function(e, n) {
                    var o = -1,
                        i = n.length,
                        r = i > 1 ? n[i - 1] : void 0,
                        s = i > 2 ? n[2] : void 0;
                    for (r = t.length > 3 && "function" == typeof r ? (i--, r) : void 0, s && Ha(n[0], n[1], s) && (r = i < 3 ? void 0 : r, i = 1), e = Object(e); ++o < i;) {
                        var a = n[o];
                        a && t(e, a, o, r)
                    }
                    return e
                }))
            };
            const Wa = Ua((function(t, e, n) {
                Ta(t, e, n)
            }));
            const qa = function(t, e, n, o) {
                if (!F(t)) return t;
                for (var i = -1, r = (e = ga(e, t)).length, s = r - 1, a = t; null != a && ++i < r;) {
                    var c = fa(e[i]),
                        l = n;
                    if ("__proto__" === c || "constructor" === c || "prototype" === c) return t;
                    if (i != s) {
                        var d = a[c];
                        void 0 === (l = o ? o(d, c, a) : void 0) && (l = F(d) ? d : on(e[i + 1]) ? [] : {})
                    }
                    Ve(a, c, l), a = a[c]
                }
                return t
            };
            const Ga = function(t, e, n) {
                return null == t ? t : qa(t, e, n)
            };
            class $a {
                constructor(t) {
                    this._styles = {}, this._styleProcessor = t
                }
                get isEmpty() {
                    const t = Object.entries(this._styles);
                    return !Array.from(t).length
                }
                get size() {
                    return this.isEmpty ? 0 : this.getStyleNames().length
                }
                setTo(t) {
                    this.clear();
                    const e = Array.from(function(t) {
                        let e = null,
                            n = 0,
                            o = 0,
                            i = null;
                        const r = new Map;
                        if ("" === t) return r;
                        ";" != t.charAt(t.length - 1) && (t += ";");
                        for (let s = 0; s < t.length; s++) {
                            const a = t.charAt(s);
                            if (null === e) switch (a) {
                                case ":":
                                    i || (i = t.substr(n, s - n), o = s + 1);
                                    break;
                                case '"':
                                case "'":
                                    e = a;
                                    break;
                                case ";": {
                                    const e = t.substr(o, s - o);
                                    i && r.set(i.trim(), e.trim()), i = null, n = s + 1;
                                    break
                                }
                            } else a === e && (e = null)
                        }
                        return r
                    }(t).entries());
                    for (const [t, n] of e) this._styleProcessor.toNormalizedForm(t, n, this._styles)
                }
                has(t) {
                    if (this.isEmpty) return !1;
                    const e = this._styleProcessor.getReducedForm(t, this._styles).find((([e]) => e === t));
                    return Array.isArray(e)
                }
                set(t, e) {
                    if (F(t))
                        for (const [e, n] of Object.entries(t)) this._styleProcessor.toNormalizedForm(e, n, this._styles);
                    else this._styleProcessor.toNormalizedForm(t, e, this._styles)
                }
                remove(t) {
                    const e = Ka(t);
                    Aa(this._styles, e), delete this._styles[t], this._cleanEmptyObjectsOnPath(e)
                }
                getNormalized(t) {
                    return this._styleProcessor.getNormalized(t, this._styles)
                }
                toString() {
                    return this.isEmpty ? "" : this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";"
                }
                getAsString(t) {
                    if (this.isEmpty) return;
                    if (this._styles[t] && !F(this._styles[t])) return this._styles[t];
                    const e = this._styleProcessor.getReducedForm(t, this._styles).find((([e]) => e === t));
                    return Array.isArray(e) ? e[1] : void 0
                }
                getStyleNames(t = !1) {
                    if (this.isEmpty) return [];
                    if (t) return this._styleProcessor.getStyleNames(this._styles);
                    return this._getStylesEntries().map((([t]) => t))
                }
                clear() {
                    this._styles = {}
                }
                _getStylesEntries() {
                    const t = [],
                        e = Object.keys(this._styles);
                    for (const n of e) t.push(...this._styleProcessor.getReducedForm(n, this._styles));
                    return t
                }
                _cleanEmptyObjectsOnPath(t) {
                    const e = t.split(".");
                    if (!(e.length > 1)) return;
                    const n = e.splice(0, e.length - 1).join("."),
                        o = Ca(this._styles, n);
                    if (!o) return;
                    !Array.from(Object.keys(o)).length && this.remove(n)
                }
            }
            class Ya {
                constructor() {
                    this._normalizers = new Map, this._extractors = new Map, this._reducers = new Map, this._consumables = new Map
                }
                toNormalizedForm(t, e, n) {
                    if (F(e)) Qa(n, Ka(t), e);
                    else if (this._normalizers.has(t)) {
                        const o = this._normalizers.get(t),
                            {
                                path: i,
                                value: r
                            } = o(e);
                        Qa(n, i, r)
                    } else Qa(n, t, e)
                }
                getNormalized(t, e) {
                    if (!t) return Wa({}, e);
                    if (void 0 !== e[t]) return e[t];
                    if (this._extractors.has(t)) {
                        const n = this._extractors.get(t);
                        if ("string" == typeof n) return Ca(e, n);
                        const o = n(t, e);
                        if (o) return o
                    }
                    return Ca(e, Ka(t))
                }
                getReducedForm(t, e) {
                    const n = this.getNormalized(t, e);
                    if (void 0 === n) return [];
                    if (this._reducers.has(t)) {
                        return this._reducers.get(t)(n)
                    }
                    return [
                        [t, n]
                    ]
                }
                getStyleNames(t) {
                    const e = Array.from(this._consumables.keys()).filter((e => {
                            const n = this.getNormalized(e, t);
                            return n && "object" == typeof n ? Object.keys(n).length : n
                        })),
                        n = new Set([...e, ...Object.keys(t)]);
                    return Array.from(n.values())
                }
                getRelatedStyles(t) {
                    return this._consumables.get(t) || []
                }
                setNormalizer(t, e) {
                    this._normalizers.set(t, e)
                }
                setExtractor(t, e) {
                    this._extractors.set(t, e)
                }
                setReducer(t, e) {
                    this._reducers.set(t, e)
                }
                setStyleRelation(t, e) {
                    this._mapStyleNames(t, e);
                    for (const n of e) this._mapStyleNames(n, [t])
                }
                _mapStyleNames(t, e) {
                    this._consumables.has(t) || this._consumables.set(t, []), this._consumables.get(t).push(...e)
                }
            }
    
            function Ka(t) {
                return t.replace("-", ".")
            }
    
            function Qa(t, e, n) {
                let o = n;
                F(n) && (o = Wa({}, Ca(t, e), n)), Ga(t, e, o)
            }
            class Za extends Hs {
                constructor(t, e, n, o) {
                    if (super(t), this.name = e, this._attrs = function(t) {
                            const e = fr(t);
                            for (const [t, n] of e) null === n ? e.delete(t) : "string" != typeof n && e.set(t, String(n));
                            return e
                        }(n), this._children = [], o && this._insertChild(0, o), this._classes = new Set, this._attrs.has("class")) {
                        const t = this._attrs.get("class");
                        Ja(this._classes, t), this._attrs.delete("class")
                    }
                    this._styles = new $a(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style")), this._customProperties = new Map, this._unsafeAttributesToRender = []
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return 0 === this._children.length
                }
                getChild(t) {
                    return this._children[t]
                }
                getChildIndex(t) {
                    return this._children.indexOf(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }* getAttributeKeys() {
                    this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys()
                }* getAttributes() {
                    yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")])
                }
                getAttribute(t) {
                    if ("class" == t) return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
                    if ("style" == t) {
                        const t = this._styles.toString();
                        return "" == t ? void 0 : t
                    }
                    return this._attrs.get(t)
                }
                hasAttribute(t) {
                    return "class" == t ? this._classes.size > 0 : "style" == t ? !this._styles.isEmpty : this._attrs.has(t)
                }
                isSimilar(t) {
                    if (!(t instanceof Za)) return !1;
                    if (this === t) return !0;
                    if (this.name != t.name) return !1;
                    if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) return !1;
                    for (const [e, n] of this._attrs)
                        if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
                    for (const e of this._classes)
                        if (!t._classes.has(e)) return !1;
                    for (const e of this._styles.getStyleNames())
                        if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) return !1;
                    return !0
                }
                hasClass(...t) {
                    for (const e of t)
                        if (!this._classes.has(e)) return !1;
                    return !0
                }
                getClassNames() {
                    return this._classes.keys()
                }
                getStyle(t) {
                    return this._styles.getAsString(t)
                }
                getNormalizedStyle(t) {
                    return this._styles.getNormalized(t)
                }
                getStyleNames(t) {
                    return this._styles.getStyleNames(t)
                }
                hasStyle(...t) {
                    for (const e of t)
                        if (!this._styles.has(e)) return !1;
                    return !0
                }
                findAncestor(...t) {
                    const e = new qs(...t);
                    let n = this.parent;
                    for (; n && !n.is("documentFragment");) {
                        if (e.match(n)) return n;
                        n = n.parent
                    }
                    return null
                }
                getCustomProperty(t) {
                    return this._customProperties.get(t)
                }* getCustomProperties() {
                    yield* this._customProperties.entries()
                }
                getIdentity() {
                    const t = Array.from(this._classes).sort().join(","),
                        e = this._styles.toString(),
                        n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" ");
                    return this.name + ("" == t ? "" : ` class="${t}"`) + (e ? ` style="${e}"` : "") + ("" == n ? "" : ` ${n}`)
                }
                shouldRenderUnsafeAttribute(t) {
                    return this._unsafeAttributesToRender.includes(t)
                }
                _clone(t = !1) {
                    const e = [];
                    if (t)
                        for (const n of this.getChildren()) e.push(n._clone(t));
                    const n = new this.constructor(this.document, this.name, this._attrs, e);
                    return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n
                }
                _appendChild(t) {
                    return this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    this._fireChange("children", this);
                    let n = 0;
                    const o = function(t, e) {
                        if ("string" == typeof e) return [new Us(t, e)];
                        nt(e) || (e = [e]);
                        return Array.from(e).map((e => "string" == typeof e ? new Us(t, e) : e instanceof Ws ? new Us(t, e.data) : e))
                    }(this.document, e);
                    for (const e of o) null !== e.parent && e._remove(), e.parent = this, e.document = this.document, this._children.splice(t, 0, e), t++, n++;
                    return n
                }
                _removeChildren(t, e = 1) {
                    this._fireChange("children", this);
                    for (let n = t; n < t + e; n++) this._children[n].parent = null;
                    return this._children.splice(t, e)
                }
                _setAttribute(t, e) {
                    const n = String(e);
                    this._fireChange("attributes", this), "class" == t ? Ja(this._classes, n) : "style" == t ? this._styles.setTo(n) : this._attrs.set(t, n)
                }
                _removeAttribute(t) {
                    return this._fireChange("attributes", this), "class" == t ? this._classes.size > 0 && (this._classes.clear(), !0) : "style" == t ? !this._styles.isEmpty && (this._styles.clear(), !0) : this._attrs.delete(t)
                }
                _addClass(t) {
                    this._fireChange("attributes", this);
                    for (const e of ar(t)) this._classes.add(e)
                }
                _removeClass(t) {
                    this._fireChange("attributes", this);
                    for (const e of ar(t)) this._classes.delete(e)
                }
                _setStyle(t, e) {
                    this._fireChange("attributes", this), St(t) ? this._styles.set(t) : this._styles.set(t, e)
                }
                _removeStyle(t) {
                    this._fireChange("attributes", this);
                    for (const e of ar(t)) this._styles.remove(e)
                }
                _setCustomProperty(t, e) {
                    this._customProperties.set(t, e)
                }
                _removeCustomProperty(t) {
                    return this._customProperties.delete(t)
                }
            }
    
            function Ja(t, e) {
                const n = e.split(/\s+/);
                t.clear(), n.forEach((e => t.add(e)))
            }
            Za.prototype.is = function(t, e) {
                return e ? e === this.name && ("element" === t || "view:element" === t) : "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class Xa extends Za {
                constructor(...t) {
                    super(...t), this.getFillerOffset = tc
                }
            }
    
            function tc() {
                const t = [...this.getChildren()],
                    e = t[this.childCount - 1];
                if (e && e.is("element", "br")) return this.childCount;
                for (const e of t)
                    if (!e.is("uiElement")) return null;
                return this.childCount
            }
            Xa.prototype.is = function(t, e) {
                return e ? e === this.name && ("containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class ec extends($(Xa)) {
                constructor(...t) {
                    super(...t);
                    const e = t[0];
                    this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (t => t && e.selection.editableElement == this)), this.listenTo(e.selection, "change", (() => {
                        this.isFocused = e.isFocused && e.selection.editableElement == this
                    }))
                }
                destroy() {
                    this.stopListening()
                }
            }
            ec.prototype.is = function(t, e) {
                return e ? e === this.name && ("editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            const nc = Symbol("rootName");
            class oc extends ec {
                constructor(t, e) {
                    super(t, e), this.rootName = "main"
                }
                get rootName() {
                    return this.getCustomProperty(nc)
                }
                set rootName(t) {
                    this._setCustomProperty(nc, t)
                }
                set _name(t) {
                    this.name = t
                }
            }
            oc.prototype.is = function(t, e) {
                return e ? e === this.name && ("rootElement" === t || "view:rootElement" === t || "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t) : "rootElement" === t || "view:rootElement" === t || "editableElement" === t || "view:editableElement" === t || "containerElement" === t || "view:containerElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class ic {
                constructor(t = {}) {
                    if (!t.boundaries && !t.startPosition) throw new A("view-tree-walker-no-start-position", null);
                    if (t.direction && "forward" != t.direction && "backward" != t.direction) throw new A("view-tree-walker-unknown-direction", t.startPosition, {
                        direction: t.direction
                    });
                    this.boundaries = t.boundaries || null, t.startPosition ? this.position = rc._createAt(t.startPosition) : this.position = rc._createAt(t.boundaries["backward" == t.direction ? "end" : "start"]), this.direction = t.direction || "forward", this.singleCharacters = !!t.singleCharacters, this.shallow = !!t.shallow, this.ignoreElementEnd = !!t.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
                } [Symbol.iterator]() {
                    return this
                }
                skip(t) {
                    let e, n, o;
                    do {
                        o = this.position, ({
                            done: e,
                            value: n
                        } = this.next())
                    } while (!e && t(n));
                    e || (this.position = o)
                }
                next() {
                    return "forward" == this.direction ? this._next() : this._previous()
                }
                _next() {
                    let t = this.position.clone();
                    const e = this.position,
                        n = t.parent;
                    if (null === n.parent && t.offset === n.childCount) return {
                        done: !0,
                        value: void 0
                    };
                    if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return {
                        done: !0,
                        value: void 0
                    };
                    let o;
                    if (n instanceof Us) {
                        if (t.isAtEnd) return this.position = rc._createAfter(n), this._next();
                        o = n.data[t.offset]
                    } else o = n.getChild(t.offset);
                    if (o instanceof Za) return this.shallow ? t.offset++ : t = new rc(o, 0), this.position = t, this._formatReturnValue("elementStart", o, e, t, 1);
                    if (o instanceof Us) {
                        if (this.singleCharacters) return t = new rc(o, 0), this.position = t, this._next();
                        {
                            let n, i = o.data.length;
                            return o == this._boundaryEndParent ? (i = this.boundaries.end.offset, n = new Ws(o, 0, i), t = rc._createAfter(n)) : (n = new Ws(o, 0, o.data.length), t.offset++), this.position = t, this._formatReturnValue("text", n, e, t, i)
                        }
                    }
                    if ("string" == typeof o) {
                        let o;
                        if (this.singleCharacters) o = 1;
                        else {
                            o = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - t.offset
                        }
                        const i = new Ws(n, t.offset, o);
                        return t.offset += o, this.position = t, this._formatReturnValue("text", i, e, t, o)
                    }
                    return t = rc._createAfter(n), this.position = t, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, e, t)
                }
                _previous() {
                    let t = this.position.clone();
                    const e = this.position,
                        n = t.parent;
                    if (null === n.parent && 0 === t.offset) return {
                        done: !0,
                        value: void 0
                    };
                    if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return {
                        done: !0,
                        value: void 0
                    };
                    let o;
                    if (n instanceof Us) {
                        if (t.isAtStart) return this.position = rc._createBefore(n), this._previous();
                        o = n.data[t.offset - 1]
                    } else o = n.getChild(t.offset - 1);
                    if (o instanceof Za) return this.shallow ? (t.offset--, this.position = t, this._formatReturnValue("elementStart", o, e, t, 1)) : (t = new rc(o, o.childCount), this.position = t, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", o, e, t));
                    if (o instanceof Us) {
                        if (this.singleCharacters) return t = new rc(o, o.data.length), this.position = t, this._previous();
                        {
                            let n, i = o.data.length;
                            if (o == this._boundaryStartParent) {
                                const e = this.boundaries.start.offset;
                                n = new Ws(o, e, o.data.length - e), i = n.data.length, t = rc._createBefore(n)
                            } else n = new Ws(o, 0, o.data.length), t.offset--;
                            return this.position = t, this._formatReturnValue("text", n, e, t, i)
                        }
                    }
                    if ("string" == typeof o) {
                        let o;
                        if (this.singleCharacters) o = 1;
                        else {
                            const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                            o = t.offset - e
                        }
                        t.offset -= o;
                        const i = new Ws(n, t.offset, o);
                        return this.position = t, this._formatReturnValue("text", i, e, t, o)
                    }
                    return t = rc._createBefore(n), this.position = t, this._formatReturnValue("elementStart", n, e, t, 1)
                }
                _formatReturnValue(t, e, n, o, i) {
                    return e instanceof Ws && (e.offsetInText + e.data.length == e.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n = rc._createAfter(e.textNode) : (o = rc._createAfter(e.textNode), this.position = o)), 0 === e.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n = rc._createBefore(e.textNode) : (o = rc._createBefore(e.textNode), this.position = o))), {
                        done: !1,
                        value: {
                            type: t,
                            item: e,
                            previousPosition: n,
                            nextPosition: o,
                            length: i
                        }
                    }
                }
            }
            class rc extends js {
                constructor(t, e) {
                    super(), this.parent = t, this.offset = e
                }
                get nodeAfter() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null
                }
                get nodeBefore() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null
                }
                get isAtStart() {
                    return 0 === this.offset
                }
                get isAtEnd() {
                    const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                    return this.offset === t
                }
                get root() {
                    return this.parent.root
                }
                get editableElement() {
                    let t = this.parent;
                    for (; !(t instanceof ec);) {
                        if (!t.parent) return null;
                        t = t.parent
                    }
                    return t
                }
                getShiftedBy(t) {
                    const e = rc._createAt(this),
                        n = e.offset + t;
                    return e.offset = n < 0 ? 0 : n, e
                }
                getLastMatchingPosition(t, e = {}) {
                    e.startPosition = this;
                    const n = new ic(e);
                    return n.skip(t), n.position
                }
                getAncestors() {
                    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({
                        includeSelf: !0
                    })
                }
                getCommonAncestor(t) {
                    const e = this.getAncestors(),
                        n = t.getAncestors();
                    let o = 0;
                    for (; e[o] == n[o] && e[o];) o++;
                    return 0 === o ? null : e[o - 1]
                }
                isEqual(t) {
                    return this.parent == t.parent && this.offset == t.offset
                }
                isBefore(t) {
                    return "before" == this.compareWith(t)
                }
                isAfter(t) {
                    return "after" == this.compareWith(t)
                }
                compareWith(t) {
                    if (this.root !== t.root) return "different";
                    if (this.isEqual(t)) return "same";
                    const e = this.parent.is("node") ? this.parent.getPath() : [],
                        n = t.parent.is("node") ? t.parent.getPath() : [];
                    e.push(this.offset), n.push(t.offset);
                    const o = et(e, n);
                    switch (o) {
                        case "prefix":
                            return "before";
                        case "extension":
                            return "after";
                        default:
                            return e[o] < n[o] ? "before" : "after"
                    }
                }
                getWalker(t = {}) {
                    return t.startPosition = this, new ic(t)
                }
                clone() {
                    return new rc(this.parent, this.offset)
                }
                static _createAt(t, e) {
                    if (t instanceof rc) return new this(t.parent, t.offset);
                    {
                        const n = t;
                        if ("end" == e) e = n.is("$text") ? n.data.length : n.childCount;
                        else {
                            if ("before" == e) return this._createBefore(n);
                            if ("after" == e) return this._createAfter(n);
                            if (0 !== e && !e) throw new A("view-createpositionat-offset-required", n)
                        }
                        return new rc(n, e)
                    }
                }
                static _createAfter(t) {
                    if (t.is("$textProxy")) return new rc(t.textNode, t.offsetInText + t.data.length);
                    if (!t.parent) throw new A("view-position-after-root", t, {
                        root: t
                    });
                    return new rc(t.parent, t.index + 1)
                }
                static _createBefore(t) {
                    if (t.is("$textProxy")) return new rc(t.textNode, t.offsetInText);
                    if (!t.parent) throw new A("view-position-before-root", t, {
                        root: t
                    });
                    return new rc(t.parent, t.index)
                }
            }
            rc.prototype.is = function(t) {
                return "position" === t || "view:position" === t
            };
            class sc extends js {
                constructor(t, e = null) {
                    super(), this.start = t.clone(), this.end = e ? e.clone() : t.clone()
                }*[Symbol.iterator]() {
                    yield* new ic({
                        boundaries: this,
                        ignoreElementEnd: !0
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    return this.start.parent === this.end.parent
                }
                get root() {
                    return this.start.root
                }
                getEnlarged() {
                    let t = this.start.getLastMatchingPosition(ac, {
                            direction: "backward"
                        }),
                        e = this.end.getLastMatchingPosition(ac);
                    return t.parent.is("$text") && t.isAtStart && (t = rc._createBefore(t.parent)), e.parent.is("$text") && e.isAtEnd && (e = rc._createAfter(e.parent)), new sc(t, e)
                }
                getTrimmed() {
                    let t = this.start.getLastMatchingPosition(ac);
                    if (t.isAfter(this.end) || t.isEqual(this.end)) return new sc(t, t);
                    let e = this.end.getLastMatchingPosition(ac, {
                        direction: "backward"
                    });
                    const n = t.nodeAfter,
                        o = e.nodeBefore;
                    return n && n.is("$text") && (t = new rc(n, 0)), o && o.is("$text") && (e = new rc(o, o.data.length)), new sc(t, e)
                }
                isEqual(t) {
                    return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
                }
                containsPosition(t) {
                    return t.isAfter(this.start) && t.isBefore(this.end)
                }
                containsRange(t, e = !1) {
                    t.isCollapsed && (e = !1);
                    const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start),
                        o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                    return n && o
                }
                getDifference(t) {
                    const e = [];
                    return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new sc(this.start, t.start)), this.containsPosition(t.end) && e.push(new sc(t.end, this.end))) : e.push(this.clone()), e
                }
                getIntersection(t) {
                    if (this.isIntersecting(t)) {
                        let e = this.start,
                            n = this.end;
                        return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (n = t.end), new sc(e, n)
                    }
                    return null
                }
                getWalker(t = {}) {
                    return t.boundaries = this, new ic(t)
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                getContainedElement() {
                    if (this.isCollapsed) return null;
                    let t = this.start.nodeAfter,
                        e = this.end.nodeBefore;
                    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e = this.end.parent.previousSibling), t && t.is("element") && t === e ? t : null
                }
                clone() {
                    return new sc(this.start, this.end)
                }* getItems(t = {}) {
                    t.boundaries = this, t.ignoreElementEnd = !0;
                    const e = new ic(t);
                    for (const t of e) yield t.item
                }* getPositions(t = {}) {
                    t.boundaries = this;
                    const e = new ic(t);
                    yield e.position;
                    for (const t of e) yield t.nextPosition
                }
                isIntersecting(t) {
                    return this.start.isBefore(t.end) && this.end.isAfter(t.start)
                }
                static _createFromParentsAndOffsets(t, e, n, o) {
                    return new this(new rc(t, e), new rc(n, o))
                }
                static _createFromPositionAndShift(t, e) {
                    const n = t,
                        o = t.getShiftedBy(e);
                    return e > 0 ? new this(n, o) : new this(o, n)
                }
                static _createIn(t) {
                    return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
                }
                static _createOn(t) {
                    const e = t.is("$textProxy") ? t.offsetSize : 1;
                    return this._createFromPositionAndShift(rc._createBefore(t), e)
                }
            }
    
            function ac(t) {
                return !(!t.item.is("attributeElement") && !t.item.is("uiElement"))
            }
            sc.prototype.is = function(t) {
                return "range" === t || "view:range" === t
            };
            class cc extends(N(js)) {
                constructor(...t) {
                    super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", t.length && this.setTo(...t)
                }
                get isFake() {
                    return this._isFake
                }
                get fakeSelectionLabel() {
                    return this._fakeSelectionLabel
                }
                get anchor() {
                    if (!this._ranges.length) return null;
                    const t = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? t.end : t.start).clone()
                }
                get focus() {
                    if (!this._ranges.length) return null;
                    const t = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? t.start : t.end).clone()
                }
                get isCollapsed() {
                    return 1 === this.rangeCount && this._ranges[0].isCollapsed
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                get editableElement() {
                    return this.anchor ? this.anchor.editableElement : null
                }* getRanges() {
                    for (const t of this._ranges) yield t.clone()
                }
                getFirstRange() {
                    let t = null;
                    for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
                    return t ? t.clone() : null
                }
                getLastRange() {
                    let t = null;
                    for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
                    return t ? t.clone() : null
                }
                getFirstPosition() {
                    const t = this.getFirstRange();
                    return t ? t.start.clone() : null
                }
                getLastPosition() {
                    const t = this.getLastRange();
                    return t ? t.end.clone() : null
                }
                isEqual(t) {
                    if (this.isFake != t.isFake) return !1;
                    if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) return !1;
                    if (this.rangeCount != t.rangeCount) return !1;
                    if (0 === this.rangeCount) return !0;
                    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
                    for (const e of this._ranges) {
                        let n = !1;
                        for (const o of t._ranges)
                            if (e.isEqual(o)) {
                                n = !0;
                                break
                            } if (!n) return !1
                    }
                    return !0
                }
                isSimilar(t) {
                    if (this.isBackward != t.isBackward) return !1;
                    const e = tt(this.getRanges());
                    if (e != tt(t.getRanges())) return !1;
                    if (0 == e) return !0;
                    for (let e of this.getRanges()) {
                        e = e.getTrimmed();
                        let n = !1;
                        for (let o of t.getRanges())
                            if (o = o.getTrimmed(), e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                                n = !0;
                                break
                            } if (!n) return !1
                    }
                    return !0
                }
                getSelectedElement() {
                    return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement()
                }
                setTo(...t) {
                    let [e, n, o] = t;
                    if ("object" == typeof n && (o = n, n = void 0), null === e) this._setRanges([]), this._setFakeOptions(o);
                    else if (e instanceof cc || e instanceof lc) this._setRanges(e.getRanges(), e.isBackward), this._setFakeOptions({
                        fake: e.isFake,
                        label: e.fakeSelectionLabel
                    });
                    else if (e instanceof sc) this._setRanges([e], o && o.backward), this._setFakeOptions(o);
                    else if (e instanceof rc) this._setRanges([new sc(e)]), this._setFakeOptions(o);
                    else if (e instanceof Hs) {
                        const t = !!o && !!o.backward;
                        let i;
                        if (void 0 === n) throw new A("view-selection-setto-required-second-parameter", this);
                        i = "in" == n ? sc._createIn(e) : "on" == n ? sc._createOn(e) : new sc(rc._createAt(e, n)), this._setRanges([i], t), this._setFakeOptions(o)
                    } else {
                        if (!nt(e)) throw new A("view-selection-setto-not-selectable", this);
                        this._setRanges(e, o && o.backward), this._setFakeOptions(o)
                    }
                    this.fire("change")
                }
                setFocus(t, e) {
                    if (null === this.anchor) throw new A("view-selection-setfocus-no-ranges", this);
                    const n = rc._createAt(t, e);
                    if ("same" == n.compareWith(this.focus)) return;
                    const o = this.anchor;
                    this._ranges.pop(), "before" == n.compareWith(o) ? this._addRange(new sc(n, o), !0) : this._addRange(new sc(o, n)), this.fire("change")
                }
                _setRanges(t, e = !1) {
                    t = Array.from(t), this._ranges = [];
                    for (const e of t) this._addRange(e);
                    this._lastRangeBackward = !!e
                }
                _setFakeOptions(t = {}) {
                    this._isFake = !!t.fake, this._fakeSelectionLabel = t.fake && t.label || ""
                }
                _addRange(t, e = !1) {
                    if (!(t instanceof sc)) throw new A("view-selection-add-range-not-range", this);
                    this._pushRange(t), this._lastRangeBackward = !!e
                }
                _pushRange(t) {
                    for (const e of this._ranges)
                        if (t.isIntersecting(e)) throw new A("view-selection-range-intersects", this, {
                            addedRange: t,
                            intersectingRange: e
                        });
                    this._ranges.push(new sc(t.start, t.end))
                }
            }
            cc.prototype.is = function(t) {
                return "selection" === t || "view:selection" === t
            };
            class lc extends(N(js)) {
                constructor(...t) {
                    super(), this._selection = new cc, this._selection.delegate("change").to(this), t.length && this._selection.setTo(...t)
                }
                get isFake() {
                    return this._selection.isFake
                }
                get fakeSelectionLabel() {
                    return this._selection.fakeSelectionLabel
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get editableElement() {
                    return this._selection.editableElement
                }
                get _ranges() {
                    return this._selection._ranges
                }* getRanges() {
                    yield* this._selection.getRanges()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                isEqual(t) {
                    return this._selection.isEqual(t)
                }
                isSimilar(t) {
                    return this._selection.isSimilar(t)
                }
                _setTo(...t) {
                    this._selection.setTo(...t)
                }
                _setFocus(t, e) {
                    this._selection.setFocus(t, e)
                }
            }
            lc.prototype.is = function(t) {
                return "selection" === t || "documentSelection" == t || "view:selection" == t || "view:documentSelection" == t
            };
            class dc extends p {
                constructor(t, e, n) {
                    super(t, e), this.startRange = n, this._eventPhase = "none", this._currentTarget = null
                }
                get eventPhase() {
                    return this._eventPhase
                }
                get currentTarget() {
                    return this._currentTarget
                }
            }
            const hc = Symbol("bubbling contexts");
    
            function uc(t) {
                return class extends t {
                    fire(t, ...e) {
                        try {
                            const n = t instanceof p ? t : new p(this, t),
                                o = fc(this);
                            if (!o.size) return;
                            if (gc(n, "capturing", this), mc(o, "$capture", n, ...e)) return n.return;
                            const i = n.startRange || this.selection.getFirstRange(),
                                r = i ? i.getContainedElement() : null,
                                s = !!r && Boolean(pc(o, r));
                            let a = r || function(t) {
                                if (!t) return null;
                                const e = t.start.parent,
                                    n = t.end.parent,
                                    o = e.getPath(),
                                    i = n.getPath();
                                return o.length > i.length ? e : n
                            }(i);
                            if (gc(n, "atTarget", a), !s) {
                                if (mc(o, "$text", n, ...e)) return n.return;
                                gc(n, "bubbling", a)
                            }
                            for (; a;) {
                                if (a.is("rootElement")) {
                                    if (mc(o, "$root", n, ...e)) return n.return
                                } else if (a.is("element") && mc(o, a.name, n, ...e)) return n.return;
                                if (mc(o, a, n, ...e)) return n.return;
                                a = a.parent, gc(n, "bubbling", a)
                            }
                            return gc(n, "bubbling", this), mc(o, "$document", n, ...e), n.return
                        } catch (t) {
                            A.rethrowUnexpectedError(t, this)
                        }
                    }
                    _addEventListener(t, e, n) {
                        const o = ar(n.context || "$document"),
                            i = fc(this);
                        for (const r of o) {
                            let o = i.get(r);
                            o || (o = new(N()), i.set(r, o)), this.listenTo(o, t, e, n)
                        }
                    }
                    _removeEventListener(t, e) {
                        const n = fc(this);
                        for (const o of n.values()) this.stopListening(o, t, e)
                    }
                }
            } {
                const t = uc(Object);
                ["fire", "_addEventListener", "_removeEventListener"].forEach((e => {
                    uc[e] = t.prototype[e]
                }))
            }
    
            function gc(t, e, n) {
                t instanceof dc && (t._eventPhase = e, t._currentTarget = n)
            }
    
            function mc(t, e, n, ...o) {
                const i = "string" == typeof e ? t.get(e) : pc(t, e);
                return !!i && (i.fire(n, ...o), n.stop.called)
            }
    
            function pc(t, e) {
                for (const [n, o] of t)
                    if ("function" == typeof n && n(e)) return o;
                return null
            }
    
            function fc(t) {
                return t[hc] || (t[hc] = new Map), t[hc]
            }
            class kc extends(uc($())) {
                constructor(t) {
                    super(), this.selection = new lc, this.roots = new ur({
                        idProperty: "rootName"
                    }), this.stylesProcessor = t, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1), this._postFixers = new Set
                }
                getRoot(t = "main") {
                    return this.roots.get(t)
                }
                registerPostFixer(t) {
                    this._postFixers.add(t)
                }
                destroy() {
                    this.roots.map((t => t.destroy())), this.stopListening()
                }
                _callPostFixers(t) {
                    let e = !1;
                    do {
                        for (const n of this._postFixers)
                            if (e = n(t), e) break
                    } while (e)
                }
            }
            class bc extends Za {
                constructor(...t) {
                    super(...t), this.getFillerOffset = wc, this._priority = 10, this._id = null, this._clonesGroup = null
                }
                get priority() {
                    return this._priority
                }
                get id() {
                    return this._id
                }
                getElementsWithSameId() {
                    if (null === this.id) throw new A("attribute-element-get-elements-with-same-id-no-id", this);
                    return new Set(this._clonesGroup)
                }
                isSimilar(t) {
                    return null !== this.id || null !== t.id ? this.id === t.id : super.isSimilar(t) && this.priority == t.priority
                }
                _clone(t = !1) {
                    const e = super._clone(t);
                    return e._priority = this._priority, e._id = this._id, e
                }
            }
    
            function wc() {
                if (_c(this)) return null;
                let t = this.parent;
                for (; t && t.is("attributeElement");) {
                    if (_c(t) > 1) return null;
                    t = t.parent
                }
                return !t || _c(t) > 1 ? null : this.childCount
            }
    
            function _c(t) {
                return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length
            }
            bc.DEFAULT_PRIORITY = 10, bc.prototype.is = function(t, e) {
                return e ? e === this.name && ("attributeElement" === t || "view:attributeElement" === t || "element" === t || "view:element" === t) : "attributeElement" === t || "view:attributeElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class Ac extends Za {
                constructor(t, e, n, o) {
                    super(t, e, n, o), this.getFillerOffset = Cc
                }
                _insertChild(t, e) {
                    if (e && (e instanceof Hs || Array.from(e).length > 0)) throw new A("view-emptyelement-cannot-add", [this, e]);
                    return 0
                }
            }
    
            function Cc() {
                return null
            }
            Ac.prototype.is = function(t, e) {
                return e ? e === this.name && ("emptyElement" === t || "view:emptyElement" === t || "element" === t || "view:element" === t) : "emptyElement" === t || "view:emptyElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class vc extends Za {
                constructor(...t) {
                    super(...t), this.getFillerOffset = xc
                }
                _insertChild(t, e) {
                    if (e && (e instanceof Hs || Array.from(e).length > 0)) throw new A("view-uielement-cannot-add", [this, e]);
                    return 0
                }
                render(t, e) {
                    return this.toDomElement(t)
                }
                toDomElement(t) {
                    const e = t.createElement(this.name);
                    for (const t of this.getAttributeKeys()) e.setAttribute(t, this.getAttribute(t));
                    return e
                }
            }
    
            function yc(t) {
                t.document.on("arrowKey", ((e, n) => function(t, e, n) {
                    if (e.keyCode == er.arrowright) {
                        const t = e.domTarget.ownerDocument.defaultView.getSelection(),
                            o = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
                        if (o || e.shiftKey) {
                            const e = t.focusNode,
                                i = t.focusOffset,
                                r = n.domPositionToView(e, i);
                            if (null === r) return;
                            let s = !1;
                            const a = r.getLastMatchingPosition((t => (t.item.is("uiElement") && (s = !0), !(!t.item.is("uiElement") && !t.item.is("attributeElement")))));
                            if (s) {
                                const e = n.viewPositionToDom(a);
                                o ? t.collapse(e.parent, e.offset) : t.extend(e.parent, e.offset)
                            }
                        }
                    }
                }(0, n, t.domConverter)), {
                    priority: "low"
                })
            }
    
            function xc() {
                return null
            }
            vc.prototype.is = function(t, e) {
                return e ? e === this.name && ("uiElement" === t || "view:uiElement" === t || "element" === t || "view:element" === t) : "uiElement" === t || "view:uiElement" === t || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class Ec extends Za {
                constructor(...t) {
                    super(...t), this.getFillerOffset = Dc
                }
                _insertChild(t, e) {
                    if (e && (e instanceof Hs || Array.from(e).length > 0)) throw new A("view-rawelement-cannot-add", [this, e]);
                    return 0
                }
                render() {}
            }
    
            function Dc() {
                return null
            }
            Ec.prototype.is = function(t, e) {
                return e ? e === this.name && ("rawElement" === t || "view:rawElement" === t || "element" === t || "view:element" === t) : "rawElement" === t || "view:rawElement" === t || t === this.name || t === "view:" + this.name || "element" === t || "view:element" === t || "node" === t || "view:node" === t
            };
            class Ic extends(N(js)) {
                constructor(t, e) {
                    super(), this.document = t, this._children = [], e && this._insertChild(0, e), this._customProperties = new Map
                } [Symbol.iterator]() {
                    return this._children[Symbol.iterator]()
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return 0 === this.childCount
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                getCustomProperty(t) {
                    return this._customProperties.get(t)
                }* getCustomProperties() {
                    yield* this._customProperties.entries()
                }
                _appendChild(t) {
                    return this._insertChild(this.childCount, t)
                }
                getChild(t) {
                    return this._children[t]
                }
                getChildIndex(t) {
                    return this._children.indexOf(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                _insertChild(t, e) {
                    this._fireChange("children", this);
                    let n = 0;
                    const o = function(t, e) {
                        if ("string" == typeof e) return [new Us(t, e)];
                        nt(e) || (e = [e]);
                        return Array.from(e).map((e => "string" == typeof e ? new Us(t, e) : e instanceof Ws ? new Us(t, e.data) : e))
                    }(this.document, e);
                    for (const e of o) null !== e.parent && e._remove(), e.parent = this, this._children.splice(t, 0, e), t++, n++;
                    return n
                }
                _removeChildren(t, e = 1) {
                    this._fireChange("children", this);
                    for (let n = t; n < t + e; n++) this._children[n].parent = null;
                    return this._children.splice(t, e)
                }
                _fireChange(t, e) {
                    this.fire("change:" + t, e)
                }
                _setCustomProperty(t, e) {
                    this._customProperties.set(t, e)
                }
                _removeCustomProperty(t) {
                    return this._customProperties.delete(t)
                }
            }
            Ic.prototype.is = function(t) {
                return "documentFragment" === t || "view:documentFragment" === t
            };
            class Tc {
                constructor(t) {
                    this.document = t, this._cloneGroups = new Map, this._slotFactory = null
                }
                setSelection(...t) {
                    this.document.selection._setTo(...t)
                }
                setSelectionFocus(...t) {
                    this.document.selection._setFocus(...t)
                }
                createDocumentFragment(t) {
                    return new Ic(this.document, t)
                }
                createText(t) {
                    return new Us(this.document, t)
                }
                createAttributeElement(t, e, n = {}) {
                    const o = new bc(this.document, t, e);
                    return "number" == typeof n.priority && (o._priority = n.priority), n.id && (o._id = n.id), n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
                }
                createContainerElement(t, e, n = {}, o = {}) {
                    let i = null;
                    St(n) ? o = n : i = n;
                    const r = new Xa(this.document, t, e, i);
                    return o.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes), r
                }
                createEditableElement(t, e, n = {}) {
                    const o = new ec(this.document, t, e);
                    return n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
                }
                createEmptyElement(t, e, n = {}) {
                    const o = new Ac(this.document, t, e);
                    return n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
                }
                createUIElement(t, e, n) {
                    const o = new vc(this.document, t, e);
                    return n && (o.render = n), o
                }
                createRawElement(t, e, n, o = {}) {
                    const i = new Ec(this.document, t, e);
                    return n && (i.render = n), o.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes), i
                }
                setAttribute(t, e, n) {
                    n._setAttribute(t, e)
                }
                removeAttribute(t, e) {
                    e._removeAttribute(t)
                }
                addClass(t, e) {
                    e._addClass(t)
                }
                removeClass(t, e) {
                    e._removeClass(t)
                }
                setStyle(t, e, n) {
                    St(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e)
                }
                removeStyle(t, e) {
                    e._removeStyle(t)
                }
                setCustomProperty(t, e, n) {
                    n._setCustomProperty(t, e)
                }
                removeCustomProperty(t, e) {
                    return e._removeCustomProperty(t)
                }
                breakAttributes(t) {
                    return t instanceof rc ? this._breakAttributes(t) : this._breakAttributesRange(t)
                }
                breakContainer(t) {
                    const e = t.parent;
                    if (!e.is("containerElement")) throw new A("view-writer-break-non-container-element", this.document);
                    if (!e.parent) throw new A("view-writer-break-root", this.document);
                    if (t.isAtStart) return rc._createBefore(e);
                    if (!t.isAtEnd) {
                        const n = e._clone(!1);
                        this.insert(rc._createAfter(e), n);
                        const o = new sc(t, rc._createAt(e, "end")),
                            i = new rc(n, 0);
                        this.move(o, i)
                    }
                    return rc._createAfter(e)
                }
                mergeAttributes(t) {
                    const e = t.offset,
                        n = t.parent;
                    if (n.is("$text")) return t;
                    if (n.is("attributeElement") && 0 === n.childCount) {
                        const t = n.parent,
                            e = n.index;
                        return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new rc(t, e))
                    }
                    const o = n.getChild(e - 1),
                        i = n.getChild(e);
                    if (!o || !i) return t;
                    if (o.is("$text") && i.is("$text")) return Pc(o, i);
                    if (o.is("attributeElement") && i.is("attributeElement") && o.isSimilar(i)) {
                        const t = o.childCount;
                        return o._appendChild(i.getChildren()), i._remove(), this._removeFromClonedElementsGroup(i), this.mergeAttributes(new rc(o, t))
                    }
                    return t
                }
                mergeContainers(t) {
                    const e = t.nodeBefore,
                        n = t.nodeAfter;
                    if (!(e && n && e.is("containerElement") && n.is("containerElement"))) throw new A("view-writer-merge-containers-invalid-position", this.document);
                    const o = e.getChild(e.childCount - 1),
                        i = o instanceof Us ? rc._createAt(o, "end") : rc._createAt(e, "end");
                    return this.move(sc._createIn(n), rc._createAt(e, "end")), this.remove(sc._createOn(n)), i
                }
                insert(t, e) {
                    Lc(e = nt(e) ? [...e] : [e], this.document);
                    const n = e.reduce(((t, e) => {
                        const n = t[t.length - 1],
                            o = !e.is("uiElement");
                        return n && n.breakAttributes == o ? n.nodes.push(e) : t.push({
                            breakAttributes: o,
                            nodes: [e]
                        }), t
                    }), []);
                    let o = null,
                        i = t;
                    for (const {
                            nodes: t,
                            breakAttributes: e
                        }
                        of n) {
                        const n = this._insertNodes(i, t, e);
                        o || (o = n.start), i = n.end
                    }
                    return o ? new sc(o, i) : new sc(t)
                }
                remove(t) {
                    const e = t instanceof sc ? t : sc._createOn(t);
                    if (Rc(e, this.document), e.isCollapsed) return new Ic(this.document);
                    const {
                        start: n,
                        end: o
                    } = this._breakAttributesRange(e, !0), i = n.parent, r = o.offset - n.offset, s = i._removeChildren(n.offset, r);
                    for (const t of s) this._removeFromClonedElementsGroup(t);
                    const a = this.mergeAttributes(n);
                    return e.start = a, e.end = a.clone(), new Ic(this.document, s)
                }
                clear(t, e) {
                    Rc(t, this.document);
                    const n = t.getWalker({
                        direction: "backward",
                        ignoreElementEnd: !0
                    });
                    for (const o of n) {
                        const n = o.item;
                        let i;
                        if (n.is("element") && e.isSimilar(n)) i = sc._createOn(n);
                        else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
                            const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t)));
                            t && (i = sc._createIn(t))
                        }
                        i && (i.end.isAfter(t.end) && (i.end = t.end), i.start.isBefore(t.start) && (i.start = t.start), this.remove(i))
                    }
                }
                move(t, e) {
                    let n;
                    if (e.isAfter(t.end)) {
                        const o = (e = this._breakAttributes(e, !0)).parent,
                            i = o.childCount;
                        t = this._breakAttributesRange(t, !0), n = this.remove(t), e.offset += o.childCount - i
                    } else n = this.remove(t);
                    return this.insert(e, n)
                }
                wrap(t, e) {
                    if (!(e instanceof bc)) throw new A("view-writer-wrap-invalid-attribute", this.document);
                    if (Rc(t, this.document), t.isCollapsed) {
                        let o = t.start;
                        o.parent.is("element") && (n = o.parent, !Array.from(n.getChildren()).some((t => !t.is("uiElement")))) && (o = o.getLastMatchingPosition((t => t.item.is("uiElement")))), o = this._wrapPosition(o, e);
                        const i = this.document.selection;
                        return i.isCollapsed && i.getFirstPosition().isEqual(t.start) && this.setSelection(o), new sc(o)
                    }
                    return this._wrapRange(t, e);
                    var n
                }
                unwrap(t, e) {
                    if (!(e instanceof bc)) throw new A("view-writer-unwrap-invalid-attribute", this.document);
                    if (Rc(t, this.document), t.isCollapsed) return t;
                    const {
                        start: n,
                        end: o
                    } = this._breakAttributesRange(t, !0), i = n.parent, r = this._unwrapChildren(i, n.offset, o.offset, e), s = this.mergeAttributes(r.start);
                    s.isEqual(r.start) || r.end.offset--;
                    const a = this.mergeAttributes(r.end);
                    return new sc(s, a)
                }
                rename(t, e) {
                    const n = new Xa(this.document, t, e.getAttributes());
                    return this.insert(rc._createAfter(e), n), this.move(sc._createIn(e), rc._createAt(n, 0)), this.remove(sc._createOn(e)), n
                }
                clearClonedElementsGroup(t) {
                    this._cloneGroups.delete(t)
                }
                createPositionAt(t, e) {
                    return rc._createAt(t, e)
                }
                createPositionAfter(t) {
                    return rc._createAfter(t)
                }
                createPositionBefore(t) {
                    return rc._createBefore(t)
                }
                createRange(...t) {
                    return new sc(...t)
                }
                createRangeOn(t) {
                    return sc._createOn(t)
                }
                createRangeIn(t) {
                    return sc._createIn(t)
                }
                createSelection(...t) {
                    return new cc(...t)
                }
                createSlot(t) {
                    if (!this._slotFactory) throw new A("view-writer-invalid-create-slot-context", this.document);
                    return this._slotFactory(this, t)
                }
                _registerSlotFactory(t) {
                    this._slotFactory = t
                }
                _clearSlotFactory() {
                    this._slotFactory = null
                }
                _insertNodes(t, e, n) {
                    let o, i;
                    if (o = n ? Mc(t) : t.parent.is("$text") ? t.parent.parent : t.parent, !o) throw new A("view-writer-invalid-position-container", this.document);
                    i = n ? this._breakAttributes(t, !0) : t.parent.is("$text") ? Bc(t) : t;
                    const r = o._insertChild(i.offset, e);
                    for (const t of e) this._addToClonedElementsGroup(t);
                    const s = i.getShiftedBy(r),
                        a = this.mergeAttributes(i);
                    a.isEqual(i) || s.offset--;
                    const c = this.mergeAttributes(s);
                    return new sc(a, c)
                }
                _wrapChildren(t, e, n, o) {
                    let i = e;
                    const r = [];
                    for (; i < n;) {
                        const e = t.getChild(i),
                            n = e.is("$text"),
                            s = e.is("attributeElement");
                        if (s && this._wrapAttributeElement(o, e)) r.push(new rc(t, i));
                        else if (n || !s || Sc(o, e)) {
                            const n = o._clone();
                            e._remove(), n._appendChild(e), t._insertChild(i, n), this._addToClonedElementsGroup(n), r.push(new rc(t, i))
                        } else this._wrapChildren(e, 0, e.childCount, o);
                        i++
                    }
                    let s = 0;
                    for (const t of r) {
                        if (t.offset -= s, t.offset == e) continue;
                        this.mergeAttributes(t).isEqual(t) || (s++, n--)
                    }
                    return sc._createFromParentsAndOffsets(t, e, t, n)
                }
                _unwrapChildren(t, e, n, o) {
                    let i = e;
                    const r = [];
                    for (; i < n;) {
                        const e = t.getChild(i);
                        if (e.is("attributeElement"))
                            if (e.isSimilar(o)) {
                                const o = e.getChildren(),
                                    s = e.childCount;
                                e._remove(), t._insertChild(i, o), this._removeFromClonedElementsGroup(e), r.push(new rc(t, i), new rc(t, i + s)), i += s, n += s - 1
                            } else this._unwrapAttributeElement(o, e) ? (r.push(new rc(t, i), new rc(t, i + 1)), i++) : (this._unwrapChildren(e, 0, e.childCount, o), i++);
                        else i++
                    }
                    let s = 0;
                    for (const t of r) {
                        if (t.offset -= s, t.offset == e || t.offset == n) continue;
                        this.mergeAttributes(t).isEqual(t) || (s++, n--)
                    }
                    return sc._createFromParentsAndOffsets(t, e, t, n)
                }
                _wrapRange(t, e) {
                    const {
                        start: n,
                        end: o
                    } = this._breakAttributesRange(t, !0), i = n.parent, r = this._wrapChildren(i, n.offset, o.offset, e), s = this.mergeAttributes(r.start);
                    s.isEqual(r.start) || r.end.offset--;
                    const a = this.mergeAttributes(r.end);
                    return new sc(s, a)
                }
                _wrapPosition(t, e) {
                    if (e.isSimilar(t.parent)) return Nc(t.clone());
                    t.parent.is("$text") && (t = Bc(t));
                    const n = this.createAttributeElement("_wrapPosition-fake-element");
                    n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, t.parent._insertChild(t.offset, n);
                    const o = new sc(t, t.getShiftedBy(1));
                    this.wrap(o, e);
                    const i = new rc(n.parent, n.index);
                    n._remove();
                    const r = i.nodeBefore,
                        s = i.nodeAfter;
                    return r instanceof Us && s instanceof Us ? Pc(r, s) : Nc(i)
                }
                _wrapAttributeElement(t, e) {
                    if (!jc(t, e)) return !1;
                    if (t.name !== e.name || t.priority !== e.priority) return !1;
                    for (const n of t.getAttributeKeys())
                        if ("class" !== n && "style" !== n && e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) return !1;
                    for (const n of t.getStyleNames())
                        if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
                    for (const n of t.getAttributeKeys()) "class" !== n && "style" !== n && (e.hasAttribute(n) || this.setAttribute(n, t.getAttribute(n), e));
                    for (const n of t.getStyleNames()) e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
                    for (const n of t.getClassNames()) e.hasClass(n) || this.addClass(n, e);
                    return !0
                }
                _unwrapAttributeElement(t, e) {
                    if (!jc(t, e)) return !1;
                    if (t.name !== e.name || t.priority !== e.priority) return !1;
                    for (const n of t.getAttributeKeys())
                        if ("class" !== n && "style" !== n && (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n))) return !1;
                    if (!e.hasClass(...t.getClassNames())) return !1;
                    for (const n of t.getStyleNames())
                        if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) return !1;
                    for (const n of t.getAttributeKeys()) "class" !== n && "style" !== n && this.removeAttribute(n, e);
                    return this.removeClass(Array.from(t.getClassNames()), e), this.removeStyle(Array.from(t.getStyleNames()), e), !0
                }
                _breakAttributesRange(t, e = !1) {
                    const n = t.start,
                        o = t.end;
                    if (Rc(t, this.document), t.isCollapsed) {
                        const n = this._breakAttributes(t.start, e);
                        return new sc(n, n)
                    }
                    const i = this._breakAttributes(o, e),
                        r = i.parent.childCount,
                        s = this._breakAttributes(n, e);
                    return i.offset += i.parent.childCount - r, new sc(s, i)
                }
                _breakAttributes(t, e = !1) {
                    const n = t.offset,
                        o = t.parent;
                    if (t.parent.is("emptyElement")) throw new A("view-writer-cannot-break-empty-element", this.document);
                    if (t.parent.is("uiElement")) throw new A("view-writer-cannot-break-ui-element", this.document);
                    if (t.parent.is("rawElement")) throw new A("view-writer-cannot-break-raw-element", this.document);
                    if (!e && o.is("$text") && Oc(o.parent)) return t.clone();
                    if (Oc(o)) return t.clone();
                    if (o.is("$text")) return this._breakAttributes(Bc(t), e);
                    if (n == o.childCount) {
                        const t = new rc(o.parent, o.index + 1);
                        return this._breakAttributes(t, e)
                    }
                    if (0 === n) {
                        const t = new rc(o.parent, o.index);
                        return this._breakAttributes(t, e)
                    } {
                        const t = o.index + 1,
                            i = o._clone();
                        o.parent._insertChild(t, i), this._addToClonedElementsGroup(i);
                        const r = o.childCount - n,
                            s = o._removeChildren(n, r);
                        i._appendChild(s);
                        const a = new rc(o.parent, t);
                        return this._breakAttributes(a, e)
                    }
                }
                _addToClonedElementsGroup(t) {
                    if (!t.root.is("rootElement")) return;
                    if (t.is("element"))
                        for (const e of t.getChildren()) this._addToClonedElementsGroup(e);
                    const e = t.id;
                    if (!e) return;
                    let n = this._cloneGroups.get(e);
                    n || (n = new Set, this._cloneGroups.set(e, n)), n.add(t), t._clonesGroup = n
                }
                _removeFromClonedElementsGroup(t) {
                    if (t.is("element"))
                        for (const e of t.getChildren()) this._removeFromClonedElementsGroup(e);
                    const e = t.id;
                    if (!e) return;
                    const n = this._cloneGroups.get(e);
                    n && n.delete(t)
                }
            }
    
            function Mc(t) {
                let e = t.parent;
                for (; !Oc(e);) {
                    if (!e) return;
                    e = e.parent
                }
                return e
            }
    
            function Sc(t, e) {
                return t.priority < e.priority || !(t.priority > e.priority) && t.getIdentity() < e.getIdentity()
            }
    
            function Nc(t) {
                const e = t.nodeBefore;
                if (e && e.is("$text")) return new rc(e, e.data.length);
                const n = t.nodeAfter;
                return n && n.is("$text") ? new rc(n, 0) : t
            }
    
            function Bc(t) {
                if (t.offset == t.parent.data.length) return new rc(t.parent.parent, t.parent.index + 1);
                if (0 === t.offset) return new rc(t.parent.parent, t.parent.index);
                const e = t.parent.data.slice(t.offset);
                return t.parent._data = t.parent.data.slice(0, t.offset), t.parent.parent._insertChild(t.parent.index + 1, new Us(t.root.document, e)), new rc(t.parent.parent, t.parent.index + 1)
            }
    
            function Pc(t, e) {
                const n = t.data.length;
                return t._data += e.data, e._remove(), new rc(t, n)
            }
            const zc = [Us, bc, Xa, Ac, Ec, vc];
    
            function Lc(t, e) {
                for (const n of t) {
                    if (!zc.some((t => n instanceof t))) throw new A("view-writer-insert-invalid-node-type", e);
                    n.is("$text") || Lc(n.getChildren(), e)
                }
            }
    
            function Oc(t) {
                return t && (t.is("containerElement") || t.is("documentFragment"))
            }
    
            function Rc(t, e) {
                const n = Mc(t.start),
                    o = Mc(t.end);
                if (!n || !o || n !== o) throw new A("view-writer-invalid-range-container", e)
            }
    
            function jc(t, e) {
                return null === t.id && null === e.id
            }
            const Fc = t => t.createTextNode(" "),
                Vc = t => {
                    const e = t.createElement("span");
                    return e.dataset.ckeFiller = "true", e.innerText = " ", e
                },
                Hc = t => {
                    const e = t.createElement("br");
                    return e.dataset.ckeFiller = "true", e
                },
                Uc = 7,
                Wc = "".repeat(Uc);
    
            function qc(t) {
                return xi(t) && t.data.substr(0, Uc) === Wc
            }
    
            function Gc(t) {
                return t.data.length == Uc && qc(t)
            }
    
            function $c(t) {
                return qc(t) ? t.data.slice(Uc) : t.data
            }
    
            function Yc(t, e) {
                if (e.keyCode == er.arrowleft) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection();
                    if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
                        const e = t.getRangeAt(0).startContainer,
                            n = t.getRangeAt(0).startOffset;
                        qc(e) && n <= Uc && t.collapse(e, 0)
                    }
                }
            }
            var Kc = n(9315),
                Qc = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Kc.Z, Qc);
            Kc.Z.locals;
            class Zc extends($()) {
                constructor(t, e) {
                    super(), this.domDocuments = new Set, this.domConverter = t, this.markedAttributes = new Set, this.markedChildren = new Set, this.markedTexts = new Set, this.selection = e, this.set("isFocused", !1), this.set("isSelecting", !1), a.isBlink && !a.isAndroid && this.on("change:isSelecting", (() => {
                        this.isSelecting || this.render()
                    })), this.set("isComposing", !1), this.on("change:isComposing", (() => {
                        this.isComposing || this.render()
                    })), this._inlineFiller = null, this._fakeSelectionContainer = null
                }
                markToSync(t, e) {
                    if ("text" === t) this.domConverter.mapViewToDom(e.parent) && this.markedTexts.add(e);
                    else {
                        if (!this.domConverter.mapViewToDom(e)) return;
                        if ("attributes" === t) this.markedAttributes.add(e);
                        else {
                            if ("children" !== t) throw new A("view-renderer-unknown-type", this);
                            this.markedChildren.add(e)
                        }
                    }
                }
                render() {
                    if (this.isComposing && !a.isAndroid) return;
                    let t = null;
                    const e = !(a.isBlink && !a.isAndroid) || !this.isSelecting;
                    for (const t of this.markedChildren) this._updateChildrenMappings(t);
                    e ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t = this.selection.getFirstPosition(), this.markedChildren.add(t.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (t = this.domConverter.domPositionToView(this._inlineFiller), t && t.parent.is("$text") && (t = rc._createBefore(t.parent)));
                    for (const t of this.markedAttributes) this._updateAttrs(t);
                    for (const e of this.markedChildren) this._updateChildren(e, {
                        inlineFillerPosition: t
                    });
                    for (const e of this.markedTexts) !this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent) && this._updateText(e, {
                        inlineFillerPosition: t
                    });
                    if (e)
                        if (t) {
                            const e = this.domConverter.viewPositionToDom(t),
                                n = e.parent.ownerDocument;
                            qc(e.parent) ? this._inlineFiller = e.parent : this._inlineFiller = Jc(n, e.parent, e.offset)
                        } else this._inlineFiller = null;
                    this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear()
                }
                _updateChildrenMappings(t) {
                    if (!this.domConverter.mapViewToDom(t)) return;
                    const e = Array.from(this.domConverter.mapViewToDom(t).childNodes),
                        n = Array.from(this.domConverter.viewChildrenToDom(t, {
                            withChildren: !1
                        })),
                        o = this._diffNodeLists(e, n),
                        i = this._findReplaceActions(o, e, n);
                    if (-1 !== i.indexOf("replace")) {
                        const o = {
                            equal: 0,
                            insert: 0,
                            delete: 0
                        };
                        for (const r of i)
                            if ("replace" === r) {
                                const i = o.equal + o.insert,
                                    r = o.equal + o.delete,
                                    s = t.getChild(i);
                                !s || s.is("uiElement") || s.is("rawElement") || this._updateElementMappings(s, e[r]), Ui(n[i]), o.equal++
                            } else o[r]++
                    }
                }
                _updateElementMappings(t, e) {
                    this.domConverter.unbindDomElement(e), this.domConverter.bindElements(e, t), this.markedChildren.add(t), this.markedAttributes.add(t)
                }
                _getInlineFillerPosition() {
                    const t = this.selection.getFirstPosition();
                    return t.parent.is("$text") ? rc._createBefore(t.parent) : t
                }
                _isSelectionInInlineFiller() {
                    if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
                    const t = this.selection.getFirstPosition(),
                        e = this.domConverter.viewPositionToDom(t);
                    return !!(e && xi(e.parent) && qc(e.parent))
                }
                _removeInlineFiller() {
                    const t = this._inlineFiller;
                    if (!qc(t)) throw new A("view-renderer-filler-was-lost", this);
                    Gc(t) ? t.remove() : t.data = t.data.substr(Uc), this._inlineFiller = null
                }
                _needsInlineFillerAtSelection() {
                    if (1 != this.selection.rangeCount || !this.selection.isCollapsed) return !1;
                    const t = this.selection.getFirstPosition(),
                        e = t.parent,
                        n = t.offset;
                    if (!this.domConverter.mapViewToDom(e.root)) return !1;
                    if (!e.is("element")) return !1;
                    if (! function(t) {
                            if ("false" == t.getAttribute("contenteditable")) return !1;
                            const e = t.findAncestor((t => t.hasAttribute("contenteditable")));
                            return !e || "true" == e.getAttribute("contenteditable")
                        }(e)) return !1;
                    if (n === e.getFillerOffset()) return !1;
                    const o = t.nodeBefore,
                        i = t.nodeAfter;
                    return !(o instanceof Us || i instanceof Us) && (!a.isAndroid || !o && !i)
                }
                _updateText(t, e) {
                    const n = this.domConverter.findCorrespondingDomText(t);
                    let o = this.domConverter.viewToDom(t).data;
                    const i = e.inlineFillerPosition;
                    i && i.parent == t.parent && i.offset == t.index && (o = Wc + o), nl(n, o)
                }
                _updateAttrs(t) {
                    const e = this.domConverter.mapViewToDom(t);
                    if (!e) return;
                    const n = Array.from(e.attributes).map((t => t.name)),
                        o = t.getAttributeKeys();
                    for (const n of o) this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t);
                    for (const o of n) t.hasAttribute(o) || this.domConverter.removeDomElementAttribute(e, o)
                }
                _updateChildren(t, e) {
                    const n = this.domConverter.mapViewToDom(t);
                    if (!n) return;
                    if (a.isAndroid) {
                        let t = null;
                        for (const e of Array.from(n.childNodes)) {
                            if (t && xi(t) && xi(e)) {
                                n.normalize();
                                break
                            }
                            t = e
                        }
                    }
                    const o = e.inlineFillerPosition,
                        i = n.childNodes,
                        r = Array.from(this.domConverter.viewChildrenToDom(t, {
                            bind: !0
                        }));
                    o && o.parent === t && Jc(n.ownerDocument, r, o.offset);
                    const s = this._diffNodeLists(i, r),
                        c = a.isAndroid ? this._findReplaceActions(s, i, r, {
                            replaceText: !0
                        }) : s;
                    let l = 0;
                    const d = new Set;
                    for (const t of c) "delete" === t ? (d.add(i[l]), Ui(i[l])) : "equal" !== t && "replace" !== t || l++;
                    l = 0;
                    for (const t of c) "insert" === t ? (Oi(n, l, r[l]), l++) : "replace" === t ? (nl(i[l], r[l].data), l++) : "equal" === t && (this._markDescendantTextToSync(this.domConverter.domToView(r[l])), l++);
                    for (const t of d) t.parentNode || this.domConverter.unbindDomElement(t)
                }
                _diffNodeLists(t, e) {
                    return t = function(t, e) {
                        const n = Array.from(t);
                        if (0 == n.length || !e) return n;
                        const o = n[n.length - 1];
                        o == e && n.pop();
                        return n
                    }(t, this._fakeSelectionContainer), u(t, e, el.bind(null, this.domConverter))
                }
                _findReplaceActions(t, e, n, o = {}) {
                    if (-1 === t.indexOf("insert") || -1 === t.indexOf("delete")) return t;
                    let i = [],
                        r = [],
                        s = [];
                    const a = {
                        equal: 0,
                        insert: 0,
                        delete: 0
                    };
                    for (const c of t) "insert" === c ? s.push(n[a.equal + a.insert]) : "delete" === c ? r.push(e[a.equal + a.delete]) : (i = i.concat(u(r, s, o.replaceText ? tl : Xc).map((t => "equal" === t ? "replace" : t))), i.push("equal"), r = [], s = []), a[c]++;
                    return i.concat(u(r, s, o.replaceText ? tl : Xc).map((t => "equal" === t ? "replace" : t)))
                }
                _markDescendantTextToSync(t) {
                    if (t)
                        if (t.is("$text")) this.markedTexts.add(t);
                        else if (t.is("element"))
                        for (const e of t.getChildren()) this._markDescendantTextToSync(e)
                }
                _updateSelection() {
                    if (a.isBlink && !a.isAndroid && this.isSelecting && !this.markedChildren.size) return;
                    if (0 === this.selection.rangeCount) return this._removeDomSelection(), void this._removeFakeSelection();
                    const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                    this.isFocused && t && (this.selection.isFake ? this._updateFakeSelection(t) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(t)) : this.isComposing && a.isAndroid || this._updateDomSelection(t))
                }
                _updateFakeSelection(t) {
                    const e = t.ownerDocument;
                    this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t) {
                        const e = t.createElement("div");
                        return e.className = "ck-fake-selection-container", Object.assign(e.style, {
                            position: "fixed",
                            top: 0,
                            left: "-9999px",
                            width: "42px"
                        }), e.textContent = " ", e
                    }(e));
                    const n = this._fakeSelectionContainer;
                    if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(t)) return;
                    n.parentElement && n.parentElement == t || t.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
                    const o = e.getSelection(),
                        i = e.createRange();
                    o.removeAllRanges(), i.selectNodeContents(n), o.addRange(i)
                }
                _updateDomSelection(t) {
                    const e = t.ownerDocument.defaultView.getSelection();
                    if (!this._domSelectionNeedsUpdate(e)) return;
                    const n = this.domConverter.viewPositionToDom(this.selection.anchor),
                        o = this.domConverter.viewPositionToDom(this.selection.focus);
                    e.collapse(n.parent, n.offset), e.extend(o.parent, o.offset), a.isGecko && function(t, e) {
                        const n = t.parent;
                        if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) return;
                        const o = n.childNodes[t.offset];
                        o && "BR" == o.tagName && e.addRange(e.getRangeAt(0))
                    }(o, e)
                }
                _domSelectionNeedsUpdate(t) {
                    if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
                    const e = t && this.domConverter.domSelectionToView(t);
                    return (!e || !this.selection.isEqual(e)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e))
                }
                _fakeSelectionNeedsUpdate(t) {
                    const e = this._fakeSelectionContainer,
                        n = t.ownerDocument.getSelection();
                    return !e || e.parentElement !== t || (n.anchorNode !== e && !e.contains(n.anchorNode) || e.textContent !== this.selection.fakeSelectionLabel)
                }
                _removeDomSelection() {
                    for (const t of this.domDocuments) {
                        const e = t.getSelection();
                        if (e.rangeCount) {
                            const n = t.activeElement,
                                o = this.domConverter.mapDomToView(n);
                            n && o && e.removeAllRanges()
                        }
                    }
                }
                _removeFakeSelection() {
                    const t = this._fakeSelectionContainer;
                    t && t.remove()
                }
                _updateFocus() {
                    if (this.isFocused) {
                        const t = this.selection.editableElement;
                        t && this.domConverter.focus(t)
                    }
                }
            }
    
            function Jc(t, e, n) {
                const o = e instanceof Array ? e : e.childNodes,
                    i = o[n];
                if (xi(i)) return i.data = Wc + i.data, i;
                {
                    const i = t.createTextNode(Wc);
                    return Array.isArray(e) ? o.splice(n, 0, i) : Oi(e, n, i), i
                }
            }
    
            function Xc(t, e) {
                return fi(t) && fi(e) && !xi(t) && !xi(e) && !Ri(t) && !Ri(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase()
            }
    
            function tl(t, e) {
                return fi(t) && fi(e) && xi(t) && xi(e)
            }
    
            function el(t, e, n) {
                return e === n || (xi(e) && xi(n) ? e.data === n.data : !(!t.isBlockFiller(e) || !t.isBlockFiller(n)))
            }
    
            function nl(t, e) {
                const n = t.data;
                if (n == e) return;
                const o = l(n, e);
                for (const e of o) "insert" === e.type ? t.insertData(e.index, e.values.join("")) : t.deleteData(e.index, e.howMany)
            }
            const ol = Hc(vi.document),
                il = Fc(vi.document),
                rl = Vc(vi.document),
                sl = "data-ck-unsafe-attribute-",
                al = "data-ck-unsafe-element";
            class cl {
                constructor(t, e = {}) {
                    this.document = t, this.renderingMode = e.renderingMode || "editing", this.blockFillerMode = e.blockFillerMode || ("editing" === this.renderingMode ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = "editing" === this.renderingMode ? vi.document : vi.document.implementation.createHTMLDocument(""), this._domToViewMapping = new WeakMap, this._viewToDomMapping = new WeakMap, this._fakeSelectionMapping = new WeakMap, this._rawContentElementMatcher = new qs, this._encounteredRawContentDomNodes = new WeakSet
                }
                bindFakeSelection(t, e) {
                    this._fakeSelectionMapping.set(t, new cc(e))
                }
                fakeSelectionToView(t) {
                    return this._fakeSelectionMapping.get(t)
                }
                bindElements(t, e) {
                    this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t)
                }
                unbindDomElement(t) {
                    const e = this._domToViewMapping.get(t);
                    if (e) {
                        this._domToViewMapping.delete(t), this._viewToDomMapping.delete(e);
                        for (const e of Array.from(t.children)) this.unbindDomElement(e)
                    }
                }
                bindDocumentFragments(t, e) {
                    this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t)
                }
                shouldRenderAttribute(t, e, n) {
                    return "data" === this.renderingMode || !(t = t.toLowerCase()).startsWith("on") && (("srcdoc" !== t || !e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && ("img" === n && ("src" === t || "srcset" === t) || ("source" === n && "srcset" === t || !e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))))
                }
                setContentOf(t, e) {
                    if ("data" === this.renderingMode) return void(t.innerHTML = e);
                    const n = (new DOMParser).parseFromString(e, "text/html"),
                        o = n.createDocumentFragment(),
                        i = n.body.childNodes;
                    for (; i.length > 0;) o.appendChild(i[0]);
                    const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT),
                        s = [];
                    let a;
                    for (; a = r.nextNode();) s.push(a);
                    for (const t of s) {
                        for (const e of t.getAttributeNames()) this.setDomElementAttribute(t, e, t.getAttribute(e));
                        const e = t.tagName.toLowerCase();
                        this._shouldRenameElement(e) && (hl(e), t.replaceWith(this._createReplacementDomElement(e, t)))
                    }
                    for (; t.firstChild;) t.firstChild.remove();
                    t.append(o)
                }
                viewToDom(t, e = {}) {
                    if (t.is("$text")) {
                        const e = this._processDataFromViewText(t);
                        return this._domDocument.createTextNode(e)
                    } {
                        if (this.mapViewToDom(t)) return this.mapViewToDom(t);
                        let n;
                        if (t.is("documentFragment")) n = this._domDocument.createDocumentFragment(), e.bind && this.bindDocumentFragments(n, t);
                        else {
                            if (t.is("uiElement")) return n = "$comment" === t.name ? this._domDocument.createComment(t.getCustomProperty("$rawContent")) : t.render(this._domDocument, this), e.bind && this.bindElements(n, t), n;
                            this._shouldRenameElement(t.name) ? (hl(t.name), n = this._createReplacementDomElement(t.name)) : n = t.hasAttribute("xmlns") ? this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name) : this._domDocument.createElement(t.name), t.is("rawElement") && t.render(n, this), e.bind && this.bindElements(n, t);
                            for (const e of t.getAttributeKeys()) this.setDomElementAttribute(n, e, t.getAttribute(e), t)
                        }
                        if (!1 !== e.withChildren)
                            for (const o of this.viewChildrenToDom(t, e)) n.appendChild(o);
                        return n
                    }
                }
                setDomElementAttribute(t, e, n, o) {
                    const i = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || o && o.shouldRenderUnsafeAttribute(e);
                    i || C("domconverter-unsafe-attribute-detected", {
                        domElement: t,
                        key: e,
                        value: n
                    }), t.hasAttribute(e) && !i ? t.removeAttribute(e) : t.hasAttribute(sl + e) && i && t.removeAttribute(sl + e), t.setAttribute(i ? e : sl + e, n)
                }
                removeDomElementAttribute(t, e) {
                    e != al && (t.removeAttribute(e), t.removeAttribute(sl + e))
                }* viewChildrenToDom(t, e = {}) {
                    const n = t.getFillerOffset && t.getFillerOffset();
                    let o = 0;
                    for (const i of t.getChildren()) {
                        n === o && (yield this._getBlockFiller());
                        const t = i.is("element") && !!i.getCustomProperty("dataPipeline:transparentRendering") && !gr(i.getAttributes());
                        t && "data" == this.renderingMode ? yield* this.viewChildrenToDom(i, e): (t && C("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                            viewElement: i
                        }), yield this.viewToDom(i, e)), o++
                    }
                    n === o && (yield this._getBlockFiller())
                }
                viewRangeToDom(t) {
                    const e = this.viewPositionToDom(t.start),
                        n = this.viewPositionToDom(t.end),
                        o = this._domDocument.createRange();
                    return o.setStart(e.parent, e.offset), o.setEnd(n.parent, n.offset), o
                }
                viewPositionToDom(t) {
                    const e = t.parent;
                    if (e.is("$text")) {
                        const n = this.findCorrespondingDomText(e);
                        if (!n) return null;
                        let o = t.offset;
                        return qc(n) && (o += Uc), {
                            parent: n,
                            offset: o
                        }
                    } {
                        let n, o, i;
                        if (0 === t.offset) {
                            if (n = this.mapViewToDom(e), !n) return null;
                            i = n.childNodes[0]
                        } else {
                            const e = t.nodeBefore;
                            if (o = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e), !o) return null;
                            n = o.parentNode, i = o.nextSibling
                        }
                        if (xi(i) && qc(i)) return {
                            parent: i,
                            offset: Uc
                        };
                        return {
                            parent: n,
                            offset: o ? Li(o) + 1 : 0
                        }
                    }
                }
                domToView(t, e = {}) {
                    if (this.isBlockFiller(t)) return null;
                    const n = this.getHostViewElement(t);
                    if (n) return n;
                    if (Ri(t) && e.skipComments) return null;
                    if (xi(t)) {
                        if (Gc(t)) return null;
                        {
                            const e = this._processDataFromDomText(t);
                            return "" === e ? null : new Us(this.document, e)
                        }
                    } {
                        if (this.mapDomToView(t)) return this.mapDomToView(t);
                        let n;
                        if (this.isDocumentFragment(t)) n = new Ic(this.document), e.bind && this.bindDocumentFragments(t, n);
                        else {
                            n = this._createViewElement(t, e), e.bind && this.bindElements(t, n);
                            const o = t.attributes;
                            if (o)
                                for (let t = o.length, e = 0; e < t; e++) n._setAttribute(o[e].name, o[e].value);
                            if (this._isViewElementWithRawContent(n, e) || Ri(t)) {
                                const e = Ri(t) ? t.data : t.innerHTML;
                                return n._setCustomProperty("$rawContent", e), this._encounteredRawContentDomNodes.add(t), n
                            }
                        }
                        if (!1 !== e.withChildren)
                            for (const o of this.domChildrenToView(t, e)) n._appendChild(o);
                        return n
                    }
                }* domChildrenToView(t, e) {
                    for (let n = 0; n < t.childNodes.length; n++) {
                        const o = t.childNodes[n],
                            i = this.domToView(o, e);
                        null !== i && (yield i)
                    }
                }
                domSelectionToView(t) {
                    if (1 === t.rangeCount) {
                        let e = t.getRangeAt(0).startContainer;
                        xi(e) && (e = e.parentNode);
                        const n = this.fakeSelectionToView(e);
                        if (n) return n
                    }
                    const e = this.isDomSelectionBackward(t),
                        n = [];
                    for (let e = 0; e < t.rangeCount; e++) {
                        const o = t.getRangeAt(e),
                            i = this.domRangeToView(o);
                        i && n.push(i)
                    }
                    return new cc(n, {
                        backward: e
                    })
                }
                domRangeToView(t) {
                    const e = this.domPositionToView(t.startContainer, t.startOffset),
                        n = this.domPositionToView(t.endContainer, t.endOffset);
                    return e && n ? new sc(e, n) : null
                }
                domPositionToView(t, e = 0) {
                    if (this.isBlockFiller(t)) return this.domPositionToView(t.parentNode, Li(t));
                    const n = this.mapDomToView(t);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) return rc._createBefore(n);
                    if (xi(t)) {
                        if (Gc(t)) return this.domPositionToView(t.parentNode, Li(t));
                        const n = this.findCorrespondingViewText(t);
                        let o = e;
                        return n ? (qc(t) && (o -= Uc, o = o < 0 ? 0 : o), new rc(n, o)) : null
                    }
                    if (0 === e) {
                        const e = this.mapDomToView(t);
                        if (e) return new rc(e, 0)
                    } else {
                        const n = t.childNodes[e - 1];
                        if (xi(n) && Gc(n)) return this.domPositionToView(n.parentNode, Li(n));
                        const o = xi(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                        if (o && o.parent) return new rc(o.parent, o.index + 1)
                    }
                    return null
                }
                mapDomToView(t) {
                    return this.getHostViewElement(t) || this._domToViewMapping.get(t)
                }
                findCorrespondingViewText(t) {
                    if (Gc(t)) return null;
                    const e = this.getHostViewElement(t);
                    if (e) return e;
                    const n = t.previousSibling;
                    if (n) {
                        if (!this.isElement(n)) return null;
                        const t = this.mapDomToView(n);
                        if (t) {
                            const e = t.nextSibling;
                            return e instanceof Us ? e : null
                        }
                    } else {
                        const e = this.mapDomToView(t.parentNode);
                        if (e) {
                            const t = e.getChild(0);
                            return t instanceof Us ? t : null
                        }
                    }
                    return null
                }
                mapViewToDom(t) {
                    return this._viewToDomMapping.get(t)
                }
                findCorrespondingDomText(t) {
                    const e = t.previousSibling;
                    return e && this.mapViewToDom(e) ? this.mapViewToDom(e).nextSibling : !e && t.parent && this.mapViewToDom(t.parent) ? this.mapViewToDom(t.parent).childNodes[0] : null
                }
                focus(t) {
                    const e = this.mapViewToDom(t);
                    if (e && e.ownerDocument.activeElement !== e) {
                        const {
                            scrollX: t,
                            scrollY: n
                        } = vi.window, o = [];
                        ll(e, (t => {
                            const {
                                scrollLeft: e,
                                scrollTop: n
                            } = t;
                            o.push([e, n])
                        })), e.focus(), ll(e, (t => {
                            const [e, n] = o.shift();
                            t.scrollLeft = e, t.scrollTop = n
                        })), vi.window.scrollTo(t, n)
                    }
                }
                isElement(t) {
                    return t && t.nodeType == Node.ELEMENT_NODE
                }
                isDocumentFragment(t) {
                    return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
                }
                isBlockFiller(t) {
                    return "br" == this.blockFillerMode ? t.isEqualNode(ol) : !("BR" !== t.tagName || !dl(t, this.blockElements) || 1 !== t.parentNode.childNodes.length) || (t.isEqualNode(rl) || function(t, e) {
                        const n = t.isEqualNode(il);
                        return n && dl(t, e) && 1 === t.parentNode.childNodes.length
                    }(t, this.blockElements))
                }
                isDomSelectionBackward(t) {
                    if (t.isCollapsed) return !1;
                    const e = this._domDocument.createRange();
                    try {
                        e.setStart(t.anchorNode, t.anchorOffset), e.setEnd(t.focusNode, t.focusOffset)
                    } catch (t) {
                        return !1
                    }
                    const n = e.collapsed;
                    return e.detach(), n
                }
                getHostViewElement(t) {
                    const e = yi(t);
                    for (e.pop(); e.length;) {
                        const t = e.pop(),
                            n = this._domToViewMapping.get(t);
                        if (n && (n.is("uiElement") || n.is("rawElement"))) return n
                    }
                    return null
                }
                isDomSelectionCorrect(t) {
                    return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
                }
                registerRawContentMatcher(t) {
                    this._rawContentElementMatcher.add(t)
                }
                _getBlockFiller() {
                    switch (this.blockFillerMode) {
                        case "nbsp":
                            return Fc(this._domDocument);
                        case "markedNbsp":
                            return Vc(this._domDocument);
                        case "br":
                            return Hc(this._domDocument)
                    }
                }
                _isDomSelectionPositionCorrect(t, e) {
                    if (xi(t) && qc(t) && e < Uc) return !1;
                    if (this.isElement(t) && qc(t.childNodes[e])) return !1;
                    const n = this.mapDomToView(t);
                    return !n || !n.is("uiElement") && !n.is("rawElement")
                }
                _processDataFromViewText(t) {
                    let e = t.data;
                    if (t.getAncestors().some((t => this.preElements.includes(t.name)))) return e;
                    if (" " == e.charAt(0)) {
                        const n = this._getTouchingInlineViewNode(t, !1);
                        !(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n || (e = " " + e.substr(1))
                    }
                    if (" " == e.charAt(e.length - 1)) {
                        const n = this._getTouchingInlineViewNode(t, !0),
                            o = n && n.is("$textProxy") && " " == n.data.charAt(0);
                        " " != e.charAt(e.length - 2) && n && !o || (e = e.substr(0, e.length - 1) + " ")
                    }
                    return e.replace(/ {2}/g, "  ")
                }
                _nodeEndsWithSpace(t) {
                    if (t.getAncestors().some((t => this.preElements.includes(t.name)))) return !1;
                    const e = this._processDataFromViewText(t);
                    return " " == e.charAt(e.length - 1)
                }
                _processDataFromDomText(t) {
                    let e = t.data;
                    if (function(t, e) {
                            const n = yi(t);
                            return n.some((t => t.tagName && e.includes(t.tagName.toLowerCase())))
                        }(t, this.preElements)) return $c(t);
                    e = e.replace(/[ \n\t\r]{1,}/g, " ");
                    const n = this._getTouchingInlineDomNode(t, !1),
                        o = this._getTouchingInlineDomNode(t, !0),
                        i = this._checkShouldLeftTrimDomText(t, n),
                        r = this._checkShouldRightTrimDomText(t, o);
                    i && (e = e.replace(/^ /, "")), r && (e = e.replace(/ $/, "")), e = $c(new Text(e)), e = e.replace(/ \u00A0/g, "  ");
                    const s = o && this.isElement(o) && "BR" != o.tagName,
                        a = o && xi(o) && " " == o.data.charAt(0);
                    return (/( |\u00A0)\u00A0$/.test(e) || !o || s || a) && (e = e.replace(/\u00A0$/, " ")), (i || n && this.isElement(n) && "BR" != n.tagName) && (e = e.replace(/^\u00A0/, " ")), e
                }
                _checkShouldLeftTrimDomText(t, e) {
                    return !e || (this.isElement(e) ? "BR" === e.tagName : !this._encounteredRawContentDomNodes.has(t.previousSibling) && /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
                }
                _checkShouldRightTrimDomText(t, e) {
                    return !e && !qc(t)
                }
                _getTouchingInlineViewNode(t, e) {
                    const n = new ic({
                        startPosition: e ? rc._createAfter(t) : rc._createBefore(t),
                        direction: e ? "forward" : "backward"
                    });
                    for (const t of n) {
                        if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) return t.item;
                        if (t.item.is("containerElement")) return null;
                        if (t.item.is("element", "br")) return null;
                        if (t.item.is("$textProxy")) return t.item
                    }
                    return null
                }
                _getTouchingInlineDomNode(t, e) {
                    if (!t.parentNode) return null;
                    const n = e ? "firstChild" : "lastChild",
                        o = e ? "nextSibling" : "previousSibling";
                    let i = !0,
                        r = t;
                    do {
                        if (!i && r[n] ? r = r[n] : r[o] ? (r = r[o], i = !1) : (r = r.parentNode, i = !0), !r || this._isBlockElement(r)) return null
                    } while (!xi(r) && "BR" != r.tagName && !this._isInlineObjectElement(r));
                    return r
                }
                _isBlockElement(t) {
                    return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase())
                }
                _isInlineObjectElement(t) {
                    return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase())
                }
                _createViewElement(t, e) {
                    if (Ri(t)) return new vc(this.document, "$comment");
                    const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                    return new Za(this.document, n)
                }
                _isViewElementWithRawContent(t, e) {
                    return !1 !== e.withChildren && !!this._rawContentElementMatcher.match(t)
                }
                _shouldRenameElement(t) {
                    const e = t.toLowerCase();
                    return "editing" === this.renderingMode && this.unsafeElements.includes(e)
                }
                _createReplacementDomElement(t, e) {
                    const n = this._domDocument.createElement("span");
                    if (n.setAttribute(al, t), e) {
                        for (; e.firstChild;) n.appendChild(e.firstChild);
                        for (const t of e.getAttributeNames()) n.setAttribute(t, e.getAttribute(t))
                    }
                    return n
                }
            }
    
            function ll(t, e) {
                let n = t;
                for (; n;) e(n), n = n.parentElement
            }
    
            function dl(t, e) {
                const n = t.parentNode;
                return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
            }
    
            function hl(t) {
                "script" === t && C("domconverter-unsafe-script-element-detected"), "style" === t && C("domconverter-unsafe-style-element-detected")
            }
            class ul extends(wi()) {
                constructor(t) {
                    super(), this.view = t, this.document = t.document, this.isEnabled = !1
                }
                enable() {
                    this.isEnabled = !0
                }
                disable() {
                    this.isEnabled = !1
                }
                destroy() {
                    this.disable(), this.stopListening()
                }
                checkShouldIgnoreEventFromTarget(t) {
                    return t && 3 === t.nodeType && (t = t.parentNode), !(!t || 1 !== t.nodeType) && t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
                }
            }
            const gl = Ua((function(t, e) {
                He(e, Tn(e), t)
            }));
            class ml {
                constructor(t, e, n) {
                    this.view = t, this.document = t.document, this.domEvent = e, this.domTarget = e.target, gl(this, n)
                }
                get target() {
                    return this.view.domConverter.mapDomToView(this.domTarget)
                }
                preventDefault() {
                    this.domEvent.preventDefault()
                }
                stopPropagation() {
                    this.domEvent.stopPropagation()
                }
            }
            class pl extends ul {
                constructor(t) {
                    super(t), this.useCapture = !1
                }
                observe(t) {
                    ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e => {
                        this.listenTo(t, e, ((t, e) => {
                            this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target) && this.onDomEvent(e)
                        }), {
                            useCapture: this.useCapture
                        })
                    }))
                }
                fire(t, e, n) {
                    this.isEnabled && this.document.fire(t, new ml(this.view, e, n))
                }
            }
            class fl extends pl {
                constructor(t) {
                    super(t), this.domEventType = ["keydown", "keyup"]
                }
                onDomEvent(t) {
                    const e = {
                        keyCode: t.keyCode,
                        altKey: t.altKey,
                        ctrlKey: t.ctrlKey,
                        shiftKey: t.shiftKey,
                        metaKey: t.metaKey,
                        get keystroke() {
                            return or(this)
                        }
                    };
                    this.fire(t.type, t, e)
                }
            }
            const kl = function() {
                return rt.Date.now()
            };
            var bl = /\s/;
            const wl = function(t) {
                for (var e = t.length; e-- && bl.test(t.charAt(e)););
                return e
            };
            var _l = /^\s+/;
            const Al = function(t) {
                return t ? t.slice(0, wl(t) + 1).replace(_l, "") : t
            };
            var Cl = NaN,
                vl = /^[-+]0x[0-9a-f]+$/i,
                yl = /^0b[01]+$/i,
                xl = /^0o[0-7]+$/i,
                El = parseInt;
            const Dl = function(t) {
                if ("number" == typeof t) return t;
                if (Ks(t)) return Cl;
                if (F(t)) {
                    var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                    t = F(e) ? e + "" : e
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = Al(t);
                var n = yl.test(t);
                return n || xl.test(t) ? El(t.slice(2), n ? 2 : 8) : vl.test(t) ? Cl : +t
            };
            var Il = "Expected a function",
                Tl = Math.max,
                Ml = Math.min;
            const Sl = function(t, e, n) {
                var o, i, r, s, a, c, l = 0,
                    d = !1,
                    h = !1,
                    u = !0;
                if ("function" != typeof t) throw new TypeError(Il);
    
                function g(e) {
                    var n = o,
                        r = i;
                    return o = i = void 0, l = e, s = t.apply(r, n)
                }
    
                function m(t) {
                    var n = t - c;
                    return void 0 === c || n >= e || n < 0 || h && t - l >= r
                }
    
                function p() {
                    var t = kl();
                    if (m(t)) return f(t);
                    a = setTimeout(p, function(t) {
                        var n = e - (t - c);
                        return h ? Ml(n, r - (t - l)) : n
                    }(t))
                }
    
                function f(t) {
                    return a = void 0, u && o ? g(t) : (o = i = void 0, s)
                }
    
                function k() {
                    var t = kl(),
                        n = m(t);
                    if (o = arguments, i = this, c = t, n) {
                        if (void 0 === a) return function(t) {
                            return l = t, a = setTimeout(p, e), d ? g(t) : s
                        }(c);
                        if (h) return clearTimeout(a), a = setTimeout(p, e), g(c)
                    }
                    return void 0 === a && (a = setTimeout(p, e)), s
                }
                return e = Dl(e) || 0, F(n) && (d = !!n.leading, r = (h = "maxWait" in n) ? Tl(Dl(n.maxWait) || 0, e) : r, u = "trailing" in n ? !!n.trailing : u), k.cancel = function() {
                    void 0 !== a && clearTimeout(a), l = 0, o = c = i = a = void 0
                }, k.flush = function() {
                    return void 0 === a ? s : f(kl())
                }, k
            };
            class Nl extends ul {
                constructor(t) {
                    super(t), this._fireSelectionChangeDoneDebounced = Sl((t => {
                        this.document.fire("selectionChangeDone", t)
                    }), 200)
                }
                observe() {
                    const t = this.document;
                    t.on("arrowKey", ((e, n) => {
                        t.selection.isFake && this.isEnabled && n.preventDefault()
                    }), {
                        context: "$capture"
                    }), t.on("arrowKey", ((e, n) => {
                        t.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode)
                    }), {
                        priority: "lowest"
                    })
                }
                destroy() {
                    super.destroy(), this._fireSelectionChangeDoneDebounced.cancel()
                }
                _handleSelectionMove(t) {
                    const e = this.document.selection,
                        n = new cc(e.getRanges(), {
                            backward: e.isBackward,
                            fake: !1
                        });
                    t != er.arrowleft && t != er.arrowup || n.setTo(n.getFirstPosition()), t != er.arrowright && t != er.arrowdown || n.setTo(n.getLastPosition());
                    const o = {
                        oldSelection: e,
                        newSelection: n,
                        domSelection: null
                    };
                    this.document.fire("selectionChange", o), this._fireSelectionChangeDoneDebounced(o)
                }
            }
            var Bl = "__lodash_hash_undefined__";
            const Pl = function(t) {
                return this.__data__.set(t, Bl), this
            };
            const zl = function(t) {
                return this.__data__.has(t)
            };
    
            function Ll(t) {
                var e = -1,
                    n = null == t ? 0 : t.length;
                for (this.__data__ = new Ne; ++e < n;) this.add(t[e])
            }
            Ll.prototype.add = Ll.prototype.push = Pl, Ll.prototype.has = zl;
            const Ol = Ll;
            const Rl = function(t, e) {
                for (var n = -1, o = null == t ? 0 : t.length; ++n < o;)
                    if (e(t[n], n, t)) return !0;
                return !1
            };
            const jl = function(t, e) {
                return t.has(e)
            };
            var Fl = 1,
                Vl = 2;
            const Hl = function(t, e, n, o, i, r) {
                var s = n & Fl,
                    a = t.length,
                    c = e.length;
                if (a != c && !(s && c > a)) return !1;
                var l = r.get(t),
                    d = r.get(e);
                if (l && d) return l == e && d == t;
                var h = -1,
                    u = !0,
                    g = n & Vl ? new Ol : void 0;
                for (r.set(t, e), r.set(e, t); ++h < a;) {
                    var m = t[h],
                        p = e[h];
                    if (o) var f = s ? o(p, m, h, e, t, r) : o(m, p, h, t, e, r);
                    if (void 0 !== f) {
                        if (f) continue;
                        u = !1;
                        break
                    }
                    if (g) {
                        if (!Rl(e, (function(t, e) {
                                if (!jl(g, e) && (m === t || i(m, t, n, o, r))) return g.push(e)
                            }))) {
                            u = !1;
                            break
                        }
                    } else if (m !== p && !i(m, p, n, o, r)) {
                        u = !1;
                        break
                    }
                }
                return r.delete(t), r.delete(e), u
            };
            const Ul = function(t) {
                var e = -1,
                    n = Array(t.size);
                return t.forEach((function(t, o) {
                    n[++e] = [o, t]
                })), n
            };
            const Wl = function(t) {
                var e = -1,
                    n = Array(t.size);
                return t.forEach((function(t) {
                    n[++e] = t
                })), n
            };
            var ql = 1,
                Gl = 2,
                $l = "[object Boolean]",
                Yl = "[object Date]",
                Kl = "[object Error]",
                Ql = "[object Map]",
                Zl = "[object Number]",
                Jl = "[object RegExp]",
                Xl = "[object Set]",
                td = "[object String]",
                ed = "[object Symbol]",
                nd = "[object ArrayBuffer]",
                od = "[object DataView]",
                id = st ? st.prototype : void 0,
                rd = id ? id.valueOf : void 0;
            const sd = function(t, e, n, o, i, r, s) {
                switch (n) {
                    case od:
                        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                        t = t.buffer, e = e.buffer;
                    case nd:
                        return !(t.byteLength != e.byteLength || !r(new mo(t), new mo(e)));
                    case $l:
                    case Yl:
                    case Zl:
                        return Bt(+t, +e);
                    case Kl:
                        return t.name == e.name && t.message == e.message;
                    case Jl:
                    case td:
                        return t == e + "";
                    case Ql:
                        var a = Ul;
                    case Xl:
                        var c = o & ql;
                        if (a || (a = Wl), t.size != e.size && !c) return !1;
                        var l = s.get(t);
                        if (l) return l == e;
                        o |= Gl, s.set(t, e);
                        var d = Hl(a(t), a(e), o, i, r, s);
                        return s.delete(t), d;
                    case ed:
                        if (rd) return rd.call(t) == rd.call(e)
                }
                return !1
            };
            var ad = 1,
                cd = Object.prototype.hasOwnProperty;
            const ld = function(t, e, n, o, i, r) {
                var s = n & ad,
                    a = $n(t),
                    c = a.length;
                if (c != $n(e).length && !s) return !1;
                for (var l = c; l--;) {
                    var d = a[l];
                    if (!(s ? d in e : cd.call(e, d))) return !1
                }
                var h = r.get(t),
                    u = r.get(e);
                if (h && u) return h == e && u == t;
                var g = !0;
                r.set(t, e), r.set(e, t);
                for (var m = s; ++l < c;) {
                    var p = t[d = a[l]],
                        f = e[d];
                    if (o) var k = s ? o(f, p, d, e, t, r) : o(p, f, d, t, e, r);
                    if (!(void 0 === k ? p === f || i(p, f, n, o, r) : k)) {
                        g = !1;
                        break
                    }
                    m || (m = "constructor" == d)
                }
                if (g && !m) {
                    var b = t.constructor,
                        w = e.constructor;
                    b == w || !("constructor" in t) || !("constructor" in e) || "function" == typeof b && b instanceof b && "function" == typeof w && w instanceof w || (g = !1)
                }
                return r.delete(t), r.delete(e), g
            };
            var dd = 1,
                hd = "[object Arguments]",
                ud = "[object Array]",
                gd = "[object Object]",
                md = Object.prototype.hasOwnProperty;
            const pd = function(t, e, n, o, i, r) {
                var s = bt(t),
                    a = bt(e),
                    c = s ? ud : ho(t),
                    l = a ? ud : ho(e),
                    d = (c = c == hd ? gd : c) == gd,
                    h = (l = l == hd ? gd : l) == gd,
                    u = c == l;
                if (u && tn(t)) {
                    if (!tn(e)) return !1;
                    s = !0, d = !1
                }
                if (u && !d) return r || (r = new Le), s || pn(t) ? Hl(t, e, n, o, i, r) : sd(t, e, c, n, o, i, r);
                if (!(n & dd)) {
                    var g = d && md.call(t, "__wrapped__"),
                        m = h && md.call(e, "__wrapped__");
                    if (g || m) {
                        var p = g ? t.value() : t,
                            f = m ? e.value() : e;
                        return r || (r = new Le), i(p, f, n, o, r)
                    }
                }
                return !!u && (r || (r = new Le), ld(t, e, n, o, i, r))
            };
            const fd = function t(e, n, o, i, r) {
                return e === n || (null == e || null == n || !wt(e) && !wt(n) ? e != e && n != n : pd(e, n, o, i, t, r))
            };
            const kd = function(t, e, n) {
                var o = (n = "function" == typeof n ? n : void 0) ? n(t, e) : void 0;
                return void 0 === o ? fd(t, e, void 0, n) : !!o
            };
            class bd extends ul {
                constructor(t) {
                    super(t), this._config = {
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    }, this.domConverter = t.domConverter, this.renderer = t._renderer, this._domElements = [], this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
                }
                flush() {
                    this._onMutations(this._mutationObserver.takeRecords())
                }
                observe(t) {
                    this._domElements.push(t), this.isEnabled && this._mutationObserver.observe(t, this._config)
                }
                enable() {
                    super.enable();
                    for (const t of this._domElements) this._mutationObserver.observe(t, this._config)
                }
                disable() {
                    super.disable(), this._mutationObserver.disconnect()
                }
                destroy() {
                    super.destroy(), this._mutationObserver.disconnect()
                }
                _onMutations(t) {
                    if (0 === t.length) return;
                    const e = this.domConverter,
                        n = new Set,
                        o = new Set;
                    for (const n of t) {
                        const t = e.mapDomToView(n.target);
                        t && (t.is("uiElement") || t.is("rawElement") || "childList" !== n.type || this._isBogusBrMutation(n) || o.add(t))
                    }
                    for (const i of t) {
                        const t = e.mapDomToView(i.target);
                        if ((!t || !t.is("uiElement") && !t.is("rawElement")) && "characterData" === i.type) {
                            const t = e.findCorrespondingViewText(i.target);
                            t && !o.has(t.parent) ? n.add(t) : !t && qc(i.target) && o.add(e.mapDomToView(i.target.parentNode))
                        }
                    }
                    let i = !1;
                    for (const t of n) i = !0, this.renderer.markToSync("text", t);
                    for (const t of o) {
                        const n = e.mapViewToDom(t),
                            o = Array.from(t.getChildren()),
                            r = Array.from(e.domChildrenToView(n, {
                                withChildren: !1
                            }));
                        kd(o, r, wd) || (i = !0, this.renderer.markToSync("children", t))
                    }
                    i && this.view.forceRender()
                }
                _isBogusBrMutation(t) {
                    let e = null;
                    return null === t.nextSibling && 0 === t.removedNodes.length && 1 == t.addedNodes.length && (e = this.domConverter.domToView(t.addedNodes[0], {
                        withChildren: !1
                    })), e && e.is("element", "br")
                }
            }
    
            function wd(t, e) {
                if (!Array.isArray(t)) return t === e || !(!t.is("$text") || !e.is("$text")) && t.data === e.data
            }
            class _d extends pl {
                constructor(t) {
                    super(t), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
                    const e = this.document;
                    e.on("focus", (() => {
                        this._isFocusChanging = !0, this._renderTimeoutId = setTimeout((() => {
                            this.flush(), t.change((() => {}))
                        }), 50)
                    })), e.on("blur", ((n, o) => {
                        const i = e.selection.editableElement;
                        null !== i && i !== o.target || (e.isFocused = !1, this._isFocusChanging = !1, t.change((() => {})))
                    }))
                }
                flush() {
                    this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0)
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
                destroy() {
                    this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy()
                }
            }
            class Ad extends ul {
                constructor(t) {
                    super(t), this.mutationObserver = t.getObserver(bd), this.focusObserver = t.getObserver(_d), this.selection = this.document.selection, this.domConverter = t.domConverter, this._documents = new WeakSet, this._fireSelectionChangeDoneDebounced = Sl((t => {
                        this.document.fire("selectionChangeDone", t)
                    }), 200), this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Sl((() => this.document.isSelecting = !1), 5e3), this._loopbackCounter = 0
                }
                observe(t) {
                    const e = t.ownerDocument,
                        n = () => {
                            this.document.isSelecting && (this._handleSelectionChange(null, e), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel())
                        };
                    this.listenTo(t, "selectstart", (() => {
                        this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced()
                    }), {
                        priority: "highest"
                    }), this.listenTo(t, "keydown", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this.listenTo(t, "keyup", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this._documents.has(e) || (this.listenTo(e, "mouseup", n, {
                        priority: "highest",
                        useCapture: !0
                    }), this.listenTo(e, "selectionchange", ((t, n) => {
                        this.document.isComposing && !a.isAndroid || (this._handleSelectionChange(n, e), this._documentIsSelectingInactivityTimeoutDebounced())
                    })), this._documents.add(e))
                }
                destroy() {
                    super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel()
                }
                _handleSelectionChange(t, e) {
                    if (!this.isEnabled) return;
                    const n = e.defaultView.getSelection();
                    if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
                    this.mutationObserver.flush();
                    const o = this.domConverter.domSelectionToView(n);
                    if (0 != o.rangeCount) {
                        if (this.view.hasDomSelection = !0, !(this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n) || ++this._loopbackCounter > 60))
                            if (this.focusObserver.flush(), this.selection.isSimilar(o)) this.view.forceRender();
                            else {
                                const t = {
                                    oldSelection: this.selection,
                                    newSelection: o,
                                    domSelection: n
                                };
                                this.document.fire("selectionChange", t), this._fireSelectionChangeDoneDebounced(t)
                            }
                    } else this.view.hasDomSelection = !1
                }
                _clearInfiniteLoop() {
                    this._loopbackCounter = 0
                }
            }
            class Cd extends pl {
                constructor(t) {
                    super(t), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                    const e = this.document;
                    e.on("compositionstart", (() => {
                        e.isComposing = !0
                    }), {
                        priority: "low"
                    }), e.on("compositionend", (() => {
                        e.isComposing = !1
                    }), {
                        priority: "low"
                    })
                }
                onDomEvent(t) {
                    this.fire(t.type, t, {
                        data: t.data
                    })
                }
            }
            class vd {
                constructor(t, e = {}) {
                    this._files = e.cacheFiles ? yd(t) : null, this._native = t
                }
                get files() {
                    return this._files || (this._files = yd(this._native)), this._files
                }
                get types() {
                    return this._native.types
                }
                getData(t) {
                    return this._native.getData(t)
                }
                setData(t, e) {
                    this._native.setData(t, e)
                }
                set effectAllowed(t) {
                    this._native.effectAllowed = t
                }
                get effectAllowed() {
                    return this._native.effectAllowed
                }
                set dropEffect(t) {
                    this._native.dropEffect = t
                }
                get dropEffect() {
                    return this._native.dropEffect
                }
                get isCanceled() {
                    return "none" == this._native.dropEffect || !!this._native.mozUserCancelled
                }
            }
    
            function yd(t) {
                const e = Array.from(t.files || []),
                    n = Array.from(t.items || []);
                return e.length ? e : n.filter((t => "file" === t.kind)).map((t => t.getAsFile()))
            }
            class xd extends pl {
                constructor(t) {
                    super(t), this.domEventType = ["beforeinput"]
                }
                onDomEvent(t) {
                    const e = t.getTargetRanges(),
                        n = this.view,
                        o = n.document;
                    let i = null,
                        r = null,
                        s = [];
                    if (t.dataTransfer && (i = new vd(t.dataTransfer)), null !== t.data ? r = t.data : i && (r = i.getData("text/plain")), o.selection.isFake) s = Array.from(o.selection.getRanges());
                    else if (e.length) s = e.map((t => n.domConverter.domRangeToView(t)));
                    else if (a.isAndroid) {
                        const e = t.target.ownerDocument.defaultView.getSelection();
                        s = Array.from(n.domConverter.domSelectionToView(e).getRanges())
                    }
                    if (a.isAndroid && "insertCompositionText" == t.inputType && r && r.endsWith("\n")) this.fire(t.type, t, {
                        inputType: "insertParagraph",
                        targetRanges: [n.createRange(s[0].end)]
                    });
                    else if ("insertText" == t.inputType && r && r.includes("\n")) {
                        const e = r.split(/\n{1,2}/g);
                        let n = s;
                        for (let r = 0; r < e.length; r++) {
                            const s = e[r];
                            "" != s && (this.fire(t.type, t, {
                                data: s,
                                dataTransfer: i,
                                targetRanges: n,
                                inputType: t.inputType,
                                isComposing: t.isComposing
                            }), n = [o.selection.getFirstRange()]), r + 1 < e.length && (this.fire(t.type, t, {
                                inputType: "insertParagraph",
                                targetRanges: n
                            }), n = [o.selection.getFirstRange()])
                        }
                    } else this.fire(t.type, t, {
                        data: r,
                        dataTransfer: i,
                        targetRanges: s,
                        inputType: t.inputType,
                        isComposing: t.isComposing
                    })
                }
            }
            class Ed extends ul {
                constructor(t) {
                    super(t), this.document.on("keydown", ((t, e) => {
                        if (this.isEnabled && ((n = e.keyCode) == er.arrowright || n == er.arrowleft || n == er.arrowup || n == er.arrowdown)) {
                            const n = new dc(this.document, "arrowKey", this.document.selection.getFirstRange());
                            this.document.fire(n, e), n.stop.called && t.stop()
                        }
                        var n
                    }))
                }
                observe() {}
            }
            class Dd extends ul {
                constructor(t) {
                    super(t);
                    const e = this.document;
                    e.on("keydown", ((t, n) => {
                        if (!this.isEnabled || n.keyCode != er.tab || n.ctrlKey) return;
                        const o = new dc(e, "tab", e.selection.getFirstRange());
                        e.fire(o, n), o.stop.called && t.stop()
                    }))
                }
                observe() {}
            }
            class Id extends($()) {
                constructor(t) {
                    super(), this.document = new kc(t), this.domConverter = new cl(this.document), this.domRoots = new Map, this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new Zc(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._initialDomRootAttributes = new WeakMap, this._observers = new Map, this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this._writer = new Tc(this.document), this.addObserver(bd), this.addObserver(_d), this.addObserver(Ad), this.addObserver(fl), this.addObserver(Nl), this.addObserver(Cd), this.addObserver(Ed), this.addObserver(xd), this.addObserver(Dd), this.document.on("arrowKey", Yc, {
                        priority: "low"
                    }), yc(this), this.on("render", (() => {
                        this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1
                    })), this.listenTo(this.document.selection, "change", (() => {
                        this._hasChangedSinceTheLastRendering = !0
                    })), this.listenTo(this.document, "change:isFocused", (() => {
                        this._hasChangedSinceTheLastRendering = !0
                    }))
                }
                attachDomRoot(t, e = "main") {
                    const n = this.document.getRoot(e);
                    n._name = t.tagName.toLowerCase();
                    const o = {};
                    for (const {
                            name: e,
                            value: i
                        }
                        of Array.from(t.attributes)) o[e] = i, "class" === e ? this._writer.addClass(i.split(" "), n) : this._writer.setAttribute(e, i, n);
                    this._initialDomRootAttributes.set(t, o);
                    const i = () => {
                        this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n)
                    };
                    i(), this.domRoots.set(e, t), this.domConverter.bindElements(t, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(t.ownerDocument), n.on("change:children", ((t, e) => this._renderer.markToSync("children", e))), n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e))), n.on("change:text", ((t, e) => this._renderer.markToSync("text", e))), n.on("change:isReadOnly", (() => this.change(i))), n.on("change", (() => {
                        this._hasChangedSinceTheLastRendering = !0
                    }));
                    for (const n of this._observers.values()) n.observe(t, e)
                }
                detachDomRoot(t) {
                    const e = this.domRoots.get(t);
                    Array.from(e.attributes).forEach((({
                        name: t
                    }) => e.removeAttribute(t)));
                    const n = this._initialDomRootAttributes.get(e);
                    for (const t in n) e.setAttribute(t, n[t]);
                    this.domRoots.delete(t), this.domConverter.unbindDomElement(e)
                }
                getDomRoot(t = "main") {
                    return this.domRoots.get(t)
                }
                addObserver(t) {
                    let e = this._observers.get(t);
                    if (e) return e;
                    e = new t(this), this._observers.set(t, e);
                    for (const [t, n] of this.domRoots) e.observe(n, t);
                    return e.enable(), e
                }
                getObserver(t) {
                    return this._observers.get(t)
                }
                disableObservers() {
                    for (const t of this._observers.values()) t.disable()
                }
                enableObservers() {
                    for (const t of this._observers.values()) t.enable()
                }
                scrollToTheSelection() {
                    const t = this.document.selection.getFirstRange();
                    t && function({
                        target: t,
                        viewportOffset: e = 0
                    }) {
                        const n = Qi(t);
                        let o = n,
                            i = null;
                        for (; o;) {
                            let r;
                            r = Zi(o == n ? t : i), qi(r, (() => Ji(t, o)));
                            const s = Ji(t, o);
                            if (Wi(o, s, e), o.parent != o) {
                                if (i = o.frameElement, o = o.parent, !i) return
                            } else o = null
                        }
                    }({
                        target: this.domConverter.viewRangeToDom(t),
                        viewportOffset: 20
                    })
                }
                focus() {
                    if (!this.document.isFocused) {
                        const t = this.document.selection.editableElement;
                        t && (this.domConverter.focus(t), this.forceRender())
                    }
                }
                change(t) {
                    if (this.isRenderingInProgress || this._postFixersInProgress) throw new A("cannot-change-view-tree", this);
                    try {
                        if (this._ongoingChange) return t(this._writer);
                        this._ongoingChange = !0;
                        const e = t(this._writer);
                        return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), e
                    } catch (t) {
                        A.rethrowUnexpectedError(t, this)
                    }
                }
                forceRender() {
                    this._hasChangedSinceTheLastRendering = !0, this.getObserver(_d).flush(), this.change((() => {}))
                }
                destroy() {
                    for (const t of this._observers.values()) t.destroy();
                    this.document.destroy(), this.stopListening()
                }
                createPositionAt(t, e) {
                    return rc._createAt(t, e)
                }
                createPositionAfter(t) {
                    return rc._createAfter(t)
                }
                createPositionBefore(t) {
                    return rc._createBefore(t)
                }
                createRange(...t) {
                    return new sc(...t)
                }
                createRangeOn(t) {
                    return sc._createOn(t)
                }
                createRangeIn(t) {
                    return sc._createIn(t)
                }
                createSelection(...t) {
                    return new cc(...t)
                }
                _disableRendering(t) {
                    this._renderingDisabled = t, 0 == t && this.change((() => {}))
                }
                _render() {
                    this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1
                }
            }
            class Td {
                is() {
                    throw new Error("is() method is abstract")
                }
            }
            class Md extends Td {
                constructor(t) {
                    super(), this.parent = null, this._attrs = fr(t)
                }
                get document() {
                    return null
                }
                get index() {
                    let t;
                    if (!this.parent) return null;
                    if (null === (t = this.parent.getChildIndex(this))) throw new A("model-node-not-found-in-parent", this);
                    return t
                }
                get startOffset() {
                    let t;
                    if (!this.parent) return null;
                    if (null === (t = this.parent.getChildStartOffset(this))) throw new A("model-node-not-found-in-parent", this);
                    return t
                }
                get offsetSize() {
                    return 1
                }
                get endOffset() {
                    return this.parent ? this.startOffset + this.offsetSize : null
                }
                get nextSibling() {
                    const t = this.index;
                    return null !== t && this.parent.getChild(t + 1) || null
                }
                get previousSibling() {
                    const t = this.index;
                    return null !== t && this.parent.getChild(t - 1) || null
                }
                get root() {
                    let t = this;
                    for (; t.parent;) t = t.parent;
                    return t
                }
                isAttached() {
                    return this.root.is("rootElement")
                }
                getPath() {
                    const t = [];
                    let e = this;
                    for (; e.parent;) t.unshift(e.startOffset), e = e.parent;
                    return t
                }
                getAncestors(t = {}) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return e
                }
                getCommonAncestor(t, e = {}) {
                    const n = this.getAncestors(e),
                        o = t.getAncestors(e);
                    let i = 0;
                    for (; n[i] == o[i] && n[i];) i++;
                    return 0 === i ? null : n[i - 1]
                }
                isBefore(t) {
                    if (this == t) return !1;
                    if (this.root !== t.root) return !1;
                    const e = this.getPath(),
                        n = t.getPath(),
                        o = et(e, n);
                    switch (o) {
                        case "prefix":
                            return !0;
                        case "extension":
                            return !1;
                        default:
                            return e[o] < n[o]
                    }
                }
                isAfter(t) {
                    return this != t && (this.root === t.root && !this.isBefore(t))
                }
                hasAttribute(t) {
                    return this._attrs.has(t)
                }
                getAttribute(t) {
                    return this._attrs.get(t)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                toJSON() {
                    const t = {};
                    return this._attrs.size && (t.attributes = Array.from(this._attrs).reduce(((t, e) => (t[e[0]] = e[1], t)), {})), t
                }
                _clone(t) {
                    return new this.constructor(this._attrs)
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _setAttribute(t, e) {
                    this._attrs.set(t, e)
                }
                _setAttributesTo(t) {
                    this._attrs = fr(t)
                }
                _removeAttribute(t) {
                    return this._attrs.delete(t)
                }
                _clearAttributes() {
                    this._attrs.clear()
                }
            }
            Md.prototype.is = function(t) {
                return "node" === t || "model:node" === t
            };
            class Sd {
                constructor(t) {
                    this._nodes = [], t && this._insertNodes(0, t)
                } [Symbol.iterator]() {
                    return this._nodes[Symbol.iterator]()
                }
                get length() {
                    return this._nodes.length
                }
                get maxOffset() {
                    return this._nodes.reduce(((t, e) => t + e.offsetSize), 0)
                }
                getNode(t) {
                    return this._nodes[t] || null
                }
                getNodeIndex(t) {
                    const e = this._nodes.indexOf(t);
                    return -1 == e ? null : e
                }
                getNodeStartOffset(t) {
                    const e = this.getNodeIndex(t);
                    return null === e ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0)
                }
                indexToOffset(t) {
                    if (t == this._nodes.length) return this.maxOffset;
                    const e = this._nodes[t];
                    if (!e) throw new A("model-nodelist-index-out-of-bounds", this);
                    return this.getNodeStartOffset(e)
                }
                offsetToIndex(t) {
                    let e = 0;
                    for (const n of this._nodes) {
                        if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
                        e += n.offsetSize
                    }
                    if (e != t) throw new A("model-nodelist-offset-out-of-bounds", this, {
                        offset: t,
                        nodeList: this
                    });
                    return this.length
                }
                _insertNodes(t, e) {
                    for (const t of e)
                        if (!(t instanceof Md)) throw new A("model-nodelist-insertnodes-not-node", this);
                    this._nodes = function(t, e, n, o) {
                        if (Math.max(e.length, t.length) > kr) return t.slice(0, n).concat(e).concat(t.slice(n + o, t.length));
                        {
                            const i = Array.from(t);
                            return i.splice(n, o, ...e), i
                        }
                    }(this._nodes, Array.from(e), t, 0)
                }
                _removeNodes(t, e = 1) {
                    return this._nodes.splice(t, e)
                }
                toJSON() {
                    return this._nodes.map((t => t.toJSON()))
                }
            }
            class Nd extends Md {
                constructor(t, e) {
                    super(e), this._data = t || ""
                }
                get offsetSize() {
                    return this.data.length
                }
                get data() {
                    return this._data
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.data = this.data, t
                }
                _clone() {
                    return new Nd(this.data, this.getAttributes())
                }
                static fromJSON(t) {
                    return new Nd(t.data, t.attributes)
                }
            }
            Nd.prototype.is = function(t) {
                return "$text" === t || "model:$text" === t || "text" === t || "model:text" === t || "node" === t || "model:node" === t
            };
            class Bd extends Td {
                constructor(t, e, n) {
                    if (super(), this.textNode = t, e < 0 || e > t.offsetSize) throw new A("model-textproxy-wrong-offsetintext", this);
                    if (n < 0 || e + n > t.offsetSize) throw new A("model-textproxy-wrong-length", this);
                    this.data = t.data.substring(e, e + n), this.offsetInText = e
                }
                get startOffset() {
                    return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null
                }
                get offsetSize() {
                    return this.data.length
                }
                get endOffset() {
                    return null !== this.startOffset ? this.startOffset + this.offsetSize : null
                }
                get isPartial() {
                    return this.offsetSize !== this.textNode.offsetSize
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                getPath() {
                    const t = this.textNode.getPath();
                    return t.length > 0 && (t[t.length - 1] += this.offsetInText), t
                }
                getAncestors(t = {}) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    for (; n;) e[t.parentFirst ? "push" : "unshift"](n), n = n.parent;
                    return e
                }
                hasAttribute(t) {
                    return this.textNode.hasAttribute(t)
                }
                getAttribute(t) {
                    return this.textNode.getAttribute(t)
                }
                getAttributes() {
                    return this.textNode.getAttributes()
                }
                getAttributeKeys() {
                    return this.textNode.getAttributeKeys()
                }
            }
            Bd.prototype.is = function(t) {
                return "$textProxy" === t || "model:$textProxy" === t || "textProxy" === t || "model:textProxy" === t
            };
            class Pd extends Md {
                constructor(t, e, n) {
                    super(e), this._children = new Sd, this.name = t, n && this._insertChild(0, n)
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return 0 === this.childCount
                }
                getChild(t) {
                    return this._children.getNode(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(t) {
                    return this._children.getNodeIndex(t)
                }
                getChildStartOffset(t) {
                    return this._children.getNodeStartOffset(t)
                }
                offsetToIndex(t) {
                    return this._children.offsetToIndex(t)
                }
                getNodeByPath(t) {
                    let e = this;
                    for (const n of t) e = e.getChild(e.offsetToIndex(n));
                    return e
                }
                findAncestor(t, e = {}) {
                    let n = e.includeSelf ? this : this.parent;
                    for (; n;) {
                        if (n.name === t) return n;
                        n = n.parent
                    }
                    return null
                }
                toJSON() {
                    const t = super.toJSON();
                    if (t.name = this.name, this._children.length > 0) {
                        t.children = [];
                        for (const e of this._children) t.children.push(e.toJSON())
                    }
                    return t
                }
                _clone(t = !1) {
                    const e = t ? Array.from(this._children).map((t => t._clone(!0))) : void 0;
                    return new Pd(this.name, this.getAttributes(), e)
                }
                _appendChild(t) {
                    this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    const n = function(t) {
                        if ("string" == typeof t) return [new Nd(t)];
                        nt(t) || (t = [t]);
                        return Array.from(t).map((t => "string" == typeof t ? new Nd(t) : t instanceof Bd ? new Nd(t.data, t.getAttributes()) : t))
                    }(e);
                    for (const t of n) null !== t.parent && t._remove(), t.parent = this;
                    this._children._insertNodes(t, n)
                }
                _removeChildren(t, e = 1) {
                    const n = this._children._removeNodes(t, e);
                    for (const t of n) t.parent = null;
                    return n
                }
                static fromJSON(t) {
                    let e;
                    if (t.children) {
                        e = [];
                        for (const n of t.children) n.name ? e.push(Pd.fromJSON(n)) : e.push(Nd.fromJSON(n))
                    }
                    return new Pd(t.name, t.attributes, e)
                }
            }
            Pd.prototype.is = function(t, e) {
                return e ? e === this.name && ("element" === t || "model:element" === t) : "element" === t || "model:element" === t || "node" === t || "model:node" === t
            };
            class zd {
                constructor(t) {
                    if (!t || !t.boundaries && !t.startPosition) throw new A("model-tree-walker-no-start-position", null);
                    const e = t.direction || "forward";
                    if ("forward" != e && "backward" != e) throw new A("model-tree-walker-unknown-direction", t, {
                        direction: e
                    });
                    this.direction = e, this.boundaries = t.boundaries || null, t.startPosition ? this.position = t.startPosition.clone() : this.position = Od._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t.singleCharacters, this.shallow = !!t.shallow, this.ignoreElementEnd = !!t.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent
                } [Symbol.iterator]() {
                    return this
                }
                skip(t) {
                    let e, n, o, i;
                    do {
                        o = this.position, i = this._visitedParent, ({
                            done: e,
                            value: n
                        } = this.next())
                    } while (!e && t(n));
                    e || (this.position = o, this._visitedParent = i)
                }
                next() {
                    return "forward" == this.direction ? this._next() : this._previous()
                }
                _next() {
                    const t = this.position,
                        e = this.position.clone(),
                        n = this._visitedParent;
                    if (null === n.parent && e.offset === n.maxOffset) return {
                        done: !0,
                        value: void 0
                    };
                    if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return {
                        done: !0,
                        value: void 0
                    };
                    const o = Rd(e, n),
                        i = o || jd(e, n, o);
                    if (i instanceof Pd) return this.shallow ? e.offset++ : (e.path.push(0), this._visitedParent = i), this.position = e, Ld("elementStart", i, t, e, 1);
                    if (i instanceof Nd) {
                        let o;
                        if (this.singleCharacters) o = 1;
                        else {
                            let t = i.endOffset;
                            this._boundaryEndParent == n && this.boundaries.end.offset < t && (t = this.boundaries.end.offset), o = t - e.offset
                        }
                        const r = e.offset - i.startOffset,
                            s = new Bd(i, r, o);
                        return e.offset += o, this.position = e, Ld("text", s, t, e, o)
                    }
                    return e.path.pop(), e.offset++, this.position = e, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : Ld("elementEnd", n, t, e)
                }
                _previous() {
                    const t = this.position,
                        e = this.position.clone(),
                        n = this._visitedParent;
                    if (null === n.parent && 0 === e.offset) return {
                        done: !0,
                        value: void 0
                    };
                    if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return {
                        done: !0,
                        value: void 0
                    };
                    const o = e.parent,
                        i = Rd(e, o),
                        r = i || Fd(e, o, i);
                    if (r instanceof Pd) return e.offset--, this.shallow ? (this.position = e, Ld("elementStart", r, t, e, 1)) : (e.path.push(r.maxOffset), this.position = e, this._visitedParent = r, this.ignoreElementEnd ? this._previous() : Ld("elementEnd", r, t, e));
                    if (r instanceof Nd) {
                        let o;
                        if (this.singleCharacters) o = 1;
                        else {
                            let t = r.startOffset;
                            this._boundaryStartParent == n && this.boundaries.start.offset > t && (t = this.boundaries.start.offset), o = e.offset - t
                        }
                        const i = e.offset - r.startOffset,
                            s = new Bd(r, i - o, o);
                        return e.offset -= o, this.position = e, Ld("text", s, t, e, o)
                    }
                    return e.path.pop(), this.position = e, this._visitedParent = n.parent, Ld("elementStart", n, t, e, 1)
                }
            }
    
            function Ld(t, e, n, o, i) {
                return {
                    done: !1,
                    value: {
                        type: t,
                        item: e,
                        previousPosition: n,
                        nextPosition: o,
                        length: i
                    }
                }
            }
            class Od extends Td {
                constructor(t, e, n = "toNone") {
                    if (super(), !t.is("element") && !t.is("documentFragment")) throw new A("model-position-root-invalid", t);
                    if (!(e instanceof Array) || 0 === e.length) throw new A("model-position-path-incorrect-format", t, {
                        path: e
                    });
                    t.is("rootElement") ? e = e.slice() : (e = [...t.getPath(), ...e], t = t.root), this.root = t, this.path = e, this.stickiness = n
                }
                get offset() {
                    return this.path[this.path.length - 1]
                }
                set offset(t) {
                    this.path[this.path.length - 1] = t
                }
                get parent() {
                    let t = this.root;
                    for (let e = 0; e < this.path.length - 1; e++)
                        if (t = t.getChild(t.offsetToIndex(this.path[e])), !t) throw new A("model-position-path-incorrect", this, {
                            position: this
                        });
                    if (t.is("$text")) throw new A("model-position-path-incorrect", this, {
                        position: this
                    });
                    return t
                }
                get index() {
                    return this.parent.offsetToIndex(this.offset)
                }
                get textNode() {
                    return Rd(this, this.parent)
                }
                get nodeAfter() {
                    const t = this.parent;
                    return jd(this, t, Rd(this, t))
                }
                get nodeBefore() {
                    const t = this.parent;
                    return Fd(this, t, Rd(this, t))
                }
                get isAtStart() {
                    return 0 === this.offset
                }
                get isAtEnd() {
                    return this.offset == this.parent.maxOffset
                }
                compareWith(t) {
                    if (this.root != t.root) return "different";
                    const e = et(this.path, t.path);
                    switch (e) {
                        case "same":
                            return "same";
                        case "prefix":
                            return "before";
                        case "extension":
                            return "after";
                        default:
                            return this.path[e] < t.path[e] ? "before" : "after"
                    }
                }
                getLastMatchingPosition(t, e = {}) {
                    e.startPosition = this;
                    const n = new zd(e);
                    return n.skip(t), n.position
                }
                getParentPath() {
                    return this.path.slice(0, -1)
                }
                getAncestors() {
                    const t = this.parent;
                    return t.is("documentFragment") ? [t] : t.getAncestors({
                        includeSelf: !0
                    })
                }
                findAncestor(t) {
                    const e = this.parent;
                    return e.is("element") ? e.findAncestor(t, {
                        includeSelf: !0
                    }) : null
                }
                getCommonPath(t) {
                    if (this.root != t.root) return [];
                    const e = et(this.path, t.path),
                        n = "string" == typeof e ? Math.min(this.path.length, t.path.length) : e;
                    return this.path.slice(0, n)
                }
                getCommonAncestor(t) {
                    const e = this.getAncestors(),
                        n = t.getAncestors();
                    let o = 0;
                    for (; e[o] == n[o] && e[o];) o++;
                    return 0 === o ? null : e[o - 1]
                }
                getShiftedBy(t) {
                    const e = this.clone(),
                        n = e.offset + t;
                    return e.offset = n < 0 ? 0 : n, e
                }
                isAfter(t) {
                    return "after" == this.compareWith(t)
                }
                isBefore(t) {
                    return "before" == this.compareWith(t)
                }
                isEqual(t) {
                    return "same" == this.compareWith(t)
                }
                isTouching(t) {
                    if (this.root !== t.root) return !1;
                    const e = Math.min(this.path.length, t.path.length);
                    for (let n = 0; n < e; n++) {
                        const e = this.path[n] - t.path[n];
                        if (e < -1 || e > 1) return !1;
                        if (1 === e) return Vd(t, this, n);
                        if (-1 === e) return Vd(this, t, n)
                    }
                    return this.path.length === t.path.length || (this.path.length > t.path.length ? Hd(this.path, e) : Hd(t.path, e))
                }
                hasSameParentAs(t) {
                    if (this.root !== t.root) return !1;
                    return "same" == et(this.getParentPath(), t.getParentPath())
                }
                getTransformedByOperation(t) {
                    let e;
                    switch (t.type) {
                        case "insert":
                            e = this._getTransformedByInsertOperation(t);
                            break;
                        case "move":
                        case "remove":
                        case "reinsert":
                            e = this._getTransformedByMoveOperation(t);
                            break;
                        case "split":
                            e = this._getTransformedBySplitOperation(t);
                            break;
                        case "merge":
                            e = this._getTransformedByMergeOperation(t);
                            break;
                        default:
                            e = Od._createAt(this)
                    }
                    return e
                }
                _getTransformedByInsertOperation(t) {
                    return this._getTransformedByInsertion(t.position, t.howMany)
                }
                _getTransformedByMoveOperation(t) {
                    return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
                }
                _getTransformedBySplitOperation(t) {
                    const e = t.movedRange;
                    return e.containsPosition(this) || e.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t.splitPosition, t.moveTargetPosition) : t.graveyardPosition ? this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1) : this._getTransformedByInsertion(t.insertionPosition, 1)
                }
                _getTransformedByMergeOperation(t) {
                    const e = t.movedRange;
                    let n;
                    return e.containsPosition(this) || e.start.isEqual(this) ? (n = this._getCombined(t.sourcePosition, t.targetPosition), t.sourcePosition.isBefore(t.targetPosition) && (n = n._getTransformedByDeletion(t.deletionPosition, 1))) : n = this.isEqual(t.deletionPosition) ? Od._createAt(t.deletionPosition) : this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1), n
                }
                _getTransformedByDeletion(t, e) {
                    const n = Od._createAt(this);
                    if (this.root != t.root) return n;
                    if ("same" == et(t.getParentPath(), this.getParentPath())) {
                        if (t.offset < this.offset) {
                            if (t.offset + e > this.offset) return null;
                            n.offset -= e
                        }
                    } else if ("prefix" == et(t.getParentPath(), this.getParentPath())) {
                        const o = t.path.length - 1;
                        if (t.offset <= this.path[o]) {
                            if (t.offset + e > this.path[o]) return null;
                            n.path[o] -= e
                        }
                    }
                    return n
                }
                _getTransformedByInsertion(t, e) {
                    const n = Od._createAt(this);
                    if (this.root != t.root) return n;
                    if ("same" == et(t.getParentPath(), this.getParentPath()))(t.offset < this.offset || t.offset == this.offset && "toPrevious" != this.stickiness) && (n.offset += e);
                    else if ("prefix" == et(t.getParentPath(), this.getParentPath())) {
                        const o = t.path.length - 1;
                        t.offset <= this.path[o] && (n.path[o] += e)
                    }
                    return n
                }
                _getTransformedByMove(t, e, n) {
                    if (e = e._getTransformedByDeletion(t, n), t.isEqual(e)) return Od._createAt(this);
                    const o = this._getTransformedByDeletion(t, n);
                    return null === o || t.isEqual(this) && "toNext" == this.stickiness || t.getShiftedBy(n).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t, e) : o._getTransformedByInsertion(e, n)
                }
                _getCombined(t, e) {
                    const n = t.path.length - 1,
                        o = Od._createAt(e);
                    return o.stickiness = this.stickiness, o.offset = o.offset + this.path[n] - t.offset, o.path = [...o.path, ...this.path.slice(n + 1)], o
                }
                toJSON() {
                    return {
                        root: this.root.toJSON(),
                        path: Array.from(this.path),
                        stickiness: this.stickiness
                    }
                }
                clone() {
                    return new this.constructor(this.root, this.path, this.stickiness)
                }
                static _createAt(t, e, n = "toNone") {
                    if (t instanceof Od) return new Od(t.root, t.path, t.stickiness);
                    {
                        const o = t;
                        if ("end" == e) e = o.maxOffset;
                        else {
                            if ("before" == e) return this._createBefore(o, n);
                            if ("after" == e) return this._createAfter(o, n);
                            if (0 !== e && !e) throw new A("model-createpositionat-offset-required", [this, t])
                        }
                        if (!o.is("element") && !o.is("documentFragment")) throw new A("model-position-parent-incorrect", [this, t]);
                        const i = o.getPath();
                        return i.push(e), new this(o.root, i, n)
                    }
                }
                static _createAfter(t, e) {
                    if (!t.parent) throw new A("model-position-after-root", [this, t], {
                        root: t
                    });
                    return this._createAt(t.parent, t.endOffset, e)
                }
                static _createBefore(t, e) {
                    if (!t.parent) throw new A("model-position-before-root", t, {
                        root: t
                    });
                    return this._createAt(t.parent, t.startOffset, e)
                }
                static fromJSON(t, e) {
                    if ("$graveyard" === t.root) {
                        const n = new Od(e.graveyard, t.path);
                        return n.stickiness = t.stickiness, n
                    }
                    if (!e.getRoot(t.root)) throw new A("model-position-fromjson-no-root", e, {
                        rootName: t.root
                    });
                    return new Od(e.getRoot(t.root), t.path, t.stickiness)
                }
            }
    
            function Rd(t, e) {
                const n = e.getChild(e.offsetToIndex(t.offset));
                return n && n.is("$text") && n.startOffset < t.offset ? n : null
            }
    
            function jd(t, e, n) {
                return null !== n ? null : e.getChild(e.offsetToIndex(t.offset))
            }
    
            function Fd(t, e, n) {
                return null !== n ? null : e.getChild(e.offsetToIndex(t.offset) - 1)
            }
    
            function Vd(t, e, n) {
                return n + 1 !== t.path.length && (!!Hd(e.path, n + 1) && !! function(t, e) {
                    let n = t.parent,
                        o = t.path.length - 1,
                        i = 0;
                    for (; o >= e;) {
                        if (t.path[o] + i !== n.maxOffset) return !1;
                        i = 1, o--, n = n.parent
                    }
                    return !0
                }(t, n + 1))
            }
    
            function Hd(t, e) {
                for (; e < t.length;) {
                    if (0 !== t[e]) return !1;
                    e++
                }
                return !0
            }
            Od.prototype.is = function(t) {
                return "position" === t || "model:position" === t
            };
            class Ud extends Td {
                constructor(t, e) {
                    super(), this.start = Od._createAt(t), this.end = e ? Od._createAt(e) : Od._createAt(t), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
                }*[Symbol.iterator]() {
                    yield* new zd({
                        boundaries: this,
                        ignoreElementEnd: !0
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    return "same" == et(this.start.getParentPath(), this.end.getParentPath())
                }
                get root() {
                    return this.start.root
                }
                containsPosition(t) {
                    return t.isAfter(this.start) && t.isBefore(this.end)
                }
                containsRange(t, e = !1) {
                    t.isCollapsed && (e = !1);
                    const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start),
                        o = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                    return n && o
                }
                containsItem(t) {
                    const e = Od._createBefore(t);
                    return this.containsPosition(e) || this.start.isEqual(e)
                }
                isEqual(t) {
                    return this.start.isEqual(t.start) && this.end.isEqual(t.end)
                }
                isIntersecting(t) {
                    return this.start.isBefore(t.end) && this.end.isAfter(t.start)
                }
                getDifference(t) {
                    const e = [];
                    return this.isIntersecting(t) ? (this.containsPosition(t.start) && e.push(new Ud(this.start, t.start)), this.containsPosition(t.end) && e.push(new Ud(t.end, this.end))) : e.push(new Ud(this.start, this.end)), e
                }
                getIntersection(t) {
                    if (this.isIntersecting(t)) {
                        let e = this.start,
                            n = this.end;
                        return this.containsPosition(t.start) && (e = t.start), this.containsPosition(t.end) && (n = t.end), new Ud(e, n)
                    }
                    return null
                }
                getJoined(t, e = !1) {
                    let n = this.isIntersecting(t);
                    if (n || (n = this.start.isBefore(t.start) ? e ? this.end.isTouching(t.start) : this.end.isEqual(t.start) : e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)), !n) return null;
                    let o = this.start,
                        i = this.end;
                    return t.start.isBefore(o) && (o = t.start), t.end.isAfter(i) && (i = t.end), new Ud(o, i)
                }
                getMinimalFlatRanges() {
                    const t = [],
                        e = this.start.getCommonPath(this.end).length,
                        n = Od._createAt(this.start);
                    let o = n.parent;
                    for (; n.path.length > e + 1;) {
                        const e = o.maxOffset - n.offset;
                        0 !== e && t.push(new Ud(n, n.getShiftedBy(e))), n.path = n.path.slice(0, -1), n.offset++, o = o.parent
                    }
                    for (; n.path.length <= this.end.path.length;) {
                        const e = this.end.path[n.path.length - 1],
                            o = e - n.offset;
                        0 !== o && t.push(new Ud(n, n.getShiftedBy(o))), n.offset = e, n.path.push(0)
                    }
                    return t
                }
                getWalker(t = {}) {
                    return t.boundaries = this, new zd(t)
                }* getItems(t = {}) {
                    t.boundaries = this, t.ignoreElementEnd = !0;
                    const e = new zd(t);
                    for (const t of e) yield t.item
                }* getPositions(t = {}) {
                    t.boundaries = this;
                    const e = new zd(t);
                    yield e.position;
                    for (const t of e) yield t.nextPosition
                }
                getTransformedByOperation(t) {
                    switch (t.type) {
                        case "insert":
                            return this._getTransformedByInsertOperation(t);
                        case "move":
                        case "remove":
                        case "reinsert":
                            return this._getTransformedByMoveOperation(t);
                        case "split":
                            return [this._getTransformedBySplitOperation(t)];
                        case "merge":
                            return [this._getTransformedByMergeOperation(t)]
                    }
                    return [new Ud(this.start, this.end)]
                }
                getTransformedByOperations(t) {
                    const e = [new Ud(this.start, this.end)];
                    for (const n of t)
                        for (let t = 0; t < e.length; t++) {
                            const o = e[t].getTransformedByOperation(n);
                            e.splice(t, 1, ...o), t += o.length - 1
                        }
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        for (let o = t + 1; o < e.length; o++) {
                            const t = e[o];
                            (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) && e.splice(o, 1)
                        }
                    }
                    return e
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                getContainedElement() {
                    if (this.isCollapsed) return null;
                    const t = this.start.nodeAfter,
                        e = this.end.nodeBefore;
                    return t && t.is("element") && t === e ? t : null
                }
                toJSON() {
                    return {
                        start: this.start.toJSON(),
                        end: this.end.toJSON()
                    }
                }
                clone() {
                    return new this.constructor(this.start, this.end)
                }
                _getTransformedByInsertOperation(t, e = !1) {
                    return this._getTransformedByInsertion(t.position, t.howMany, e)
                }
                _getTransformedByMoveOperation(t, e = !1) {
                    const n = t.sourcePosition,
                        o = t.howMany,
                        i = t.targetPosition;
                    return this._getTransformedByMove(n, i, o, e)
                }
                _getTransformedBySplitOperation(t) {
                    const e = this.start._getTransformedBySplitOperation(t);
                    let n = this.end._getTransformedBySplitOperation(t);
                    return this.end.isEqual(t.insertionPosition) && (n = this.end.getShiftedBy(1)), e.root != n.root && (n = this.end.getShiftedBy(-1)), new Ud(e, n)
                }
                _getTransformedByMergeOperation(t) {
                    if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) return new Ud(this.start);
                    let e = this.start._getTransformedByMergeOperation(t),
                        n = this.end._getTransformedByMergeOperation(t);
                    return e.root != n.root && (n = this.end.getShiftedBy(-1)), e.isAfter(n) ? (t.sourcePosition.isBefore(t.targetPosition) ? (e = Od._createAt(n), e.offset = 0) : (t.deletionPosition.isEqual(e) || (n = t.deletionPosition), e = t.targetPosition), new Ud(e, n)) : new Ud(e, n)
                }
                _getTransformedByInsertion(t, e, n = !1) {
                    if (n && this.containsPosition(t)) return [new Ud(this.start, t), new Ud(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))];
                    {
                        const n = new Ud(this.start, this.end);
                        return n.start = n.start._getTransformedByInsertion(t, e), n.end = n.end._getTransformedByInsertion(t, e), [n]
                    }
                }
                _getTransformedByMove(t, e, n, o = !1) {
                    if (this.isCollapsed) {
                        const o = this.start._getTransformedByMove(t, e, n);
                        return [new Ud(o)]
                    }
                    const i = Ud._createFromPositionAndShift(t, n),
                        r = e._getTransformedByDeletion(t, n);
                    if (this.containsPosition(e) && !o && (i.containsPosition(this.start) || i.containsPosition(this.end))) {
                        const o = this.start._getTransformedByMove(t, e, n),
                            i = this.end._getTransformedByMove(t, e, n);
                        return [new Ud(o, i)]
                    }
                    let s;
                    const a = this.getDifference(i);
                    let c = null;
                    const l = this.getIntersection(i);
                    if (1 == a.length ? c = new Ud(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n)) : 2 == a.length && (c = new Ud(this.start, this.end._getTransformedByDeletion(t, n))), s = c ? c._getTransformedByInsertion(r, n, null !== l || o) : [], l) {
                        const t = new Ud(l.start._getCombined(i.start, r), l.end._getCombined(i.start, r));
                        2 == s.length ? s.splice(1, 0, t) : s.push(t)
                    }
                    return s
                }
                _getTransformedByDeletion(t, e) {
                    let n = this.start._getTransformedByDeletion(t, e),
                        o = this.end._getTransformedByDeletion(t, e);
                    return null == n && null == o ? null : (null == n && (n = t), null == o && (o = t), new Ud(n, o))
                }
                static _createFromPositionAndShift(t, e) {
                    const n = t,
                        o = t.getShiftedBy(e);
                    return e > 0 ? new this(n, o) : new this(o, n)
                }
                static _createIn(t) {
                    return new this(Od._createAt(t, 0), Od._createAt(t, t.maxOffset))
                }
                static _createOn(t) {
                    return this._createFromPositionAndShift(Od._createBefore(t), t.offsetSize)
                }
                static _createFromRanges(t) {
                    if (0 === t.length) throw new A("range-create-from-ranges-empty-array", null);
                    if (1 == t.length) return t[0].clone();
                    const e = t[0];
                    t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1));
                    const n = t.indexOf(e),
                        o = new this(e.start, e.end);
                    if (n > 0)
                        for (let e = n - 1; t[e].end.isEqual(o.start); e++) o.start = Od._createAt(t[e].start);
                    for (let e = n + 1; e < t.length && t[e].start.isEqual(o.end); e++) o.end = Od._createAt(t[e].end);
                    return o
                }
                static fromJSON(t, e) {
                    return new this(Od.fromJSON(t.start, e), Od.fromJSON(t.end, e))
                }
            }
            Ud.prototype.is = function(t) {
                return "range" === t || "model:range" === t
            };
            class Wd extends(N()) {
                constructor() {
                    super(), this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._viewToModelLengthCallbacks = new Map, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._deferredBindingRemovals = new Map, this._unboundMarkerNames = new Set, this.on("modelToViewPosition", ((t, e) => {
                        if (e.viewPosition) return;
                        const n = this._modelToViewMapping.get(e.modelPosition.parent);
                        if (!n) throw new A("mapping-model-position-view-parent-not-found", this, {
                            modelPosition: e.modelPosition
                        });
                        e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
                    }), {
                        priority: "low"
                    }), this.on("viewToModelPosition", ((t, e) => {
                        if (e.modelPosition) return;
                        const n = this.findMappedViewAncestor(e.viewPosition),
                            o = this._viewToModelMapping.get(n),
                            i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                        e.modelPosition = Od._createAt(o, i)
                    }), {
                        priority: "low"
                    })
                }
                bindElements(t, e) {
                    this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t)
                }
                unbindViewElement(t, e = {}) {
                    const n = this.toModelElement(t);
                    if (this._elementToMarkerNames.has(t))
                        for (const e of this._elementToMarkerNames.get(t)) this._unboundMarkerNames.add(e);
                    e.defer ? this._deferredBindingRemovals.set(t, t.root) : (this._viewToModelMapping.delete(t), this._modelToViewMapping.get(n) == t && this._modelToViewMapping.delete(n))
                }
                unbindModelElement(t) {
                    const e = this.toViewElement(t);
                    this._modelToViewMapping.delete(t), this._viewToModelMapping.get(e) == t && this._viewToModelMapping.delete(e)
                }
                bindElementToMarker(t, e) {
                    const n = this._markerNameToElements.get(e) || new Set;
                    n.add(t);
                    const o = this._elementToMarkerNames.get(t) || new Set;
                    o.add(e), this._markerNameToElements.set(e, n), this._elementToMarkerNames.set(t, o)
                }
                unbindElementFromMarkerName(t, e) {
                    const n = this._markerNameToElements.get(e);
                    n && (n.delete(t), 0 == n.size && this._markerNameToElements.delete(e));
                    const o = this._elementToMarkerNames.get(t);
                    o && (o.delete(e), 0 == o.size && this._elementToMarkerNames.delete(t))
                }
                flushUnboundMarkerNames() {
                    const t = Array.from(this._unboundMarkerNames);
                    return this._unboundMarkerNames.clear(), t
                }
                flushDeferredBindings() {
                    for (const [t, e] of this._deferredBindingRemovals) t.root == e && this.unbindViewElement(t);
                    this._deferredBindingRemovals = new Map
                }
                clearBindings() {
                    this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._unboundMarkerNames = new Set, this._deferredBindingRemovals = new Map
                }
                toModelElement(t) {
                    return this._viewToModelMapping.get(t)
                }
                toViewElement(t) {
                    return this._modelToViewMapping.get(t)
                }
                toModelRange(t) {
                    return new Ud(this.toModelPosition(t.start), this.toModelPosition(t.end))
                }
                toViewRange(t) {
                    return new sc(this.toViewPosition(t.start), this.toViewPosition(t.end))
                }
                toModelPosition(t) {
                    const e = {
                        viewPosition: t,
                        mapper: this
                    };
                    return this.fire("viewToModelPosition", e), e.modelPosition
                }
                toViewPosition(t, e = {}) {
                    const n = {
                        modelPosition: t,
                        mapper: this,
                        isPhantom: e.isPhantom
                    };
                    return this.fire("modelToViewPosition", n), n.viewPosition
                }
                markerNameToElements(t) {
                    const e = this._markerNameToElements.get(t);
                    if (!e) return null;
                    const n = new Set;
                    for (const t of e)
                        if (t.is("attributeElement"))
                            for (const e of t.getElementsWithSameId()) n.add(e);
                        else n.add(t);
                    return n
                }
                registerViewToModelLength(t, e) {
                    this._viewToModelLengthCallbacks.set(t, e)
                }
                findMappedViewAncestor(t) {
                    let e = t.parent;
                    for (; !this._viewToModelMapping.has(e);) e = e.parent;
                    return e
                }
                _toModelOffset(t, e, n) {
                    if (n != t) {
                        return this._toModelOffset(t.parent, t.index, n) + this._toModelOffset(t, e, t)
                    }
                    if (t.is("$text")) return e;
                    let o = 0;
                    for (let n = 0; n < e; n++) o += this.getModelLength(t.getChild(n));
                    return o
                }
                getModelLength(t) {
                    if (this._viewToModelLengthCallbacks.get(t.name)) {
                        return this._viewToModelLengthCallbacks.get(t.name)(t)
                    }
                    if (this._viewToModelMapping.has(t)) return 1;
                    if (t.is("$text")) return t.data.length;
                    if (t.is("uiElement")) return 0;
                    {
                        let e = 0;
                        for (const n of t.getChildren()) e += this.getModelLength(n);
                        return e
                    }
                }
                findPositionIn(t, e) {
                    let n, o = 0,
                        i = 0,
                        r = 0;
                    if (t.is("$text")) return new rc(t, e);
                    for (; i < e;) n = t.getChild(r), o = this.getModelLength(n), i += o, r++;
                    return i == e ? this._moveViewPositionToTextNode(new rc(t, r)) : this.findPositionIn(n, e - (i - o))
                }
                _moveViewPositionToTextNode(t) {
                    const e = t.nodeBefore,
                        n = t.nodeAfter;
                    return e instanceof Us ? new rc(e, e.data.length) : n instanceof Us ? new rc(n, 0) : t
                }
            }
            class qd {
                constructor() {
                    this._consumable = new Map, this._textProxyRegistry = new Map
                }
                add(t, e) {
                    e = Gd(e), t instanceof Bd && (t = this._getSymbolForTextProxy(t)), this._consumable.has(t) || this._consumable.set(t, new Map), this._consumable.get(t).set(e, !0)
                }
                consume(t, e) {
                    return e = Gd(e), t instanceof Bd && (t = this._getSymbolForTextProxy(t)), !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
                }
                test(t, e) {
                    e = Gd(e), t instanceof Bd && (t = this._getSymbolForTextProxy(t));
                    const n = this._consumable.get(t);
                    if (void 0 === n) return null;
                    const o = n.get(e);
                    return void 0 === o ? null : o
                }
                revert(t, e) {
                    e = Gd(e), t instanceof Bd && (t = this._getSymbolForTextProxy(t));
                    const n = this.test(t, e);
                    return !1 === n ? (this._consumable.get(t).set(e, !0), !0) : !0 !== n && null
                }
                verifyAllConsumed(t) {
                    const e = [];
                    for (const [n, o] of this._consumable)
                        for (const [i, r] of o) {
                            const o = i.split(":")[0];
                            r && t == o && e.push({
                                event: i,
                                item: n.name || n.description
                            })
                        }
                    if (e.length) throw new A("conversion-model-consumable-not-consumed", null, {
                        items: e
                    })
                }
                _getSymbolForTextProxy(t) {
                    let e = null;
                    const n = this._textProxyRegistry.get(t.startOffset);
                    if (n) {
                        const o = n.get(t.endOffset);
                        o && (e = o.get(t.parent))
                    }
                    return e || (e = this._addSymbolForTextProxy(t)), e
                }
                _addSymbolForTextProxy(t) {
                    const e = t.startOffset,
                        n = t.endOffset,
                        o = t.parent,
                        i = Symbol("$textProxy:" + t.data);
                    let r, s;
                    return r = this._textProxyRegistry.get(e), r || (r = new Map, this._textProxyRegistry.set(e, r)), s = r.get(n), s || (s = new Map, r.set(n, s)), s.set(o, i), i
                }
            }
    
            function Gd(t) {
                const e = t.split(":");
                return "insert" == e[0] ? e[0] : "addMarker" == e[0] || "removeMarker" == e[0] ? t : e.length > 1 ? e[0] + ":" + e[1] : e[0]
            }
            class $d extends(N()) {
                constructor(t) {
                    super(), this._conversionApi = {
                        dispatcher: this,
                        ...t
                    }, this._firedEventsMap = new WeakMap
                }
                convertChanges(t, e, n) {
                    const o = this._createConversionApi(n, t.getRefreshedItems());
                    for (const e of t.getMarkersToRemove()) this._convertMarkerRemove(e.name, e.range, o);
                    const i = this._reduceChanges(t.getChanges());
                    for (const t of i) "insert" === t.type ? this._convertInsert(Ud._createFromPositionAndShift(t.position, t.length), o) : "reinsert" === t.type ? this._convertReinsert(Ud._createFromPositionAndShift(t.position, t.length), o) : "remove" === t.type ? this._convertRemove(t.position, t.length, t.name, o) : this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, o);
                    for (const t of o.mapper.flushUnboundMarkerNames()) {
                        const n = e.get(t).getRange();
                        this._convertMarkerRemove(t, n, o), this._convertMarkerAdd(t, n, o)
                    }
                    for (const e of t.getMarkersToAdd()) this._convertMarkerAdd(e.name, e.range, o);
                    o.mapper.flushDeferredBindings(), o.consumable.verifyAllConsumed("insert")
                }
                convert(t, e, n, o = {}) {
                    const i = this._createConversionApi(n, void 0, o);
                    this._convertInsert(t, i);
                    for (const [t, n] of e) this._convertMarkerAdd(t, n, i);
                    i.consumable.verifyAllConsumed("insert")
                }
                convertSelection(t, e, n) {
                    const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition())),
                        i = this._createConversionApi(n);
                    if (this._addConsumablesForSelection(i.consumable, t, o), this.fire("selection", {
                            selection: t
                        }, i), t.isCollapsed) {
                        for (const e of o) {
                            const n = e.getRange();
                            if (!Yd(t.getFirstPosition(), e, i.mapper)) continue;
                            const o = {
                                item: t,
                                markerName: e.name,
                                markerRange: n
                            };
                            i.consumable.test(t, "addMarker:" + e.name) && this.fire(`addMarker:${e.name}`, o, i)
                        }
                        for (const e of t.getAttributeKeys()) {
                            const n = {
                                item: t,
                                range: t.getFirstRange(),
                                attributeKey: e,
                                attributeOldValue: null,
                                attributeNewValue: t.getAttribute(e)
                            };
                            i.consumable.test(t, "attribute:" + n.attributeKey) && this.fire(`attribute:${n.attributeKey}:$text`, n, i)
                        }
                    }
                }
                _convertInsert(t, e, n = {}) {
                    n.doNotAddConsumables || this._addConsumablesForInsert(e.consumable, Array.from(t));
                    for (const n of Array.from(t.getWalker({
                            shallow: !0
                        })).map(Kd)) this._testAndFire("insert", n, e)
                }
                _convertRemove(t, e, n, o) {
                    this.fire(`remove:${n}`, {
                        position: t,
                        length: e
                    }, o)
                }
                _convertAttribute(t, e, n, o, i) {
                    this._addConsumablesForRange(i.consumable, t, `attribute:${e}`);
                    for (const r of t) {
                        const t = {
                            item: r.item,
                            range: Ud._createFromPositionAndShift(r.previousPosition, r.length),
                            attributeKey: e,
                            attributeOldValue: n,
                            attributeNewValue: o
                        };
                        this._testAndFire(`attribute:${e}`, t, i)
                    }
                }
                _convertReinsert(t, e) {
                    const n = Array.from(t.getWalker({
                        shallow: !0
                    }));
                    this._addConsumablesForInsert(e.consumable, n);
                    for (const t of n.map(Kd)) this._testAndFire("insert", {
                        ...t,
                        reconversion: !0
                    }, e)
                }
                _convertMarkerAdd(t, e, n) {
                    if ("$graveyard" == e.root.rootName) return;
                    const o = `addMarker:${t}`;
                    if (n.consumable.add(e, o), this.fire(o, {
                            markerName: t,
                            markerRange: e
                        }, n), n.consumable.consume(e, o)) {
                        this._addConsumablesForRange(n.consumable, e, o);
                        for (const i of e.getItems()) {
                            if (!n.consumable.test(i, o)) continue;
                            const r = {
                                item: i,
                                range: Ud._createOn(i),
                                markerName: t,
                                markerRange: e
                            };
                            this.fire(o, r, n)
                        }
                    }
                }
                _convertMarkerRemove(t, e, n) {
                    "$graveyard" != e.root.rootName && this.fire(`removeMarker:${t}`, {
                        markerName: t,
                        markerRange: e
                    }, n)
                }
                _reduceChanges(t) {
                    const e = {
                        changes: t
                    };
                    return this.fire("reduceChanges", e), e.changes
                }
                _addConsumablesForInsert(t, e) {
                    for (const n of e) {
                        const e = n.item;
                        if (null === t.test(e, "insert")) {
                            t.add(e, "insert");
                            for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n)
                        }
                    }
                    return t
                }
                _addConsumablesForRange(t, e, n) {
                    for (const o of e.getItems()) t.add(o, n);
                    return t
                }
                _addConsumablesForSelection(t, e, n) {
                    t.add(e, "selection");
                    for (const o of n) t.add(e, "addMarker:" + o.name);
                    for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n);
                    return t
                }
                _testAndFire(t, e, n) {
                    const o = function(t, e) {
                            const n = e.item.is("element") ? e.item.name : "$text";
                            return `${t}:${n}`
                        }(t, e),
                        i = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item,
                        r = this._firedEventsMap.get(n),
                        s = r.get(i);
                    if (s) {
                        if (s.has(o)) return;
                        s.add(o)
                    } else r.set(i, new Set([o]));
                    this.fire(o, e, n)
                }
                _testAndFireAddAttributes(t, e) {
                    const n = {
                        item: t,
                        range: Ud._createOn(t)
                    };
                    for (const t of n.item.getAttributeKeys()) n.attributeKey = t, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(t), this._testAndFire(`attribute:${t}`, n, e)
                }
                _createConversionApi(t, e = new Set, n = {}) {
                    const o = {
                        ...this._conversionApi,
                        consumable: new qd,
                        writer: t,
                        options: n,
                        convertItem: t => this._convertInsert(Ud._createOn(t), o),
                        convertChildren: t => this._convertInsert(Ud._createIn(t), o, {
                            doNotAddConsumables: !0
                        }),
                        convertAttributes: t => this._testAndFireAddAttributes(t, o),
                        canReuseView: t => !e.has(o.mapper.toModelElement(t))
                    };
                    return this._firedEventsMap.set(o, new Map), o
                }
            }
    
            function Yd(t, e, n) {
                const o = e.getRange(),
                    i = Array.from(t.getAncestors());
                i.shift(), i.reverse();
                return !i.some((t => {
                    if (o.containsItem(t)) {
                        return !!n.toViewElement(t).getCustomProperty("addHighlight")
                    }
                }))
            }
    
            function Kd(t) {
                return {
                    item: t.item,
                    range: Ud._createFromPositionAndShift(t.previousPosition, t.length)
                }
            }
            class Qd extends(N(Td)) {
                constructor(...t) {
                    super(), this._lastRangeBackward = !1, this._attrs = new Map, this._ranges = [], t.length && this.setTo(...t)
                }
                get anchor() {
                    if (this._ranges.length > 0) {
                        const t = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? t.end : t.start
                    }
                    return null
                }
                get focus() {
                    if (this._ranges.length > 0) {
                        const t = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? t.start : t.end
                    }
                    return null
                }
                get isCollapsed() {
                    return 1 === this._ranges.length && this._ranges[0].isCollapsed
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                isEqual(t) {
                    if (this.rangeCount != t.rangeCount) return !1;
                    if (0 === this.rangeCount) return !0;
                    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) return !1;
                    for (const e of this._ranges) {
                        let n = !1;
                        for (const o of t._ranges)
                            if (e.isEqual(o)) {
                                n = !0;
                                break
                            } if (!n) return !1
                    }
                    return !0
                }* getRanges() {
                    for (const t of this._ranges) yield new Ud(t.start, t.end)
                }
                getFirstRange() {
                    let t = null;
                    for (const e of this._ranges) t && !e.start.isBefore(t.start) || (t = e);
                    return t ? new Ud(t.start, t.end) : null
                }
                getLastRange() {
                    let t = null;
                    for (const e of this._ranges) t && !e.end.isAfter(t.end) || (t = e);
                    return t ? new Ud(t.start, t.end) : null
                }
                getFirstPosition() {
                    const t = this.getFirstRange();
                    return t ? t.start.clone() : null
                }
                getLastPosition() {
                    const t = this.getLastRange();
                    return t ? t.end.clone() : null
                }
                setTo(...t) {
                    let [e, n, o] = t;
                    if ("object" == typeof n && (o = n, n = void 0), null === e) this._setRanges([]);
                    else if (e instanceof Qd) this._setRanges(e.getRanges(), e.isBackward);
                    else if (e && "function" == typeof e.getRanges) this._setRanges(e.getRanges(), e.isBackward);
                    else if (e instanceof Ud) this._setRanges([e], !!o && !!o.backward);
                    else if (e instanceof Od) this._setRanges([new Ud(e)]);
                    else if (e instanceof Md) {
                        const t = !!o && !!o.backward;
                        let i;
                        if ("in" == n) i = Ud._createIn(e);
                        else if ("on" == n) i = Ud._createOn(e);
                        else {
                            if (void 0 === n) throw new A("model-selection-setto-required-second-parameter", [this, e]);
                            i = new Ud(Od._createAt(e, n))
                        }
                        this._setRanges([i], t)
                    } else {
                        if (!nt(e)) throw new A("model-selection-setto-not-selectable", [this, e]);
                        this._setRanges(e, o && !!o.backward)
                    }
                }
                _setRanges(t, e = !1) {
                    const n = Array.from(t),
                        o = n.some((e => {
                            if (!(e instanceof Ud)) throw new A("model-selection-set-ranges-not-range", [this, t]);
                            return this._ranges.every((t => !t.isEqual(e)))
                        }));
                    (n.length !== this._ranges.length || o) && (this._replaceAllRanges(n), this._lastRangeBackward = !!e, this.fire("change:range", {
                        directChange: !0
                    }))
                }
                setFocus(t, e) {
                    if (null === this.anchor) throw new A("model-selection-setfocus-no-ranges", [this, t]);
                    const n = Od._createAt(t, e);
                    if ("same" == n.compareWith(this.focus)) return;
                    const o = this.anchor;
                    this._ranges.length && this._popRange(), "before" == n.compareWith(o) ? (this._pushRange(new Ud(n, o)), this._lastRangeBackward = !0) : (this._pushRange(new Ud(o, n)), this._lastRangeBackward = !1), this.fire("change:range", {
                        directChange: !0
                    })
                }
                getAttribute(t) {
                    return this._attrs.get(t)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                hasAttribute(t) {
                    return this._attrs.has(t)
                }
                removeAttribute(t) {
                    this.hasAttribute(t) && (this._attrs.delete(t), this.fire("change:attribute", {
                        attributeKeys: [t],
                        directChange: !0
                    }))
                }
                setAttribute(t, e) {
                    this.getAttribute(t) !== e && (this._attrs.set(t, e), this.fire("change:attribute", {
                        attributeKeys: [t],
                        directChange: !0
                    }))
                }
                getSelectedElement() {
                    return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement()
                }* getSelectedBlocks() {
                    const t = new WeakSet;
                    for (const e of this.getRanges()) {
                        const n = Xd(e.start, t);
                        n && th(n, e) && (yield n);
                        for (const n of e.getWalker()) {
                            const o = n.item;
                            "elementEnd" == n.type && Jd(o, t, e) && (yield o)
                        }
                        const o = Xd(e.end, t);
                        o && !e.end.isTouching(Od._createAt(o, 0)) && th(o, e) && (yield o)
                    }
                }
                containsEntireContent(t = this.anchor.root) {
                    const e = Od._createAt(t, 0),
                        n = Od._createAt(t, "end");
                    return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
                }
                _pushRange(t) {
                    this._checkRange(t), this._ranges.push(new Ud(t.start, t.end))
                }
                _checkRange(t) {
                    for (let e = 0; e < this._ranges.length; e++)
                        if (t.isIntersecting(this._ranges[e])) throw new A("model-selection-range-intersects", [this, t], {
                            addedRange: t,
                            intersectingRange: this._ranges[e]
                        })
                }
                _replaceAllRanges(t) {
                    this._removeAllRanges();
                    for (const e of t) this._pushRange(e)
                }
                _removeAllRanges() {
                    for (; this._ranges.length > 0;) this._popRange()
                }
                _popRange() {
                    this._ranges.pop()
                }
            }
    
            function Zd(t, e) {
                return !e.has(t) && (e.add(t), t.root.document.model.schema.isBlock(t) && !!t.parent)
            }
    
            function Jd(t, e, n) {
                return Zd(t, e) && th(t, n)
            }
    
            function Xd(t, e) {
                const n = t.parent.root.document.model.schema,
                    o = t.parent.getAncestors({
                        parentFirst: !0,
                        includeSelf: !0
                    });
                let i = !1;
                const r = o.find((t => !i && (i = n.isLimit(t), !i && Zd(t, e))));
                return o.forEach((t => e.add(t))), r
            }
    
            function th(t, e) {
                const n = function(t) {
                    const e = t.root.document.model.schema;
                    let n = t.parent;
                    for (; n;) {
                        if (e.isBlock(n)) return n;
                        n = n.parent
                    }
                }(t);
                if (!n) return !0;
                return !e.containsRange(Ud._createOn(n), !0)
            }
            Qd.prototype.is = function(t) {
                return "selection" === t || "model:selection" === t
            };
            class eh extends(N(Ud)) {
                constructor(t, e) {
                    super(t, e), nh.call(this)
                }
                detach() {
                    this.stopListening()
                }
                toRange() {
                    return new Ud(this.start, this.end)
                }
                static fromRange(t) {
                    return new eh(t.start, t.end)
                }
            }
    
            function nh() {
                this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && oh.call(this, n)
                }), {
                    priority: "low"
                })
            }
    
            function oh(t) {
                const e = this.getTransformedByOperation(t),
                    n = Ud._createFromRanges(e),
                    o = !n.isEqual(this),
                    i = function(t, e) {
                        switch (e.type) {
                            case "insert":
                                return t.containsPosition(e.position);
                            case "move":
                            case "remove":
                            case "reinsert":
                            case "merge":
                                return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                            case "split":
                                return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
                        }
                        return !1
                    }(this, t);
                let r = null;
                if (o) {
                    "$graveyard" == n.root.rootName && (r = "remove" == t.type ? t.sourcePosition : t.deletionPosition);
                    const e = this.toRange();
                    this.start = n.start, this.end = n.end, this.fire("change:range", e, {
                        deletionPosition: r
                    })
                } else i && this.fire("change:content", this.toRange(), {
                    deletionPosition: r
                })
            }
            eh.prototype.is = function(t) {
                return "liveRange" === t || "model:liveRange" === t || "range" == t || "model:range" === t
            };
            const ih = "selection:";
            class rh extends(N(Td)) {
                constructor(t) {
                    super(), this._selection = new sh(t), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this)
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get hasOwnRange() {
                    return this._selection.hasOwnRange
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get isGravityOverridden() {
                    return this._selection.isGravityOverridden
                }
                get markers() {
                    return this._selection.markers
                }
                get _ranges() {
                    return this._selection._ranges
                }
                getRanges() {
                    return this._selection.getRanges()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getSelectedBlocks() {
                    return this._selection.getSelectedBlocks()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                containsEntireContent(t) {
                    return this._selection.containsEntireContent(t)
                }
                destroy() {
                    this._selection.destroy()
                }
                getAttributeKeys() {
                    return this._selection.getAttributeKeys()
                }
                getAttributes() {
                    return this._selection.getAttributes()
                }
                getAttribute(t) {
                    return this._selection.getAttribute(t)
                }
                hasAttribute(t) {
                    return this._selection.hasAttribute(t)
                }
                refresh() {
                    this._selection.updateMarkers(), this._selection._updateAttributes(!1)
                }
                observeMarkers(t) {
                    this._selection.observeMarkers(t)
                }
                _setFocus(t, e) {
                    this._selection.setFocus(t, e)
                }
                _setTo(...t) {
                    this._selection.setTo(...t)
                }
                _setAttribute(t, e) {
                    this._selection.setAttribute(t, e)
                }
                _removeAttribute(t) {
                    this._selection.removeAttribute(t)
                }
                _getStoredAttributes() {
                    return this._selection.getStoredAttributes()
                }
                _overrideGravity() {
                    return this._selection.overrideGravity()
                }
                _restoreGravity(t) {
                    this._selection.restoreGravity(t)
                }
                static _getStoreAttributeKey(t) {
                    return ih + t
                }
                static _isStoreAttributeKey(t) {
                    return t.startsWith(ih)
                }
            }
            rh.prototype.is = function(t) {
                return "selection" === t || "model:selection" == t || "documentSelection" == t || "model:documentSelection" == t
            };
            class sh extends Qd {
                constructor(t) {
                    super(), this.markers = new ur({
                        idProperty: "name"
                    }), this._attributePriority = new Map, this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = new Set, this._observedMarkers = new Set, this._model = t.model, this._document = t, this.listenTo(this._model, "applyOperation", ((t, e) => {
                        const n = e[0];
                        n.isDocumentOperation && "marker" != n.type && "rename" != n.type && "noop" != n.type && (0 == this._ranges.length && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", {
                            directChange: !1
                        })))
                    }), {
                        priority: "lowest"
                    }), this.on("change:range", (() => {
                        this._validateSelectionRanges(this.getRanges())
                    })), this.listenTo(this._model.markers, "update", ((t, e, n, o) => {
                        this._updateMarker(e, o)
                    })), this.listenTo(this._document, "change", ((t, e) => {
                        ! function(t, e) {
                            const n = t.document.differ;
                            for (const o of n.getChanges()) {
                                if ("insert" != o.type) continue;
                                const n = o.position.parent;
                                o.length === n.maxOffset && t.enqueueChange(e, (t => {
                                    const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(ih)));
                                    for (const o of e) t.removeAttribute(o, n)
                                }))
                            }
                        }(this._model, e)
                    }))
                }
                get isCollapsed() {
                    return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
                }
                get anchor() {
                    return super.anchor || this._document._getDefaultRange().start
                }
                get focus() {
                    return super.focus || this._document._getDefaultRange().end
                }
                get rangeCount() {
                    return this._ranges.length ? this._ranges.length : 1
                }
                get hasOwnRange() {
                    return this._ranges.length > 0
                }
                get isGravityOverridden() {
                    return !!this._overriddenGravityRegister.size
                }
                destroy() {
                    for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
                    this.stopListening()
                }* getRanges() {
                    this._ranges.length ? yield* super.getRanges(): yield this._document._getDefaultRange()
                }
                getFirstRange() {
                    return super.getFirstRange() || this._document._getDefaultRange()
                }
                getLastRange() {
                    return super.getLastRange() || this._document._getDefaultRange()
                }
                setTo(...t) {
                    super.setTo(...t), this._updateAttributes(!0), this.updateMarkers()
                }
                setFocus(t, e) {
                    super.setFocus(t, e), this._updateAttributes(!0), this.updateMarkers()
                }
                setAttribute(t, e) {
                    if (this._setAttribute(t, e)) {
                        const e = [t];
                        this.fire("change:attribute", {
                            attributeKeys: e,
                            directChange: !0
                        })
                    }
                }
                removeAttribute(t) {
                    if (this._removeAttribute(t)) {
                        const e = [t];
                        this.fire("change:attribute", {
                            attributeKeys: e,
                            directChange: !0
                        })
                    }
                }
                overrideGravity() {
                    const t = k();
                    return this._overriddenGravityRegister.add(t), 1 === this._overriddenGravityRegister.size && this._updateAttributes(!0), t
                }
                restoreGravity(t) {
                    if (!this._overriddenGravityRegister.has(t)) throw new A("document-selection-gravity-wrong-restore", this, {
                        uid: t
                    });
                    this._overriddenGravityRegister.delete(t), this.isGravityOverridden || this._updateAttributes(!0)
                }
                observeMarkers(t) {
                    this._observedMarkers.add(t), this.updateMarkers()
                }
                _replaceAllRanges(t) {
                    this._validateSelectionRanges(t), super._replaceAllRanges(t)
                }
                _popRange() {
                    this._ranges.pop().detach()
                }
                _pushRange(t) {
                    const e = this._prepareRange(t);
                    e && this._ranges.push(e)
                }
                _validateSelectionRanges(t) {
                    for (const e of t)
                        if (!this._document._validateSelectionRange(e)) throw new A("document-selection-wrong-position", this, {
                            range: e
                        })
                }
                _prepareRange(t) {
                    if (this._checkRange(t), t.root == this._document.graveyard) return;
                    const e = eh.fromRange(t);
                    return e.on("change:range", ((t, n, o) => {
                        if (this._hasChangedRange = !0, e.root == this._document.graveyard) {
                            this._selectionRestorePosition = o.deletionPosition;
                            const t = this._ranges.indexOf(e);
                            this._ranges.splice(t, 1), e.detach()
                        }
                    })), e
                }
                updateMarkers() {
                    if (!this._observedMarkers.size) return;
                    const t = [];
                    let e = !1;
                    for (const e of this._model.markers) {
                        const n = e.name.split(":", 1)[0];
                        if (!this._observedMarkers.has(n)) continue;
                        const o = e.getRange();
                        for (const n of this.getRanges()) o.containsRange(n, !n.isCollapsed) && t.push(e)
                    }
                    const n = Array.from(this.markers);
                    for (const n of t) this.markers.has(n) || (this.markers.add(n), e = !0);
                    for (const n of Array.from(this.markers)) t.includes(n) || (this.markers.remove(n), e = !0);
                    e && this.fire("change:marker", {
                        oldMarkers: n,
                        directChange: !1
                    })
                }
                _updateMarker(t, e) {
                    const n = t.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(n)) return;
                    let o = !1;
                    const i = Array.from(this.markers),
                        r = this.markers.has(t);
                    if (e) {
                        let n = !1;
                        for (const t of this.getRanges())
                            if (e.containsRange(t, !t.isCollapsed)) {
                                n = !0;
                                break
                            } n && !r ? (this.markers.add(t), o = !0) : !n && r && (this.markers.remove(t), o = !0)
                    } else r && (this.markers.remove(t), o = !0);
                    o && this.fire("change:marker", {
                        oldMarkers: i,
                        directChange: !1
                    })
                }
                _updateAttributes(t) {
                    const e = fr(this._getSurroundingAttributes()),
                        n = fr(this.getAttributes());
                    if (t) this._attributePriority = new Map, this._attrs = new Map;
                    else
                        for (const [t, e] of this._attributePriority) "low" == e && (this._attrs.delete(t), this._attributePriority.delete(t));
                    this._setAttributesTo(e);
                    const o = [];
                    for (const [t, e] of this.getAttributes()) n.has(t) && n.get(t) === e || o.push(t);
                    for (const [t] of n) this.hasAttribute(t) || o.push(t);
                    o.length > 0 && this.fire("change:attribute", {
                        attributeKeys: o,
                        directChange: !1
                    })
                }
                _setAttribute(t, e, n = !0) {
                    const o = n ? "normal" : "low";
                    if ("low" == o && "normal" == this._attributePriority.get(t)) return !1;
                    return super.getAttribute(t) !== e && (this._attrs.set(t, e), this._attributePriority.set(t, o), !0)
                }
                _removeAttribute(t, e = !0) {
                    const n = e ? "normal" : "low";
                    return ("low" != n || "normal" != this._attributePriority.get(t)) && (this._attributePriority.set(t, n), !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
                }
                _setAttributesTo(t) {
                    const e = new Set;
                    for (const [e, n] of this.getAttributes()) t.get(e) !== n && this._removeAttribute(e, !1);
                    for (const [n, o] of t) {
                        this._setAttribute(n, o, !1) && e.add(n)
                    }
                    return e
                }* getStoredAttributes() {
                    const t = this.getFirstPosition().parent;
                    if (this.isCollapsed && t.isEmpty)
                        for (const e of t.getAttributeKeys())
                            if (e.startsWith(ih)) {
                                const n = e.substr(ih.length);
                                yield [n, t.getAttribute(e)]
                            }
                }
                _getSurroundingAttributes() {
                    const t = this.getFirstPosition(),
                        e = this._model.schema;
                    let n = null;
                    if (this.isCollapsed) {
                        const o = t.textNode ? t.textNode : t.nodeBefore,
                            i = t.textNode ? t.textNode : t.nodeAfter;
                        if (this.isGravityOverridden || (n = ah(o)), n || (n = ah(i)), !this.isGravityOverridden && !n) {
                            let t = o;
                            for (; t && !e.isInline(t) && !n;) t = t.previousSibling, n = ah(t)
                        }
                        if (!n) {
                            let t = i;
                            for (; t && !e.isInline(t) && !n;) t = t.nextSibling, n = ah(t)
                        }
                        n || (n = this.getStoredAttributes())
                    } else {
                        const t = this.getFirstRange();
                        for (const o of t) {
                            if (o.item.is("element") && e.isObject(o.item)) break;
                            if ("text" == o.type) {
                                n = o.item.getAttributes();
                                break
                            }
                        }
                    }
                    return n
                }
                _fixGraveyardSelection(t) {
                    const e = this._model.schema.getNearestSelectionRange(t);
                    e && this._pushRange(e)
                }
            }
    
            function ah(t) {
                return t instanceof Bd || t instanceof Nd ? t.getAttributes() : null
            }
            class ch {
                constructor(t) {
                    this._dispatchers = t
                }
                add(t) {
                    for (const e of this._dispatchers) t(e);
                    return this
                }
            }
            var lh = 1,
                dh = 4;
            const hh = function(t) {
                return ci(t, lh | dh)
            };
            class uh extends ch {
                elementToElement(t) {
                    return this.add(function(t) {
                        const e = ph(t.model),
                            n = fh(t.view, "container");
                        e.attributes.length && (e.children = !0);
                        return o => {
                            o.on(`insert:${e.name}`, function(t, e = yh) {
                                return (n, o, i) => {
                                    if (!e(o.item, i.consumable, {
                                            preflight: !0
                                        })) return;
                                    const r = t(o.item, i, o);
                                    if (!r) return;
                                    e(o.item, i.consumable);
                                    const s = i.mapper.toViewPosition(o.range.start);
                                    i.mapper.bindElements(o.item, r), i.writer.insert(s, r), i.convertAttributes(o.item), Ch(r, o.item.getChildren(), i, {
                                        reconversion: o.reconversion
                                    })
                                }
                            }(n, Ah(e)), {
                                priority: t.converterPriority || "normal"
                            }), (e.children || e.attributes.length) && o.on("reduceChanges", _h(e), {
                                priority: "low"
                            })
                        }
                    }(t))
                }
                elementToStructure(t) {
                    return this.add(function(t) {
                        const e = ph(t.model),
                            n = fh(t.view, "container");
                        return e.children = !0, o => {
                            if (o._conversionApi.schema.checkChild(e.name, "$text")) throw new A("conversion-element-to-structure-disallowed-text", o, {
                                elementName: e.name
                            });
                            var i, r;
                            o.on(`insert:${e.name}`, (i = n, r = Ah(e), (t, e, n) => {
                                if (!r(e.item, n.consumable, {
                                        preflight: !0
                                    })) return;
                                const o = new Map;
                                n.writer._registerSlotFactory(function(t, e, n) {
                                    return (o, i = "children") => {
                                        const r = o.createContainerElement("$slot");
                                        let s = null;
                                        if ("children" === i) s = Array.from(t.getChildren());
                                        else {
                                            if ("function" != typeof i) throw new A("conversion-slot-mode-unknown", n.dispatcher, {
                                                modeOrFilter: i
                                            });
                                            s = Array.from(t.getChildren()).filter((t => i(t)))
                                        }
                                        return e.set(r, s), r
                                    }
                                }(e.item, o, n));
                                const s = i(e.item, n, e);
                                if (n.writer._clearSlotFactory(), !s) return;
                                ! function(t, e, n) {
                                    const o = Array.from(e.values()).flat(),
                                        i = new Set(o);
                                    if (i.size != o.length) throw new A("conversion-slot-filter-overlap", n.dispatcher, {
                                        element: t
                                    });
                                    if (i.size != t.childCount) throw new A("conversion-slot-filter-incomplete", n.dispatcher, {
                                        element: t
                                    })
                                }(e.item, o, n), r(e.item, n.consumable);
                                const a = n.mapper.toViewPosition(e.range.start);
                                n.mapper.bindElements(e.item, s), n.writer.insert(a, s), n.convertAttributes(e.item),
                                    function(t, e, n, o) {
                                        n.mapper.on("modelToViewPosition", s, {
                                            priority: "highest"
                                        });
                                        let i = null,
                                            r = null;
                                        for ([i, r] of e) Ch(t, r, n, o), n.writer.move(n.writer.createRangeIn(i), n.writer.createPositionBefore(i)), n.writer.remove(i);
    
                                        function s(t, e) {
                                            const n = e.modelPosition.nodeAfter,
                                                o = r.indexOf(n);
                                            o < 0 || (e.viewPosition = e.mapper.findPositionIn(i, o))
                                        }
                                        n.mapper.off("modelToViewPosition", s)
                                    }(s, o, n, {
                                        reconversion: e.reconversion
                                    })
                            }), {
                                priority: t.converterPriority || "normal"
                            }), o.on("reduceChanges", _h(e), {
                                priority: "low"
                            })
                        }
                    }(t))
                }
                attributeToElement(t) {
                    return this.add(function(t) {
                        t = hh(t);
                        let e = t.model;
                        "string" == typeof e && (e = {
                            key: e
                        });
                        let n = `attribute:${e.key}`;
                        e.name && (n += ":" + e.name);
                        if (e.values)
                            for (const n of e.values) t.view[n] = fh(t.view[n], "attribute");
                        else t.view = fh(t.view, "attribute");
                        const o = kh(t);
                        return e => {
                            e.on(n, function(t) {
                                return (e, n, o) => {
                                    if (!o.consumable.test(n.item, e.name)) return;
                                    const i = t(n.attributeOldValue, o, n),
                                        r = t(n.attributeNewValue, o, n);
                                    if (!i && !r) return;
                                    o.consumable.consume(n.item, e.name);
                                    const s = o.writer,
                                        a = s.document.selection;
                                    if (n.item instanceof Qd || n.item instanceof rh) s.wrap(a.getFirstRange(), r);
                                    else {
                                        let t = o.mapper.toViewRange(n.range);
                                        null !== n.attributeOldValue && i && (t = s.unwrap(t, i)), null !== n.attributeNewValue && r && s.wrap(t, r)
                                    }
                                }
                            }(o), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(t))
                }
                attributeToAttribute(t) {
                    return this.add(function(t) {
                        t = hh(t);
                        let e = t.model;
                        "string" == typeof e && (e = {
                            key: e
                        });
                        let n = `attribute:${e.key}`;
                        e.name && (n += ":" + e.name);
                        if (e.values)
                            for (const n of e.values) t.view[n] = bh(t.view[n]);
                        else t.view = bh(t.view);
                        const o = kh(t);
                        return e => {
                            var i;
                            e.on(n, (i = o, (t, e, n) => {
                                if (!n.consumable.test(e.item, t.name)) return;
                                const o = i(e.attributeOldValue, n, e),
                                    r = i(e.attributeNewValue, n, e);
                                if (!o && !r) return;
                                n.consumable.consume(e.item, t.name);
                                const s = n.mapper.toViewElement(e.item),
                                    a = n.writer;
                                if (!s) throw new A("conversion-attribute-to-attribute-on-text", n.dispatcher, e);
                                if (null !== e.attributeOldValue && o)
                                    if ("class" == o.key) {
                                        const t = ar(o.value);
                                        for (const e of t) a.removeClass(e, s)
                                    } else if ("style" == o.key) {
                                    const t = Object.keys(o.value);
                                    for (const e of t) a.removeStyle(e, s)
                                } else a.removeAttribute(o.key, s);
                                if (null !== e.attributeNewValue && r)
                                    if ("class" == r.key) {
                                        const t = ar(r.value);
                                        for (const e of t) a.addClass(e, s)
                                    } else if ("style" == r.key) {
                                    const t = Object.keys(r.value);
                                    for (const e of t) a.setStyle(e, r.value[e], s)
                                } else a.setAttribute(r.key, r.value, s)
                            }), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(t))
                }
                markerToElement(t) {
                    return this.add(function(t) {
                        const e = fh(t.view, "ui");
                        return n => {
                            var o;
                            n.on(`addMarker:${t.model}`, (o = e, (t, e, n) => {
                                e.isOpening = !0;
                                const i = o(e, n);
                                e.isOpening = !1;
                                const r = o(e, n);
                                if (!i || !r) return;
                                const s = e.markerRange;
                                if (s.isCollapsed && !n.consumable.consume(s, t.name)) return;
                                for (const e of s)
                                    if (!n.consumable.consume(e.item, t.name)) return;
                                const a = n.mapper,
                                    c = n.writer;
                                c.insert(a.toViewPosition(s.start), i), n.mapper.bindElementToMarker(i, e.markerName), s.isCollapsed || (c.insert(a.toViewPosition(s.end), r), n.mapper.bindElementToMarker(r, e.markerName)), t.stop()
                            }), {
                                priority: t.converterPriority || "normal"
                            }), n.on(`removeMarker:${t.model}`, ((t, e, n) => {
                                const o = n.mapper.markerNameToElements(e.markerName);
                                if (o) {
                                    for (const t of o) n.mapper.unbindElementFromMarkerName(t, e.markerName), n.writer.clear(n.writer.createRangeOn(t), t);
                                    n.writer.clearClonedElementsGroup(e.markerName), t.stop()
                                }
                            }), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(t))
                }
                markerToHighlight(t) {
                    return this.add(function(t) {
                        return e => {
                            var n;
                            e.on(`addMarker:${t.model}`, (n = t.view, (t, e, o) => {
                                if (!e.item) return;
                                if (!(e.item instanceof Qd || e.item instanceof rh || e.item.is("$textProxy"))) return;
                                const i = wh(n, e, o);
                                if (!i) return;
                                if (!o.consumable.consume(e.item, t.name)) return;
                                const r = o.writer,
                                    s = gh(r, i),
                                    a = r.document.selection;
                                if (e.item instanceof Qd || e.item instanceof rh) r.wrap(a.getFirstRange(), s);
                                else {
                                    const t = o.mapper.toViewRange(e.range),
                                        n = r.wrap(t, s);
                                    for (const t of n.getItems())
                                        if (t.is("attributeElement") && t.isSimilar(s)) {
                                            o.mapper.bindElementToMarker(t, e.markerName);
                                            break
                                        }
                                }
                            }), {
                                priority: t.converterPriority || "normal"
                            }), e.on(`addMarker:${t.model}`, function(t) {
                                return (e, n, o) => {
                                    if (!n.item) return;
                                    if (!(n.item instanceof Pd)) return;
                                    const i = wh(t, n, o);
                                    if (!i) return;
                                    if (!o.consumable.test(n.item, e.name)) return;
                                    const r = o.mapper.toViewElement(n.item);
                                    if (r && r.getCustomProperty("addHighlight")) {
                                        o.consumable.consume(n.item, e.name);
                                        for (const t of Ud._createIn(n.item)) o.consumable.consume(t.item, e.name);
                                        r.getCustomProperty("addHighlight")(r, i, o.writer), o.mapper.bindElementToMarker(r, n.markerName)
                                    }
                                }
                            }(t.view), {
                                priority: t.converterPriority || "normal"
                            }), e.on(`removeMarker:${t.model}`, function(t) {
                                return (e, n, o) => {
                                    if (n.markerRange.isCollapsed) return;
                                    const i = wh(t, n, o);
                                    if (!i) return;
                                    const r = gh(o.writer, i),
                                        s = o.mapper.markerNameToElements(n.markerName);
                                    if (s) {
                                        for (const t of s)
                                            if (o.mapper.unbindElementFromMarkerName(t, n.markerName), t.is("attributeElement")) o.writer.unwrap(o.writer.createRangeOn(t), r);
                                            else {
                                                t.getCustomProperty("removeHighlight")(t, i.id, o.writer)
                                            } o.writer.clearClonedElementsGroup(n.markerName), e.stop()
                                    }
                                }
                            }(t.view), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(t))
                }
                markerToData(t) {
                    return this.add(function(t) {
                        t = hh(t);
                        const e = t.model;
                        let n = t.view;
                        n || (n = n => ({
                            group: e,
                            name: n.substr(t.model.length + 1)
                        }));
                        return o => {
                            var i;
                            o.on(`addMarker:${e}`, (i = n, (t, e, n) => {
                                const o = i(e.markerName, n);
                                if (!o) return;
                                const r = e.markerRange;
                                n.consumable.consume(r, t.name) && (mh(r, !1, n, e, o), mh(r, !0, n, e, o), t.stop())
                            }), {
                                priority: t.converterPriority || "normal"
                            }), o.on(`removeMarker:${e}`, function(t) {
                                return (e, n, o) => {
                                    const i = t(n.markerName, o);
                                    if (!i) return;
                                    const r = o.mapper.markerNameToElements(n.markerName);
                                    if (r) {
                                        for (const t of r) o.mapper.unbindElementFromMarkerName(t, n.markerName), t.is("containerElement") ? (s(`data-${i.group}-start-before`, t), s(`data-${i.group}-start-after`, t), s(`data-${i.group}-end-before`, t), s(`data-${i.group}-end-after`, t)) : o.writer.clear(o.writer.createRangeOn(t), t);
                                        o.writer.clearClonedElementsGroup(n.markerName), e.stop()
                                    }
    
                                    function s(t, e) {
                                        if (e.hasAttribute(t)) {
                                            const n = new Set(e.getAttribute(t).split(","));
                                            n.delete(i.name), 0 == n.size ? o.writer.removeAttribute(t, e) : o.writer.setAttribute(t, Array.from(n).join(","), e)
                                        }
                                    }
                                }
                            }(n), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(t))
                }
            }
    
            function gh(t, e) {
                const n = t.createAttributeElement("span", e.attributes);
                return e.classes && n._addClass(e.classes), "number" == typeof e.priority && (n._priority = e.priority), n._id = e.id, n
            }
    
            function mh(t, e, n, o, i) {
                const r = e ? t.start : t.end,
                    s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null,
                    a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
                if (s || a) {
                    let t, r;
                    e && s || !e && !a ? (t = s, r = !0) : (t = a, r = !1);
                    const c = n.mapper.toViewElement(t);
                    if (c) return void
                    function(t, e, n, o, i, r) {
                        const s = `data-${r.group}-${e?"start":"end"}-${n?"before":"after"}`,
                            a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
                        a.unshift(r.name), o.writer.setAttribute(s, a.join(","), t), o.mapper.bindElementToMarker(t, i.markerName)
                    }(c, e, r, n, o, i)
                }! function(t, e, n, o, i) {
                    const r = `${i.group}-${e?"start":"end"}`,
                        s = i.name ? {
                            name: i.name
                        } : null,
                        a = n.writer.createUIElement(r, s);
                    n.writer.insert(t, a), n.mapper.bindElementToMarker(a, o.markerName)
                }(n.mapper.toViewPosition(r), e, n, o, i)
            }
    
            function ph(t) {
                return "string" == typeof t && (t = {
                    name: t
                }), t.attributes ? Array.isArray(t.attributes) || (t.attributes = [t.attributes]) : t.attributes = [], t.children = !!t.children, t
            }
    
            function fh(t, e) {
                return "function" == typeof t ? t : (n, o) => function(t, e, n) {
                    "string" == typeof t && (t = {
                        name: t
                    });
                    let o;
                    const i = e.writer,
                        r = Object.assign({}, t.attributes);
                    if ("container" == n) o = i.createContainerElement(t.name, r);
                    else if ("attribute" == n) {
                        const e = {
                            priority: t.priority || bc.DEFAULT_PRIORITY
                        };
                        o = i.createAttributeElement(t.name, r, e)
                    } else o = i.createUIElement(t.name, r);
                    if (t.styles) {
                        const e = Object.keys(t.styles);
                        for (const n of e) i.setStyle(n, t.styles[n], o)
                    }
                    if (t.classes) {
                        const e = t.classes;
                        if ("string" == typeof e) i.addClass(e, o);
                        else
                            for (const t of e) i.addClass(t, o)
                    }
                    return o
                }(t, o, e)
            }
    
            function kh(t) {
                return t.model.values ? (e, n, o) => {
                    const i = t.view[e];
                    return i ? i(e, n, o) : null
                } : t.view
            }
    
            function bh(t) {
                return "string" == typeof t ? e => ({
                    key: t,
                    value: e
                }) : "object" == typeof t ? t.value ? () => t : e => ({
                    key: t.key,
                    value: e
                }) : t
            }
    
            function wh(t, e, n) {
                const o = "function" == typeof t ? t(e, n) : t;
                return o ? (o.priority || (o.priority = 10), o.id || (o.id = e.markerName), o) : null
            }
    
            function _h(t) {
                const e = function(t) {
                    return (e, n) => {
                        if (!e.is("element", t.name)) return !1;
                        if ("attribute" == n.type) {
                            if (t.attributes.includes(n.attributeKey)) return !0
                        } else if (t.children) return !0;
                        return !1
                    }
                }(t);
                return (t, n) => {
                    const o = [];
                    n.reconvertedElements || (n.reconvertedElements = new Set);
                    for (const t of n.changes) {
                        const i = "attribute" == t.type ? t.range.start.nodeAfter : t.position.parent;
                        if (i && e(i, t)) {
                            if (!n.reconvertedElements.has(i)) {
                                n.reconvertedElements.add(i);
                                const t = Od._createBefore(i);
                                o.push({
                                    type: "remove",
                                    name: i.name,
                                    position: t,
                                    length: 1
                                }, {
                                    type: "reinsert",
                                    name: i.name,
                                    position: t,
                                    length: 1
                                })
                            }
                        } else o.push(t)
                    }
                    n.changes = o
                }
            }
    
            function Ah(t) {
                return (e, n, o = {}) => {
                    const i = ["insert"];
                    for (const n of t.attributes) e.hasAttribute(n) && i.push(`attribute:${n}`);
                    return !!i.every((t => n.test(e, t))) && (o.preflight || i.forEach((t => n.consume(e, t))), !0)
                }
            }
    
            function Ch(t, e, n, o) {
                for (const i of e) vh(t.root, i, n, o) || n.convertItem(i)
            }
    
            function vh(t, e, n, o) {
                const {
                    writer: i,
                    mapper: r
                } = n;
                if (!o.reconversion) return !1;
                const s = r.toViewElement(e);
                return !(!s || s.root == t) && (!!n.canReuseView(s) && (i.move(i.createRangeOn(s), r.toViewPosition(Od._createBefore(e))), !0))
            }
    
            function yh(t, e, {
                preflight: n
            } = {}) {
                return n ? e.test(t, "insert") : e.consume(t, "insert")
            }
    
            function xh(t) {
                const {
                    schema: e,
                    document: n
                } = t.model;
                for (const o of n.getRootNames()) {
                    const i = n.getRoot(o);
                    if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph")) return t.insertElement("paragraph", i), !0
                }
                return !1
            }
    
            function Eh(t, e, n) {
                const o = n.createContext(t);
                return !!n.checkChild(o, "paragraph") && !!n.checkChild(o.push("paragraph"), e)
            }
    
            function Dh(t, e) {
                const n = e.createElement("paragraph");
                return e.insert(n, t), e.createPositionAt(n, 0)
            }
            class Ih extends ch {
                elementToElement(t) {
                    return this.add(Th(t))
                }
                elementToAttribute(t) {
                    return this.add(function(t) {
                        t = hh(t), Nh(t);
                        const e = Bh(t, !1),
                            n = Mh(t.view),
                            o = n ? `element:${n}` : "element";
                        return n => {
                            n.on(o, e, {
                                priority: t.converterPriority || "low"
                            })
                        }
                    }(t))
                }
                attributeToAttribute(t) {
                    return this.add(function(t) {
                        t = hh(t);
                        let e = null;
                        ("string" == typeof t.view || t.view.key) && (e = function(t) {
                            "string" == typeof t.view && (t.view = {
                                key: t.view
                            });
                            const e = t.view.key;
                            let n;
                            if ("class" == e || "style" == e) {
                                n = {
                                    ["class" == e ? "classes" : "styles"]: t.view.value
                                }
                            } else {
                                n = {
                                    attributes: {
                                        [e]: void 0 === t.view.value ? /[\s\S]*/ : t.view.value
                                    }
                                }
                            }
                            t.view.name && (n.name = t.view.name);
                            return t.view = n, e
                        }(t));
                        Nh(t, e);
                        const n = Bh(t, !0);
                        return e => {
                            e.on("element", n, {
                                priority: t.converterPriority || "low"
                            })
                        }
                    }(t))
                }
                elementToMarker(t) {
                    return this.add(function(t) {
                        const e = function(t) {
                            return (e, n) => {
                                const o = "string" == typeof t ? t : t(e, n);
                                return n.writer.createElement("$marker", {
                                    "data-name": o
                                })
                            }
                        }(t.model);
                        return Th({
                            ...t,
                            model: e
                        })
                    }(t))
                }
                dataToMarker(t) {
                    return this.add(function(t) {
                        t = hh(t), t.model || (t.model = e => e ? t.view + ":" + e : t.view);
                        const e = {
                                view: t.view,
                                model: t.model
                            },
                            n = Sh(Ph(e, "start")),
                            o = Sh(Ph(e, "end"));
                        return i => {
                            i.on(`element:${t.view}-start`, n, {
                                priority: t.converterPriority || "normal"
                            }), i.on(`element:${t.view}-end`, o, {
                                priority: t.converterPriority || "normal"
                            });
                            const r = b.get("low"),
                                s = b.get("highest"),
                                a = b.get(t.converterPriority) / s;
                            i.on("element", function(t) {
                                return (e, n, o) => {
                                    const i = `data-${t.view}`;
    
                                    function r(e, i) {
                                        for (const r of i) {
                                            const i = t.model(r, o),
                                                s = o.writer.createElement("$marker", {
                                                    "data-name": i
                                                });
                                            o.writer.insert(s, e), n.modelCursor.isEqual(e) ? n.modelCursor = n.modelCursor.getShiftedBy(1) : n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1), n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
                                        }
                                    }(o.consumable.test(n.viewItem, {
                                        attributes: i + "-end-after"
                                    }) || o.consumable.test(n.viewItem, {
                                        attributes: i + "-start-after"
                                    }) || o.consumable.test(n.viewItem, {
                                        attributes: i + "-end-before"
                                    }) || o.consumable.test(n.viewItem, {
                                        attributes: i + "-start-before"
                                    })) && (n.modelRange || Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor)), o.consumable.consume(n.viewItem, {
                                        attributes: i + "-end-after"
                                    }) && r(n.modelRange.end, n.viewItem.getAttribute(i + "-end-after").split(",")), o.consumable.consume(n.viewItem, {
                                        attributes: i + "-start-after"
                                    }) && r(n.modelRange.end, n.viewItem.getAttribute(i + "-start-after").split(",")), o.consumable.consume(n.viewItem, {
                                        attributes: i + "-end-before"
                                    }) && r(n.modelRange.start, n.viewItem.getAttribute(i + "-end-before").split(",")), o.consumable.consume(n.viewItem, {
                                        attributes: i + "-start-before"
                                    }) && r(n.modelRange.start, n.viewItem.getAttribute(i + "-start-before").split(",")))
                                }
                            }(e), {
                                priority: r + a
                            })
                        }
                    }(t))
                }
            }
    
            function Th(t) {
                const e = Sh(t = hh(t)),
                    n = Mh(t.view),
                    o = n ? `element:${n}` : "element";
                return n => {
                    n.on(o, e, {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
    
            function Mh(t) {
                return "string" == typeof t ? t : "object" == typeof t && "string" == typeof t.name ? t.name : null
            }
    
            function Sh(t) {
                const e = new qs(t.view);
                return (n, o, i) => {
                    const r = e.match(o.viewItem);
                    if (!r) return;
                    const s = r.match;
                    if (s.name = !0, !i.consumable.test(o.viewItem, s)) return;
                    const a = function(t, e, n) {
                        return t instanceof Function ? t(e, n) : n.writer.createElement(t)
                    }(t.model, o.viewItem, i);
                    a && i.safeInsert(a, o.modelCursor) && (i.consumable.consume(o.viewItem, s), i.convertChildren(o.viewItem, a), i.updateConversionResult(a, o))
                }
            }
    
            function Nh(t, e = null) {
                const n = null === e || (t => t.getAttribute(e)),
                    o = "object" != typeof t.model ? t.model : t.model.key,
                    i = "object" != typeof t.model || void 0 === t.model.value ? n : t.model.value;
                t.model = {
                    key: o,
                    value: i
                }
            }
    
            function Bh(t, e) {
                const n = new qs(t.view);
                return (o, i, r) => {
                    if (!i.modelRange && e) return;
                    const s = n.match(i.viewItem);
                    if (!s) return;
                    if (! function(t, e) {
                            const n = "function" == typeof t ? t(e) : t;
                            if ("object" == typeof n && !Mh(n)) return !1;
                            return !n.classes && !n.attributes && !n.styles
                        }(t.view, i.viewItem) ? delete s.match.name : s.match.name = !0, !r.consumable.test(i.viewItem, s.match)) return;
                    const a = t.model.key,
                        c = "function" == typeof t.model.value ? t.model.value(i.viewItem, r) : t.model.value;
                    if (null === c) return;
                    i.modelRange || Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
                    const l = function(t, e, n, o) {
                        let i = !1;
                        for (const r of Array.from(t.getItems({
                                shallow: n
                            }))) o.schema.checkAttribute(r, e.key) && (i = !0, r.hasAttribute(e.key) || o.writer.setAttribute(e.key, e.value, r));
                        return i
                    }(i.modelRange, {
                        key: a,
                        value: c
                    }, e, r);
                    l && (r.consumable.test(i.viewItem, {
                        name: !0
                    }) && (s.match.name = !0), r.consumable.consume(i.viewItem, s.match))
                }
            }
    
            function Ph(t, e) {
                return {
                    view: `${t.view}-${e}`,
                    model: (e, n) => {
                        const o = e.getAttribute("name"),
                            i = t.model(o, n);
                        return n.writer.createElement("$marker", {
                            "data-name": i
                        })
                    }
                }
            }
            class zh extends($()) {
                constructor(t, e) {
                    super(), this.model = t, this.view = new Id(e), this.mapper = new Wd, this.downcastDispatcher = new $d({
                        mapper: this.mapper,
                        schema: t.schema
                    });
                    const n = this.model.document,
                        o = n.selection,
                        i = this.model.markers;
                    this.listenTo(this.model, "_beforeChanges", (() => {
                        this.view._disableRendering(!0)
                    }), {
                        priority: "highest"
                    }), this.listenTo(this.model, "_afterChanges", (() => {
                        this.view._disableRendering(!1)
                    }), {
                        priority: "lowest"
                    }), this.listenTo(n, "change", (() => {
                        this.view.change((t => {
                            this.downcastDispatcher.convertChanges(n.differ, i, t), this.downcastDispatcher.convertSelection(o, i, t)
                        }))
                    }), {
                        priority: "low"
                    }), this.listenTo(this.view.document, "selectionChange", function(t, e) {
                        return (n, o) => {
                            const i = o.newSelection,
                                r = [];
                            for (const t of i.getRanges()) r.push(e.toModelRange(t));
                            const s = t.createSelection(r, {
                                backward: i.isBackward
                            });
                            s.isEqual(t.document.selection) || t.change((t => {
                                t.setSelection(s)
                            }))
                        }
                    }(this.model, this.mapper)), this.downcastDispatcher.on("insert:$text", ((t, e, n) => {
                        if (!n.consumable.consume(e.item, t.name)) return;
                        const o = n.writer,
                            i = n.mapper.toViewPosition(e.range.start),
                            r = o.createText(e.item.data);
                        o.insert(i, r)
                    }), {
                        priority: "lowest"
                    }), this.downcastDispatcher.on("insert", ((t, e, n) => {
                        n.convertAttributes(e.item), e.reconversion || !e.item.is("element") || e.item.isEmpty || n.convertChildren(e.item)
                    }), {
                        priority: "lowest"
                    }), this.downcastDispatcher.on("remove", ((t, e, n) => {
                        const o = n.mapper.toViewPosition(e.position),
                            i = e.position.getShiftedBy(e.length),
                            r = n.mapper.toViewPosition(i, {
                                isPhantom: !0
                            }),
                            s = n.writer.createRange(o, r),
                            a = n.writer.remove(s.getTrimmed());
                        for (const t of n.writer.createRangeIn(a).getItems()) n.mapper.unbindViewElement(t, {
                            defer: !0
                        })
                    }), {
                        priority: "low"
                    }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                        const o = n.writer,
                            i = o.document.selection;
                        for (const t of i.getRanges()) t.isCollapsed && t.end.parent.isAttached() && n.writer.mergeAttributes(t.start);
                        o.setSelection(null)
                    }), {
                        priority: "high"
                    }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                        const o = e.selection;
                        if (o.isCollapsed) return;
                        if (!n.consumable.consume(o, "selection")) return;
                        const i = [];
                        for (const t of o.getRanges()) i.push(n.mapper.toViewRange(t));
                        n.writer.setSelection(i, {
                            backward: o.isBackward
                        })
                    }), {
                        priority: "low"
                    }), this.downcastDispatcher.on("selection", ((t, e, n) => {
                        const o = e.selection;
                        if (!o.isCollapsed) return;
                        if (!n.consumable.consume(o, "selection")) return;
                        const i = n.writer,
                            r = o.getFirstPosition(),
                            s = n.mapper.toViewPosition(r),
                            a = i.breakAttributes(s);
                        i.setSelection(a)
                    }), {
                        priority: "low"
                    }), this.view.document.roots.bindTo(this.model.document.roots).using((t => {
                        if ("$graveyard" == t.rootName) return null;
                        const e = new oc(this.view.document, t.name);
                        return e.rootName = t.rootName, this.mapper.bindElements(t, e), e
                    }))
                }
                destroy() {
                    this.view.destroy(), this.stopListening()
                }
                reconvertMarker(t) {
                    const e = "string" == typeof t ? t : t.name,
                        n = this.model.markers.get(e);
                    if (!n) throw new A("editingcontroller-reconvertmarker-marker-not-exist", this, {
                        markerName: e
                    });
                    this.model.change((() => {
                        this.model.markers._refresh(n)
                    }))
                }
                reconvertItem(t) {
                    this.model.change((() => {
                        this.model.document.differ._refreshItem(t)
                    }))
                }
            }
            class Lh {
                constructor() {
                    this._consumables = new Map
                }
                add(t, e) {
                    let n;
                    t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !0) : (this._consumables.has(t) ? n = this._consumables.get(t) : (n = new Rh(t), this._consumables.set(t, n)), n.add(e))
                }
                test(t, e) {
                    const n = this._consumables.get(t);
                    return void 0 === n ? null : t.is("$text") || t.is("documentFragment") ? n : n.test(e)
                }
                consume(t, e) {
                    return !!this.test(t, e) && (t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !1) : this._consumables.get(t).consume(e), !0)
                }
                revert(t, e) {
                    const n = this._consumables.get(t);
                    void 0 !== n && (t.is("$text") || t.is("documentFragment") ? this._consumables.set(t, !0) : n.revert(e))
                }
                static consumablesFromElement(t) {
                    const e = {
                            element: t,
                            name: !0,
                            attributes: [],
                            classes: [],
                            styles: []
                        },
                        n = t.getAttributeKeys();
                    for (const t of n) "style" != t && "class" != t && e.attributes.push(t);
                    const o = t.getClassNames();
                    for (const t of o) e.classes.push(t);
                    const i = t.getStyleNames();
                    for (const t of i) e.styles.push(t);
                    return e
                }
                static createFrom(t, e) {
                    if (e || (e = new Lh), t.is("$text")) return e.add(t), e;
                    t.is("element") && e.add(t, Lh.consumablesFromElement(t)), t.is("documentFragment") && e.add(t);
                    for (const n of t.getChildren()) e = Lh.createFrom(n, e);
                    return e
                }
            }
            const Oh = ["attributes", "classes", "styles"];
            class Rh {
                constructor(t) {
                    this.element = t, this._canConsumeName = null, this._consumables = {
                        attributes: new Map,
                        styles: new Map,
                        classes: new Map
                    }
                }
                add(t) {
                    t.name && (this._canConsumeName = !0);
                    for (const e of Oh) e in t && this._add(e, t[e])
                }
                test(t) {
                    if (t.name && !this._canConsumeName) return this._canConsumeName;
                    for (const e of Oh)
                        if (e in t) {
                            const n = this._test(e, t[e]);
                            if (!0 !== n) return n
                        } return !0
                }
                consume(t) {
                    t.name && (this._canConsumeName = !1);
                    for (const e of Oh) e in t && this._consume(e, t[e])
                }
                revert(t) {
                    t.name && (this._canConsumeName = !0);
                    for (const e of Oh) e in t && this._revert(e, t[e])
                }
                _add(t, e) {
                    const n = bt(e) ? e : [e],
                        o = this._consumables[t];
                    for (const e of n) {
                        if ("attributes" === t && ("class" === e || "style" === e)) throw new A("viewconsumable-invalid-attribute", this);
                        if (o.set(e, !0), "styles" === t)
                            for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !0)
                    }
                }
                _test(t, e) {
                    const n = bt(e) ? e : [e],
                        o = this._consumables[t];
                    for (const e of n)
                        if ("attributes" !== t || "class" !== e && "style" !== e) {
                            const t = o.get(e);
                            if (void 0 === t) return null;
                            if (!t) return !1
                        } else {
                            const t = "class" == e ? "classes" : "styles",
                                n = this._test(t, [...this._consumables[t].keys()]);
                            if (!0 !== n) return n
                        } return !0
                }
                _consume(t, e) {
                    const n = bt(e) ? e : [e],
                        o = this._consumables[t];
                    for (const e of n)
                        if ("attributes" !== t || "class" !== e && "style" !== e) {
                            if (o.set(e, !1), "styles" == t)
                                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) o.set(t, !1)
                        } else {
                            const t = "class" == e ? "classes" : "styles";
                            this._consume(t, [...this._consumables[t].keys()])
                        }
                }
                _revert(t, e) {
                    const n = bt(e) ? e : [e],
                        o = this._consumables[t];
                    for (const e of n)
                        if ("attributes" !== t || "class" !== e && "style" !== e) {
                            !1 === o.get(e) && o.set(e, !0)
                        } else {
                            const t = "class" == e ? "classes" : "styles";
                            this._revert(t, [...this._consumables[t].keys()])
                        }
                }
            }
            class jh extends($()) {
                constructor() {
                    super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", ((t, e) => {
                        e[0] = new Fh(e[0])
                    }), {
                        priority: "highest"
                    }), this.on("checkChild", ((t, e) => {
                        e[0] = new Fh(e[0]), e[1] = this.getDefinition(e[1])
                    }), {
                        priority: "highest"
                    })
                }
                register(t, e) {
                    if (this._sourceDefinitions[t]) throw new A("schema-cannot-register-item-twice", this, {
                        itemName: t
                    });
                    this._sourceDefinitions[t] = [Object.assign({}, e)], this._clearCache()
                }
                extend(t, e) {
                    if (!this._sourceDefinitions[t]) throw new A("schema-cannot-extend-missing-item", this, {
                        itemName: t
                    });
                    this._sourceDefinitions[t].push(Object.assign({}, e)), this._clearCache()
                }
                getDefinitions() {
                    return this._compiledDefinitions || this._compile(), this._compiledDefinitions
                }
                getDefinition(t) {
                    let e;
                    return e = "string" == typeof t ? t : "is" in t && (t.is("$text") || t.is("$textProxy")) ? "$text" : t.name, this.getDefinitions()[e]
                }
                isRegistered(t) {
                    return !!this.getDefinition(t)
                }
                isBlock(t) {
                    const e = this.getDefinition(t);
                    return !(!e || !e.isBlock)
                }
                isLimit(t) {
                    const e = this.getDefinition(t);
                    return !!e && !(!e.isLimit && !e.isObject)
                }
                isObject(t) {
                    const e = this.getDefinition(t);
                    return !!e && !!(e.isObject || e.isLimit && e.isSelectable && e.isContent)
                }
                isInline(t) {
                    const e = this.getDefinition(t);
                    return !(!e || !e.isInline)
                }
                isSelectable(t) {
                    const e = this.getDefinition(t);
                    return !!e && !(!e.isSelectable && !e.isObject)
                }
                isContent(t) {
                    const e = this.getDefinition(t);
                    return !!e && !(!e.isContent && !e.isObject)
                }
                checkChild(t, e) {
                    return !!e && this._checkContextMatch(e, t)
                }
                checkAttribute(t, e) {
                    const n = this.getDefinition(t.last);
                    return !!n && n.allowAttributes.includes(e)
                }
                checkMerge(t, e) {
                    if (t instanceof Od) {
                        const e = t.nodeBefore,
                            n = t.nodeAfter;
                        if (!(e instanceof Pd)) throw new A("schema-check-merge-no-element-before", this);
                        if (!(n instanceof Pd)) throw new A("schema-check-merge-no-element-after", this);
                        return this.checkMerge(e, n)
                    }
                    for (const n of e.getChildren())
                        if (!this.checkChild(t, n)) return !1;
                    return !0
                }
                addChildCheck(t) {
                    this.on("checkChild", ((e, [n, o]) => {
                        if (!o) return;
                        const i = t(n, o);
                        "boolean" == typeof i && (e.stop(), e.return = i)
                    }), {
                        priority: "high"
                    })
                }
                addAttributeCheck(t) {
                    this.on("checkAttribute", ((e, [n, o]) => {
                        const i = t(n, o);
                        "boolean" == typeof i && (e.stop(), e.return = i)
                    }), {
                        priority: "high"
                    })
                }
                setAttributeProperties(t, e) {
                    this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
                }
                getAttributeProperties(t) {
                    return this._attributeProperties[t] || {}
                }
                getLimitElement(t) {
                    let e;
                    if (t instanceof Od) e = t.parent;
                    else {
                        e = (t instanceof Ud ? [t] : Array.from(t.getRanges())).reduce(((t, e) => {
                            const n = e.getCommonAncestor();
                            return t ? t.getCommonAncestor(n, {
                                includeSelf: !0
                            }) : n
                        }), null)
                    }
                    for (; !this.isLimit(e) && e.parent;) e = e.parent;
                    return e
                }
                checkAttributeInSelection(t, e) {
                    if (t.isCollapsed) {
                        const n = [...t.getFirstPosition().getAncestors(), new Nd("", t.getAttributes())];
                        return this.checkAttribute(n, e)
                    } {
                        const n = t.getRanges();
                        for (const t of n)
                            for (const n of t)
                                if (this.checkAttribute(n.item, e)) return !0
                    }
                    return !1
                }* getValidRanges(t, e) {
                    t = function*(t) {
                        for (const e of t) yield* e.getMinimalFlatRanges()
                    }(t);
                    for (const n of t) yield* this._getValidRangesForRange(n, e)
                }
                getNearestSelectionRange(t, e = "both") {
                    if (this.checkChild(t, "$text")) return new Ud(t);
                    let n, o;
                    const i = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root;
                    "both" != e && "backward" != e || (n = new zd({
                        boundaries: Ud._createIn(i),
                        startPosition: t,
                        direction: "backward"
                    })), "both" != e && "forward" != e || (o = new zd({
                        boundaries: Ud._createIn(i),
                        startPosition: t
                    }));
                    for (const t of function*(t, e) {
                            let n = !1;
                            for (; !n;) {
                                if (n = !0, t) {
                                    const e = t.next();
                                    e.done || (n = !1, yield {
                                        walker: t,
                                        value: e.value
                                    })
                                }
                                if (e) {
                                    const t = e.next();
                                    t.done || (n = !1, yield {
                                        walker: e,
                                        value: t.value
                                    })
                                }
                            }
                        }(n, o)) {
                        const e = t.walker == n ? "elementEnd" : "elementStart",
                            o = t.value;
                        if (o.type == e && this.isObject(o.item)) return Ud._createOn(o.item);
                        if (this.checkChild(o.nextPosition, "$text")) return new Ud(o.nextPosition)
                    }
                    return null
                }
                findAllowedParent(t, e) {
                    let n = t.parent;
                    for (; n;) {
                        if (this.checkChild(n, e)) return n;
                        if (this.isLimit(n)) return null;
                        n = n.parent
                    }
                    return null
                }
                setAllowedAttributes(t, e, n) {
                    const o = n.model;
                    for (const [i, r] of Object.entries(e)) o.schema.checkAttribute(t, i) && n.setAttribute(i, r, t)
                }
                removeDisallowedAttributes(t, e) {
                    for (const n of t)
                        if (n.is("$text")) Xh(this, n, e);
                        else {
                            const t = Ud._createIn(n).getPositions();
                            for (const n of t) {
                                Xh(this, n.nodeBefore || n.parent, e)
                            }
                        }
                }
                getAttributesWithProperty(t, e, n) {
                    const o = {};
                    for (const [i, r] of t.getAttributes()) {
                        const t = this.getAttributeProperties(i);
                        void 0 !== t[e] && (void 0 !== n && n !== t[e] || (o[i] = r))
                    }
                    return o
                }
                createContext(t) {
                    return new Fh(t)
                }
                _clearCache() {
                    this._compiledDefinitions = null
                }
                _compile() {
                    const t = {},
                        e = this._sourceDefinitions,
                        n = Object.keys(e);
                    for (const o of n) t[o] = Vh(e[o], o);
                    for (const e of n) Hh(t, e);
                    for (const e of n) Uh(t, e);
                    for (const e of n) Wh(t, e);
                    for (const e of n) qh(t, e), Gh(t, e);
                    for (const e of n) $h(t, e), Yh(t, e), Kh(t, e);
                    this._compiledDefinitions = t
                }
                _checkContextMatch(t, e, n = e.length - 1) {
                    const o = e.getItem(n);
                    if (t.allowIn.includes(o.name)) {
                        if (0 == n) return !0;
                        {
                            const t = this.getDefinition(o);
                            return this._checkContextMatch(t, e, n - 1)
                        }
                    }
                    return !1
                }* _getValidRangesForRange(t, e) {
                    let n = t.start,
                        o = t.start;
                    for (const i of t.getItems({
                            shallow: !0
                        })) i.is("element") && (yield* this._getValidRangesForRange(Ud._createIn(i), e)), this.checkAttribute(i, e) || (n.isEqual(o) || (yield new Ud(n, o)), n = Od._createAfter(i)), o = Od._createAfter(i);
                    n.isEqual(o) || (yield new Ud(n, o))
                }
            }
            class Fh {
                constructor(t) {
                    if (t instanceof Fh) return t;
                    let e;
                    e = "string" == typeof t ? [t] : Array.isArray(t) ? t : t.getAncestors({
                        includeSelf: !0
                    }), this._items = e.map(Jh)
                }
                get length() {
                    return this._items.length
                }
                get last() {
                    return this._items[this._items.length - 1]
                } [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
                push(t) {
                    const e = new Fh([t]);
                    return e._items = [...this._items, ...e._items], e
                }
                getItem(t) {
                    return this._items[t]
                }* getNames() {
                    yield* this._items.map((t => t.name))
                }
                endsWith(t) {
                    return Array.from(this.getNames()).join(" ").endsWith(t)
                }
                startsWith(t) {
                    return Array.from(this.getNames()).join(" ").startsWith(t)
                }
            }
    
            function Vh(t, e) {
                const n = {
                    name: e,
                    allowIn: [],
                    allowContentOf: [],
                    allowWhere: [],
                    allowAttributes: [],
                    allowAttributesOf: [],
                    allowChildren: [],
                    inheritTypesFrom: []
                };
                return function(t, e) {
                        for (const n of t) {
                            const t = Object.keys(n).filter((t => t.startsWith("is")));
                            for (const o of t) e[o] = !!n[o]
                        }
                    }(t, n), Qh(t, n, "allowIn"), Qh(t, n, "allowContentOf"), Qh(t, n, "allowWhere"), Qh(t, n, "allowAttributes"), Qh(t, n, "allowAttributesOf"), Qh(t, n, "allowChildren"), Qh(t, n, "inheritTypesFrom"),
                    function(t, e) {
                        for (const n of t) {
                            const t = n.inheritAllFrom;
                            t && (e.allowContentOf.push(t), e.allowWhere.push(t), e.allowAttributesOf.push(t), e.inheritTypesFrom.push(t))
                        }
                    }(t, n), n
            }
    
            function Hh(t, e) {
                const n = t[e];
                for (const o of n.allowChildren) {
                    const n = t[o];
                    n && n.allowIn.push(e)
                }
                n.allowChildren.length = 0
            }
    
            function Uh(t, e) {
                for (const n of t[e].allowContentOf)
                    if (t[n]) {
                        Zh(t, n).forEach((t => {
                            t.allowIn.push(e)
                        }))
                    } delete t[e].allowContentOf
            }
    
            function Wh(t, e) {
                for (const n of t[e].allowWhere) {
                    const o = t[n];
                    if (o) {
                        const n = o.allowIn;
                        t[e].allowIn.push(...n)
                    }
                }
                delete t[e].allowWhere
            }
    
            function qh(t, e) {
                for (const n of t[e].allowAttributesOf) {
                    const o = t[n];
                    if (o) {
                        const n = o.allowAttributes;
                        t[e].allowAttributes.push(...n)
                    }
                }
                delete t[e].allowAttributesOf
            }
    
            function Gh(t, e) {
                const n = t[e];
                for (const e of n.inheritTypesFrom) {
                    const o = t[e];
                    if (o) {
                        const t = Object.keys(o).filter((t => t.startsWith("is")));
                        for (const e of t) e in n || (n[e] = o[e])
                    }
                }
                delete n.inheritTypesFrom
            }
    
            function $h(t, e) {
                const n = t[e],
                    o = n.allowIn.filter((e => t[e]));
                n.allowIn = Array.from(new Set(o))
            }
    
            function Yh(t, e) {
                const n = t[e];
                for (const o of n.allowIn) {
                    t[o].allowChildren.push(e)
                }
            }
    
            function Kh(t, e) {
                const n = t[e];
                n.allowAttributes = Array.from(new Set(n.allowAttributes))
            }
    
            function Qh(t, e, n) {
                for (const o of t) {
                    const t = o[n];
                    "string" == typeof t ? e[n].push(t) : Array.isArray(t) && e[n].push(...t)
                }
            }
    
            function Zh(t, e) {
                const n = t[e];
                return (o = t, Object.keys(o).map((t => o[t]))).filter((t => t.allowIn.includes(n.name)));
                var o
            }
    
            function Jh(t) {
                return "string" == typeof t || t.is("documentFragment") ? {
                    name: "string" == typeof t ? t : "$documentFragment",
                    * getAttributeKeys() {},
                    getAttribute() {}
                } : {
                    name: t.is("element") ? t.name : "$text",
                    * getAttributeKeys() {
                        yield* t.getAttributeKeys()
                    },
                    getAttribute: e => t.getAttribute(e)
                }
            }
    
            function Xh(t, e, n) {
                for (const o of e.getAttributeKeys()) t.checkAttribute(e, o) || n.removeAttribute(o, e)
            }
            class tu extends(N()) {
                constructor(t) {
                    super(), this._splitParts = new Map, this._cursorParents = new Map, this._modelCursor = null, this._emptyElementsToKeep = new Set, this.conversionApi = {
                        ...t,
                        consumable: null,
                        writer: null,
                        store: null,
                        convertItem: (t, e) => this._convertItem(t, e),
                        convertChildren: (t, e) => this._convertChildren(t, e),
                        safeInsert: (t, e) => this._safeInsert(t, e),
                        updateConversionResult: (t, e) => this._updateConversionResult(t, e),
                        splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
                        getSplitParts: t => this._getSplitParts(t),
                        keepEmptyElement: t => this._keepEmptyElement(t)
                    }
                }
                convert(t, e, n = ["$root"]) {
                    this.fire("viewCleanup", t), this._modelCursor = function(t, e) {
                        let n;
                        for (const o of new Fh(t)) {
                            const t = {};
                            for (const e of o.getAttributeKeys()) t[e] = o.getAttribute(e);
                            const i = e.createElement(o.name, t);
                            n && e.insert(i, n), n = Od._createAt(i, 0)
                        }
                        return n
                    }(n, e), this.conversionApi.writer = e, this.conversionApi.consumable = Lh.createFrom(t), this.conversionApi.store = {};
                    const {
                        modelRange: o
                    } = this._convertItem(t, this._modelCursor), i = e.createDocumentFragment();
                    if (o) {
                        this._removeEmptyElements();
                        for (const t of Array.from(this._modelCursor.parent.getChildren())) e.append(t, i);
                        i.markers = function(t, e) {
                            const n = new Set,
                                o = new Map,
                                i = Ud._createIn(t).getItems();
                            for (const t of i) t.is("element", "$marker") && n.add(t);
                            for (const t of n) {
                                const n = t.getAttribute("data-name"),
                                    i = e.createPositionBefore(t);
                                o.has(n) ? o.get(n).end = i.clone() : o.set(n, new Ud(i.clone())), e.remove(t)
                            }
                            return o
                        }(i, e)
                    }
                    return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, i
                }
                _convertItem(t, e) {
                    const n = {
                        viewItem: t,
                        modelCursor: e,
                        modelRange: null
                    };
                    if (t.is("element") ? this.fire(`element:${t.name}`, n, this.conversionApi) : t.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof Ud)) throw new A("view-conversion-dispatcher-incorrect-result", this);
                    return {
                        modelRange: n.modelRange,
                        modelCursor: n.modelCursor
                    }
                }
                _convertChildren(t, e) {
                    let n = e.is("position") ? e : Od._createAt(e, 0);
                    const o = new Ud(n);
                    for (const e of Array.from(t.getChildren())) {
                        const t = this._convertItem(e, n);
                        t.modelRange instanceof Ud && (o.end = t.modelRange.end, n = t.modelCursor)
                    }
                    return {
                        modelRange: o,
                        modelCursor: n
                    }
                }
                _safeInsert(t, e) {
                    const n = this._splitToAllowedParent(t, e);
                    return !!n && (this.conversionApi.writer.insert(t, n.position), !0)
                }
                _updateConversionResult(t, e) {
                    const n = this._getSplitParts(t),
                        o = this.conversionApi.writer;
                    e.modelRange || (e.modelRange = o.createRange(o.createPositionBefore(t), o.createPositionAfter(n[n.length - 1])));
                    const i = this._cursorParents.get(t);
                    e.modelCursor = i ? o.createPositionAt(i, 0) : e.modelRange.end
                }
                _splitToAllowedParent(t, e) {
                    const {
                        schema: n,
                        writer: o
                    } = this.conversionApi;
                    let i = n.findAllowedParent(e, t);
                    if (i) {
                        if (i === e.parent) return {
                            position: e
                        };
                        this._modelCursor.parent.getAncestors().includes(i) && (i = null)
                    }
                    if (!i) return Eh(e, t, n) ? {
                        position: Dh(e, o)
                    } : null;
                    const r = this.conversionApi.writer.split(e, i),
                        s = [];
                    for (const t of r.range.getWalker())
                        if ("elementEnd" == t.type) s.push(t.item);
                        else {
                            const e = s.pop(),
                                n = t.item;
                            this._registerSplitPair(e, n)
                        } const a = r.range.end.parent;
                    return this._cursorParents.set(t, a), {
                        position: r.position,
                        cursorParent: a
                    }
                }
                _registerSplitPair(t, e) {
                    this._splitParts.has(t) || this._splitParts.set(t, [t]);
                    const n = this._splitParts.get(t);
                    this._splitParts.set(e, n), n.push(e)
                }
                _getSplitParts(t) {
                    let e;
                    return e = this._splitParts.has(t) ? this._splitParts.get(t) : [t], e
                }
                _keepEmptyElement(t) {
                    this._emptyElementsToKeep.add(t)
                }
                _removeEmptyElements() {
                    let t = !1;
                    for (const e of this._splitParts.keys()) e.isEmpty && !this._emptyElementsToKeep.has(e) && (this.conversionApi.writer.remove(e), this._splitParts.delete(e), t = !0);
                    t && this._removeEmptyElements()
                }
            }
            class eu {
                getHtml(t) {
                    const e = document.implementation.createHTMLDocument("").createElement("div");
                    return e.appendChild(t), e.innerHTML
                }
            }
            class nu {
                constructor(t) {
                    this.skipComments = !0, this.domParser = new DOMParser, this.domConverter = new cl(t, {
                        renderingMode: "data"
                    }), this.htmlWriter = new eu
                }
                toData(t) {
                    const e = this.domConverter.viewToDom(t);
                    return this.htmlWriter.getHtml(e)
                }
                toView(t) {
                    const e = this._toDom(t);
                    return this.domConverter.domToView(e, {
                        skipComments: this.skipComments
                    })
                }
                registerRawContentMatcher(t) {
                    this.domConverter.registerRawContentMatcher(t)
                }
                useFillerType(t) {
                    this.domConverter.blockFillerMode = "marked" == t ? "markedNbsp" : "nbsp"
                }
                _toDom(t) {
                    t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (t = `<body>${t}</body>`);
                    const e = this.domParser.parseFromString(t, "text/html"),
                        n = e.createDocumentFragment(),
                        o = e.body.childNodes;
                    for (; o.length > 0;) n.appendChild(o[0]);
                    return n
                }
            }
            class ou extends(N()) {
                constructor(t, e) {
                    super(), this.model = t, this.mapper = new Wd, this.downcastDispatcher = new $d({
                        mapper: this.mapper,
                        schema: t.schema
                    }), this.downcastDispatcher.on("insert:$text", ((t, e, n) => {
                        if (!n.consumable.consume(e.item, t.name)) return;
                        const o = n.writer,
                            i = n.mapper.toViewPosition(e.range.start),
                            r = o.createText(e.item.data);
                        o.insert(i, r)
                    }), {
                        priority: "lowest"
                    }), this.downcastDispatcher.on("insert", ((t, e, n) => {
                        n.convertAttributes(e.item), e.reconversion || !e.item.is("element") || e.item.isEmpty || n.convertChildren(e.item)
                    }), {
                        priority: "lowest"
                    }), this.upcastDispatcher = new tu({
                        schema: t.schema
                    }), this.viewDocument = new kc(e), this.stylesProcessor = e, this.htmlProcessor = new nu(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Tc(this.viewDocument), this.upcastDispatcher.on("text", ((t, e, {
                        schema: n,
                        consumable: o,
                        writer: i
                    }) => {
                        let r = e.modelCursor;
                        if (!o.test(e.viewItem)) return;
                        if (!n.checkChild(r, "$text")) {
                            if (!Eh(r, "$text", n)) return;
                            if (0 == e.viewItem.data.trim().length) return;
                            const t = r.nodeBefore;
                            r = Dh(r, i), t && t.is("element", "$marker") && (i.move(i.createRangeOn(t), r), r = i.createPositionAfter(t))
                        }
                        o.consume(e.viewItem);
                        const s = i.createText(e.viewItem.data);
                        i.insert(s, r), e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize)), e.modelCursor = e.modelRange.end
                    }), {
                        priority: "lowest"
                    }), this.upcastDispatcher.on("element", ((t, e, n) => {
                        if (!e.modelRange && n.consumable.consume(e.viewItem, {
                                name: !0
                            })) {
                            const {
                                modelRange: t,
                                modelCursor: o
                            } = n.convertChildren(e.viewItem, e.modelCursor);
                            e.modelRange = t, e.modelCursor = o
                        }
                    }), {
                        priority: "lowest"
                    }), this.upcastDispatcher.on("documentFragment", ((t, e, n) => {
                        if (!e.modelRange && n.consumable.consume(e.viewItem, {
                                name: !0
                            })) {
                            const {
                                modelRange: t,
                                modelCursor: o
                            } = n.convertChildren(e.viewItem, e.modelCursor);
                            e.modelRange = t, e.modelCursor = o
                        }
                    }), {
                        priority: "lowest"
                    }), $().prototype.decorate.call(this, "init"), $().prototype.decorate.call(this, "set"), $().prototype.decorate.call(this, "get"), $().prototype.decorate.call(this, "toView"), $().prototype.decorate.call(this, "toModel"), this.on("init", (() => {
                        this.fire("ready")
                    }), {
                        priority: "lowest"
                    }), this.on("ready", (() => {
                        this.model.enqueueChange({
                            isUndoable: !1
                        }, xh)
                    }), {
                        priority: "lowest"
                    })
                }
                get(t = {}) {
                    const {
                        rootName: e = "main",
                        trim: n = "empty"
                    } = t;
                    if (!this._checkIfRootsExists([e])) throw new A("datacontroller-get-non-existent-root", this);
                    const o = this.model.document.getRoot(e);
                    return "empty" !== n || this.model.hasContent(o, {
                        ignoreWhitespaces: !0
                    }) ? this.stringify(o, t) : ""
                }
                stringify(t, e = {}) {
                    const n = this.toView(t, e);
                    return this.processor.toData(n)
                }
                toView(t, e = {}) {
                    const n = this.viewDocument,
                        o = this._viewWriter;
                    this.mapper.clearBindings();
                    const i = Ud._createIn(t),
                        r = new Ic(n);
                    this.mapper.bindElements(t, r);
                    const s = t.is("documentFragment") ? t.markers : function(t) {
                        const e = [],
                            n = t.root.document;
                        if (!n) return new Map;
                        const o = Ud._createIn(t);
                        for (const t of n.model.markers) {
                            const n = t.getRange(),
                                i = n.isCollapsed,
                                r = n.start.isEqual(o.start) || n.end.isEqual(o.end);
                            if (i && r) e.push([t.name, n]);
                            else {
                                const i = o.getIntersection(n);
                                i && e.push([t.name, i])
                            }
                        }
                        return e.sort((([t, e], [n, o]) => {
                            if ("after" !== e.end.compareWith(o.start)) return 1;
                            if ("before" !== e.start.compareWith(o.end)) return -1;
                            switch (e.start.compareWith(o.start)) {
                                case "before":
                                    return 1;
                                case "after":
                                    return -1;
                                default:
                                    switch (e.end.compareWith(o.end)) {
                                        case "before":
                                            return 1;
                                        case "after":
                                            return -1;
                                        default:
                                            return n.localeCompare(t)
                                    }
                            }
                        })), new Map(e)
                    }(t);
                    return this.downcastDispatcher.convert(i, s, o, e), r
                }
                init(t) {
                    if (this.model.document.version) throw new A("datacontroller-init-document-not-empty", this);
                    let e = {};
                    if ("string" == typeof t ? e.main = t : e = t, !this._checkIfRootsExists(Object.keys(e))) throw new A("datacontroller-init-non-existent-root", this);
                    return this.model.enqueueChange({
                        isUndoable: !1
                    }, (t => {
                        for (const n of Object.keys(e)) {
                            const o = this.model.document.getRoot(n);
                            t.insert(this.parse(e[n], o), o, 0)
                        }
                    })), Promise.resolve()
                }
                set(t, e = {}) {
                    let n = {};
                    if ("string" == typeof t ? n.main = t : n = t, !this._checkIfRootsExists(Object.keys(n))) throw new A("datacontroller-set-non-existent-root", this);
                    this.model.enqueueChange(e.batchType || {}, (t => {
                        t.setSelection(null), t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                        for (const e of Object.keys(n)) {
                            const o = this.model.document.getRoot(e);
                            t.remove(t.createRangeIn(o)), t.insert(this.parse(n[e], o), o, 0)
                        }
                    }))
                }
                parse(t, e = "$root") {
                    const n = this.processor.toView(t);
                    return this.toModel(n, e)
                }
                toModel(t, e = "$root") {
                    return this.model.change((n => this.upcastDispatcher.convert(t, n, e)))
                }
                addStyleProcessorRules(t) {
                    t(this.stylesProcessor)
                }
                registerRawContentMatcher(t) {
                    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t), this.htmlProcessor.registerRawContentMatcher(t)
                }
                destroy() {
                    this.stopListening()
                }
                _checkIfRootsExists(t) {
                    for (const e of t)
                        if (!this.model.document.getRootNames().includes(e)) return !1;
                    return !0
                }
            }
            class iu {
                constructor(t, e) {
                    this._helpers = new Map, this._downcast = ar(t), this._createConversionHelpers({
                        name: "downcast",
                        dispatchers: this._downcast,
                        isDowncast: !0
                    }), this._upcast = ar(e), this._createConversionHelpers({
                        name: "upcast",
                        dispatchers: this._upcast,
                        isDowncast: !1
                    })
                }
                addAlias(t, e) {
                    const n = this._downcast.includes(e);
                    if (!this._upcast.includes(e) && !n) throw new A("conversion-add-alias-dispatcher-not-registered", this);
                    this._createConversionHelpers({
                        name: t,
                        dispatchers: [e],
                        isDowncast: n
                    })
                }
                for (t) {
                    if (!this._helpers.has(t)) throw new A("conversion-for-unknown-group", this);
                    return this._helpers.get(t)
                }
                elementToElement(t) {
                    this.for("downcast").elementToElement(t);
                    for (const {
                            model: e,
                            view: n
                        }
                        of ru(t)) this.for("upcast").elementToElement({
                        model: e,
                        view: n,
                        converterPriority: t.converterPriority
                    })
                }
                attributeToElement(t) {
                    this.for("downcast").attributeToElement(t);
                    for (const {
                            model: e,
                            view: n
                        }
                        of ru(t)) this.for("upcast").elementToAttribute({
                        view: n,
                        model: e,
                        converterPriority: t.converterPriority
                    })
                }
                attributeToAttribute(t) {
                    this.for("downcast").attributeToAttribute(t);
                    for (const {
                            model: e,
                            view: n
                        }
                        of ru(t)) this.for("upcast").attributeToAttribute({
                        view: n,
                        model: e
                    })
                }
                _createConversionHelpers({
                    name: t,
                    dispatchers: e,
                    isDowncast: n
                }) {
                    if (this._helpers.has(t)) throw new A("conversion-group-exists", this);
                    const o = n ? new uh(e) : new Ih(e);
                    this._helpers.set(t, o)
                }
            }
    
            function* ru(t) {
                if (t.model.values)
                    for (const e of t.model.values) {
                        const n = {
                                key: t.model.key,
                                value: e
                            },
                            o = t.view[e],
                            i = t.upcastAlso ? t.upcastAlso[e] : void 0;
                        yield* su(n, o, i)
                    } else yield* su(t.model, t.view, t.upcastAlso)
            }
    
            function* su(t, e, n) {
                if (yield {
                        model: t,
                        view: e
                    }, n)
                    for (const e of ar(n)) yield {
                        model: t,
                        view: e
                    }
            }
            class au {
                constructor(t) {
                    this.baseVersion = t, this.isDocumentOperation = null !== this.baseVersion, this.batch = null
                }
                _validate() {}
                toJSON() {
                    const t = Object.assign({}, this);
                    return t.__className = this.constructor.className, delete t.batch, delete t.isDocumentOperation, t
                }
                static get className() {
                    return "Operation"
                }
                static fromJSON(t, e) {
                    return new this(t.baseVersion)
                }
            }
    
            function cu(t, e) {
                const n = hu(e),
                    o = n.reduce(((t, e) => t + e.offsetSize), 0),
                    i = t.parent;
                gu(t);
                const r = t.index;
                return i._insertChild(r, n), uu(i, r + n.length), uu(i, r), new Ud(t, t.getShiftedBy(o))
            }
    
            function lu(t) {
                if (!t.isFlat) throw new A("operation-utils-remove-range-not-flat", this);
                const e = t.start.parent;
                gu(t.start), gu(t.end);
                const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
                return uu(e, t.start.index), n
            }
    
            function du(t, e) {
                if (!t.isFlat) throw new A("operation-utils-move-range-not-flat", this);
                const n = lu(t);
                return cu(e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset), n)
            }
    
            function hu(t) {
                const e = [];
                ! function t(n) {
                    if ("string" == typeof n) e.push(new Nd(n));
                    else if (n instanceof Bd) e.push(new Nd(n.data, n.getAttributes()));
                    else if (n instanceof Md) e.push(n);
                    else if (nt(n))
                        for (const e of n) t(e)
                }(t);
                for (let t = 1; t < e.length; t++) {
                    const n = e[t],
                        o = e[t - 1];
                    n instanceof Nd && o instanceof Nd && mu(n, o) && (e.splice(t - 1, 2, new Nd(o.data + n.data, o.getAttributes())), t--)
                }
                return e
            }
    
            function uu(t, e) {
                const n = t.getChild(e - 1),
                    o = t.getChild(e);
                if (n && o && n.is("$text") && o.is("$text") && mu(n, o)) {
                    const i = new Nd(n.data + o.data, n.getAttributes());
                    t._removeChildren(e - 1, 2), t._insertChild(e - 1, i)
                }
            }
    
            function gu(t) {
                const e = t.textNode,
                    n = t.parent;
                if (e) {
                    const o = t.offset - e.startOffset,
                        i = e.index;
                    n._removeChildren(i, 1);
                    const r = new Nd(e.data.substr(0, o), e.getAttributes()),
                        s = new Nd(e.data.substr(o), e.getAttributes());
                    n._insertChild(i, [r, s])
                }
            }
    
            function mu(t, e) {
                const n = t.getAttributes(),
                    o = e.getAttributes();
                for (const t of n) {
                    if (t[1] !== e.getAttribute(t[0])) return !1;
                    o.next()
                }
                return o.next().done
            }
            class pu extends au {
                constructor(t, e, n, o) {
                    super(o), this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone"
                }
                get type() {
                    return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move"
                }
                clone() {
                    return new pu(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
                }
                getMovedRangeStart() {
                    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
                }
                getReversed() {
                    const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                    return new pu(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.sourcePosition.parent,
                        e = this.targetPosition.parent,
                        n = this.sourcePosition.offset,
                        o = this.targetPosition.offset;
                    if (n + this.howMany > t.maxOffset) throw new A("move-operation-nodes-do-not-exist", this);
                    if (t === e && n < o && o < n + this.howMany) throw new A("move-operation-range-into-itself", this);
                    if (this.sourcePosition.root == this.targetPosition.root && "prefix" == et(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
                        const t = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) throw new A("move-operation-node-into-itself", this)
                    }
                }
                _execute() {
                    du(Ud._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.sourcePosition = this.sourcePosition.toJSON(), t.targetPosition = this.targetPosition.toJSON(), t
                }
                static get className() {
                    return "MoveOperation"
                }
                static fromJSON(t, e) {
                    const n = Od.fromJSON(t.sourcePosition, e),
                        o = Od.fromJSON(t.targetPosition, e);
                    return new this(n, t.howMany, o, t.baseVersion)
                }
            }
            class fu extends au {
                constructor(t, e, n) {
                    super(n), this.position = t.clone(), this.position.stickiness = "toNone", this.nodes = new Sd(hu(e)), this.shouldReceiveAttributes = !1
                }
                get type() {
                    return "insert"
                }
                get howMany() {
                    return this.nodes.maxOffset
                }
                clone() {
                    const t = new Sd([...this.nodes].map((t => t._clone(!0)))),
                        e = new fu(this.position, t, this.baseVersion);
                    return e.shouldReceiveAttributes = this.shouldReceiveAttributes, e
                }
                getReversed() {
                    const t = this.position.root.document.graveyard,
                        e = new Od(t, [0]);
                    return new pu(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.position.parent;
                    if (!t || t.maxOffset < this.position.offset) throw new A("insert-operation-position-invalid", this)
                }
                _execute() {
                    const t = this.nodes;
                    this.nodes = new Sd([...t].map((t => t._clone(!0)))), cu(this.position, t)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.position = this.position.toJSON(), t.nodes = this.nodes.toJSON(), t
                }
                static get className() {
                    return "InsertOperation"
                }
                static fromJSON(t, e) {
                    const n = [];
                    for (const e of t.nodes) e.name ? n.push(Pd.fromJSON(e)) : n.push(Nd.fromJSON(e));
                    const o = new fu(Od.fromJSON(t.position, e), n, t.baseVersion);
                    return o.shouldReceiveAttributes = t.shouldReceiveAttributes, o
                }
            }
            class ku extends au {
                constructor(t, e, n, o, i, r) {
                    super(r), this.name = t, this.oldRange = e ? e.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = i, this._markers = o
                }
                get type() {
                    return "marker"
                }
                clone() {
                    return new ku(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
                }
                getReversed() {
                    return new ku(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
                }
                _execute() {
                    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name)
                }
                toJSON() {
                    const t = super.toJSON();
                    return this.oldRange && (t.oldRange = this.oldRange.toJSON()), this.newRange && (t.newRange = this.newRange.toJSON()), delete t._markers, t
                }
                static get className() {
                    return "MarkerOperation"
                }
                static fromJSON(t, e) {
                    return new ku(t.name, t.oldRange ? Ud.fromJSON(t.oldRange, e) : null, t.newRange ? Ud.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
                }
            }
            const bu = function(t, e) {
                return fd(t, e)
            };
            class wu extends au {
                constructor(t, e, n, o, i) {
                    super(i), this.range = t.clone(), this.key = e, this.oldValue = void 0 === n ? null : n, this.newValue = void 0 === o ? null : o
                }
                get type() {
                    return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute"
                }
                clone() {
                    return new wu(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
                }
                getReversed() {
                    return new wu(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.range = this.range.toJSON(), t
                }
                _validate() {
                    if (!this.range.isFlat) throw new A("attribute-operation-range-not-flat", this);
                    for (const t of this.range.getItems({
                            shallow: !0
                        })) {
                        if (null !== this.oldValue && !bu(t.getAttribute(this.key), this.oldValue)) throw new A("attribute-operation-wrong-old-value", this, {
                            item: t,
                            key: this.key,
                            value: this.oldValue
                        });
                        if (null === this.oldValue && null !== this.newValue && t.hasAttribute(this.key)) throw new A("attribute-operation-attribute-exists", this, {
                            node: t,
                            key: this.key
                        })
                    }
                }
                _execute() {
                    bu(this.oldValue, this.newValue) || function(t, e, n) {
                        gu(t.start), gu(t.end);
                        for (const o of t.getItems({
                                shallow: !0
                            })) {
                            const t = o.is("$textProxy") ? o.textNode : o;
                            null !== n ? t._setAttribute(e, n) : t._removeAttribute(e), uu(t.parent, t.index)
                        }
                        uu(t.end.parent, t.end.index)
                    }(this.range, this.key, this.newValue)
                }
                static get className() {
                    return "AttributeOperation"
                }
                static fromJSON(t, e) {
                    return new wu(Ud.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
                }
            }
            class _u extends au {
                get type() {
                    return "noop"
                }
                clone() {
                    return new _u(this.baseVersion)
                }
                getReversed() {
                    return new _u(this.baseVersion + 1)
                }
                _execute() {}
                static get className() {
                    return "NoOperation"
                }
            }
            class Au extends au {
                constructor(t, e, n, o) {
                    super(o), this.position = t, this.position.stickiness = "toNext", this.oldName = e, this.newName = n
                }
                get type() {
                    return "rename"
                }
                clone() {
                    return new Au(this.position.clone(), this.oldName, this.newName, this.baseVersion)
                }
                getReversed() {
                    return new Au(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.position.nodeAfter;
                    if (!(t instanceof Pd)) throw new A("rename-operation-wrong-position", this);
                    if (t.name !== this.oldName) throw new A("rename-operation-wrong-name", this)
                }
                _execute() {
                    this.position.nodeAfter.name = this.newName
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.position = this.position.toJSON(), t
                }
                static get className() {
                    return "RenameOperation"
                }
                static fromJSON(t, e) {
                    return new Au(Od.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
                }
            }
            class Cu extends au {
                constructor(t, e, n, o, i) {
                    super(i), this.root = t, this.key = e, this.oldValue = n, this.newValue = o
                }
                get type() {
                    return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute"
                }
                clone() {
                    return new Cu(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
                }
                getReversed() {
                    return new Cu(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }
                _validate() {
                    if (this.root != this.root.root || this.root.is("documentFragment")) throw new A("rootattribute-operation-not-a-root", this, {
                        root: this.root,
                        key: this.key
                    });
                    if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue) throw new A("rootattribute-operation-wrong-old-value", this, {
                        root: this.root,
                        key: this.key
                    });
                    if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key)) throw new A("rootattribute-operation-attribute-exists", this, {
                        root: this.root,
                        key: this.key
                    })
                }
                _execute() {
                    null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.root = this.root.toJSON(), t
                }
                static get className() {
                    return "RootAttributeOperation"
                }
                static fromJSON(t, e) {
                    if (!e.getRoot(t.root)) throw new A("rootattribute-operation-fromjson-no-root", this, {
                        rootName: t.root
                    });
                    return new Cu(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
                }
            }
            class vu extends au {
                constructor(t, e, n, o, i) {
                    super(i), this.sourcePosition = t.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = o.clone()
                }
                get type() {
                    return "merge"
                }
                get deletionPosition() {
                    return new Od(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
                }
                get movedRange() {
                    const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Ud(this.sourcePosition, t)
                }
                clone() {
                    return new vu(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
                }
                getReversed() {
                    const t = this.targetPosition._getTransformedByMergeOperation(this),
                        e = this.sourcePosition.path.slice(0, -1),
                        n = new Od(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                    return new yu(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.sourcePosition.parent,
                        e = this.targetPosition.parent;
                    if (!t.parent) throw new A("merge-operation-source-position-invalid", this);
                    if (!e.parent) throw new A("merge-operation-target-position-invalid", this);
                    if (this.howMany != t.maxOffset) throw new A("merge-operation-how-many-invalid", this)
                }
                _execute() {
                    const t = this.sourcePosition.parent;
                    du(Ud._createIn(t), this.targetPosition), du(Ud._createOn(t), this.graveyardPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.sourcePosition = t.sourcePosition.toJSON(), t.targetPosition = t.targetPosition.toJSON(), t.graveyardPosition = t.graveyardPosition.toJSON(), t
                }
                static get className() {
                    return "MergeOperation"
                }
                static fromJSON(t, e) {
                    const n = Od.fromJSON(t.sourcePosition, e),
                        o = Od.fromJSON(t.targetPosition, e),
                        i = Od.fromJSON(t.graveyardPosition, e);
                    return new this(n, t.howMany, o, i, t.baseVersion)
                }
            }
            class yu extends au {
                constructor(t, e, n, o, i) {
                    super(i), this.splitPosition = t.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e, this.insertionPosition = n, this.graveyardPosition = o ? o.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext")
                }
                get type() {
                    return "split"
                }
                get moveTargetPosition() {
                    const t = this.insertionPosition.path.slice();
                    return t.push(0), new Od(this.insertionPosition.root, t)
                }
                get movedRange() {
                    const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Ud(this.splitPosition, t)
                }
                clone() {
                    return new yu(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion)
                }
                getReversed() {
                    const t = this.splitPosition.root.document.graveyard,
                        e = new Od(t, [0]);
                    return new vu(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.splitPosition.parent,
                        e = this.splitPosition.offset;
                    if (!t || t.maxOffset < e) throw new A("split-operation-position-invalid", this);
                    if (!t.parent) throw new A("split-operation-split-in-root", this);
                    if (this.howMany != t.maxOffset - this.splitPosition.offset) throw new A("split-operation-how-many-invalid", this);
                    if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new A("split-operation-graveyard-position-invalid", this)
                }
                _execute() {
                    const t = this.splitPosition.parent;
                    if (this.graveyardPosition) du(Ud._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
                    else {
                        const e = t._clone();
                        cu(this.insertionPosition, e)
                    }
                    du(new Ud(Od._createAt(t, this.splitPosition.offset), Od._createAt(t, t.maxOffset)), this.moveTargetPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.splitPosition = this.splitPosition.toJSON(), t.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t.graveyardPosition = this.graveyardPosition.toJSON()), t
                }
                static get className() {
                    return "SplitOperation"
                }
                static getInsertionPosition(t) {
                    const e = t.path.slice(0, -1);
                    return e[e.length - 1]++, new Od(t.root, e, "toPrevious")
                }
                static fromJSON(t, e) {
                    const n = Od.fromJSON(t.splitPosition, e),
                        o = Od.fromJSON(t.insertionPosition, e),
                        i = t.graveyardPosition ? Od.fromJSON(t.graveyardPosition, e) : null;
                    return new this(n, t.howMany, o, i, t.baseVersion)
                }
            }
            const xu = {};
            xu[wu.className] = wu, xu[fu.className] = fu, xu[ku.className] = ku, xu[pu.className] = pu, xu[_u.className] = _u, xu[au.className] = au, xu[Au.className] = Au, xu[Cu.className] = Cu, xu[yu.className] = yu, xu[vu.className] = vu;
            class Eu {
                static fromJSON(t, e) {
                    return xu[t.__className].fromJSON(t, e)
                }
            }
            const Du = new Map;
    
            function Iu(t, e, n) {
                let o = Du.get(t);
                o || (o = new Map, Du.set(t, o)), o.set(e, n)
            }
    
            function Tu(t) {
                return [t]
            }
    
            function Mu(t, e, n = {}) {
                const o = function(t, e) {
                    const n = Du.get(t);
                    return n && n.has(e) ? n.get(e) : Tu
                }(t.constructor, e.constructor);
                try {
                    return o(t = t.clone(), e, n)
                } catch (t) {
                    throw t
                }
            }
    
            function Su(t, e, n) {
                t = t.slice(), e = e.slice();
                const o = new Nu(n.document, n.useRelations, n.forceWeakRemove);
                o.setOriginalOperations(t), o.setOriginalOperations(e);
                const i = o.originalOperations;
                if (0 == t.length || 0 == e.length) return {
                    operationsA: t,
                    operationsB: e,
                    originalOperations: i
                };
                const r = new WeakMap;
                for (const e of t) r.set(e, 0);
                const s = {
                    nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                    originalOperationsACount: t.length,
                    originalOperationsBCount: e.length
                };
                let a = 0;
                for (; a < t.length;) {
                    const n = t[a],
                        i = r.get(n);
                    if (i == e.length) {
                        a++;
                        continue
                    }
                    const s = e[i],
                        c = Mu(n, s, o.getContext(n, s, !0)),
                        l = Mu(s, n, o.getContext(s, n, !1));
                    o.updateRelation(n, s), o.setOriginalOperations(c, n), o.setOriginalOperations(l, s);
                    for (const t of c) r.set(t, i + l.length);
                    t.splice(a, 1, ...c), e.splice(i, 1, ...l)
                }
                if (n.padWithNoOps) {
                    const n = t.length - s.originalOperationsACount,
                        o = e.length - s.originalOperationsBCount;
                    Pu(t, o - n), Pu(e, n - o)
                }
                return Bu(t, s.nextBaseVersionB), Bu(e, s.nextBaseVersionA), {
                    operationsA: t,
                    operationsB: e,
                    originalOperations: i
                }
            }
            class Nu {
                constructor(t, e, n = !1) {
                    this.originalOperations = new Map, this._history = t.history, this._useRelations = e, this._forceWeakRemove = !!n, this._relations = new Map
                }
                setOriginalOperations(t, e = null) {
                    const n = e ? this.originalOperations.get(e) : null;
                    for (const e of t) this.originalOperations.set(e, n || e)
                }
                updateRelation(t, e) {
                    if (t instanceof pu) e instanceof vu ? t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition) ? this._setRelation(t, e, "insertAtSource") : t.targetPosition.isEqual(e.deletionPosition) ? this._setRelation(t, e, "insertBetween") : t.targetPosition.isAfter(e.sourcePosition) && this._setRelation(t, e, "moveTargetAfter") : e instanceof pu && (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition) ? this._setRelation(t, e, "insertBefore") : this._setRelation(t, e, "insertAfter"));
                    else if (t instanceof yu) {
                        if (e instanceof vu) t.splitPosition.isBefore(e.sourcePosition) && this._setRelation(t, e, "splitBefore");
                        else if (e instanceof pu)
                            if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) this._setRelation(t, e, "splitBefore");
                            else {
                                const n = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany);
                                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) {
                                    const o = n.end.offset - t.splitPosition.offset,
                                        i = t.splitPosition.offset - n.start.offset;
                                    this._setRelation(t, e, {
                                        howMany: o,
                                        offset: i
                                    })
                                }
                            }
                    } else if (t instanceof vu) e instanceof vu ? (t.targetPosition.isEqual(e.sourcePosition) || this._setRelation(t, e, "mergeTargetNotMoved"), t.sourcePosition.isEqual(e.targetPosition) && this._setRelation(t, e, "mergeSourceNotMoved"), t.sourcePosition.isEqual(e.sourcePosition) && this._setRelation(t, e, "mergeSameElement")) : e instanceof yu && t.sourcePosition.isEqual(e.splitPosition) && this._setRelation(t, e, "splitAtSource");
                    else if (t instanceof ku) {
                        const n = t.newRange;
                        if (!n) return;
                        if (e instanceof pu) {
                            const o = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany),
                                i = o.containsPosition(n.start) || o.start.isEqual(n.start),
                                r = o.containsPosition(n.end) || o.end.isEqual(n.end);
                            !i && !r || o.containsRange(n) || this._setRelation(t, e, {
                                side: i ? "left" : "right",
                                path: i ? n.start.path.slice() : n.end.path.slice()
                            })
                        } else if (e instanceof vu) {
                            const o = n.start.isEqual(e.targetPosition),
                                i = n.start.isEqual(e.deletionPosition),
                                r = n.end.isEqual(e.deletionPosition),
                                s = n.end.isEqual(e.sourcePosition);
                            (o || i || r || s) && this._setRelation(t, e, {
                                wasInLeftElement: o,
                                wasStartBeforeMergedElement: i,
                                wasEndBeforeMergedElement: r,
                                wasInRightElement: s
                            })
                        }
                    }
                }
                getContext(t, e, n) {
                    return {
                        aIsStrong: n,
                        aWasUndone: this._wasUndone(t),
                        bWasUndone: this._wasUndone(e),
                        abRelation: this._useRelations ? this._getRelation(t, e) : null,
                        baRelation: this._useRelations ? this._getRelation(e, t) : null,
                        forceWeakRemove: this._forceWeakRemove
                    }
                }
                _wasUndone(t) {
                    const e = this.originalOperations.get(t);
                    return e.wasUndone || this._history.isUndoneOperation(e)
                }
                _getRelation(t, e) {
                    const n = this.originalOperations.get(e),
                        o = this._history.getUndoneOperation(n);
                    if (!o) return null;
                    const i = this.originalOperations.get(t),
                        r = this._relations.get(i);
                    return r && r.get(o) || null
                }
                _setRelation(t, e, n) {
                    const o = this.originalOperations.get(t),
                        i = this.originalOperations.get(e);
                    let r = this._relations.get(o);
                    r || (r = new Map, this._relations.set(o, r)), r.set(i, n)
                }
            }
    
            function Bu(t, e) {
                for (const n of t) n.baseVersion = e++
            }
    
            function Pu(t, e) {
                for (let n = 0; n < e; n++) t.push(new _u(0))
            }
    
            function zu(t, e, n) {
                const o = t.nodes.getNode(0).getAttribute(e);
                if (o == n) return null;
                const i = new Ud(t.position, t.position.getShiftedBy(t.howMany));
                return new wu(i, e, o, n, 0)
            }
    
            function Lu(t, e) {
                return null === t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
            }
    
            function Ou(t, e) {
                const n = [];
                for (let o = 0; o < t.length; o++) {
                    const i = t[o],
                        r = new pu(i.start, i.end.offset - i.start.offset, e, 0);
                    n.push(r);
                    for (let e = o + 1; e < t.length; e++) t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
                    e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
                }
                return n
            }
            Iu(wu, wu, ((t, e, n) => {
                if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
                    const o = t.range.getDifference(e.range).map((e => new wu(e, t.key, t.oldValue, t.newValue, 0))),
                        i = t.range.getIntersection(e.range);
                    return i && n.aIsStrong && o.push(new wu(i, e.key, e.newValue, t.newValue, 0)), 0 == o.length ? [new _u(0)] : o
                }
                return [t]
            })), Iu(wu, fu, ((t, e) => {
                if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                    const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((e => new wu(e, t.key, t.oldValue, t.newValue, t.baseVersion)));
                    if (e.shouldReceiveAttributes) {
                        const o = zu(e, t.key, t.oldValue);
                        o && n.unshift(o)
                    }
                    return n
                }
                return t.range = t.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [t]
            })), Iu(wu, vu, ((t, e) => {
                const n = [];
                t.range.start.hasSameParentAs(e.deletionPosition) && (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) && n.push(Ud._createFromPositionAndShift(e.graveyardPosition, 1));
                const o = t.range._getTransformedByMergeOperation(e);
                return o.isCollapsed || n.push(o), n.map((e => new wu(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
            })), Iu(wu, pu, ((t, e) => {
                const n = function(t, e) {
                    const n = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany);
                    let o = null,
                        i = [];
                    n.containsRange(t, !0) ? o = t : t.start.hasSameParentAs(n.start) ? (i = t.getDifference(n), o = t.getIntersection(n)) : i = [t];
                    const r = [];
                    for (let t of i) {
                        t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                        const n = e.getMovedRangeStart(),
                            o = t.start.hasSameParentAs(n),
                            i = t._getTransformedByInsertion(n, e.howMany, o);
                        r.push(...i)
                    }
                    o && r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]);
                    return r
                }(t.range, e);
                return n.map((e => new wu(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
            })), Iu(wu, yu, ((t, e) => {
                if (t.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.range.end.offset++, [t];
                if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                    const n = t.clone();
                    return n.range = new Ud(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), t.range.end = e.splitPosition.clone(), t.range.end.stickiness = "toPrevious", [t, n]
                }
                return t.range = t.range._getTransformedBySplitOperation(e), [t]
            })), Iu(fu, wu, ((t, e) => {
                const n = [t];
                if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                    const o = zu(t, e.key, e.newValue);
                    o && n.push(o)
                }
                return n
            })), Iu(fu, fu, ((t, e, n) => (t.position.isEqual(e.position) && n.aIsStrong || (t.position = t.position._getTransformedByInsertOperation(e)), [t]))), Iu(fu, pu, ((t, e) => (t.position = t.position._getTransformedByMoveOperation(e), [t]))), Iu(fu, yu, ((t, e) => (t.position = t.position._getTransformedBySplitOperation(e), [t]))), Iu(fu, vu, ((t, e) => (t.position = t.position._getTransformedByMergeOperation(e), [t]))), Iu(ku, fu, ((t, e) => (t.oldRange && (t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]), t.newRange && (t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]), [t]))), Iu(ku, ku, ((t, e, n) => {
                if (t.name == e.name) {
                    if (!n.aIsStrong) return [new _u(0)];
                    t.oldRange = e.newRange ? e.newRange.clone() : null
                }
                return [t]
            })), Iu(ku, vu, ((t, e) => (t.oldRange && (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)), t.newRange && (t.newRange = t.newRange._getTransformedByMergeOperation(e)), [t]))), Iu(ku, pu, ((t, e, n) => {
                if (t.oldRange && (t.oldRange = Ud._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))), t.newRange) {
                    if (n.abRelation) {
                        const o = Ud._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                        if ("left" == n.abRelation.side && e.targetPosition.isEqual(t.newRange.start)) return t.newRange.end = o.end, t.newRange.start.path = n.abRelation.path, [t];
                        if ("right" == n.abRelation.side && e.targetPosition.isEqual(t.newRange.end)) return t.newRange.start = o.start, t.newRange.end.path = n.abRelation.path, [t]
                    }
                    t.newRange = Ud._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
                }
                return [t]
            })), Iu(ku, yu, ((t, e, n) => {
                if (t.oldRange && (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)), t.newRange) {
                    if (n.abRelation) {
                        const o = t.newRange._getTransformedBySplitOperation(e);
                        return t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement ? t.newRange.start = Od._createAt(e.insertionPosition) : t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement && (t.newRange.start = Od._createAt(e.moveTargetPosition)), t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement ? t.newRange.end = Od._createAt(e.moveTargetPosition) : t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement ? t.newRange.end = Od._createAt(e.insertionPosition) : t.newRange.end = o.end, [t]
                    }
                    t.newRange = t.newRange._getTransformedBySplitOperation(e)
                }
                return [t]
            })), Iu(vu, fu, ((t, e) => (t.sourcePosition.hasSameParentAs(e.position) && (t.howMany += e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e), t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e), [t]))), Iu(vu, vu, ((t, e, n) => {
                if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                    if (n.bWasUndone) {
                        const n = e.graveyardPosition.path.slice();
                        return n.push(0), t.sourcePosition = new Od(e.graveyardPosition.root, n), t.howMany = 0, [t]
                    }
                    return [new _u(0)]
                }
                if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && "splitAtSource" != n.abRelation) {
                    const o = "$graveyard" == t.targetPosition.root.rootName,
                        i = "$graveyard" == e.targetPosition.root.rootName;
                    if (i && !o || !(o && !i) && n.aIsStrong) {
                        const n = e.targetPosition._getTransformedByMergeOperation(e),
                            o = t.targetPosition._getTransformedByMergeOperation(e);
                        return [new pu(n, t.howMany, o, 0)]
                    }
                    return [new _u(0)]
                }
                return t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e), t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), t.graveyardPosition.isEqual(e.graveyardPosition) && n.aIsStrong || (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)), [t]
            })), Iu(vu, pu, ((t, e, n) => {
                const o = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany);
                return "remove" == e.type && !n.bWasUndone && !n.forceWeakRemove && t.deletionPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.sourcePosition) ? [new _u(0)] : (t.sourcePosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.sourcePosition.hasSameParentAs(e.sourcePosition) && (t.howMany -= e.howMany), t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e), t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e), t.graveyardPosition.isEqual(e.targetPosition) || (t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)), [t])
            })), Iu(vu, yu, ((t, e, n) => {
                if (e.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), t.deletionPosition.isEqual(e.graveyardPosition) && (t.howMany = e.howMany)), t.targetPosition.isEqual(e.splitPosition)) {
                    const o = 0 != e.howMany,
                        i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                    if (o || i || "mergeTargetNotMoved" == n.abRelation) return t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e), [t]
                }
                if (t.sourcePosition.isEqual(e.splitPosition)) {
                    if ("mergeSourceNotMoved" == n.abRelation) return t.howMany = 0, t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t];
                    if ("mergeSameElement" == n.abRelation || t.sourcePosition.offset > 0) return t.sourcePosition = e.moveTargetPosition.clone(), t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t]
                }
                return t.sourcePosition.hasSameParentAs(e.splitPosition) && (t.howMany = e.splitPosition.offset), t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e), t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e), [t]
            })), Iu(pu, fu, ((t, e) => {
                const n = Ud._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByInsertOperation(e, !1)[0];
                return t.sourcePosition = n.start, t.howMany = n.end.offset - n.start.offset, t.targetPosition.isEqual(e.position) || (t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)), [t]
            })), Iu(pu, pu, ((t, e, n) => {
                const o = Ud._createFromPositionAndShift(t.sourcePosition, t.howMany),
                    i = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let r, s = n.aIsStrong,
                    a = !n.aIsStrong;
                if ("insertBefore" == n.abRelation || "insertAfter" == n.baRelation ? a = !0 : "insertAfter" != n.abRelation && "insertBefore" != n.baRelation || (a = !1), r = t.targetPosition.isEqual(e.targetPosition) && a ? t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Lu(t, e) && Lu(e, t)) return [e.getReversed()];
                if (o.containsPosition(e.targetPosition) && o.containsRange(i, !0)) return o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Ou([o], r);
                if (i.containsPosition(t.targetPosition) && i.containsRange(o, !0)) return o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), Ou([o], r);
                const c = et(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
                if ("prefix" == c || "extension" == c) return o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Ou([o], r);
                "remove" != t.type || "remove" == e.type || n.aWasUndone || n.forceWeakRemove ? "remove" == t.type || "remove" != e.type || n.bWasUndone || n.forceWeakRemove || (s = !1) : s = !0;
                const l = [],
                    d = o.getDifference(i);
                for (const t of d) {
                    t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany), t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const n = "same" == et(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()),
                        o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                    l.push(...o)
                }
                const h = o.getIntersection(i);
                return null !== h && s && (h.start = h.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), h.end = h.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), 0 === l.length ? l.push(h) : 1 == l.length ? i.start.isBefore(o.start) || i.start.isEqual(o.start) ? l.unshift(h) : l.push(h) : l.splice(1, 0, h)), 0 === l.length ? [new _u(t.baseVersion)] : Ou(l, r)
            })), Iu(pu, yu, ((t, e, n) => {
                let o = t.targetPosition.clone();
                t.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && "moveTargetAfter" != n.abRelation || (o = t.targetPosition._getTransformedBySplitOperation(e));
                const i = Ud._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (i.end.isEqual(e.insertionPosition)) return e.graveyardPosition || t.howMany++, t.targetPosition = o, [t];
                if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
                    let t = new Ud(e.splitPosition, i.end);
                    t = t._getTransformedBySplitOperation(e);
                    return Ou([new Ud(i.start, e.splitPosition), t], o)
                }
                t.targetPosition.isEqual(e.splitPosition) && "insertAtSource" == n.abRelation && (o = e.moveTargetPosition), t.targetPosition.isEqual(e.insertionPosition) && "insertBetween" == n.abRelation && (o = t.targetPosition);
                const r = [i._getTransformedBySplitOperation(e)];
                if (e.graveyardPosition) {
                    const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
                    t.howMany > 1 && o && !n.aWasUndone && r.push(Ud._createFromPositionAndShift(e.insertionPosition, 1))
                }
                return Ou(r, o)
            })), Iu(pu, vu, ((t, e, n) => {
                const o = Ud._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && o.containsPosition(e.sourcePosition))
                    if ("remove" != t.type || n.forceWeakRemove) {
                        if (1 == t.howMany) return n.bWasUndone ? (t.sourcePosition = e.graveyardPosition.clone(), t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), [t]) : [new _u(0)]
                    } else if (!n.aWasUndone) {
                    const n = [];
                    let o = e.graveyardPosition.clone(),
                        i = e.targetPosition._getTransformedByMergeOperation(e);
                    t.howMany > 1 && (n.push(new pu(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)), o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1), i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1));
                    const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition),
                        s = new pu(o, 1, r, 0),
                        a = s.getMovedRangeStart().path.slice();
                    a.push(0);
                    const c = new Od(s.targetPosition.root, a);
                    i = i._getTransformedByMove(o, r, 1);
                    const l = new pu(i, e.howMany, c, 0);
                    return n.push(s), n.push(l), n
                }
                const i = Ud._createFromPositionAndShift(t.sourcePosition, t.howMany)._getTransformedByMergeOperation(e);
                return t.sourcePosition = i.start, t.howMany = i.end.offset - i.start.offset, t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e), [t]
            })), Iu(Au, fu, ((t, e) => (t.position = t.position._getTransformedByInsertOperation(e), [t]))), Iu(Au, vu, ((t, e) => t.position.isEqual(e.deletionPosition) ? (t.position = e.graveyardPosition.clone(), t.position.stickiness = "toNext", [t]) : (t.position = t.position._getTransformedByMergeOperation(e), [t]))), Iu(Au, pu, ((t, e) => (t.position = t.position._getTransformedByMoveOperation(e), [t]))), Iu(Au, Au, ((t, e, n) => {
                if (t.position.isEqual(e.position)) {
                    if (!n.aIsStrong) return [new _u(0)];
                    t.oldName = e.newName
                }
                return [t]
            })), Iu(Au, yu, ((t, e) => {
                if ("same" == et(t.position.path, e.splitPosition.getParentPath()) && !e.graveyardPosition) {
                    const e = new Au(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                    return [t, e]
                }
                return t.position = t.position._getTransformedBySplitOperation(e), [t]
            })), Iu(Cu, Cu, ((t, e, n) => {
                if (t.root === e.root && t.key === e.key) {
                    if (!n.aIsStrong || t.newValue === e.newValue) return [new _u(0)];
                    t.oldValue = e.newValue
                }
                return [t]
            })), Iu(yu, fu, ((t, e) => (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset && (t.howMany += e.howMany), t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e), t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e), [t]))), Iu(yu, vu, ((t, e, n) => {
                if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    const o = new Od(e.graveyardPosition.root, n),
                        i = yu.getInsertionPosition(new Od(e.graveyardPosition.root, n)),
                        r = new yu(o, 0, i, null, 0);
                    return t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e), t.insertionPosition = yu.getInsertionPosition(t.splitPosition), t.graveyardPosition = r.insertionPosition.clone(), t.graveyardPosition.stickiness = "toNext", [r, t]
                }
                return t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition) && t.howMany--, t.splitPosition.hasSameParentAs(e.targetPosition) && (t.howMany += e.howMany), t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e), t.insertionPosition = yu.getInsertionPosition(t.splitPosition), t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)), [t]
            })), Iu(yu, pu, ((t, e, n) => {
                const o = Ud._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (t.graveyardPosition) {
                    const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition);
                    if (!n.bWasUndone && i) {
                        const n = t.splitPosition._getTransformedByMoveOperation(e),
                            o = t.graveyardPosition._getTransformedByMoveOperation(e),
                            i = o.path.slice();
                        i.push(0);
                        const r = new Od(o.root, i);
                        return [new pu(n, t.howMany, r, 0)]
                    }
                    t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
                }
                const i = t.splitPosition.isEqual(e.targetPosition);
                if (i && ("insertAtSource" == n.baRelation || "splitBefore" == n.abRelation)) return t.howMany += e.howMany, t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), t.insertionPosition = yu.getInsertionPosition(t.splitPosition), [t];
                if (i && n.abRelation && n.abRelation.howMany) {
                    const {
                        howMany: e,
                        offset: o
                    } = n.abRelation;
                    return t.howMany += e, t.splitPosition = t.splitPosition.getShiftedBy(o), [t]
                }
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && o.containsPosition(t.splitPosition)) {
                    const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                    return t.howMany -= n, t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset && (t.howMany += e.howMany), t.splitPosition = e.sourcePosition.clone(), t.insertionPosition = yu.getInsertionPosition(t.splitPosition), [t]
                }
                return e.sourcePosition.isEqual(e.targetPosition) || (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset && (t.howMany -= e.howMany), t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset && (t.howMany += e.howMany)), t.splitPosition.stickiness = "toNone", t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e), t.splitPosition.stickiness = "toNext", t.graveyardPosition ? t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e) : t.insertionPosition = yu.getInsertionPosition(t.splitPosition), [t]
            })), Iu(yu, yu, ((t, e, n) => {
                if (t.splitPosition.isEqual(e.splitPosition)) {
                    if (!t.graveyardPosition && !e.graveyardPosition) return [new _u(0)];
                    if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) return [new _u(0)];
                    if ("splitBefore" == n.abRelation) return t.howMany = 0, t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e), [t]
                }
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                    const o = "$graveyard" == t.splitPosition.root.rootName,
                        i = "$graveyard" == e.splitPosition.root.rootName;
                    if (i && !o || !(o && !i) && n.aIsStrong) {
                        const n = [];
                        return e.howMany && n.push(new pu(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), t.howMany && n.push(new pu(t.splitPosition, t.howMany, t.moveTargetPosition, 0)), n
                    }
                    return [new _u(0)]
                }
                if (t.graveyardPosition && (t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)), t.splitPosition.isEqual(e.insertionPosition) && "splitBefore" == n.abRelation) return t.howMany++, [t];
                if (e.splitPosition.isEqual(t.insertionPosition) && "splitBefore" == n.baRelation) {
                    const n = e.insertionPosition.path.slice();
                    n.push(0);
                    const o = new Od(e.insertionPosition.root, n);
                    return [t, new pu(t.insertionPosition, 1, o, 0)]
                }
                return t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset && (t.howMany -= e.howMany), t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e), t.insertionPosition = yu.getInsertionPosition(t.splitPosition), [t]
            }));
            class Ru extends(N(Od)) {
                constructor(t, e, n = "toNone") {
                    if (super(t, e, n), !this.root.is("rootElement")) throw new A("model-liveposition-root-not-rootelement", t);
                    ju.call(this)
                }
                detach() {
                    this.stopListening()
                }
                toPosition() {
                    return new Od(this.root, this.path.slice(), this.stickiness)
                }
                static fromPosition(t, e) {
                    return new this(t.root, t.path.slice(), e || t.stickiness)
                }
            }
    
            function ju() {
                this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && Fu.call(this, n)
                }), {
                    priority: "low"
                })
            }
    
            function Fu(t) {
                const e = this.getTransformedByOperation(t);
                if (!this.isEqual(e)) {
                    const t = this.toPosition();
                    this.path = e.path, this.root = e.root, this.fire("change", t)
                }
            }
            Ru.prototype.is = function(t) {
                return "livePosition" === t || "model:livePosition" === t || "position" == t || "model:position" === t
            };
            class Vu {
                constructor(t = {}) {
                    "string" == typeof t && (t = "transparent" === t ? {
                        isUndoable: !1
                    } : {}, C("batch-constructor-deprecated-string-type"));
                    const {
                        isUndoable: e = !0,
                        isLocal: n = !0,
                        isUndo: o = !1,
                        isTyping: i = !1
                    } = t;
                    this.operations = [], this.isUndoable = e, this.isLocal = n, this.isUndo = o, this.isTyping = i
                }
                get type() {
                    return C("batch-type-deprecated"), "default"
                }
                get baseVersion() {
                    for (const t of this.operations)
                        if (null !== t.baseVersion) return t.baseVersion;
                    return null
                }
                addOperation(t) {
                    return t.batch = this, this.operations.push(t), t
                }
            }
            class Hu {
                constructor(t) {
                    this._changesInElement = new Map, this._elementSnapshots = new Map, this._changedMarkers = new Map, this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = new Set, this._markerCollection = t
                }
                get isEmpty() {
                    return 0 == this._changesInElement.size && 0 == this._changedMarkers.size
                }
                bufferOperation(t) {
                    const e = t;
                    switch (e.type) {
                        case "insert":
                            if (this._isInInsertedElement(e.position.parent)) return;
                            this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset);
                            break;
                        case "addAttribute":
                        case "removeAttribute":
                        case "changeAttribute":
                            for (const t of e.range.getItems({
                                    shallow: !0
                                })) this._isInInsertedElement(t.parent) || this._markAttribute(t);
                            break;
                        case "remove":
                        case "move":
                        case "reinsert": {
                            if (e.sourcePosition.isEqual(e.targetPosition) || e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)) return;
                            const t = this._isInInsertedElement(e.sourcePosition.parent),
                                n = this._isInInsertedElement(e.targetPosition.parent);
                            t || this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany), n || this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany);
                            break
                        }
                        case "rename": {
                            if (this._isInInsertedElement(e.position.parent)) return;
                            this._markRemove(e.position.parent, e.position.offset, 1), this._markInsert(e.position.parent, e.position.offset, 1);
                            const t = Ud._createFromPositionAndShift(e.position, 1);
                            for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                                const t = e.getData();
                                this.bufferMarkerChange(e.name, t, t)
                            }
                            break
                        }
                        case "split": {
                            const t = e.splitPosition.parent;
                            this._isInInsertedElement(t) || this._markRemove(t, e.splitPosition.offset, e.howMany), this._isInInsertedElement(e.insertionPosition.parent) || this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1), e.graveyardPosition && this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1);
                            break
                        }
                        case "merge": {
                            const t = e.sourcePosition.parent;
                            this._isInInsertedElement(t.parent) || this._markRemove(t.parent, t.startOffset, 1);
                            const n = e.graveyardPosition.parent;
                            this._markInsert(n, e.graveyardPosition.offset, 1);
                            const o = e.targetPosition.parent;
                            this._isInInsertedElement(o) || this._markInsert(o, e.targetPosition.offset, t.maxOffset);
                            break
                        }
                    }
                    this._cachedChanges = null
                }
                bufferMarkerChange(t, e, n) {
                    const o = this._changedMarkers.get(t);
                    o ? (o.newMarkerData = n, null == o.oldMarkerData.range && null == n.range && this._changedMarkers.delete(t)) : this._changedMarkers.set(t, {
                        newMarkerData: n,
                        oldMarkerData: e
                    })
                }
                getMarkersToRemove() {
                    const t = [];
                    for (const [e, n] of this._changedMarkers) null != n.oldMarkerData.range && t.push({
                        name: e,
                        range: n.oldMarkerData.range
                    });
                    return t
                }
                getMarkersToAdd() {
                    const t = [];
                    for (const [e, n] of this._changedMarkers) null != n.newMarkerData.range && t.push({
                        name: e,
                        range: n.newMarkerData.range
                    });
                    return t
                }
                getChangedMarkers() {
                    return Array.from(this._changedMarkers).map((([t, e]) => ({
                        name: t,
                        data: {
                            oldRange: e.oldMarkerData.range,
                            newRange: e.newMarkerData.range
                        }
                    })))
                }
                hasDataChanges() {
                    if (this._changesInElement.size > 0) return !0;
                    for (const {
                            newMarkerData: t,
                            oldMarkerData: e
                        }
                        of this._changedMarkers.values()) {
                        if (t.affectsData !== e.affectsData) return !0;
                        if (t.affectsData) {
                            const n = t.range && !e.range,
                                o = !t.range && e.range,
                                i = t.range && e.range && !t.range.isEqual(e.range);
                            if (n || o || i) return !0
                        }
                    }
                    return !1
                }
                getChanges(t = {}) {
                    if (this._cachedChanges) return t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
                    let e = [];
                    for (const t of this._changesInElement.keys()) {
                        const n = this._changesInElement.get(t).sort(((t, e) => t.offset === e.offset ? t.type != e.type ? "remove" == t.type ? -1 : 1 : 0 : t.offset < e.offset ? -1 : 1)),
                            o = this._elementSnapshots.get(t),
                            i = Uu(t.getChildren()),
                            r = Wu(o.length, n);
                        let s = 0,
                            a = 0;
                        for (const n of r)
                            if ("i" === n) e.push(this._getInsertDiff(t, s, i[s])), s++;
                            else if ("r" === n) e.push(this._getRemoveDiff(t, s, o[a])), a++;
                        else if ("a" === n) {
                            const n = i[s].attributes,
                                r = o[a].attributes;
                            let c;
                            if ("$text" == i[s].name) c = new Ud(Od._createAt(t, s), Od._createAt(t, s + 1));
                            else {
                                const e = t.offsetToIndex(s);
                                c = new Ud(Od._createAt(t, s), Od._createAt(t.getChild(e), 0))
                            }
                            e.push(...this._getAttributesDiff(c, r, n)), s++, a++
                        } else s++, a++
                    }
                    e.sort(((t, e) => t.position.root != e.position.root ? t.position.root.rootName < e.position.root.rootName ? -1 : 1 : t.position.isEqual(e.position) ? t.changeCount - e.changeCount : t.position.isBefore(e.position) ? -1 : 1));
                    for (let t = 1, n = 0; t < e.length; t++) {
                        const o = e[n],
                            i = e[t],
                            r = "remove" == o.type && "remove" == i.type && "$text" == o.name && "$text" == i.name && o.position.isEqual(i.position),
                            s = "insert" == o.type && "insert" == i.type && "$text" == o.name && "$text" == i.name && o.position.parent == i.position.parent && o.position.offset + o.length == i.position.offset,
                            a = "attribute" == o.type && "attribute" == i.type && o.position.parent == i.position.parent && o.range.isFlat && i.range.isFlat && o.position.offset + o.length == i.position.offset && o.attributeKey == i.attributeKey && o.attributeOldValue == i.attributeOldValue && o.attributeNewValue == i.attributeNewValue;
                        r || s || a ? (o.length++, a && (o.range.end = o.range.end.getShiftedBy(1)), e[t] = null) : n = t
                    }
                    e = e.filter((t => t));
                    for (const t of e) delete t.changeCount, "attribute" == t.type && (delete t.position, delete t.length);
                    return this._changeCount = 0, this._cachedChangesWithGraveyard = e, this._cachedChanges = e.filter(qu), t.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice()
                }
                getRefreshedItems() {
                    return new Set(this._refreshedItems)
                }
                reset() {
                    this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._refreshedItems = new Set, this._cachedChanges = null
                }
                _refreshItem(t) {
                    if (this._isInInsertedElement(t.parent)) return;
                    this._markRemove(t.parent, t.startOffset, t.offsetSize), this._markInsert(t.parent, t.startOffset, t.offsetSize), this._refreshedItems.add(t);
                    const e = Ud._createOn(t);
                    for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                        const e = t.getData();
                        this.bufferMarkerChange(t.name, e, e)
                    }
                    this._cachedChanges = null
                }
                _markInsert(t, e, n) {
                    const o = {
                        type: "insert",
                        offset: e,
                        howMany: n,
                        count: this._changeCount++
                    };
                    this._markChange(t, o)
                }
                _markRemove(t, e, n) {
                    const o = {
                        type: "remove",
                        offset: e,
                        howMany: n,
                        count: this._changeCount++
                    };
                    this._markChange(t, o), this._removeAllNestedChanges(t, e, n)
                }
                _markAttribute(t) {
                    const e = {
                        type: "attribute",
                        offset: t.startOffset,
                        howMany: t.offsetSize,
                        count: this._changeCount++
                    };
                    this._markChange(t.parent, e)
                }
                _markChange(t, e) {
                    this._makeSnapshot(t);
                    const n = this._getChangesForElement(t);
                    this._handleChange(e, n), n.push(e);
                    for (let t = 0; t < n.length; t++) n[t].howMany < 1 && (n.splice(t, 1), t--)
                }
                _getChangesForElement(t) {
                    let e;
                    return this._changesInElement.has(t) ? e = this._changesInElement.get(t) : (e = [], this._changesInElement.set(t, e)), e
                }
                _makeSnapshot(t) {
                    this._elementSnapshots.has(t) || this._elementSnapshots.set(t, Uu(t.getChildren()))
                }
                _handleChange(t, e) {
                    t.nodesToHandle = t.howMany;
                    for (const n of e) {
                        const o = t.offset + t.howMany,
                            i = n.offset + n.howMany;
                        if ("insert" == t.type && ("insert" == n.type && (t.offset <= n.offset ? n.offset += t.howMany : t.offset < i && (n.howMany += t.nodesToHandle, t.nodesToHandle = 0)), "remove" == n.type && t.offset < n.offset && (n.offset += t.howMany), "attribute" == n.type))
                            if (t.offset <= n.offset) n.offset += t.howMany;
                            else if (t.offset < i) {
                            const i = n.howMany;
                            n.howMany = t.offset - n.offset, e.unshift({
                                type: "attribute",
                                offset: o,
                                howMany: i - n.howMany,
                                count: this._changeCount++
                            })
                        }
                        if ("remove" == t.type) {
                            if ("insert" == n.type)
                                if (o <= n.offset) n.offset -= t.howMany;
                                else if (o <= i)
                                if (t.offset < n.offset) {
                                    const e = o - n.offset;
                                    n.offset = t.offset, n.howMany -= e, t.nodesToHandle -= e
                                } else n.howMany -= t.nodesToHandle, t.nodesToHandle = 0;
                            else if (t.offset <= n.offset) t.nodesToHandle -= n.howMany, n.howMany = 0;
                            else if (t.offset < i) {
                                const e = i - t.offset;
                                n.howMany -= e, t.nodesToHandle -= e
                            }
                            if ("remove" == n.type && (o <= n.offset ? n.offset -= t.howMany : t.offset < n.offset && (t.nodesToHandle += n.howMany, n.howMany = 0)), "attribute" == n.type)
                                if (o <= n.offset) n.offset -= t.howMany;
                                else if (t.offset < n.offset) {
                                const e = o - n.offset;
                                n.offset = t.offset, n.howMany -= e
                            } else if (t.offset < i)
                                if (o <= i) {
                                    const o = n.howMany;
                                    n.howMany = t.offset - n.offset;
                                    const i = o - n.howMany - t.nodesToHandle;
                                    e.unshift({
                                        type: "attribute",
                                        offset: t.offset,
                                        howMany: i,
                                        count: this._changeCount++
                                    })
                                } else n.howMany -= i - t.offset
                        }
                        if ("attribute" == t.type) {
                            if ("insert" == n.type)
                                if (t.offset < n.offset && o > n.offset) {
                                    if (o > i) {
                                        const t = {
                                            type: "attribute",
                                            offset: i,
                                            howMany: o - i,
                                            count: this._changeCount++
                                        };
                                        this._handleChange(t, e), e.push(t)
                                    }
                                    t.nodesToHandle = n.offset - t.offset, t.howMany = t.nodesToHandle
                                } else t.offset >= n.offset && t.offset < i && (o > i ? (t.nodesToHandle = o - i, t.offset = i) : t.nodesToHandle = 0);
                            if ("remove" == n.type && t.offset < n.offset && o > n.offset) {
                                const i = {
                                    type: "attribute",
                                    offset: n.offset,
                                    howMany: o - n.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(i, e), e.push(i), t.nodesToHandle = n.offset - t.offset, t.howMany = t.nodesToHandle
                            }
                            "attribute" == n.type && (t.offset >= n.offset && o <= i ? (t.nodesToHandle = 0, t.howMany = 0, t.offset = 0) : t.offset <= n.offset && o >= i && (n.howMany = 0))
                        }
                    }
                    t.howMany = t.nodesToHandle, delete t.nodesToHandle
                }
                _getInsertDiff(t, e, n) {
                    return {
                        type: "insert",
                        position: Od._createAt(t, e),
                        name: n.name,
                        attributes: new Map(n.attributes),
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }
                _getRemoveDiff(t, e, n) {
                    return {
                        type: "remove",
                        position: Od._createAt(t, e),
                        name: n.name,
                        attributes: new Map(n.attributes),
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }
                _getAttributesDiff(t, e, n) {
                    const o = [];
                    n = new Map(n);
                    for (const [i, r] of e) {
                        const e = n.has(i) ? n.get(i) : null;
                        e !== r && o.push({
                            type: "attribute",
                            position: t.start,
                            range: t.clone(),
                            length: 1,
                            attributeKey: i,
                            attributeOldValue: r,
                            attributeNewValue: e,
                            changeCount: this._changeCount++
                        }), n.delete(i)
                    }
                    for (const [e, i] of n) o.push({
                        type: "attribute",
                        position: t.start,
                        range: t.clone(),
                        length: 1,
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: i,
                        changeCount: this._changeCount++
                    });
                    return o
                }
                _isInInsertedElement(t) {
                    const e = t.parent;
                    if (!e) return !1;
                    const n = this._changesInElement.get(e),
                        o = t.startOffset;
                    if (n)
                        for (const t of n)
                            if ("insert" == t.type && o >= t.offset && o < t.offset + t.howMany) return !0;
                    return this._isInInsertedElement(e)
                }
                _removeAllNestedChanges(t, e, n) {
                    const o = new Ud(Od._createAt(t, e), Od._createAt(t, e + n));
                    for (const t of o.getItems({
                            shallow: !0
                        })) t.is("element") && (this._elementSnapshots.delete(t), this._changesInElement.delete(t), this._removeAllNestedChanges(t, 0, t.maxOffset))
                }
            }
    
            function Uu(t) {
                const e = [];
                for (const n of t)
                    if (n.is("$text"))
                        for (let t = 0; t < n.data.length; t++) e.push({
                            name: "$text",
                            attributes: new Map(n.getAttributes())
                        });
                    else e.push({
                        name: n.name,
                        attributes: new Map(n.getAttributes())
                    });
                return e
            }
    
            function Wu(t, e) {
                const n = [];
                let o = 0,
                    i = 0;
                for (const t of e) {
                    if (t.offset > o) {
                        for (let e = 0; e < t.offset - o; e++) n.push("e");
                        i += t.offset - o
                    }
                    if ("insert" == t.type) {
                        for (let e = 0; e < t.howMany; e++) n.push("i");
                        o = t.offset + t.howMany
                    } else if ("remove" == t.type) {
                        for (let e = 0; e < t.howMany; e++) n.push("r");
                        o = t.offset, i += t.howMany
                    } else n.push(..."a".repeat(t.howMany).split("")), o = t.offset + t.howMany, i += t.howMany
                }
                if (i < t)
                    for (let e = 0; e < t - i - o; e++) n.push("e");
                return n
            }
    
            function qu(t) {
                const e = "position" in t && "$graveyard" == t.position.root.rootName,
                    n = "range" in t && "$graveyard" == t.range.root.rootName;
                return !e && !n
            }
            class Gu {
                constructor() {
                    this._operations = [], this._undoPairs = new Map, this._undoneOperations = new Set, this._baseVersionToOperationIndex = new Map, this._version = 0, this._gaps = new Map
                }
                get version() {
                    return this._version
                }
                set version(t) {
                    this._operations.length && t > this._version + 1 && this._gaps.set(this._version, t), this._version = t
                }
                get lastOperation() {
                    return this._operations[this._operations.length - 1]
                }
                addOperation(t) {
                    if (t.baseVersion !== this.version) throw new A("model-document-history-addoperation-incorrect-version", this, {
                        operation: t,
                        historyVersion: this.version
                    });
                    this._operations.push(t), this._version++, this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1)
                }
                getOperations(t, e = this.version) {
                    if (!this._operations.length) return [];
                    const n = this._operations[0];
                    void 0 === t && (t = n.baseVersion);
                    let o = e - 1;
                    for (const [e, n] of this._gaps) t > e && t < n && (t = n), o > e && o < n && (o = e - 1);
                    if (o < n.baseVersion || t > this.lastOperation.baseVersion) return [];
                    let i = this._baseVersionToOperationIndex.get(t);
                    void 0 === i && (i = 0);
                    let r = this._baseVersionToOperationIndex.get(o);
                    return void 0 === r && (r = this._operations.length - 1), this._operations.slice(i, r + 1)
                }
                getOperation(t) {
                    const e = this._baseVersionToOperationIndex.get(t);
                    if (void 0 !== e) return this._operations[e]
                }
                setOperationAsUndone(t, e) {
                    this._undoPairs.set(e, t), this._undoneOperations.add(t)
                }
                isUndoingOperation(t) {
                    return this._undoPairs.has(t)
                }
                isUndoneOperation(t) {
                    return this._undoneOperations.has(t)
                }
                getUndoneOperation(t) {
                    return this._undoPairs.get(t)
                }
                reset() {
                    this._version = 0, this._undoPairs = new Map, this._operations = [], this._undoneOperations = new Set, this._gaps = new Map, this._baseVersionToOperationIndex = new Map
                }
            }
            class $u extends Pd {
                constructor(t, e, n = "main") {
                    super(e), this._document = t, this.rootName = n
                }
                get document() {
                    return this._document
                }
                toJSON() {
                    return this.rootName
                }
            }
            $u.prototype.is = function(t, e) {
                return e ? e === this.name && ("rootElement" === t || "model:rootElement" === t || "element" === t || "model:element" === t) : "rootElement" === t || "model:rootElement" === t || "element" === t || "model:element" === t || "node" === t || "model:node" === t
            };
            const Yu = "$graveyard";
            class Ku extends(N()) {
                constructor(t) {
                    super(), this.model = t, this.history = new Gu, this.selection = new rh(this), this.roots = new ur({
                        idProperty: "rootName"
                    }), this.differ = new Hu(t.markers), this._postFixers = new Set, this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Yu), this.listenTo(t, "applyOperation", ((t, e) => {
                        const n = e[0];
                        n.isDocumentOperation && this.differ.bufferOperation(n)
                    }), {
                        priority: "high"
                    }), this.listenTo(t, "applyOperation", ((t, e) => {
                        const n = e[0];
                        n.isDocumentOperation && this.history.addOperation(n)
                    }), {
                        priority: "low"
                    }), this.listenTo(this.selection, "change", (() => {
                        this._hasSelectionChangedFromTheLastChangeBlock = !0
                    })), this.listenTo(t.markers, "update", ((t, e, n, o, i) => {
                        const r = {
                            ...e.getData(),
                            range: o
                        };
                        this.differ.bufferMarkerChange(e.name, i, r), null === n && e.on("change", ((t, n) => {
                            const o = e.getData();
                            this.differ.bufferMarkerChange(e.name, {
                                ...o,
                                range: n
                            }, o)
                        }))
                    }))
                }
                get version() {
                    return this.history.version
                }
                set version(t) {
                    this.history.version = t
                }
                get graveyard() {
                    return this.getRoot(Yu)
                }
                createRoot(t = "$root", e = "main") {
                    if (this.roots.get(e)) throw new A("model-document-createroot-name-exists", this, {
                        name: e
                    });
                    const n = new $u(this, t, e);
                    return this.roots.add(n), n
                }
                destroy() {
                    this.selection.destroy(), this.stopListening()
                }
                getRoot(t = "main") {
                    return this.roots.get(t)
                }
                getRootNames() {
                    return Array.from(this.roots, (t => t.rootName)).filter((t => t != Yu))
                }
                registerPostFixer(t) {
                    this._postFixers.add(t)
                }
                toJSON() {
                    const t = Vs(this);
                    return t.selection = "[engine.model.DocumentSelection]", t.model = "[engine.model.Model]", t
                }
                _handleChangeBlock(t) {
                    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t.batch) : this.fire("change", t.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1
                }
                _hasDocumentChangedFromTheLastChangeBlock() {
                    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
                }
                _getDefaultRoot() {
                    for (const t of this.roots)
                        if (t !== this.graveyard) return t;
                    return this.graveyard
                }
                _getDefaultRange() {
                    const t = this._getDefaultRoot(),
                        e = this.model,
                        n = e.schema,
                        o = e.createPositionFromPath(t, [0]);
                    return n.getNearestSelectionRange(o) || e.createRange(o)
                }
                _validateSelectionRange(t) {
                    return Qu(t.start) && Qu(t.end)
                }
                _callPostFixers(t) {
                    let e = !1;
                    do {
                        for (const n of this._postFixers)
                            if (this.selection.refresh(), e = n(t), e) break
                    } while (e)
                }
            }
    
            function Qu(t) {
                const e = t.textNode;
                if (e) {
                    const n = e.data,
                        o = t.offset - e.startOffset;
                    return !br(n, o) && !wr(n, o)
                }
                return !0
            }
            class Zu extends(N()) {
                constructor() {
                    super(...arguments), this._markers = new Map
                } [Symbol.iterator]() {
                    return this._markers.values()
                }
                has(t) {
                    const e = t instanceof Ju ? t.name : t;
                    return this._markers.has(e)
                }
                get(t) {
                    return this._markers.get(t) || null
                }
                _set(t, e, n = !1, o = !1) {
                    const i = t instanceof Ju ? t.name : t;
                    if (i.includes(",")) throw new A("markercollection-incorrect-marker-name", this);
                    const r = this._markers.get(i);
                    if (r) {
                        const t = r.getData(),
                            s = r.getRange();
                        let a = !1;
                        return s.isEqual(e) || (r._attachLiveRange(eh.fromRange(e)), a = !0), n != r.managedUsingOperations && (r._managedUsingOperations = n, a = !0), "boolean" == typeof o && o != r.affectsData && (r._affectsData = o, a = !0), a && this.fire(`update:${i}`, r, s, e, t), r
                    }
                    const s = eh.fromRange(e),
                        a = new Ju(i, s, n, o);
                    return this._markers.set(i, a), this.fire(`update:${i}`, a, null, e, {
                        ...a.getData(),
                        range: null
                    }), a
                }
                _remove(t) {
                    const e = t instanceof Ju ? t.name : t,
                        n = this._markers.get(e);
                    return !!n && (this._markers.delete(e), this.fire(`update:${e}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0)
                }
                _refresh(t) {
                    const e = t instanceof Ju ? t.name : t,
                        n = this._markers.get(e);
                    if (!n) throw new A("markercollection-refresh-marker-not-exists", this);
                    const o = n.getRange();
                    this.fire(`update:${e}`, n, o, o, n.getData())
                }* getMarkersAtPosition(t) {
                    for (const e of this) e.getRange().containsPosition(t) && (yield e)
                }* getMarkersIntersectingRange(t) {
                    for (const e of this) null !== e.getRange().getIntersection(t) && (yield e)
                }
                destroy() {
                    for (const t of this._markers.values()) this._destroyMarker(t);
                    this._markers = null, this.stopListening()
                }* getMarkersGroup(t) {
                    for (const e of this._markers.values()) e.name.startsWith(t + ":") && (yield e)
                }
                _destroyMarker(t) {
                    t.stopListening(), t._detachLiveRange()
                }
            }
            class Ju extends(N(Td)) {
                constructor(t, e, n, o) {
                    super(), this.name = t, this._liveRange = this._attachLiveRange(e), this._managedUsingOperations = n, this._affectsData = o
                }
                get managedUsingOperations() {
                    if (!this._liveRange) throw new A("marker-destroyed", this);
                    return this._managedUsingOperations
                }
                get affectsData() {
                    if (!this._liveRange) throw new A("marker-destroyed", this);
                    return this._affectsData
                }
                getData() {
                    return {
                        range: this.getRange(),
                        affectsData: this.affectsData,
                        managedUsingOperations: this.managedUsingOperations
                    }
                }
                getStart() {
                    if (!this._liveRange) throw new A("marker-destroyed", this);
                    return this._liveRange.start.clone()
                }
                getEnd() {
                    if (!this._liveRange) throw new A("marker-destroyed", this);
                    return this._liveRange.end.clone()
                }
                getRange() {
                    if (!this._liveRange) throw new A("marker-destroyed", this);
                    return this._liveRange.toRange()
                }
                _attachLiveRange(t) {
                    return this._liveRange && this._detachLiveRange(), t.delegate("change:range").to(this), t.delegate("change:content").to(this), this._liveRange = t, t
                }
                _detachLiveRange() {
                    this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null
                }
            }
            Ju.prototype.is = function(t) {
                return "marker" === t || "model:marker" === t
            };
            class Xu extends au {
                constructor(t, e) {
                    super(null), this.sourcePosition = t.clone(), this.howMany = e
                }
                get type() {
                    return "detach"
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.sourcePosition = this.sourcePosition.toJSON(), t
                }
                _validate() {
                    if (this.sourcePosition.root.document) throw new A("detach-operation-on-document-node", this)
                }
                _execute() {
                    lu(Ud._createFromPositionAndShift(this.sourcePosition, this.howMany))
                }
                static get className() {
                    return "DetachOperation"
                }
            }
            class tg extends Td {
                constructor(t) {
                    super(), this.markers = new Map, this._children = new Sd, t && this._insertChild(0, t)
                } [Symbol.iterator]() {
                    return this.getChildren()
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return 0 === this.childCount
                }
                get nextSibling() {
                    return null
                }
                get previousSibling() {
                    return null
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                get document() {
                    return null
                }
                getAncestors() {
                    return []
                }
                getChild(t) {
                    return this._children.getNode(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(t) {
                    return this._children.getNodeIndex(t)
                }
                getChildStartOffset(t) {
                    return this._children.getNodeStartOffset(t)
                }
                getPath() {
                    return []
                }
                getNodeByPath(t) {
                    let e = this;
                    for (const n of t) e = e.getChild(e.offsetToIndex(n));
                    return e
                }
                offsetToIndex(t) {
                    return this._children.offsetToIndex(t)
                }
                toJSON() {
                    const t = [];
                    for (const e of this._children) t.push(e.toJSON());
                    return t
                }
                static fromJSON(t) {
                    const e = [];
                    for (const n of t) n.name ? e.push(Pd.fromJSON(n)) : e.push(Nd.fromJSON(n));
                    return new tg(e)
                }
                _appendChild(t) {
                    this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    const n = function(t) {
                        if ("string" == typeof t) return [new Nd(t)];
                        nt(t) || (t = [t]);
                        return Array.from(t).map((t => "string" == typeof t ? new Nd(t) : t instanceof Bd ? new Nd(t.data, t.getAttributes()) : t))
                    }(e);
                    for (const t of n) null !== t.parent && t._remove(), t.parent = this;
                    this._children._insertNodes(t, n)
                }
                _removeChildren(t, e = 1) {
                    const n = this._children._removeNodes(t, e);
                    for (const t of n) t.parent = null;
                    return n
                }
            }
            tg.prototype.is = function(t) {
                return "documentFragment" === t || "model:documentFragment" === t
            };
            class eg {
                constructor(t, e) {
                    this.model = t, this.batch = e
                }
                createText(t, e) {
                    return new Nd(t, e)
                }
                createElement(t, e) {
                    return new Pd(t, e)
                }
                createDocumentFragment() {
                    return new tg
                }
                cloneElement(t, e = !0) {
                    return t._clone(e)
                }
                insert(t, e, n = 0) {
                    if (this._assertWriterUsedCorrectly(), t instanceof Nd && "" == t.data) return;
                    const o = Od._createAt(e, n);
                    if (t.parent) {
                        if (sg(t.root, o.root)) return void this.move(Ud._createOn(t), o);
                        if (t.root.document) throw new A("model-writer-insert-forbidden-move", this);
                        this.remove(t)
                    }
                    const i = o.root.document ? o.root.document.version : null,
                        r = new fu(o, t, i);
                    if (t instanceof Nd && (r.shouldReceiveAttributes = !0), this.batch.addOperation(r), this.model.applyOperation(r), t instanceof tg)
                        for (const [e, n] of t.markers) {
                            const t = Od._createAt(n.root, 0),
                                i = {
                                    range: new Ud(n.start._getCombined(t, o), n.end._getCombined(t, o)),
                                    usingOperation: !0,
                                    affectsData: !0
                                };
                            this.model.markers.has(e) ? this.updateMarker(e, i) : this.addMarker(e, i)
                        }
                }
                insertText(t, e, n, o) {
                    e instanceof tg || e instanceof Pd || e instanceof Od ? this.insert(this.createText(t), e, n) : this.insert(this.createText(t, e), n, o)
                }
                insertElement(t, e, n, o) {
                    e instanceof tg || e instanceof Pd || e instanceof Od ? this.insert(this.createElement(t), e, n) : this.insert(this.createElement(t, e), n, o)
                }
                append(t, e) {
                    this.insert(t, e, "end")
                }
                appendText(t, e, n) {
                    e instanceof tg || e instanceof Pd ? this.insert(this.createText(t), e, "end") : this.insert(this.createText(t, e), n, "end")
                }
                appendElement(t, e, n) {
                    e instanceof tg || e instanceof Pd ? this.insert(this.createElement(t), e, "end") : this.insert(this.createElement(t, e), n, "end")
                }
                setAttribute(t, e, n) {
                    if (this._assertWriterUsedCorrectly(), n instanceof Ud) {
                        const o = n.getMinimalFlatRanges();
                        for (const n of o) ng(this, t, e, n)
                    } else og(this, t, e, n)
                }
                setAttributes(t, e) {
                    for (const [n, o] of fr(t)) this.setAttribute(n, o, e)
                }
                removeAttribute(t, e) {
                    if (this._assertWriterUsedCorrectly(), e instanceof Ud) {
                        const n = e.getMinimalFlatRanges();
                        for (const e of n) ng(this, t, null, e)
                    } else og(this, t, null, e)
                }
                clearAttributes(t) {
                    this._assertWriterUsedCorrectly();
                    const e = t => {
                        for (const e of t.getAttributeKeys()) this.removeAttribute(e, t)
                    };
                    if (t instanceof Ud)
                        for (const n of t.getItems()) e(n);
                    else e(t)
                }
                move(t, e, n) {
                    if (this._assertWriterUsedCorrectly(), !(t instanceof Ud)) throw new A("writer-move-invalid-range", this);
                    if (!t.isFlat) throw new A("writer-move-range-not-flat", this);
                    const o = Od._createAt(e, n);
                    if (o.isEqual(t.start)) return;
                    if (this._addOperationForAffectedMarkers("move", t), !sg(t.root, o.root)) throw new A("writer-move-different-document", this);
                    const i = t.root.document ? t.root.document.version : null,
                        r = new pu(t.start, t.end.offset - t.start.offset, o, i);
                    this.batch.addOperation(r), this.model.applyOperation(r)
                }
                remove(t) {
                    this._assertWriterUsedCorrectly();
                    const e = (t instanceof Ud ? t : Ud._createOn(t)).getMinimalFlatRanges().reverse();
                    for (const t of e) this._addOperationForAffectedMarkers("move", t), rg(t.start, t.end.offset - t.start.offset, this.batch, this.model)
                }
                merge(t) {
                    this._assertWriterUsedCorrectly();
                    const e = t.nodeBefore,
                        n = t.nodeAfter;
                    if (this._addOperationForAffectedMarkers("merge", t), !(e instanceof Pd)) throw new A("writer-merge-no-element-before", this);
                    if (!(n instanceof Pd)) throw new A("writer-merge-no-element-after", this);
                    t.root.document ? this._merge(t) : this._mergeDetached(t)
                }
                createPositionFromPath(t, e, n) {
                    return this.model.createPositionFromPath(t, e, n)
                }
                createPositionAt(t, e) {
                    return this.model.createPositionAt(t, e)
                }
                createPositionAfter(t) {
                    return this.model.createPositionAfter(t)
                }
                createPositionBefore(t) {
                    return this.model.createPositionBefore(t)
                }
                createRange(t, e) {
                    return this.model.createRange(t, e)
                }
                createRangeIn(t) {
                    return this.model.createRangeIn(t)
                }
                createRangeOn(t) {
                    return this.model.createRangeOn(t)
                }
                createSelection(...t) {
                    return this.model.createSelection(...t)
                }
                _mergeDetached(t) {
                    const e = t.nodeBefore,
                        n = t.nodeAfter;
                    this.move(Ud._createIn(n), Od._createAt(e, "end")), this.remove(n)
                }
                _merge(t) {
                    const e = Od._createAt(t.nodeBefore, "end"),
                        n = Od._createAt(t.nodeAfter, 0),
                        o = t.root.document.graveyard,
                        i = new Od(o, [0]),
                        r = t.root.document.version,
                        s = new vu(n, t.nodeAfter.maxOffset, e, i, r);
                    this.batch.addOperation(s), this.model.applyOperation(s)
                }
                rename(t, e) {
                    if (this._assertWriterUsedCorrectly(), !(t instanceof Pd)) throw new A("writer-rename-not-element-instance", this);
                    const n = t.root.document ? t.root.document.version : null,
                        o = new Au(Od._createBefore(t), t.name, e, n);
                    this.batch.addOperation(o), this.model.applyOperation(o)
                }
                split(t, e) {
                    this._assertWriterUsedCorrectly();
                    let n, o, i = t.parent;
                    if (!i.parent) throw new A("writer-split-element-no-parent", this);
                    if (e || (e = i.parent), !t.parent.getAncestors({
                            includeSelf: !0
                        }).includes(e)) throw new A("writer-split-invalid-limit-element", this);
                    do {
                        const e = i.root.document ? i.root.document.version : null,
                            r = i.maxOffset - t.offset,
                            s = yu.getInsertionPosition(t),
                            a = new yu(t, r, s, null, e);
                        this.batch.addOperation(a), this.model.applyOperation(a), n || o || (n = i, o = t.parent.nextSibling), i = (t = this.createPositionAfter(t.parent)).parent
                    } while (i !== e);
                    return {
                        position: t,
                        range: new Ud(Od._createAt(n, "end"), Od._createAt(o, 0))
                    }
                }
                wrap(t, e) {
                    if (this._assertWriterUsedCorrectly(), !t.isFlat) throw new A("writer-wrap-range-not-flat", this);
                    const n = e instanceof Pd ? e : new Pd(e);
                    if (n.childCount > 0) throw new A("writer-wrap-element-not-empty", this);
                    if (null !== n.parent) throw new A("writer-wrap-element-attached", this);
                    this.insert(n, t.start);
                    const o = new Ud(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                    this.move(o, Od._createAt(n, 0))
                }
                unwrap(t) {
                    if (this._assertWriterUsedCorrectly(), null === t.parent) throw new A("writer-unwrap-element-no-parent", this);
                    this.move(Ud._createIn(t), this.createPositionAfter(t)), this.remove(t)
                }
                addMarker(t, e) {
                    if (this._assertWriterUsedCorrectly(), !e || "boolean" != typeof e.usingOperation) throw new A("writer-addmarker-no-usingoperation", this);
                    const n = e.usingOperation,
                        o = e.range,
                        i = void 0 !== e.affectsData && e.affectsData;
                    if (this.model.markers.has(t)) throw new A("writer-addmarker-marker-exists", this);
                    if (!o) throw new A("writer-addmarker-no-range", this);
                    return n ? (ig(this, t, null, o, i), this.model.markers.get(t)) : this.model.markers._set(t, o, n, i)
                }
                updateMarker(t, e) {
                    this._assertWriterUsedCorrectly();
                    const n = "string" == typeof t ? t : t.name,
                        o = this.model.markers.get(n);
                    if (!o) throw new A("writer-updatemarker-marker-not-exists", this);
                    if (!e) return C("writer-updatemarker-reconvert-using-editingcontroller", {
                        markerName: n
                    }), void this.model.markers._refresh(o);
                    const i = "boolean" == typeof e.usingOperation,
                        r = "boolean" == typeof e.affectsData,
                        s = r ? e.affectsData : o.affectsData;
                    if (!i && !e.range && !r) throw new A("writer-updatemarker-wrong-options", this);
                    const a = o.getRange(),
                        c = e.range ? e.range : a;
                    i && e.usingOperation !== o.managedUsingOperations ? e.usingOperation ? ig(this, n, null, c, s) : (ig(this, n, a, null, s), this.model.markers._set(n, c, void 0, s)) : o.managedUsingOperations ? ig(this, n, a, c, s) : this.model.markers._set(n, c, void 0, s)
                }
                removeMarker(t) {
                    this._assertWriterUsedCorrectly();
                    const e = "string" == typeof t ? t : t.name;
                    if (!this.model.markers.has(e)) throw new A("writer-removemarker-no-marker", this);
                    const n = this.model.markers.get(e);
                    if (!n.managedUsingOperations) return void this.model.markers._remove(e);
                    ig(this, e, n.getRange(), null, n.affectsData)
                }
                setSelection(...t) {
                    this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...t)
                }
                setSelectionFocus(t, e) {
                    this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t, e)
                }
                setSelectionAttribute(t, e) {
                    if (this._assertWriterUsedCorrectly(), "string" == typeof t) this._setSelectionAttribute(t, e);
                    else
                        for (const [e, n] of fr(t)) this._setSelectionAttribute(e, n)
                }
                removeSelectionAttribute(t) {
                    if (this._assertWriterUsedCorrectly(), "string" == typeof t) this._removeSelectionAttribute(t);
                    else
                        for (const e of t) this._removeSelectionAttribute(e)
                }
                overrideSelectionGravity() {
                    return this.model.document.selection._overrideGravity()
                }
                restoreSelectionGravity(t) {
                    this.model.document.selection._restoreGravity(t)
                }
                _setSelectionAttribute(t, e) {
                    const n = this.model.document.selection;
                    if (n.isCollapsed && n.anchor.parent.isEmpty) {
                        const o = rh._getStoreAttributeKey(t);
                        this.setAttribute(o, e, n.anchor.parent)
                    }
                    n._setAttribute(t, e)
                }
                _removeSelectionAttribute(t) {
                    const e = this.model.document.selection;
                    if (e.isCollapsed && e.anchor.parent.isEmpty) {
                        const n = rh._getStoreAttributeKey(t);
                        this.removeAttribute(n, e.anchor.parent)
                    }
                    e._removeAttribute(t)
                }
                _assertWriterUsedCorrectly() {
                    if (this.model._currentWriter !== this) throw new A("writer-incorrect-use", this)
                }
                _addOperationForAffectedMarkers(t, e) {
                    for (const n of this.model.markers) {
                        if (!n.managedUsingOperations) continue;
                        const o = n.getRange();
                        let i = !1;
                        if ("move" === t) {
                            const t = e;
                            i = t.containsPosition(o.start) || t.start.isEqual(o.start) || t.containsPosition(o.end) || t.end.isEqual(o.end)
                        } else {
                            const t = e,
                                n = t.nodeBefore,
                                r = t.nodeAfter,
                                s = o.start.parent == n && o.start.isAtEnd,
                                a = o.end.parent == r && 0 == o.end.offset,
                                c = o.end.nodeAfter == r,
                                l = o.start.nodeAfter == r;
                            i = s || a || c || l
                        }
                        i && this.updateMarker(n.name, {
                            range: o
                        })
                    }
                }
            }
    
            function ng(t, e, n, o) {
                const i = t.model,
                    r = i.document;
                let s, a, c, l = o.start;
                for (const t of o.getWalker({
                        shallow: !0
                    })) c = t.item.getAttribute(e), s && a != c && (a != n && d(), l = s), s = t.nextPosition, a = c;
    
                function d() {
                    const o = new Ud(l, s),
                        c = o.root.document ? r.version : null,
                        d = new wu(o, e, a, n, c);
                    t.batch.addOperation(d), i.applyOperation(d)
                }
                s instanceof Od && s != l && a != n && d()
            }
    
            function og(t, e, n, o) {
                const i = t.model,
                    r = i.document,
                    s = o.getAttribute(e);
                let a, c;
                if (s != n) {
                    if (o.root === o) {
                        const t = o.document ? r.version : null;
                        c = new Cu(o, e, s, n, t)
                    } else {
                        a = new Ud(Od._createBefore(o), t.createPositionAfter(o));
                        const i = a.root.document ? r.version : null;
                        c = new wu(a, e, s, n, i)
                    }
                    t.batch.addOperation(c), i.applyOperation(c)
                }
            }
    
            function ig(t, e, n, o, i) {
                const r = t.model,
                    s = r.document,
                    a = new ku(e, n, o, r.markers, !!i, s.version);
                t.batch.addOperation(a), r.applyOperation(a)
            }
    
            function rg(t, e, n, o) {
                let i;
                if (t.root.document) {
                    const n = o.document,
                        r = new Od(n.graveyard, [0]);
                    i = new pu(t, e, r, n.version)
                } else i = new Xu(t, e);
                n.addOperation(i), o.applyOperation(i)
            }
    
            function sg(t, e) {
                return t === e || t instanceof $u && e instanceof $u
            }
    
            function ag(t) {
                t.document.registerPostFixer((e => function(t, e) {
                    const n = e.document.selection,
                        o = e.schema,
                        i = [];
                    let r = !1;
                    for (const t of n.getRanges()) {
                        const e = cg(t, o);
                        e && !e.isEqual(t) ? (i.push(e), r = !0) : i.push(t)
                    }
                    r && t.setSelection(function(t) {
                        const e = [...t],
                            n = new Set;
                        let o = 1;
                        for (; o < e.length;) {
                            const t = e[o],
                                i = e.slice(0, o);
                            for (const [r, s] of i.entries())
                                if (!n.has(r))
                                    if (t.isEqual(s)) n.add(r);
                                    else if (t.isIntersecting(s)) {
                                n.add(r), n.add(o);
                                const i = t.getJoined(s);
                                e.push(i)
                            }
                            o++
                        }
                        return e.filter(((t, e) => !n.has(e)))
                    }(i), {
                        backward: n.isBackward
                    });
                    return !1
                }(e, t)))
            }
    
            function cg(t, e) {
                return t.isCollapsed ? function(t, e) {
                    const n = t.start,
                        o = e.getNearestSelectionRange(n);
                    if (!o) {
                        const t = n.getAncestors().reverse().find((t => e.isObject(t)));
                        return t ? Ud._createOn(t) : null
                    }
                    if (!o.isCollapsed) return o;
                    const i = o.start;
                    if (n.isEqual(i)) return null;
                    return new Ud(i)
                }(t, e) : function(t, e) {
                    const {
                        start: n,
                        end: o
                    } = t, i = e.checkChild(n, "$text"), r = e.checkChild(o, "$text"), s = e.getLimitElement(n), a = e.getLimitElement(o);
                    if (s === a) {
                        if (i && r) return null;
                        if (function(t, e, n) {
                                const o = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text"),
                                    i = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
                                return o || i
                            }(n, o, e)) {
                            const t = n.nodeAfter && e.isSelectable(n.nodeAfter) ? null : e.getNearestSelectionRange(n, "forward"),
                                i = o.nodeBefore && e.isSelectable(o.nodeBefore) ? null : e.getNearestSelectionRange(o, "backward"),
                                r = t ? t.start : n,
                                s = i ? i.end : o;
                            return new Ud(r, s)
                        }
                    }
                    const c = s && !s.is("rootElement"),
                        l = a && !a.is("rootElement");
                    if (c || l) {
                        const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent,
                            i = c && (!t || !dg(n.nodeAfter, e)),
                            r = l && (!t || !dg(o.nodeBefore, e));
                        let d = n,
                            h = o;
                        return i && (d = Od._createBefore(lg(s, e))), r && (h = Od._createAfter(lg(a, e))), new Ud(d, h)
                    }
                    return null
                }(t, e)
            }
    
            function lg(t, e) {
                let n = t,
                    o = n;
                for (; e.isLimit(o) && o.parent;) n = o, o = o.parent;
                return n
            }
    
            function dg(t, e) {
                return t && e.isSelectable(t)
            }
    
            function hg(t, e, n = {}) {
                if (e.isCollapsed) return;
                const o = e.getFirstRange();
                if ("$graveyard" == o.root.rootName) return;
                const i = t.schema;
                t.change((t => {
                    if (!n.doNotResetEntireContent && function(t, e) {
                            const n = t.getLimitElement(e);
                            if (!e.containsEntireContent(n)) return !1;
                            const o = e.getFirstRange();
                            if (o.start.parent == o.end.parent) return !1;
                            return t.checkChild(n, "paragraph")
                        }(i, e)) return void
                    function(t, e) {
                        const n = t.model.schema.getLimitElement(e);
                        t.remove(t.createRangeIn(n)), pg(t, t.createPositionAt(n, 0), e)
                    }(t, e);
                    const r = {};
                    if (!n.doNotAutoparagraph) {
                        const t = e.getSelectedElement();
                        t && Object.assign(r, i.getAttributesWithProperty(t, "copyOnReplace", !0))
                    }
                    const [s, a] = function(t) {
                        const e = t.root.document.model,
                            n = t.start;
                        let o = t.end;
                        if (e.hasContent(t, {
                                ignoreMarkers: !0
                            })) {
                            const n = function(t) {
                                const e = t.parent,
                                    n = e.root.document.model.schema,
                                    o = e.getAncestors({
                                        parentFirst: !0,
                                        includeSelf: !0
                                    });
                                for (const t of o) {
                                    if (n.isLimit(t)) return null;
                                    if (n.isBlock(t)) return t
                                }
                            }(o);
                            if (n && o.isTouching(e.createPositionAt(n, 0))) {
                                const n = e.createSelection(t);
                                e.modifySelection(n, {
                                    direction: "backward"
                                });
                                const i = n.getLastPosition(),
                                    r = e.createRange(i, o);
                                e.hasContent(r, {
                                    ignoreMarkers: !0
                                }) || (o = i)
                            }
                        }
                        return [Ru.fromPosition(n, "toPrevious"), Ru.fromPosition(o, "toNext")]
                    }(o);
                    s.isTouching(a) || t.remove(t.createRange(s, a)), n.leaveUnmerged || (! function(t, e, n) {
                        const o = t.model;
                        if (!mg(t.model.schema, e, n)) return;
                        const [i, r] = function(t, e) {
                            const n = t.getAncestors(),
                                o = e.getAncestors();
                            let i = 0;
                            for (; n[i] && n[i] == o[i];) i++;
                            return [n[i], o[i]]
                        }(e, n);
                        if (!i || !r) return;
                        !o.hasContent(i, {
                            ignoreMarkers: !0
                        }) && o.hasContent(r, {
                            ignoreMarkers: !0
                        }) ? gg(t, e, n, i.parent) : ug(t, e, n, i.parent)
                    }(t, s, a), i.removeDisallowedAttributes(s.parent.getChildren(), t)), fg(t, e, s), !n.doNotAutoparagraph && function(t, e) {
                        const n = t.checkChild(e, "$text"),
                            o = t.checkChild(e, "paragraph");
                        return !n && o
                    }(i, s) && pg(t, s, e, r), s.detach(), a.detach()
                }))
            }
    
            function ug(t, e, n, o) {
                const i = e.parent,
                    r = n.parent;
                if (i != o && r != o) {
                    for (e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(r, e), t.merge(e); n.parent.isEmpty;) {
                        const e = n.parent;
                        n = t.createPositionBefore(e), t.remove(e)
                    }
                    mg(t.model.schema, e, n) && ug(t, e, n, o)
                }
            }
    
            function gg(t, e, n, o) {
                const i = e.parent,
                    r = n.parent;
                if (i != o && r != o) {
                    for (e = t.createPositionAfter(i), (n = t.createPositionBefore(r)).isEqual(e) || t.insert(i, n); e.parent.isEmpty;) {
                        const n = e.parent;
                        e = t.createPositionBefore(n), t.remove(n)
                    }
                    n = t.createPositionBefore(r),
                        function(t, e) {
                            const n = e.nodeBefore,
                                o = e.nodeAfter;
                            n.name != o.name && t.rename(n, o.name);
                            t.clearAttributes(n), t.setAttributes(Object.fromEntries(o.getAttributes()), n), t.merge(e)
                        }(t, n), mg(t.model.schema, e, n) && gg(t, e, n, o)
                }
            }
    
            function mg(t, e, n) {
                const o = e.parent,
                    i = n.parent;
                return o != i && (!t.isLimit(o) && !t.isLimit(i) && function(t, e, n) {
                    const o = new Ud(t, e);
                    for (const t of o.getWalker())
                        if (n.isLimit(t.item)) return !1;
                    return !0
                }(e, n, t))
            }
    
            function pg(t, e, n, o = {}) {
                const i = t.createElement("paragraph");
                t.model.schema.setAllowedAttributes(i, o, t), t.insert(i, e), fg(t, n, t.createPositionAt(i, 0))
            }
    
            function fg(t, e, n) {
                e instanceof rh ? t.setSelection(n) : e.setTo(n)
            }
    
            function kg(t, e) {
                const n = [];
                Array.from(t.getItems({
                    direction: "backward"
                })).map((t => e.createRangeOn(t))).filter((e => (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end)))).forEach((t => {
                    n.push(t.start.parent), e.remove(t)
                })), n.forEach((t => {
                    let n = t;
                    for (; n.parent && n.isEmpty;) {
                        const t = e.createRangeOn(n);
                        n = n.parent, e.remove(t)
                    }
                }))
            }
            class bg {
                constructor(t, e, n) {
                    this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = t, this.writer = e, this.position = n, this.canMergeWith = new Set([this.position.parent]), this.schema = t.schema, this._documentFragment = e.createDocumentFragment(), this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0)
                }
                handleNodes(t) {
                    for (const e of Array.from(t)) this._handleNode(e);
                    this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = []
                }
                _updateLastNodeFromAutoParagraph(t) {
                    const e = this.writer.createPositionAfter(this._lastNode),
                        n = this.writer.createPositionAfter(t);
                    if (n.isAfter(e)) {
                        if (this._lastNode = t, this.position.parent != t || !this.position.isAtEnd) throw new A("insertcontent-invalid-insertion-position", this);
                        this.position = n, this._setAffectedBoundaries(this.position)
                    }
                }
                getSelectionRange() {
                    return this._nodeToSelect ? Ud._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position)
                }
                getAffectedRange() {
                    return this._affectedStart ? new Ud(this._affectedStart, this._affectedEnd) : null
                }
                destroy() {
                    this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach()
                }
                _handleNode(t) {
                    if (this.schema.isObject(t)) return void this._handleObject(t);
                    let e = this._checkAndAutoParagraphToAllowedPosition(t);
                    e || (e = this._checkAndSplitToAllowedPosition(t), e) ? (this._appendToFragment(t), this._firstNode || (this._firstNode = t), this._lastNode = t) : this._handleDisallowedNode(t)
                }
                _insertPartialFragment() {
                    if (this._documentFragment.isEmpty) return;
                    const t = Ru.fromPosition(this.position, "toNext");
                    this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = t.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = t.toPosition(), t.detach()
                }
                _handleObject(t) {
                    this._checkAndSplitToAllowedPosition(t) ? this._appendToFragment(t) : this._tryAutoparagraphing(t)
                }
                _handleDisallowedNode(t) {
                    t.is("element") ? this.handleNodes(t.getChildren()) : this._tryAutoparagraphing(t)
                }
                _appendToFragment(t) {
                    if (!this.schema.checkChild(this.position, t)) throw new A("insertcontent-wrong-position", this, {
                        node: t,
                        position: this.position
                    });
                    this.writer.insert(t, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize), this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = t : this._nodeToSelect = null, this._filterAttributesOf.push(t)
                }
                _setAffectedBoundaries(t) {
                    this._affectedStart || (this._affectedStart = Ru.fromPosition(t, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Ru.fromPosition(t, "toNext"))
                }
                _mergeOnLeft() {
                    const t = this._firstNode;
                    if (!(t instanceof Pd)) return;
                    if (!this._canMergeLeft(t)) return;
                    const e = Ru._createBefore(t);
                    e.stickiness = "toNext";
                    const n = Ru.fromPosition(this.position, "toNext");
                    this._affectedStart.isEqual(e) && (this._affectedStart.detach(), this._affectedStart = Ru._createAt(e.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = e.nodeBefore, this._lastNode = e.nodeBefore), this.writer.merge(e), e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Ru._createAt(e.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), e.detach()
                }
                _mergeOnRight() {
                    const t = this._lastNode;
                    if (!(t instanceof Pd)) return;
                    if (!this._canMergeRight(t)) return;
                    const e = Ru._createAfter(t);
                    if (e.stickiness = "toNext", !this.position.isEqual(e)) throw new A("insertcontent-invalid-insertion-position", this);
                    this.position = Od._createAt(e.nodeBefore, "end");
                    const n = Ru.fromPosition(this.position, "toPrevious");
                    this._affectedEnd.isEqual(e) && (this._affectedEnd.detach(), this._affectedEnd = Ru._createAt(e.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = e.nodeBefore, this._lastNode = e.nodeBefore), this.writer.merge(e), e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Ru._createAt(e.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), e.detach()
                }
                _canMergeLeft(t) {
                    const e = t.previousSibling;
                    return e instanceof Pd && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t)
                }
                _canMergeRight(t) {
                    const e = t.nextSibling;
                    return e instanceof Pd && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e)
                }
                _tryAutoparagraphing(t) {
                    const e = this.writer.createElement("paragraph");
                    this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t) && (e._appendChild(t), this._handleNode(e))
                }
                _checkAndAutoParagraphToAllowedPosition(t) {
                    if (this.schema.checkChild(this.position.parent, t)) return !0;
                    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t)) return !1;
                    this._insertPartialFragment();
                    const e = this.writer.createElement("paragraph");
                    return this.writer.insert(e, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e, this.position = this.writer.createPositionAt(e, 0), !0
                }
                _checkAndSplitToAllowedPosition(t) {
                    const e = this._getAllowedIn(this.position.parent, t);
                    if (!e) return !1;
                    for (e != this.position.parent && this._insertPartialFragment(); e != this.position.parent;)
                        if (this.position.isAtStart) {
                            const t = this.position.parent;
                            this.position = this.writer.createPositionBefore(t), t.isEmpty && t.parent === e && this.writer.remove(t)
                        } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent);
                    else {
                        const t = this.writer.createPositionAfter(this.position.parent);
                        this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t, this.canMergeWith.add(this.position.nodeAfter)
                    }
                    return !0
                }
                _getAllowedIn(t, e) {
                    return this.schema.checkChild(t, e) ? t : this.schema.isLimit(t) ? null : this._getAllowedIn(t.parent, e)
                }
            }
    
            function wg(t, e, n = "auto") {
                const o = t.getSelectedElement();
                if (o && e.schema.isObject(o) && !e.schema.isInline(o)) return "before" == n || "after" == n ? e.createRange(e.createPositionAt(o, n)) : e.createRangeOn(o);
                const i = gr(t.getSelectedBlocks());
                if (!i) return e.createRange(t.focus);
                if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
                const r = e.createPositionAfter(i);
                return t.focus.isTouching(r) ? e.createRange(r) : e.createRange(e.createPositionBefore(i))
            }
    
            function _g(t, e, n, o, i = {}) {
                if (!t.schema.isObject(e)) throw new A("insertobject-element-not-an-object", t, {
                    object: e
                });
                let r;
                r = n ? n instanceof Qd || n instanceof rh ? n : t.createSelection(n, o) : t.document.selection;
                let s = r;
                i.findOptimalPosition && t.schema.isBlock(e) && (s = t.createSelection(wg(r, t, i.findOptimalPosition)));
                const a = gr(r.getSelectedBlocks()),
                    c = {};
                return a && Object.assign(c, t.schema.getAttributesWithProperty(a, "copyOnReplace", !0)), t.change((n => {
                    s.isCollapsed || t.deleteContent(s, {
                        doNotAutoparagraph: !0
                    });
                    let o = e;
                    const r = s.anchor.parent;
                    !t.schema.checkChild(r, e) && t.schema.checkChild(r, "paragraph") && t.schema.checkChild("paragraph", e) && (o = n.createElement("paragraph"), n.insert(e, o)), t.schema.setAllowedAttributes(o, c, n);
                    const a = t.insertContent(o, s);
                    return a.isCollapsed || i.setSelection && function(t, e, n, o) {
                        const i = t.model;
                        if ("on" == n) return void t.setSelection(e, "on");
                        if ("after" != n) throw new A("insertobject-invalid-place-parameter-value", i);
                        let r = e.nextSibling;
                        if (i.schema.isInline(e)) return void t.setSelection(e, "after");
                        const s = r && i.schema.checkChild(r, "$text");
                        !s && i.schema.checkChild(e.parent, "paragraph") && (r = t.createElement("paragraph"), i.schema.setAllowedAttributes(r, o, t), i.insertContent(r, t.createPositionAfter(e)));
                        r && t.setSelection(r, 0)
                    }(n, e, i.setSelection, c), a
                }))
            }
            const Ag = ' ,.?!:;"-()';
    
            function Cg(t, e) {
                const {
                    isForward: n,
                    walker: o,
                    unit: i,
                    schema: r,
                    treatEmojiAsSingleUnit: s
                } = t, {
                    type: a,
                    item: c,
                    nextPosition: l
                } = e;
                if ("text" == a) return "word" === t.unit ? function(t, e) {
                    let n = t.position.textNode;
                    n || (n = e ? t.position.nodeAfter : t.position.nodeBefore);
                    for (; n && n.is("$text");) {
                        const o = t.position.offset - n.startOffset;
                        if (xg(n, o, e)) n = e ? t.position.nodeAfter : t.position.nodeBefore;
                        else {
                            if (yg(n.data, o, e)) break;
                            t.next()
                        }
                    }
                    return t.position
                }(o, n) : function(t, e, n) {
                    const o = t.position.textNode;
                    if (o) {
                        const i = o.data;
                        let r = t.position.offset - o.startOffset;
                        for (; br(i, r) || "character" == e && wr(i, r) || n && Ar(i, r);) t.next(), r = t.position.offset - o.startOffset
                    }
                    return t.position
                }(o, i, s);
                if (a == (n ? "elementStart" : "elementEnd")) {
                    if (r.isSelectable(c)) return Od._createAt(c, n ? "after" : "before");
                    if (r.checkChild(l, "$text")) return l
                } else {
                    if (r.isLimit(c)) return void o.skip((() => !0));
                    if (r.checkChild(l, "$text")) return l
                }
            }
    
            function vg(t, e) {
                const n = t.root,
                    o = Od._createAt(n, e ? "end" : 0);
                return e ? new Ud(t, o) : new Ud(o, t)
            }
    
            function yg(t, e, n) {
                const o = e + (n ? 0 : -1);
                return Ag.includes(t.charAt(o))
            }
    
            function xg(t, e, n) {
                return e === (n ? t.offsetSize : 0)
            }
            class Eg extends($()) {
                constructor() {
                    super(), this.markers = new Zu, this.document = new Ku(this), this.schema = new jh, this._pendingChanges = [], this._currentWriter = null, ["insertContent", "insertObject", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t))), this.on("applyOperation", ((t, e) => {
                        e[0]._validate()
                    }), {
                        priority: "highest"
                    }), this.schema.register("$root", {
                        isLimit: !0
                    }), this.schema.register("$container", {
                        allowIn: ["$root", "$container"]
                    }), this.schema.register("$block", {
                        allowIn: ["$root", "$container"],
                        isBlock: !0
                    }), this.schema.register("$blockObject", {
                        allowWhere: "$block",
                        isBlock: !0,
                        isObject: !0
                    }), this.schema.register("$inlineObject", {
                        allowWhere: "$text",
                        allowAttributesOf: "$text",
                        isInline: !0,
                        isObject: !0
                    }), this.schema.register("$text", {
                        allowIn: "$block",
                        isInline: !0,
                        isContent: !0
                    }), this.schema.register("$clipboardHolder", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }), this.schema.register("$documentFragment", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }), this.schema.register("$marker"), this.schema.addChildCheck(((t, e) => {
                        if ("$marker" === e.name) return !0
                    })), ag(this), this.document.registerPostFixer(xh)
                }
                change(t) {
                    try {
                        return 0 === this._pendingChanges.length ? (this._pendingChanges.push({
                            batch: new Vu,
                            callback: t
                        }), this._runPendingChanges()[0]) : t(this._currentWriter)
                    } catch (t) {
                        A.rethrowUnexpectedError(t, this)
                    }
                }
                enqueueChange(t, e) {
                    try {
                        t ? "function" == typeof t ? (e = t, t = new Vu) : t instanceof Vu || (t = new Vu(t)) : t = new Vu, this._pendingChanges.push({
                            batch: t,
                            callback: e
                        }), 1 == this._pendingChanges.length && this._runPendingChanges()
                    } catch (t) {
                        A.rethrowUnexpectedError(t, this)
                    }
                }
                applyOperation(t) {
                    t._execute()
                }
                insertContent(t, e, n) {
                    return function(t, e, n, o) {
                        return t.change((i => {
                            let r;
                            r = n ? n instanceof Qd || n instanceof rh ? n : i.createSelection(n, o) : t.document.selection, r.isCollapsed || t.deleteContent(r, {
                                doNotAutoparagraph: !0
                            });
                            const s = new bg(t, i, r.anchor),
                                a = [];
                            let c;
                            if (e.is("documentFragment")) {
                                if (e.markers.size) {
                                    const t = [];
                                    for (const [n, o] of e.markers) {
                                        const {
                                            start: e,
                                            end: i
                                        } = o, r = e.isEqual(i);
                                        t.push({
                                            position: e,
                                            name: n,
                                            isCollapsed: r
                                        }, {
                                            position: i,
                                            name: n,
                                            isCollapsed: r
                                        })
                                    }
                                    t.sort((({
                                        position: t
                                    }, {
                                        position: e
                                    }) => t.isBefore(e) ? 1 : -1));
                                    for (const {
                                            position: n,
                                            name: o,
                                            isCollapsed: r
                                        }
                                        of t) {
                                        let t = null,
                                            s = null;
                                        const c = n.parent === e && n.isAtStart,
                                            l = n.parent === e && n.isAtEnd;
                                        c || l ? r && (s = c ? "start" : "end") : (t = i.createElement("$marker"), i.insert(t, n)), a.push({
                                            name: o,
                                            element: t,
                                            collapsed: s
                                        })
                                    }
                                }
                                c = e.getChildren()
                            } else c = [e];
                            s.handleNodes(c);
                            let l = s.getSelectionRange();
                            if (e.is("documentFragment") && a.length) {
                                const t = l ? eh.fromRange(l) : null,
                                    e = {};
                                for (let t = a.length - 1; t >= 0; t--) {
                                    const {
                                        name: n,
                                        element: o,
                                        collapsed: r
                                    } = a[t], c = !e[n];
                                    if (c && (e[n] = []), o) {
                                        const t = i.createPositionAt(o, "before");
                                        e[n].push(t), i.remove(o)
                                    } else {
                                        const t = s.getAffectedRange();
                                        if (!t) {
                                            r && e[n].push(s.position);
                                            continue
                                        }
                                        r ? e[n].push(t[r]) : e[n].push(c ? t.start : t.end)
                                    }
                                }
                                for (const [t, [n, o]] of Object.entries(e)) n && o && n.root === o.root && i.addMarker(t, {
                                    usingOperation: !0,
                                    affectsData: !0,
                                    range: new Ud(n, o)
                                });
                                t && (l = t.toRange(), t.detach())
                            }
                            l && (r instanceof rh ? i.setSelection(l) : r.setTo(l));
                            const d = s.getAffectedRange() || t.createRange(r.anchor);
                            return s.destroy(), d
                        }))
                    }(this, t, e, n)
                }
                insertObject(t, e, n, o) {
                    return _g(this, t, e, n, o)
                }
                deleteContent(t, e) {
                    hg(this, t, e)
                }
                modifySelection(t, e) {
                    ! function(t, e, n = {}) {
                        const o = t.schema,
                            i = "backward" != n.direction,
                            r = n.unit ? n.unit : "character",
                            s = !!n.treatEmojiAsSingleUnit,
                            a = e.focus,
                            c = new zd({
                                boundaries: vg(a, i),
                                singleCharacters: !0,
                                direction: i ? "forward" : "backward"
                            }),
                            l = {
                                walker: c,
                                schema: o,
                                isForward: i,
                                unit: r,
                                treatEmojiAsSingleUnit: s
                            };
                        let d;
                        for (; d = c.next();) {
                            if (d.done) return;
                            const n = Cg(l, d.value);
                            if (n) return void(e instanceof rh ? t.change((t => {
                                t.setSelectionFocus(n)
                            })) : e.setFocus(n))
                        }
                    }(this, t, e)
                }
                getSelectedContent(t) {
                    return function(t, e) {
                        return t.change((t => {
                            const n = t.createDocumentFragment(),
                                o = e.getFirstRange();
                            if (!o || o.isCollapsed) return n;
                            const i = o.start.root,
                                r = o.start.getCommonPath(o.end),
                                s = i.getNodeByPath(r);
                            let a;
                            a = o.start.parent == o.end.parent ? o : t.createRange(t.createPositionAt(s, o.start.path[r.length]), t.createPositionAt(s, o.end.path[r.length] + 1));
                            const c = a.end.offset - a.start.offset;
                            for (const e of a.getItems({
                                    shallow: !0
                                })) e.is("$textProxy") ? t.appendText(e.data, e.getAttributes(), n) : t.append(t.cloneElement(e, !0), n);
                            if (a != o) {
                                const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0],
                                    i = t.createRange(t.createPositionAt(n, 0), e.start);
                                kg(t.createRange(e.end, t.createPositionAt(n, "end")), t), kg(i, t)
                            }
                            return n
                        }))
                    }(this, t)
                }
                hasContent(t, e = {}) {
                    const n = t instanceof Ud ? t : Ud._createIn(t);
                    if (n.isCollapsed) return !1;
                    const {
                        ignoreWhitespaces: o = !1,
                        ignoreMarkers: i = !1
                    } = e;
                    if (!i)
                        for (const t of this.markers.getMarkersIntersectingRange(n))
                            if (t.affectsData) return !0;
                    for (const t of n.getItems())
                        if (this.schema.isContent(t)) {
                            if (!t.is("$textProxy")) return !0;
                            if (!o) return !0;
                            if (-1 !== t.data.search(/\S/)) return !0
                        } return !1
                }
                createPositionFromPath(t, e, n) {
                    return new Od(t, e, n)
                }
                createPositionAt(t, e) {
                    return Od._createAt(t, e)
                }
                createPositionAfter(t) {
                    return Od._createAfter(t)
                }
                createPositionBefore(t) {
                    return Od._createBefore(t)
                }
                createRange(t, e) {
                    return new Ud(t, e)
                }
                createRangeIn(t) {
                    return Ud._createIn(t)
                }
                createRangeOn(t) {
                    return Ud._createOn(t)
                }
                createSelection(...t) {
                    return new Qd(...t)
                }
                createBatch(t) {
                    return new Vu(t)
                }
                createOperationFromJSON(t) {
                    return Eu.fromJSON(t, this.document)
                }
                destroy() {
                    this.document.destroy(), this.stopListening()
                }
                _runPendingChanges() {
                    const t = [];
                    this.fire("_beforeChanges");
                    try {
                        for (; this._pendingChanges.length;) {
                            const e = this._pendingChanges[0].batch;
                            this._currentWriter = new eg(this, e);
                            const n = this._pendingChanges[0].callback(this._currentWriter);
                            t.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null
                        }
                    } finally {
                        this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges")
                    }
                    return t
                }
            }
            class Dg extends pl {
                constructor(t) {
                    super(t), this.domEventType = "click"
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            class Ig extends pl {
                constructor(t) {
                    super(t), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"]
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            class Tg {
                constructor(t) {
                    this.document = t
                }
                createDocumentFragment(t) {
                    return new Ic(this.document, t)
                }
                createElement(t, e, n) {
                    return new Za(this.document, t, e, n)
                }
                createText(t) {
                    return new Us(this.document, t)
                }
                clone(t, e = !1) {
                    return t._clone(e)
                }
                appendChild(t, e) {
                    return e._appendChild(t)
                }
                insertChild(t, e, n) {
                    return n._insertChild(t, e)
                }
                removeChildren(t, e, n) {
                    return n._removeChildren(t, e)
                }
                remove(t) {
                    const e = t.parent;
                    return e ? this.removeChildren(e.getChildIndex(t), 1, e) : []
                }
                replace(t, e) {
                    const n = t.parent;
                    if (n) {
                        const o = n.getChildIndex(t);
                        return this.removeChildren(o, 1, n), this.insertChild(o, e, n), !0
                    }
                    return !1
                }
                unwrapElement(t) {
                    const e = t.parent;
                    if (e) {
                        const n = e.getChildIndex(t);
                        this.remove(t), this.insertChild(n, t.getChildren(), e)
                    }
                }
                rename(t, e) {
                    const n = new Za(this.document, t, e.getAttributes(), e.getChildren());
                    return this.replace(e, n) ? n : null
                }
                setAttribute(t, e, n) {
                    n._setAttribute(t, e)
                }
                removeAttribute(t, e) {
                    e._removeAttribute(t)
                }
                addClass(t, e) {
                    e._addClass(t)
                }
                removeClass(t, e) {
                    e._removeClass(t)
                }
                setStyle(t, e, n) {
                    St(t) && void 0 === n ? e._setStyle(t) : n._setStyle(t, e)
                }
                removeStyle(t, e) {
                    e._removeStyle(t)
                }
                setCustomProperty(t, e, n) {
                    n._setCustomProperty(t, e)
                }
                removeCustomProperty(t, e) {
                    return e._removeCustomProperty(t)
                }
                createPositionAt(t, e) {
                    return rc._createAt(t, e)
                }
                createPositionAfter(t) {
                    return rc._createAfter(t)
                }
                createPositionBefore(t) {
                    return rc._createBefore(t)
                }
                createRange(t, e) {
                    return new sc(t, e)
                }
                createRangeOn(t) {
                    return sc._createOn(t)
                }
                createRangeIn(t) {
                    return sc._createIn(t)
                }
                createSelection(...t) {
                    return new cc(...t)
                }
            }
            new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);
            class Mg {
                constructor() {
                    this._commands = new Map
                }
                add(t, e) {
                    this._commands.set(t, e)
                }
                get(t) {
                    return this._commands.get(t)
                }
                execute(t, ...e) {
                    const n = this.get(t);
                    if (!n) throw new A("commandcollection-command-not-found", this, {
                        commandName: t
                    });
                    return n.execute(...e)
                }* names() {
                    yield* this._commands.keys()
                }* commands() {
                    yield* this._commands.values()
                } [Symbol.iterator]() {
                    return this._commands[Symbol.iterator]()
                }
                destroy() {
                    for (const t of this.commands()) t.destroy()
                }
            }
            class Sg extends pr {
                constructor(t) {
                    super(), this.editor = t
                }
                set(t, e, n = {}) {
                    if ("string" == typeof e) {
                        const t = e;
                        e = (e, n) => {
                            this.editor.execute(t), n()
                        }
                    }
                    super.set(t, e, n)
                }
            }
            class Ng extends($()) {
                constructor(t = {}) {
                    super();
                    const e = this.constructor,
                        n = t.language || e.defaultConfig && e.defaultConfig.language;
                    this._context = t.context || new Ts({
                        language: n
                    }), this._context._addEditor(this, !t.context);
                    const o = Array.from(e.builtinPlugins || []);
                    this.config = new gi(t, e.defaultConfig), this.config.define("plugins", o), this.config.define(this._context._getEditorConfig()), this.plugins = new Is(this, o, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = new Set, this.commands = new Mg, this.set("state", "initializing"), this.once("ready", (() => this.state = "ready"), {
                        priority: "high"
                    }), this.once("destroy", (() => this.state = "destroyed"), {
                        priority: "high"
                    }), this.model = new Eg;
                    const i = new Ya;
                    this.data = new ou(this.model, i), this.editing = new zh(this.model, i), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new iu([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Sg(this), this.keystrokes.listenTo(this.editing.view.document)
                }
                get isReadOnly() {
                    return this._readOnlyLocks.size > 0
                }
                set isReadOnly(t) {
                    throw new A("editor-isreadonly-has-no-setter")
                }
                enableReadOnlyMode(t) {
                    if ("string" != typeof t && "symbol" != typeof t) throw new A("editor-read-only-lock-id-invalid", null, {
                        lockId: t
                    });
                    this._readOnlyLocks.has(t) || (this._readOnlyLocks.add(t), 1 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", !0, !1))
                }
                disableReadOnlyMode(t) {
                    if ("string" != typeof t && "symbol" != typeof t) throw new A("editor-read-only-lock-id-invalid", null, {
                        lockId: t
                    });
                    this._readOnlyLocks.has(t) && (this._readOnlyLocks.delete(t), 0 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", !1, !0))
                }
                initPlugins() {
                    const t = this.config,
                        e = t.get("plugins"),
                        n = t.get("removePlugins") || [],
                        o = t.get("extraPlugins") || [],
                        i = t.get("substitutePlugins") || [];
                    return this.plugins.init(e.concat(o), n, i)
                }
                destroy() {
                    let t = Promise.resolve();
                    return "initializing" == this.state && (t = new Promise((t => this.once("ready", t)))), t.then((() => {
                        this.fire("destroy"), this.stopListening(), this.commands.destroy()
                    })).then((() => this.plugins.destroy())).then((() => {
                        this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy()
                    })).then((() => this._context._removeEditor(this)))
                }
                execute(t, ...e) {
                    try {
                        return this.commands.execute(t, ...e)
                    } catch (t) {
                        A.rethrowUnexpectedError(t, this)
                    }
                }
                focus() {
                    this.editing.view.focus()
                }
            }
    
            function Bg(t) {
                return class extends t {
                    setData(t) {
                        this.data.set(t)
                    }
                    getData(t) {
                        return this.data.get(t)
                    }
                }
            } {
                const t = Bg(Object);
                Bg.setData = t.prototype.setData, Bg.getData = t.prototype.getData
            }
    
            function Pg(t) {
                return class extends t {
                    updateSourceElement(t = this.data.get()) {
                        if (!this.sourceElement) throw new A("editor-missing-sourceelement", this);
                        const e = this.config.get("updateSourceElementOnDestroy"),
                            n = this.sourceElement instanceof HTMLTextAreaElement;
                        Pi(this.sourceElement, e || n ? t : "")
                    }
                }
            }
            Pg.updateSourceElement = Pg(Object).prototype.updateSourceElement;
            class zg extends Ms {
                static get pluginName() {
                    return "PendingActions"
                }
                init() {
                    this.set("hasAny", !1), this._actions = new ur({
                        idProperty: "_id"
                    }), this._actions.delegate("add", "remove").to(this)
                }
                add(t) {
                    if ("string" != typeof t) throw new A("pendingactions-add-invalid-message", this);
                    const e = new($());
                    return e.set("message", t), this._actions.add(e), this.hasAny = !0, e
                }
                remove(t) {
                    this._actions.remove(t), this.hasAny = !!this._actions.length
                }
                get first() {
                    return this._actions.get(0)
                } [Symbol.iterator]() {
                    return this._actions[Symbol.iterator]()
                }
            }
            const Lg = {
                bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
                caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
                check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
                cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
                eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
                image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
                lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
                importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',
                paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',
                plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
                text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>',
                alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
                alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
                alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
                alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
                alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
                alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
                alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
                objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
                objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
                objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
                objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
                objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
                objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
                pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
                pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
                quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
                threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'
            };
            var Og = n(5542),
                Rg = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Og.Z, Rg);
            Og.Z.locals;
            const {
                threeVerticalDots: jg
            } = Lg, Fg = {
                alignLeft: Lg.alignLeft,
                bold: Lg.bold,
                importExport: Lg.importExport,
                paragraph: Lg.paragraph,
                plus: Lg.plus,
                text: Lg.text,
                threeVerticalDots: Lg.threeVerticalDots
            };
            class Vg extends Dr {
                constructor(t, e) {
                    super(t);
                    const n = this.bindTemplate,
                        o = this.t;
                    this.options = e || {}, this.set("ariaLabel", o("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new mr, this.keystrokes = new pr, this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new Hg(t), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
                    const i = "rtl" === t.uiLanguageDirection;
                    this._focusCycler = new bs({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: [i ? "arrowright" : "arrowleft", "arrowup"],
                            focusNext: [i ? "arrowleft" : "arrowright", "arrowdown"]
                        }
                    });
                    const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
                    var s;
                    this.options.shouldGroupWhenFull && this.options.isFloating && r.push("ck-toolbar_floating"), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: r,
                            role: "toolbar",
                            "aria-label": n.to("ariaLabel"),
                            style: {
                                maxWidth: n.to("maxWidth")
                            }
                        },
                        children: this.children,
                        on: {
                            mousedown: (s = this, s.bindTemplate.to((t => {
                                t.target === s.element && t.preventDefault()
                            })))
                        }
                    }), this._behavior = this.options.shouldGroupWhenFull ? new Wg(this) : new Ug(this)
                }
                render() {
                    super.render();
                    for (const t of this.items) this.focusTracker.add(t.element);
                    this.items.on("add", ((t, e) => {
                        this.focusTracker.add(e.element)
                    })), this.items.on("remove", ((t, e) => {
                        this.focusTracker.remove(e.element)
                    })), this.keystrokes.listenTo(this.element), this._behavior.render(this)
                }
                destroy() {
                    return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
                fillFromConfig(t, e, n) {
                    this.items.addMany(this._buildItemsFromConfig(t, e, n))
                }
                _buildItemsFromConfig(t, e, n) {
                    const o = Cs(t),
                        i = n || o.removeItems;
                    return this._cleanItemsConfiguration(o.items, e, i).map((t => F(t) ? this._createNestedToolbarDropdown(t, e, i) : "|" === t ? new _s : "-" === t ? new As : e.create(t))).filter((t => !!t))
                }
                _cleanItemsConfiguration(t, e, n) {
                    const o = t.filter(((t, o, i) => "|" === t || -1 === n.indexOf(t) && ("-" === t ? !this.options.shouldGroupWhenFull || (C("toolbarview-line-break-ignored-when-grouping-items", i), !1) : !(!F(t) && !e.has(t)) || (C("toolbarview-item-unavailable", {
                        item: t
                    }), !1))));
                    return this._cleanSeparatorsAndLineBreaks(o)
                }
                _cleanSeparatorsAndLineBreaks(t) {
                    const e = t => "-" !== t && "|" !== t,
                        n = t.length,
                        o = t.findIndex(e);
                    if (-1 === o) return [];
                    const i = n - t.slice().reverse().findIndex(e);
                    return t.slice(o, i).filter(((t, n, o) => {
                        if (e(t)) return !0;
                        return !(n > 0 && o[n - 1] === t)
                    }))
                }
                _createNestedToolbarDropdown(t, e, n) {
                    let {
                        label: o,
                        icon: i,
                        items: r,
                        tooltip: s = !0,
                        withText: a = !1
                    } = t;
                    if (r = this._cleanItemsConfiguration(r, e, n), !r.length) return null;
                    const c = tm(this.locale);
                    return o || C("toolbarview-nested-toolbar-dropdown-missing-label", t), c.class = "ck-toolbar__nested-toolbar-dropdown", c.buttonView.set({
                        label: o,
                        tooltip: s,
                        withText: !!a
                    }), !1 !== i ? c.buttonView.icon = Fg[i] || i || jg : c.buttonView.withText = !0, em(c, (() => c.toolbarView._buildItemsFromConfig(r, e, n))), c
                }
            }
            class Hg extends Dr {
                constructor(t) {
                    super(t), this.children = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-toolbar__items"]
                        },
                        children: this.children
                    })
                }
            }
            class Ug {
                constructor(t) {
                    const e = t.bindTemplate;
                    t.set("isVertical", !1), t.itemsView.children.bindTo(t.items).using((t => t)), t.focusables.bindTo(t.items).using((t => t)), t.extendTemplate({
                        attributes: {
                            class: [e.if("isVertical", "ck-toolbar_vertical")]
                        }
                    })
                }
                render() {}
                destroy() {}
            }
            class Wg {
                constructor(t) {
                    this.view = t, this.viewChildren = t.children, this.viewFocusables = t.focusables, this.viewItemsView = t.itemsView, this.viewFocusTracker = t.focusTracker, this.viewLocale = t.locale, this.ungroupedItems = t.createCollection(), this.groupedItems = t.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, t.itemsView.children.bindTo(this.ungroupedItems).using((t => t)), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), t.children.on("change", this._updateFocusCycleableItems.bind(this)), t.items.on("change", ((t, e) => {
                        const n = e.index,
                            o = Array.from(e.added);
                        for (const t of e.removed) n >= this.ungroupedItems.length ? this.groupedItems.remove(t) : this.ungroupedItems.remove(t);
                        for (let t = n; t < n + o.length; t++) {
                            const e = o[t - n];
                            t > this.ungroupedItems.length ? this.groupedItems.add(e, t - this.ungroupedItems.length) : this.ungroupedItems.add(e, t)
                        }
                        this._updateGrouping()
                    })), t.extendTemplate({
                        attributes: {
                            class: ["ck-toolbar_grouping"]
                        }
                    })
                }
                render(t) {
                    this.viewElement = t.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t)
                }
                destroy() {
                    this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy()
                }
                _updateGrouping() {
                    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
                    if (!ji(this.viewElement)) return void(this.shouldUpdateGroupingOnNextResize = !0);
                    const t = this.groupedItems.length;
                    let e;
                    for (; this._areItemsOverflowing;) this._groupLastItem(), e = !0;
                    if (!e && this.groupedItems.length) {
                        for (; this.groupedItems.length && !this._areItemsOverflowing;) this._ungroupFirstItem();
                        this._areItemsOverflowing && this._groupLastItem()
                    }
                    this.groupedItems.length !== t && this.view.fire("groupedItemsUpdate")
                }
                get _areItemsOverflowing() {
                    if (!this.ungroupedItems.length) return !1;
                    const t = this.viewElement,
                        e = this.viewLocale.uiLanguageDirection,
                        n = new Ti(t.lastChild),
                        o = new Ti(t);
                    if (!this.cachedPadding) {
                        const n = vi.window.getComputedStyle(t),
                            o = "ltr" === e ? "paddingRight" : "paddingLeft";
                        this.cachedPadding = Number.parseInt(n[o])
                    }
                    return "ltr" === e ? n.right > o.right - this.cachedPadding : n.left < o.left + this.cachedPadding
                }
                _enableGroupingOnResize() {
                    let t;
                    this.resizeObserver = new Bi(this.viewElement, (e => {
                        t && t === e.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), t = e.contentRect.width)
                    })), this._updateGrouping()
                }
                _enableGroupingOnMaxWidthChange(t) {
                    t.on("change:maxWidth", (() => {
                        this._updateGrouping()
                    }))
                }
                _groupLastItem() {
                    this.groupedItems.length || (this.viewChildren.add(new _s), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
                }
                _ungroupFirstItem() {
                    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element))
                }
                _createGroupedItemsDropdown() {
                    const t = this.viewLocale,
                        e = t.t,
                        n = tm(t);
                    return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = "ltr" === t.uiLanguageDirection ? "sw" : "se", em(n, this.groupedItems), n.buttonView.set({
                        label: e("Show more items"),
                        tooltip: !0,
                        tooltipPosition: "rtl" === t.uiLanguageDirection ? "se" : "sw",
                        icon: jg
                    }), n
                }
                _updateFocusCycleableItems() {
                    this.viewFocusables.clear(), this.ungroupedItems.map((t => {
                        this.viewFocusables.add(t)
                    })), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }
            var qg = n(1046),
                Gg = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(qg.Z, Gg);
            qg.Z.locals;
            class $g extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.items = this.createCollection(), this.focusTracker = new mr, this.keystrokes = new pr, this._focusCycler = new bs({
                        focusables: this.items,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "arrowup",
                            focusNext: "arrowdown"
                        }
                    }), this.set("ariaLabel", void 0), this.setTemplate({
                        tag: "ul",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"],
                            "aria-label": e.to("ariaLabel")
                        },
                        children: this.items
                    })
                }
                render() {
                    super.render();
                    for (const t of this.items) this.focusTracker.add(t.element);
                    this.items.on("add", ((t, e) => {
                        this.focusTracker.add(e.element)
                    })), this.items.on("remove", ((t, e) => {
                        this.focusTracker.remove(e.element)
                    })), this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
            }
            class Yg extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t => !t))]
                        },
                        children: this.children
                    })
                }
                focus() {
                    this.children.first.focus()
                }
            }
            class Kg extends Dr {
                constructor(t) {
                    super(t), this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__separator"]
                        }
                    })
                }
            }
            var Qg = n(7339),
                Zg = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Qg.Z, Zg);
            Qg.Z.locals;
            var Jg = n(3949),
                Xg = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Jg.Z, Xg);
            Jg.Z.locals;
    
            function tm(e, n = gs) {
                const o = new n(e),
                    i = new ks(e),
                    r = new hs(e, o, i);
                return o.bind("isEnabled").to(r), o instanceof fs ? o.arrowView.bind("isOn").to(r, "isOpen") : o.bind("isOn").to(r, "isOpen"),
                    function(e) {
                        (function(e) {
                            e.on("render", (() => {
                                t({
                                    emitter: e,
                                    activator: () => e.isOpen,
                                    callback: () => {
                                        e.isOpen = !1
                                    },
                                    contextElements: [e.element]
                                })
                            }))
                        })(e),
                        function(t) {
                            t.on("execute", (e => {
                                e.source instanceof is || (t.isOpen = !1)
                            }))
                        }(e),
                        function(t) {
                            t.focusTracker.on("change:isFocused", ((e, n, o) => {
                                t.isOpen && !o && (t.isOpen = !1)
                            }))
                        }(e),
                        function(t) {
                            t.keystrokes.set("arrowdown", ((e, n) => {
                                t.isOpen && (t.panelView.focus(), n())
                            })), t.keystrokes.set("arrowup", ((e, n) => {
                                t.isOpen && (t.panelView.focusLast(), n())
                            }))
                        }(e),
                        function(t) {
                            t.on("change:isOpen", ((e, n, o) => {
                                if (o) return;
                                const i = t.panelView.element;
                                i && i.contains(vi.document.activeElement) && t.buttonView.focus()
                            }))
                        }(e),
                        function(t) {
                            t.on("change:isOpen", ((e, n, o) => {
                                o && t.panelView.focus()
                            }), {
                                priority: "low"
                            })
                        }(e)
                    }(r), r
            }
    
            function em(t, e, n = {}) {
                t.extendTemplate({
                    attributes: {
                        class: ["ck-toolbar-dropdown"]
                    }
                }), t.isOpen ? nm(t, e, n) : t.once("change:isOpen", (() => nm(t, e, n)), {
                    priority: "highest"
                }), n.enableActiveItemFocusOnDropdownOpen && rm(t, (() => t.toolbarView.items.find((t => t.isOn))))
            }
    
            function nm(t, e, n) {
                const o = t.locale,
                    i = o.t,
                    r = t.toolbarView = new Vg(o),
                    s = "function" == typeof e ? e() : e;
                r.ariaLabel = n.ariaLabel || i("Dropdown toolbar"), n.maxWidth && (r.maxWidth = n.maxWidth), n.class && (r.class = n.class), n.isCompact && (r.isCompact = n.isCompact), n.isVertical && (r.isVertical = !0), s instanceof Cr ? r.items.bindTo(s).using((t => t)) : r.items.addMany(s), t.panelView.children.add(r), r.items.delegate("execute").to(t)
            }
    
            function om(t, e, n = {}) {
                t.isOpen ? im(t, e, n) : t.once("change:isOpen", (() => im(t, e, n)), {
                    priority: "highest"
                }), rm(t, (() => t.listView.items.find((t => t instanceof Yg && t.children.first.isOn))))
            }
    
            function im(t, e, n) {
                const o = t.locale,
                    i = t.listView = new $g(o),
                    r = "function" == typeof e ? e() : e;
                i.ariaLabel = n.ariaLabel, i.items.bindTo(r).using((t => {
                    if ("separator" === t.type) return new Kg(o);
                    if ("button" === t.type || "switchbutton" === t.type) {
                        const e = new Yg(o);
                        let n;
                        return n = "button" === t.type ? new es(o) : new is(o), n.bind(...Object.keys(t.model)).to(t.model), n.delegate("execute").to(e), e.children.add(n), e
                    }
                    return null
                })), t.panelView.children.add(i), i.items.delegate("execute").to(t)
            }
    
            function rm(t, e) {
                t.on("change:isOpen", (() => {
                    if (!t.isOpen) return;
                    const n = e();
                    n && ("function" == typeof n.focus ? n.focus() : C("ui-dropdown-focus-child-on-open-child-missing-focus", {
                        view: n
                    }))
                }), {
                    priority: b.low - 10
                })
            }
            var sm = n(8793),
                am = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(sm.Z, am);
            sm.Z.locals;
            const cm = zi("px"),
                lm = vi.document.body;
            class dm extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                            style: {
                                top: e.to("top", cm),
                                left: e.to("left", cm)
                            }
                        },
                        children: this.content
                    })
                }
                show() {
                    this.isVisible = !0
                }
                hide() {
                    this.isVisible = !1
                }
                attachTo(t) {
                    this.show();
                    const e = dm.defaultPositions,
                        n = Object.assign({}, {
                            element: this.element,
                            positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth],
                            limiter: lm,
                            fitInViewport: !0
                        }, t),
                        o = dm._getOptimalPosition(n),
                        i = parseInt(o.left),
                        r = parseInt(o.top),
                        s = o.name,
                        a = o.config || {},
                        {
                            withArrow: c = !0
                        } = a;
                    this.top = r, this.left = i, this.position = s, this.withArrow = c
                }
                pin(t) {
                    this.unpin(), this._pinWhenIsVisibleCallback = () => {
                        this.isVisible ? this._startPinning(t) : this._stopPinning()
                    }, this._startPinning(t), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
                }
                unpin() {
                    this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide())
                }
                _startPinning(t) {
                    this.attachTo(t);
                    const e = hm(t.target),
                        n = t.limiter ? hm(t.limiter) : lm;
                    this.listenTo(vi.document, "scroll", ((o, i) => {
                        const r = i.target,
                            s = e && r.contains(e),
                            a = n && r.contains(n);
                        !s && !a && e && n || this.attachTo(t)
                    }), {
                        useCapture: !0
                    }), this.listenTo(vi.window, "resize", (() => {
                        this.attachTo(t)
                    }))
                }
                _stopPinning() {
                    this.stopListening(vi.document, "scroll"), this.stopListening(vi.window, "resize")
                }
            }
    
            function hm(t) {
                return ui(t) ? t : Ei(t) ? t.commonAncestorContainer : "function" == typeof t ? hm(t()) : null
            }
    
            function um(t = {}) {
                const {
                    sideOffset: e = dm.arrowSideOffset,
                    heightOffset: n = dm.arrowHeightOffset,
                    stickyVerticalOffset: o = dm.stickyVerticalOffset,
                    config: i
                } = t;
                return {
                    northWestArrowSouthWest: (t, n) => ({
                        top: r(t, n),
                        left: t.left - e,
                        name: "arrow_sw",
                        ...i && {
                            config: i
                        }
                    }),
                    northWestArrowSouthMiddleWest: (t, n) => ({
                        top: r(t, n),
                        left: t.left - .25 * n.width - e,
                        name: "arrow_smw",
                        ...i && {
                            config: i
                        }
                    }),
                    northWestArrowSouth: (t, e) => ({
                        top: r(t, e),
                        left: t.left - e.width / 2,
                        name: "arrow_s",
                        ...i && {
                            config: i
                        }
                    }),
                    northWestArrowSouthMiddleEast: (t, n) => ({
                        top: r(t, n),
                        left: t.left - .75 * n.width + e,
                        name: "arrow_sme",
                        ...i && {
                            config: i
                        }
                    }),
                    northWestArrowSouthEast: (t, n) => ({
                        top: r(t, n),
                        left: t.left - n.width + e,
                        name: "arrow_se",
                        ...i && {
                            config: i
                        }
                    }),
                    northArrowSouthWest: (t, n) => ({
                        top: r(t, n),
                        left: t.left + t.width / 2 - e,
                        name: "arrow_sw",
                        ...i && {
                            config: i
                        }
                    }),
                    northArrowSouthMiddleWest: (t, n) => ({
                        top: r(t, n),
                        left: t.left + t.width / 2 - .25 * n.width - e,
                        name: "arrow_smw",
                        ...i && {
                            config: i
                        }
                    }),
                    northArrowSouth: (t, e) => ({
                        top: r(t, e),
                        left: t.left + t.width / 2 - e.width / 2,
                        name: "arrow_s",
                        ...i && {
                            config: i
                        }
                    }),
                    northArrowSouthMiddleEast: (t, n) => ({
                        top: r(t, n),
                        left: t.left + t.width / 2 - .75 * n.width + e,
                        name: "arrow_sme",
                        ...i && {
                            config: i
                        }
                    }),
                    northArrowSouthEast: (t, n) => ({
                        top: r(t, n),
                        left: t.left + t.width / 2 - n.width + e,
                        name: "arrow_se",
                        ...i && {
                            config: i
                        }
                    }),
                    northEastArrowSouthWest: (t, n) => ({
                        top: r(t, n),
                        left: t.right - e,
                        name: "arrow_sw",
                        ...i && {
                            config: i
                        }
                    }),
                    northEastArrowSouthMiddleWest: (t, n) => ({
                        top: r(t, n),
                        left: t.right - .25 * n.width - e,
                        name: "arrow_smw",
                        ...i && {
                            config: i
                        }
                    }),
                    northEastArrowSouth: (t, e) => ({
                        top: r(t, e),
                        left: t.right - e.width / 2,
                        name: "arrow_s",
                        ...i && {
                            config: i
                        }
                    }),
                    northEastArrowSouthMiddleEast: (t, n) => ({
                        top: r(t, n),
                        left: t.right - .75 * n.width + e,
                        name: "arrow_sme",
                        ...i && {
                            config: i
                        }
                    }),
                    northEastArrowSouthEast: (t, n) => ({
                        top: r(t, n),
                        left: t.right - n.width + e,
                        name: "arrow_se",
                        ...i && {
                            config: i
                        }
                    }),
                    southWestArrowNorthWest: t => ({
                        top: s(t),
                        left: t.left - e,
                        name: "arrow_nw",
                        ...i && {
                            config: i
                        }
                    }),
                    southWestArrowNorthMiddleWest: (t, n) => ({
                        top: s(t),
                        left: t.left - .25 * n.width - e,
                        name: "arrow_nmw",
                        ...i && {
                            config: i
                        }
                    }),
                    southWestArrowNorth: (t, e) => ({
                        top: s(t),
                        left: t.left - e.width / 2,
                        name: "arrow_n",
                        ...i && {
                            config: i
                        }
                    }),
                    southWestArrowNorthMiddleEast: (t, n) => ({
                        top: s(t),
                        left: t.left - .75 * n.width + e,
                        name: "arrow_nme",
                        ...i && {
                            config: i
                        }
                    }),
                    southWestArrowNorthEast: (t, n) => ({
                        top: s(t),
                        left: t.left - n.width + e,
                        name: "arrow_ne",
                        ...i && {
                            config: i
                        }
                    }),
                    southArrowNorthWest: t => ({
                        top: s(t),
                        left: t.left + t.width / 2 - e,
                        name: "arrow_nw",
                        ...i && {
                            config: i
                        }
                    }),
                    southArrowNorthMiddleWest: (t, n) => ({
                        top: s(t),
                        left: t.left + t.width / 2 - .25 * n.width - e,
                        name: "arrow_nmw",
                        ...i && {
                            config: i
                        }
                    }),
                    southArrowNorth: (t, e) => ({
                        top: s(t),
                        left: t.left + t.width / 2 - e.width / 2,
                        name: "arrow_n",
                        ...i && {
                            config: i
                        }
                    }),
                    southArrowNorthMiddleEast: (t, n) => ({
                        top: s(t),
                        left: t.left + t.width / 2 - .75 * n.width + e,
                        name: "arrow_nme",
                        ...i && {
                            config: i
                        }
                    }),
                    southArrowNorthEast: (t, n) => ({
                        top: s(t),
                        left: t.left + t.width / 2 - n.width + e,
                        name: "arrow_ne",
                        ...i && {
                            config: i
                        }
                    }),
                    southEastArrowNorthWest: t => ({
                        top: s(t),
                        left: t.right - e,
                        name: "arrow_nw",
                        ...i && {
                            config: i
                        }
                    }),
                    southEastArrowNorthMiddleWest: (t, n) => ({
                        top: s(t),
                        left: t.right - .25 * n.width - e,
                        name: "arrow_nmw",
                        ...i && {
                            config: i
                        }
                    }),
                    southEastArrowNorth: (t, e) => ({
                        top: s(t),
                        left: t.right - e.width / 2,
                        name: "arrow_n",
                        ...i && {
                            config: i
                        }
                    }),
                    southEastArrowNorthMiddleEast: (t, n) => ({
                        top: s(t),
                        left: t.right - .75 * n.width + e,
                        name: "arrow_nme",
                        ...i && {
                            config: i
                        }
                    }),
                    southEastArrowNorthEast: (t, n) => ({
                        top: s(t),
                        left: t.right - n.width + e,
                        name: "arrow_ne",
                        ...i && {
                            config: i
                        }
                    }),
                    westArrowEast: (t, e) => ({
                        top: t.top + t.height / 2 - e.height / 2,
                        left: t.left - e.width - n,
                        name: "arrow_e",
                        ...i && {
                            config: i
                        }
                    }),
                    eastArrowWest: (t, e) => ({
                        top: t.top + t.height / 2 - e.height / 2,
                        left: t.right + n,
                        name: "arrow_w",
                        ...i && {
                            config: i
                        }
                    }),
                    viewportStickyNorth: (t, e, n) => t.getIntersection(n) ? {
                        top: n.top + o,
                        left: t.left + t.width / 2 - e.width / 2,
                        name: "arrowless",
                        config: {
                            withArrow: !1,
                            ...i
                        }
                    } : null
                };
    
                function r(t, e) {
                    return t.top - e.height - n
                }
    
                function s(t) {
                    return t.bottom + n
                }
            }
            dm.arrowSideOffset = 25, dm.arrowHeightOffset = 10, dm.stickyVerticalOffset = 20, dm._getOptimalPosition = Fi, dm.defaultPositions = um();
            var gm = n(3332),
                mm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(gm.Z, mm);
            gm.Z.locals;
            const pm = "ck-tooltip";
            class fm extends(wi()) {
                constructor(t) {
                    if (super(), fm._editors.add(t), fm._instance) return fm._instance;
                    fm._instance = this, this.tooltipTextView = new Dr(t.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-tooltip__text"]
                        },
                        children: [{
                            text: this.tooltipTextView.bindTemplate.to("text")
                        }]
                    }), this.balloonPanelView = new dm(t.locale), this.balloonPanelView.class = pm, this.balloonPanelView.content.add(this.tooltipTextView), this._resizeObserver = null, this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._pinTooltipDebounced = Sl(this._pinTooltip, 600), this.listenTo(vi.document, "mouseenter", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }), this.listenTo(vi.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }), this.listenTo(vi.document, "focus", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }), this.listenTo(vi.document, "blur", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }), this.listenTo(vi.document, "scroll", this._onScroll.bind(this), {
                        useCapture: !0
                    }), this._watchdogExcluded = !0
                }
                destroy(t) {
                    const e = t.ui.view && t.ui.view.body;
                    fm._editors.delete(t), this.stopListening(t.ui), e && e.has(this.balloonPanelView) && e.remove(this.balloonPanelView), fm._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), fm._instance = null)
                }
                static getPositioningFunctions(t) {
                    const e = fm.defaultBalloonPositions;
                    return {
                        s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
                        n: [e.northArrowSouth],
                        e: [e.eastArrowWest],
                        w: [e.westArrowEast],
                        sw: [e.southArrowNorthEast],
                        se: [e.southArrowNorthWest]
                    } [t]
                }
                _onEnterOrFocus(t, {
                    target: e
                }) {
                    const n = km(e);
                    var o;
                    n && (n !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n, {
                        text: (o = n).dataset.ckeTooltipText,
                        position: o.dataset.ckeTooltipPosition || "s",
                        cssClass: o.dataset.ckeTooltipClass || ""
                    })))
                }
                _onLeaveOrBlur(t, {
                    target: e,
                    relatedTarget: n
                }) {
                    if ("mouseleave" === t.name) {
                        if (!ui(e)) return;
                        if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        const t = km(e),
                            o = km(n);
                        t && t !== o && this._unpinTooltip()
                    } else {
                        if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) return;
                        this._unpinTooltip()
                    }
                }
                _onScroll(t, {
                    target: e
                }) {
                    this._currentElementWithTooltip && (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip) || this._unpinTooltip())
                }
                _pinTooltip(t, {
                    text: e,
                    position: n,
                    cssClass: o
                }) {
                    const i = gr(fm._editors.values()).ui.view.body;
                    i.has(this.balloonPanelView) || i.add(this.balloonPanelView), this.tooltipTextView.text = e, this.balloonPanelView.pin({
                        target: t,
                        positions: fm.getPositioningFunctions(n)
                    }), this._resizeObserver = new Bi(t, (() => {
                        ji(t) || this._unpinTooltip()
                    })), this.balloonPanelView.class = [pm, o].filter((t => t)).join(" ");
                    for (const t of fm._editors) this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), {
                        priority: "low"
                    });
                    this._currentElementWithTooltip = t, this._currentTooltipPosition = n
                }
                _unpinTooltip() {
                    this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
                    for (const t of fm._editors) this.stopListening(t.ui, "update");
                    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy()
                }
                _updateTooltipPosition() {
                    ji(this._currentElementWithTooltip) ? this.balloonPanelView.pin({
                        target: this._currentElementWithTooltip,
                        positions: fm.getPositioningFunctions(this._currentTooltipPosition)
                    }) : this._unpinTooltip()
                }
            }
    
            function km(t) {
                return ui(t) ? t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null
            }
            fm.defaultBalloonPositions = um({
                heightOffset: 5,
                sideOffset: 13
            }), fm._editors = new Set, fm._instance = null;
            class bm extends($()) {
                constructor(t) {
                    super(), this.editor = t, this.componentFactory = new as(t), this.focusTracker = new mr, this.tooltipManager = new fm(t), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.isReady = !1, this.once("ready", (() => {
                        this.isReady = !0
                    })), this._editableElementsMap = new Map, this._focusableToolbarDefinitions = [], this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update())), this._initFocusTracking()
                }
                get element() {
                    return null
                }
                update() {
                    this.fire("update")
                }
                destroy() {
                    this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor);
                    for (const t of this._editableElementsMap.values()) t.ckeditorInstance = null;
                    this._editableElementsMap = new Map, this._focusableToolbarDefinitions = []
                }
                setEditableElement(t, e) {
                    this._editableElementsMap.set(t, e), e.ckeditorInstance || (e.ckeditorInstance = this.editor), this.focusTracker.add(e);
                    const n = () => {
                        this.editor.editing.view.getDomRoot(t) || this.editor.keystrokes.listenTo(e)
                    };
                    this.isReady ? n() : this.once("ready", n)
                }
                getEditableElement(t = "main") {
                    return this._editableElementsMap.get(t)
                }
                getEditableElementsNames() {
                    return this._editableElementsMap.keys()
                }
                addToolbar(t, e = {}) {
                    t.isRendered ? (this.focusTracker.add(t.element), this.editor.keystrokes.listenTo(t.element)) : t.once("render", (() => {
                        this.focusTracker.add(t.element), this.editor.keystrokes.listenTo(t.element)
                    })), this._focusableToolbarDefinitions.push({
                        toolbarView: t,
                        options: e
                    })
                }
                get _editableElements() {
                    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
                        editorUI: this
                    }), this._editableElementsMap
                }
                _readViewportOffsetFromConfig() {
                    const t = this.editor,
                        e = t.config.get("ui.viewportOffset");
                    if (e) return e;
                    const n = t.config.get("toolbar.viewportTopOffset");
                    return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), {
                        top: n
                    }) : {
                        top: 0
                    }
                }
                _initFocusTracking() {
                    const t = this.editor,
                        e = t.editing.view;
                    let n, o;
                    t.keystrokes.set("Alt+F10", ((t, i) => {
                        const r = this.focusTracker.focusedElement;
                        Array.from(this._editableElementsMap.values()).includes(r) && !Array.from(e.domRoots.values()).includes(r) && (n = r);
                        const s = this._getCurrentFocusedToolbarDefinition();
                        s && o || (o = this._getFocusableCandidateToolbarDefinitions());
                        for (let t = 0; t < o.length; t++) {
                            const t = o.shift();
                            if (o.push(t), t !== s && this._focusFocusableCandidateToolbar(t)) {
                                s && s.options.afterBlur && s.options.afterBlur();
                                break
                            }
                        }
                        i()
                    })), t.keystrokes.set("Esc", ((e, o) => {
                        const i = this._getCurrentFocusedToolbarDefinition();
                        i && (n ? (n.focus(), n = null) : t.editing.view.focus(), i.options.afterBlur && i.options.afterBlur(), o())
                    }))
                }
                _getFocusableCandidateToolbarDefinitions() {
                    const t = [];
                    for (const e of this._focusableToolbarDefinitions) {
                        const {
                            toolbarView: n,
                            options: o
                        } = e;
                        (ji(n.element) || o.beforeFocus) && t.push(e)
                    }
                    return t.sort(((t, e) => wm(t) - wm(e))), t
                }
                _getCurrentFocusedToolbarDefinition() {
                    for (const t of this._focusableToolbarDefinitions)
                        if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) return t;
                    return null
                }
                _focusFocusableCandidateToolbar(t) {
                    const {
                        toolbarView: e,
                        options: {
                            beforeFocus: n
                        }
                    } = t;
                    return n && n(), !!ji(e.element) && (e.focus(), !0)
                }
            }
    
            function wm(t) {
                const {
                    toolbarView: e,
                    options: n
                } = t;
                let o = 10;
                return ji(e.element) && o--, n.isContextual && o--, o
            }
            var _m = n(9688),
                Am = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(_m.Z, Am);
            _m.Z.locals;
            class Cm extends Dr {
                constructor(t) {
                    super(t), this.body = new Kr(t)
                }
                render() {
                    super.render(), this.body.attachToDom()
                }
                destroy() {
                    return this.body.detachFromDom(), super.destroy()
                }
            }
            var vm = n(3662),
                ym = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(vm.Z, ym);
            vm.Z.locals;
            class xm extends Dr {
                constructor(t) {
                    super(t), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${k()}`;
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "label",
                        attributes: {
                            class: ["ck", "ck-label"],
                            id: this.id,
                            for: e.to("for")
                        },
                        children: [{
                            text: e.to("text")
                        }]
                    })
                }
            }
            class Em extends Cm {
                constructor(t) {
                    super(t), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                            role: "application",
                            dir: t.uiLanguageDirection,
                            lang: t.uiLanguage,
                            "aria-labelledby": this._voiceLabelView.id
                        },
                        children: [this._voiceLabelView, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__top", "ck-reset_all"],
                                role: "presentation"
                            },
                            children: this.top
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__main"],
                                role: "presentation"
                            },
                            children: this.main
                        }]
                    })
                }
                _createVoiceLabel() {
                    const t = this.t,
                        e = new xm;
                    return e.text = t("Rich Text Editor"), e.extendTemplate({
                        attributes: {
                            class: "ck-voice-label"
                        }
                    }), e
                }
            }
            class Dm extends Dr {
                constructor(t, e, n) {
                    super(t), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                            lang: t.contentLanguage,
                            dir: t.contentLanguageDirection
                        }
                    }), this.name = null, this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = e
                }
                render() {
                    super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", (() => this._updateIsFocusedClasses())), this._updateIsFocusedClasses()
                }
                destroy() {
                    this._hasExternalElement && this.template.revert(this._editableElement), super.destroy()
                }
                _updateIsFocusedClasses() {
                    const t = this._editingView;
    
                    function e(e) {
                        t.change((n => {
                            const o = t.document.getRoot(e.name);
                            n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o), n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o)
                        }))
                    }
                    t.isRenderingInProgress ? function n(o) {
                        t.once("change:isRenderingInProgress", ((t, i, r) => {
                            r ? n(o) : e(o)
                        }))
                    }(this) : e(this)
                }
            }
            class Im extends Dm {
                constructor(t, e, n, o = {}) {
                    super(t, e, n);
                    const i = t.t;
                    this.extendTemplate({
                        attributes: {
                            role: "textbox",
                            class: "ck-editor__editable_inline"
                        }
                    }), this._generateLabel = o.label || (() => i("Editor editing area: %0", this.name))
                }
                render() {
                    super.render();
                    const t = this._editingView;
                    t.change((e => {
                        const n = t.document.getRoot(this.name);
                        e.setAttribute("aria-label", this._generateLabel(this), n)
                    }))
                }
            }
            var Tm = n(8847),
                Mm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Tm.Z, Mm);
            Tm.Z.locals;
            var Sm = n(4879),
                Nm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Sm.Z, Nm);
            Sm.Z.locals;
            class Bm extends Dr {
                constructor(t) {
                    super(t), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new mr, this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")],
                            id: e.to("id"),
                            placeholder: e.to("placeholder"),
                            readonly: e.to("isReadOnly"),
                            inputmode: e.to("inputMode"),
                            "aria-invalid": e.if("hasError", !0),
                            "aria-describedby": e.to("ariaDescribedById")
                        },
                        on: {
                            input: e.to(((...t) => {
                                this.fire("input", ...t), this._updateIsEmpty()
                            })),
                            change: e.to(this._updateIsEmpty.bind(this))
                        }
                    })
                }
                render() {
                    super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", ((t, e, n) => {
                        this._setDomElementValue(n), this._updateIsEmpty()
                    }))
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy()
                }
                select() {
                    this.element.select()
                }
                focus() {
                    this.element.focus()
                }
                _updateIsEmpty() {
                    this.isEmpty = !this.element.value
                }
                _setDomElementValue(t) {
                    this.element.value = t || 0 === t ? t : ""
                }
            }
            class Pm extends Bm {
                constructor(t) {
                    super(t), this.extendTemplate({
                        attributes: {
                            type: "text",
                            class: ["ck-input-text"]
                        }
                    })
                }
            }
            var zm = n(2577),
                Lm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(zm.Z, Lm);
            zm.Z.locals;
            class Om extends Dr {
                constructor(t, e) {
                    super(t);
                    const n = `ck-labeled-field-view-${k()}`,
                        o = `ck-labeled-field-view-status-${k()}`;
                    this.fieldView = e(this, n, o), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(o), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e));
                    const i = this.bindTemplate;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t)), i.if("isEmpty", "ck-labeled-field-view_empty"), i.if("isFocused", "ck-labeled-field-view_focused"), i.if("placeholder", "ck-labeled-field-view_placeholder"), i.if("errorText", "ck-error")]
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-labeled-field-view__input-wrapper"]
                            },
                            children: this.fieldWrapperChildren
                        }, this.statusView]
                    })
                }
                _createLabelView(t) {
                    const e = new xm(this.locale);
                    return e.for = t, e.bind("text").to(this, "label"), e
                }
                _createStatusView(t) {
                    const e = new Dr(this.locale),
                        n = this.bindTemplate;
                    return e.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))],
                            id: t,
                            role: n.if("errorText", "alert")
                        },
                        children: [{
                            text: n.to("_statusText")
                        }]
                    }), e
                }
                focus() {
                    this.fieldView.focus()
                }
            }
    
            function Rm(t, e, n) {
                const o = new Pm(t.locale);
                return o.set({
                    id: e,
                    ariaDescribedById: n
                }), o.bind("isReadOnly").to(t, "isEnabled", (t => !t)), o.bind("hasError").to(t, "errorText", (t => !!t)), o.on("input", (() => {
                    t.errorText = null
                })), t.bind("isEmpty", "isFocused", "placeholder").to(o), o
            }
            class jm extends Ms {
                static get pluginName() {
                    return "Notification"
                }
                init() {
                    this.on("show:warning", ((t, e) => {
                        window.alert(e.message)
                    }), {
                        priority: "lowest"
                    })
                }
                showSuccess(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "success",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                showInfo(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "info",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                showWarning(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "warning",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                _showNotification(t) {
                    const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`;
                    this.fire(e, {
                        message: t.message,
                        type: t.type,
                        title: t.title || ""
                    })
                }
            }
            class Fm extends($()) {
                constructor(t, e) {
                    super(), e && gl(this, e), t && this.set(t)
                }
            }
            var Vm = n(4650),
                Hm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Vm.Z, Hm);
            Vm.Z.locals;
            var Um = n(7676),
                Wm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Um.Z, Wm);
            Um.Z.locals;
            const qm = zi("px");
            class Gm extends vs {
                static get pluginName() {
                    return "ContextualBalloon"
                }
                constructor(t) {
                    super(t), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
                        const t = this.editor.editing.view,
                            e = t.document.selection.editableElement;
                        return e ? t.domConverter.mapViewToDom(e.root) : null
                    }, this.set("visibleView", null), this._viewToStack = new Map, this._idToStack = new Map, this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1), this._rotatorView = null, this._fakePanelsView = null
                }
                destroy() {
                    super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy()
                }
                get view() {
                    return this._view || this._createPanelView(), this._view
                }
                hasView(t) {
                    return Array.from(this._viewToStack.keys()).includes(t)
                }
                add(t) {
                    if (this._view || this._createPanelView(), this.hasView(t.view)) throw new A("contextualballoon-add-view-exist", [this, t]);
                    const e = t.stackId || "main";
                    if (!this._idToStack.has(e)) return this._idToStack.set(e, new Map([
                        [t.view, t]
                    ])), this._viewToStack.set(t.view, this._idToStack.get(e)), this._numberOfStacks = this._idToStack.size, void(this._visibleStack && !t.singleViewMode || this.showStack(e));
                    const n = this._idToStack.get(e);
                    t.singleViewMode && this.showStack(e), n.set(t.view, t), this._viewToStack.set(t.view, n), n === this._visibleStack && this._showView(t)
                }
                remove(t) {
                    if (!this.hasView(t)) throw new A("contextualballoon-remove-view-not-exist", [this, t]);
                    const e = this._viewToStack.get(t);
                    this._singleViewMode && this.visibleView === t && (this._singleViewMode = !1), this.visibleView === t && (1 === e.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e.values())[e.size - 2])), 1 === e.size ? (this._idToStack.delete(this._getStackId(e)), this._numberOfStacks = this._idToStack.size) : e.delete(t), this._viewToStack.delete(t)
                }
                updatePosition(t) {
                    t && (this._visibleStack.get(this.visibleView).position = t), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition()
                }
                showStack(t) {
                    this.visibleStack = t;
                    const e = this._idToStack.get(t);
                    if (!e) throw new A("contextualballoon-showstack-stack-not-exist", this);
                    this._visibleStack !== e && this._showView(Array.from(e.values()).pop())
                }
                _createPanelView() {
                    this._view = new dm(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView()
                }
                get _visibleStack() {
                    return this._viewToStack.get(this.visibleView)
                }
                _getStackId(t) {
                    return Array.from(this._idToStack.entries()).find((e => e[1] === t))[0]
                }
                _showNextStack() {
                    const t = Array.from(this._idToStack.values());
                    let e = t.indexOf(this._visibleStack) + 1;
                    t[e] || (e = 0), this.showStack(this._getStackId(t[e]))
                }
                _showPrevStack() {
                    const t = Array.from(this._idToStack.values());
                    let e = t.indexOf(this._visibleStack) - 1;
                    t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]))
                }
                _createRotatorView() {
                    const t = new $m(this.editor.locale),
                        e = this.editor.locale.t;
                    return this.view.content.add(t), t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1)), t.on("change:isNavigationVisible", (() => this.updatePosition()), {
                        priority: "low"
                    }), t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => {
                        if (n < 2) return "";
                        const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                        return e("%0 of %1", [o, n])
                    })), t.buttonNextView.on("execute", (() => {
                        t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack()
                    })), t.buttonPrevView.on("execute", (() => {
                        t.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack()
                    })), t
                }
                _createFakePanelsView() {
                    const t = new Ym(this.editor.locale, this.view);
                    return t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t >= 2 ? Math.min(t - 1, 2) : 0)), t.listenTo(this.view, "change:top", (() => t.updatePosition())), t.listenTo(this.view, "change:left", (() => t.updatePosition())), this.editor.ui.view.body.add(t), t
                }
                _showView({
                    view: t,
                    balloonClassName: e = "",
                    withArrow: n = !0,
                    singleViewMode: o = !1
                }) {
                    this.view.class = e, this.view.withArrow = n, this._rotatorView.showView(t), this.visibleView = t, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), o && (this._singleViewMode = !0)
                }
                _getBalloonPosition() {
                    let t = Array.from(this._visibleStack.values()).pop().position;
                    return t && (t.limiter || (t = Object.assign({}, t, {
                        limiter: this.positionLimiter
                    })), t = Object.assign({}, t, {
                        viewportOffsetConfig: this.editor.ui.viewportOffset
                    })), t
                }
            }
            class $m extends Dr {
                constructor(t) {
                    super(t);
                    const e = t.t,
                        n = this.bindTemplate;
                    this.set("isNavigationVisible", !0), this.focusTracker = new mr, this.buttonPrevView = this._createButtonView(e("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(e("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-rotator"],
                            "z-index": "-1"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))]
                            },
                            children: [this.buttonPrevView, {
                                tag: "span",
                                attributes: {
                                    class: ["ck-balloon-rotator__counter"]
                                },
                                children: [{
                                    text: n.to("counter")
                                }]
                            }, this.buttonNextView]
                        }, {
                            tag: "div",
                            attributes: {
                                class: "ck-balloon-rotator__content"
                            },
                            children: this.content
                        }]
                    })
                }
                render() {
                    super.render(), this.focusTracker.add(this.element)
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy()
                }
                showView(t) {
                    this.hideView(), this.content.add(t)
                }
                hideView() {
                    this.content.clear()
                }
                _createButtonView(t, e) {
                    const n = new es(this.locale);
                    return n.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), n
                }
            }
            class Ym extends Dr {
                constructor(t, e) {
                    super(t);
                    const n = this.bindTemplate;
                    this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e, this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))],
                            style: {
                                top: n.to("top", qm),
                                left: n.to("left", qm),
                                width: n.to("width", qm),
                                height: n.to("height", qm)
                            }
                        },
                        children: this.content
                    }), this.on("change:numberOfPanels", ((t, e, n, o) => {
                        n > o ? this._addPanels(n - o) : this._removePanels(o - n), this.updatePosition()
                    }))
                }
                _addPanels(t) {
                    for (; t--;) {
                        const t = new Dr;
                        t.setTemplate({
                            tag: "div"
                        }), this.content.add(t), this.registerChild(t)
                    }
                }
                _removePanels(t) {
                    for (; t--;) {
                        const t = this.content.last;
                        this.content.remove(t), this.deregisterChild(t), t.destroy()
                    }
                }
                updatePosition() {
                    if (this.numberOfPanels) {
                        const {
                            top: t,
                            left: e
                        } = this._balloonPanelView, {
                            width: n,
                            height: o
                        } = new Ti(this._balloonPanelView.element);
                        Object.assign(this, {
                            top: t,
                            left: e,
                            width: n,
                            height: o
                        })
                    }
                }
            }
            var Km = n(5868),
                Qm = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Km.Z, Qm);
            Km.Z.locals;
            const Zm = zi("px");
            class Jm extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", !1), this.set("_hasViewportTopOffset", !1), this.content = this.createCollection(), this._contentPanelPlaceholder = new Ir({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__placeholder"],
                            style: {
                                display: e.to("isSticky", (t => t ? "block" : "none")),
                                height: e.to("isSticky", (t => t ? Zm(this._panelRect.height) : null))
                            }
                        }
                    }).render(), this._contentPanel = new Ir({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                            style: {
                                width: e.to("isSticky", (t => t ? Zm(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)),
                                top: e.to("_hasViewportTopOffset", (t => t ? Zm(this.viewportTopOffset) : null)),
                                bottom: e.to("_isStickyToTheLimiter", (t => t ? Zm(this.limiterBottomOffset) : null)),
                                marginLeft: e.to("_marginLeft")
                            }
                        },
                        children: this.content
                    }).render(), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel"]
                        },
                        children: [this._contentPanelPlaceholder, this._contentPanel]
                    })
                }
                render() {
                    super.render(), this._checkIfShouldBeSticky(), this.listenTo(vi.window, "scroll", (() => {
                        this._checkIfShouldBeSticky()
                    })), this.listenTo(this, "change:isActive", (() => {
                        this._checkIfShouldBeSticky()
                    }))
                }
                _checkIfShouldBeSticky() {
                    const t = this._panelRect = this._contentPanel.getBoundingClientRect();
                    let e;
                    this.limiterElement ? (e = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height) : this.isSticky = !1, this.isSticky ? (this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : Zm(-vi.window.scrollX)) : (this._isStickyToTheLimiter = !1, this._hasViewportTopOffset = !1, this._marginLeft = null)
                }
            }
            zi("px");
            var Xm = n(9695),
                tp = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Xm.Z, tp);
            Xm.Z.locals, zi("px");
            zi("px");
            const {
                pilcrow: ep
            } = Lg;
            class np extends bm {
                constructor(t, e) {
                    super(t), this.view = e, this._toolbarConfig = Cs(t.config.get("toolbar")), this._elementReplacer = new X
                }
                get element() {
                    return this.view.element
                }
                init(t) {
                    const e = this.editor,
                        n = this.view,
                        o = e.editing.view,
                        i = n.editable,
                        r = o.document.getRoot();
                    i.name = r.rootName, n.render();
                    const s = i.element;
                    this.setEditableElement(i.name, s), n.editable.bind("isFocused").to(this.focusTracker), o.attachDomRoot(s), t && this._elementReplacer.replace(t, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready")
                }
                destroy() {
                    super.destroy();
                    const t = this.view,
                        e = this.editor.editing.view;
                    this._elementReplacer.restore(), e.detachDomRoot(t.editable.name), t.destroy()
                }
                _initToolbar() {
                    const t = this.view;
                    t.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), t.stickyPanel.limiterElement = t.element, t.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", (({
                        top: t
                    }) => t || 0)), t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(t.toolbar)
                }
                _initPlaceholder() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = e.document.getRoot(),
                        o = t.sourceElement,
                        i = t.config.get("placeholder") || o && "textarea" === o.tagName.toLowerCase() && o.getAttribute("placeholder");
                    i && Ps({
                        view: e,
                        element: n,
                        text: i,
                        isDirectHost: !1,
                        keepOnFocus: !0
                    })
                }
            }
            var op = n(3143),
                ip = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(op.Z, ip);
            op.Z.locals;
            class rp extends Em {
                constructor(t, e, n = {}) {
                    super(t), this.stickyPanel = new Jm(t), this.toolbar = new Vg(t, {
                        shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
                    }), this.editable = new Im(t, e)
                }
                render() {
                    super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable)
                }
            }
            class sp extends(Bg(Pg(Ng))) {
                constructor(t, e = {}) {
                    if (!ap(t) && void 0 !== e.initialData) throw new A("editor-create-initial-data", null);
                    super(e), void 0 === this.config.get("initialData") && this.config.set("initialData", function(t) {
                        return ap(t) ? (e = t, e instanceof HTMLTextAreaElement ? e.value : e.innerHTML) : t;
                        var e
                    }(t)), ap(t) && (this.sourceElement = t), this.model.document.createRoot();
                    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"),
                        o = new rp(this.locale, this.editing.view, {
                            shouldToolbarGroupWhenFull: n
                        });
                    this.ui = new np(this, o),
                        function(t) {
                            if (!Qt(t.updateSourceElement)) throw new A("attachtoform-missing-elementapi-interface", t);
                            const e = t.sourceElement;
                            if (function(t) {
                                    return !!t && "textarea" === t.tagName.toLowerCase()
                                }(e) && e.form) {
                                let n;
                                const o = e.form,
                                    i = () => t.updateSourceElement();
                                Qt(o.submit) && (n = o.submit, o.submit = () => {
                                    i(), n.apply(o)
                                }), o.addEventListener("submit", i), t.on("destroy", (() => {
                                    o.removeEventListener("submit", i), n && (o.submit = n)
                                }))
                            }
                        }(this)
                }
                destroy() {
                    return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy()
                }
                static create(t, e = {}) {
                    return new Promise((n => {
                        const o = new this(t, e);
                        n(o.initPlugins().then((() => o.ui.init(ap(t) ? t : null))).then((() => o.data.init(o.config.get("initialData")))).then((() => o.fire("ready"))).then((() => o)))
                    }))
                }
            }
    
            function ap(t) {
                return ui(t)
            }
            class cp extends pl {
                constructor(t) {
                    super(t);
                    const e = this.document;
    
                    function n(t) {
                        return (n, o) => {
                            o.preventDefault();
                            const i = o.dropRange ? [o.dropRange] : null,
                                r = new p(e, t);
                            e.fire(r, {
                                dataTransfer: o.dataTransfer,
                                method: n.name,
                                targetRanges: i,
                                target: o.target
                            }), r.stop.called && o.stopPropagation()
                        }
                    }
                    this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"], this.listenTo(e, "paste", n("clipboardInput"), {
                        priority: "low"
                    }), this.listenTo(e, "drop", n("clipboardInput"), {
                        priority: "low"
                    }), this.listenTo(e, "dragover", n("dragging"), {
                        priority: "low"
                    })
                }
                onDomEvent(t) {
                    const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer,
                        n = "drop" == t.type || "paste" == t.type,
                        o = {
                            dataTransfer: new vd(e, {
                                cacheFiles: n
                            })
                        };
                    "drop" != t.type && "dragover" != t.type || (o.dropRange = function(t, e) {
                        const n = e.target.ownerDocument,
                            o = e.clientX,
                            i = e.clientY;
                        let r;
                        n.caretRangeFromPoint && n.caretRangeFromPoint(o, i) ? r = n.caretRangeFromPoint(o, i) : e.rangeParent && (r = n.createRange(), r.setStart(e.rangeParent, e.rangeOffset), r.collapse(!0));
                        if (r) return t.domConverter.domRangeToView(r);
                        return null
                    }(this.view, t)), this.fire(t.type, t, o)
                }
            }
            const lp = ["figcaption", "li"];
    
            function dp(t) {
                let e = "";
                if (t.is("$text") || t.is("$textProxy")) e = t.data;
                else if (t.is("element", "img") && t.hasAttribute("alt")) e = t.getAttribute("alt");
                else if (t.is("element", "br")) e = "\n";
                else {
                    let n = null;
                    for (const o of t.getChildren()) {
                        const t = dp(o);
                        n && (n.is("containerElement") || o.is("containerElement")) && (lp.includes(n.name) || lp.includes(o.name) ? e += "\n" : e += "\n\n"), e += t, n = o
                    }
                }
                return e
            }
            class hp extends vs {
                static get pluginName() {
                    return "ClipboardPipeline"
                }
                init() {
                    this.editor.editing.view.addObserver(cp), this._setupPasteDrop(), this._setupCopyCut()
                }
                _setupPasteDrop() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = n.document;
                    this.listenTo(o, "clipboardInput", (e => {
                        t.isReadOnly && e.stop()
                    }), {
                        priority: "highest"
                    }), this.listenTo(o, "clipboardInput", ((t, e) => {
                        const o = e.dataTransfer;
                        let i;
                        if (e.content) i = e.content;
                        else {
                            let t = "";
                            o.getData("text/html") ? t = function(t) {
                                return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => 1 == e.length ? " " : e)).replace(/<!--[\s\S]*?-->/g, "")
                            }(o.getData("text/html")) : o.getData("text/plain") && (((r = (r = o.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || r.includes("<br>")) && (r = `<p>${r}</p>`), t = r), i = this.editor.data.htmlProcessor.toView(t)
                        }
                        var r;
                        const s = new p(this, "inputTransformation");
                        this.fire(s, {
                            content: i,
                            dataTransfer: o,
                            targetRanges: e.targetRanges,
                            method: e.method
                        }), s.stop.called && t.stop(), n.scrollToTheSelection()
                    }), {
                        priority: "low"
                    }), this.listenTo(this, "inputTransformation", ((t, n) => {
                        if (n.content.isEmpty) return;
                        const o = this.editor.data.toModel(n.content, "$clipboardHolder");
                        0 != o.childCount && (t.stop(), e.change((() => {
                            this.fire("contentInsertion", {
                                content: o,
                                method: n.method,
                                dataTransfer: n.dataTransfer,
                                targetRanges: n.targetRanges
                            })
                        })))
                    }), {
                        priority: "low"
                    }), this.listenTo(this, "contentInsertion", ((t, n) => {
                        n.resultRange = e.insertContent(n.content)
                    }), {
                        priority: "low"
                    })
                }
                _setupCopyCut() {
                    const t = this.editor,
                        e = t.model.document,
                        n = t.editing.view.document,
                        o = (o, i) => {
                            const r = i.dataTransfer;
                            i.preventDefault();
                            const s = t.data.toView(t.model.getSelectedContent(e.selection));
                            n.fire("clipboardOutput", {
                                dataTransfer: r,
                                content: s,
                                method: o.name
                            })
                        };
                    this.listenTo(n, "copy", o, {
                        priority: "low"
                    }), this.listenTo(n, "cut", ((e, n) => {
                        t.isReadOnly ? n.preventDefault() : o(e, n)
                    }), {
                        priority: "low"
                    }), this.listenTo(n, "clipboardOutput", ((n, o) => {
                        o.content.isEmpty || (o.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(o.content)), o.dataTransfer.setData("text/plain", dp(o.content))), "cut" == o.method && t.model.deleteContent(e.selection)
                    }), {
                        priority: "low"
                    })
                }
            }
            class up {
                constructor(t, e = 20) {
                    this._batch = null, this.model = t, this._size = 0, this.limit = e, this._isLocked = !1, this._changeCallback = (t, e) => {
                        e.isLocal && e.isUndoable && e !== this._batch && this._reset(!0)
                    }, this._selectionChangeCallback = () => {
                        this._reset()
                    }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
                }
                get batch() {
                    return this._batch || (this._batch = this.model.createBatch({
                        isTyping: !0
                    })), this._batch
                }
                get size() {
                    return this._size
                }
                input(t) {
                    this._size += t, this._size >= this.limit && this._reset(!0)
                }
                get isLocked() {
                    return this._isLocked
                }
                lock() {
                    this._isLocked = !0
                }
                unlock() {
                    this._isLocked = !1
                }
                destroy() {
                    this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
                }
                _reset(t = !1) {
                    this.isLocked && !t || (this._batch = null, this._size = 0)
                }
            }
            class gp extends xs {
                constructor(t, e) {
                    super(t), this._buffer = new up(t.model, e)
                }
                get buffer() {
                    return this._buffer
                }
                destroy() {
                    super.destroy(), this._buffer.destroy()
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.document,
                        o = t.text || "",
                        i = o.length;
                    let r = n.selection;
                    t.selection ? r = t.selection : t.range && (r = e.createSelection(t.range));
                    const s = t.resultRange;
                    e.enqueueChange(this._buffer.batch, (t => {
                        this._buffer.lock(), e.deleteContent(r), o && e.insertContent(t.createText(o, n.selection.getAttributes()), r), s ? t.setSelection(s) : r.is("documentSelection") || t.setSelection(r), this._buffer.unlock(), this._buffer.input(i)
                    }))
                }
            }
            const mp = ["insertText", "insertReplacementText"];
            class pp extends ul {
                constructor(t) {
                    super(t), a.isAndroid && mp.push("insertCompositionText");
                    const e = t.document;
                    e.on("beforeinput", ((n, o) => {
                        if (!this.isEnabled) return;
                        const {
                            data: i,
                            targetRanges: r,
                            inputType: s,
                            domEvent: a
                        } = o;
                        if (!mp.includes(s)) return;
                        const c = new p(e, "insertText");
                        e.fire(c, new ml(t, a, {
                            text: i,
                            selection: t.createSelection(r)
                        })), c.stop.called && n.stop()
                    })), e.on("compositionend", ((n, {
                        data: o,
                        domEvent: i
                    }) => {
                        this.isEnabled && !a.isAndroid && o && e.fire("insertText", new ml(t, i, {
                            text: o,
                            selection: e.selection
                        }))
                    }), {
                        priority: "lowest"
                    })
                }
                observe() {}
            }
            class fp extends vs {
                static get pluginName() {
                    return "Input"
                }
                init() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = e.document.selection;
                    n.addObserver(pp);
                    const i = new gp(t, t.config.get("typing.undoStep") || 20);
                    t.commands.add("insertText", i), t.commands.add("input", i), this.listenTo(n.document, "insertText", ((o, i) => {
                        n.document.isComposing || i.preventDefault();
                        const {
                            text: r,
                            selection: s,
                            resultRange: c
                        } = i, l = Array.from(s.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                        let d = r;
                        if (a.isAndroid) {
                            const t = Array.from(l[0].getItems()).reduce(((t, e) => t + (e.is("$textProxy") ? e.data : "")), "");
                            t && (t.length <= d.length ? d.startsWith(t) && (d = d.substring(t.length), l[0].start = l[0].start.getShiftedBy(t.length)) : t.startsWith(d) && (l[0].start = l[0].start.getShiftedBy(d.length), d = ""))
                        }
                        const h = {
                            text: d,
                            selection: e.createSelection(l)
                        };
                        c && (h.resultRange = t.editing.mapper.toModelRange(c)), t.execute("insertText", h)
                    })), a.isAndroid ? this.listenTo(n.document, "keydown", ((t, r) => {
                        !o.isCollapsed && 229 == r.keyCode && n.document.isComposing && kp(e, i)
                    })) : this.listenTo(n.document, "compositionstart", (() => {
                        o.isCollapsed || kp(e, i)
                    }))
                }
            }
    
            function kp(t, e) {
                if (!e.isEnabled) return;
                const n = e.buffer;
                n.lock(), t.enqueueChange(n.batch, (() => {
                    t.deleteContent(t.document.selection)
                })), n.unlock()
            }
            class bp extends xs {
                constructor(t, e) {
                    super(t), this.direction = e, this._buffer = new up(t.model, t.config.get("typing.undoStep"))
                }
                get buffer() {
                    return this._buffer
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.document;
                    e.enqueueChange(this._buffer.batch, (o => {
                        this._buffer.lock();
                        const i = o.createSelection(t.selection || n.selection),
                            r = t.sequence || 1,
                            s = i.isCollapsed;
                        if (i.isCollapsed && e.modifySelection(i, {
                                direction: this.direction,
                                unit: t.unit,
                                treatEmojiAsSingleUnit: !0
                            }), this._shouldEntireContentBeReplacedWithParagraph(r)) return void this._replaceEntireContentWithParagraph(o);
                        if (this._shouldReplaceFirstBlockWithParagraph(i, r)) return void this.editor.execute("paragraph", {
                            selection: i
                        });
                        if (i.isCollapsed) return;
                        let a = 0;
                        i.getFirstRange().getMinimalFlatRanges().forEach((t => {
                            a += tt(t.getWalker({
                                singleCharacters: !0,
                                ignoreElementEnd: !0,
                                shallow: !0
                            }))
                        })), e.deleteContent(i, {
                            doNotResetEntireContent: s,
                            direction: this.direction
                        }), this._buffer.input(a), o.setSelection(i), this._buffer.unlock()
                    }))
                }
                _shouldEntireContentBeReplacedWithParagraph(t) {
                    if (t > 1) return !1;
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = e.schema.getLimitElement(n);
                    if (!(n.isCollapsed && n.containsEntireContent(o))) return !1;
                    if (!e.schema.checkChild(o, "paragraph")) return !1;
                    const i = o.getChild(0);
                    return !i || !i.is("element", "paragraph")
                }
                _replaceEntireContentWithParagraph(t) {
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = e.schema.getLimitElement(n),
                        i = t.createElement("paragraph");
                    t.remove(t.createRangeIn(o)), t.insert(i, o), t.setSelection(i, 0)
                }
                _shouldReplaceFirstBlockWithParagraph(t, e) {
                    const n = this.editor.model;
                    if (e > 1 || "backward" != this.direction) return !1;
                    if (!t.isCollapsed) return !1;
                    const o = t.getFirstPosition(),
                        i = n.schema.getLimitElement(o),
                        r = i.getChild(0);
                    return o.parent == r && (!!t.containsEntireContent(r) && (!!n.schema.checkChild(i, "paragraph") && "paragraph" != r.name))
                }
            }
            const wp = "word",
                _p = "selection",
                Ap = "backward",
                Cp = "forward",
                vp = {
                    deleteContent: {
                        unit: _p,
                        direction: Ap
                    },
                    deleteContentBackward: {
                        unit: "codePoint",
                        direction: Ap
                    },
                    deleteWordBackward: {
                        unit: wp,
                        direction: Ap
                    },
                    deleteHardLineBackward: {
                        unit: _p,
                        direction: Ap
                    },
                    deleteSoftLineBackward: {
                        unit: _p,
                        direction: Ap
                    },
                    deleteContentForward: {
                        unit: "character",
                        direction: Cp
                    },
                    deleteWordForward: {
                        unit: wp,
                        direction: Cp
                    },
                    deleteHardLineForward: {
                        unit: _p,
                        direction: Cp
                    },
                    deleteSoftLineForward: {
                        unit: _p,
                        direction: Cp
                    }
                };
            class yp extends ul {
                constructor(t) {
                    super(t);
                    const e = t.document;
                    let n = 0;
                    e.on("keydown", (() => {
                        n++
                    })), e.on("keyup", (() => {
                        n = 0
                    })), e.on("beforeinput", ((o, i) => {
                        if (!this.isEnabled) return;
                        const {
                            targetRanges: r,
                            domEvent: s,
                            inputType: c
                        } = i, l = vp[c];
                        if (!l) return;
                        const d = {
                            direction: l.direction,
                            unit: l.unit,
                            sequence: n
                        };
                        d.unit == _p && (d.selectionToRemove = t.createSelection(r[0])), a.isAndroid && "deleteContentBackward" === c && (d.sequence = 1, 1 != r.length || r[0].start.parent == r[0].end.parent && r[0].start.offset + 1 == r[0].end.offset || (d.unit = _p, d.selectionToRemove = t.createSelection(r)));
                        const h = new dc(e, "delete", r[0]);
                        e.fire(h, new ml(t, s, d)), h.stop.called && o.stop()
                    })), a.isBlink && function(t) {
                        const e = t.view,
                            n = e.document;
                        let o = null,
                            i = !1;
    
                        function r(t) {
                            return t == er.backspace || t == er.delete
                        }
    
                        function s(t) {
                            return t == er.backspace ? Ap : Cp
                        }
                        n.on("keydown", ((t, {
                            keyCode: e
                        }) => {
                            o = e, i = !1
                        })), n.on("keyup", ((a, {
                            keyCode: c,
                            domEvent: l
                        }) => {
                            const d = n.selection,
                                h = t.isEnabled && c == o && r(c) && !d.isCollapsed && !i;
                            if (o = null, h) {
                                const t = d.getFirstRange(),
                                    o = new dc(n, "delete", t),
                                    i = {
                                        unit: _p,
                                        direction: s(c),
                                        selectionToRemove: d
                                    };
                                n.fire(o, new ml(e, l, i))
                            }
                        })), n.on("beforeinput", ((t, {
                            inputType: e
                        }) => {
                            const n = vp[e];
                            r(o) && n && n.direction == s(o) && (i = !0)
                        }), {
                            priority: "high"
                        }), n.on("beforeinput", ((t, {
                            inputType: e,
                            data: n
                        }) => {
                            o == er.delete && "insertText" == e && "" == n && t.stop()
                        }), {
                            priority: "high"
                        })
                    }(this)
                }
                observe() {}
            }
            class xp extends vs {
                static get pluginName() {
                    return "Delete"
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = e.document,
                        o = t.model.document;
                    e.addObserver(yp), this._undoOnBackspace = !1;
                    const i = new bp(t, "forward");
                    t.commands.add("deleteForward", i), t.commands.add("forwardDelete", i), t.commands.add("delete", new bp(t, "backward")), this.listenTo(n, "delete", ((o, i) => {
                        n.isComposing || i.preventDefault();
                        const {
                            direction: r,
                            sequence: s,
                            selectionToRemove: a,
                            unit: c
                        } = i, l = "forward" === r ? "deleteForward" : "delete", d = {
                            sequence: s
                        };
                        if ("selection" == c) {
                            const e = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e)));
                            d.selection = t.model.createSelection(e)
                        } else d.unit = c;
                        t.execute(l, d), e.scrollToTheSelection()
                    }), {
                        priority: "low"
                    }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", ((e, n) => {
                        this._undoOnBackspace && "backward" == n.direction && 1 == n.sequence && "codePoint" == n.unit && (this._undoOnBackspace = !1, t.execute("undo"), n.preventDefault(), e.stop())
                    }), {
                        context: "$capture"
                    }), this.listenTo(o, "change", (() => {
                        this._undoOnBackspace = !1
                    })))
                }
                requestUndoOnBackspace() {
                    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0)
                }
            }
            class Ep extends vs {
                static get requires() {
                    return [fp, xp]
                }
                static get pluginName() {
                    return "Typing"
                }
            }
    
            function Dp(t, e) {
                let n = t.start;
                return {
                    text: Array.from(t.getItems()).reduce(((t, o) => o.is("$text") || o.is("$textProxy") ? t + o.data : (n = e.createPositionAfter(o), "")), ""),
                    range: e.createRange(n, t.end)
                }
            }
            class Ip extends($()) {
                constructor(t, e) {
                    super(), this.model = t, this.testCallback = e, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", (() => {
                        this.isEnabled ? this._startListening() : (this.stopListening(t.document.selection), this.stopListening(t.document))
                    })), this._startListening()
                }
                get hasMatch() {
                    return this._hasMatch
                }
                _startListening() {
                    const t = this.model.document;
                    this.listenTo(t.selection, "change:range", ((e, {
                        directChange: n
                    }) => {
                        n && (t.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1))
                    })), this.listenTo(t, "change:data", ((t, e) => {
                        !e.isUndo && e.isLocal && this._evaluateTextBeforeSelection("data", {
                            batch: e
                        })
                    }))
                }
                _evaluateTextBeforeSelection(t, e = {}) {
                    const n = this.model,
                        o = n.document.selection,
                        i = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus),
                        {
                            text: r,
                            range: s
                        } = Dp(i, n),
                        a = this.testCallback(r);
                    if (!a && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!a, a) {
                        const n = Object.assign(e, {
                            text: r,
                            range: s
                        });
                        "object" == typeof a && Object.assign(n, a), this.fire(`matched:${t}`, n)
                    }
                }
            }
            class Tp extends vs {
                static get pluginName() {
                    return "TwoStepCaretMovement"
                }
                constructor(t) {
                    super(t), this.attributes = new Set, this._overrideUid = null
                }
                init() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = t.locale,
                        i = e.document.selection;
                    this.listenTo(n.document, "arrowKey", ((t, e) => {
                        if (!i.isCollapsed) return;
                        if (e.shiftKey || e.altKey || e.ctrlKey) return;
                        const n = e.keyCode == er.arrowright,
                            r = e.keyCode == er.arrowleft;
                        if (!n && !r) return;
                        const s = o.contentLanguageDirection;
                        let a = !1;
                        a = "ltr" === s && n || "rtl" === s && r ? this._handleForwardMovement(e) : this._handleBackwardMovement(e), !0 === a && t.stop()
                    }), {
                        context: "$text",
                        priority: "highest"
                    }), this._isNextGravityRestorationSkipped = !1, this.listenTo(i, "change:range", ((t, e) => {
                        this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!e.directChange && Bp(i.getFirstPosition(), this.attributes) || this._restoreGravity())
                    }))
                }
                registerAttribute(t) {
                    this.attributes.add(t)
                }
                _handleForwardMovement(t) {
                    const e = this.attributes,
                        n = this.editor.model.document.selection,
                        o = n.getFirstPosition();
                    return !this._isGravityOverridden && ((!o.isAtStart || !Mp(n, e)) && (!!Bp(o, e) && (Np(t), this._overrideGravity(), !0)))
                }
                _handleBackwardMovement(t) {
                    const e = this.attributes,
                        n = this.editor.model,
                        o = n.document.selection,
                        i = o.getFirstPosition();
                    return this._isGravityOverridden ? (Np(t), this._restoreGravity(), Sp(n, e, i), !0) : i.isAtStart ? !!Mp(o, e) && (Np(t), Sp(n, e, i), !0) : !! function(t, e) {
                        const n = t.getShiftedBy(-1);
                        return Bp(n, e)
                    }(i, e) && (i.isAtEnd && !Mp(o, e) && Bp(i, e) ? (Np(t), Sp(n, e, i), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1))
                }
                get _isGravityOverridden() {
                    return !!this._overrideUid
                }
                _overrideGravity() {
                    this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity()))
                }
                _restoreGravity() {
                    this.editor.model.change((t => {
                        t.restoreSelectionGravity(this._overrideUid), this._overrideUid = null
                    }))
                }
            }
    
            function Mp(t, e) {
                for (const n of e)
                    if (t.hasAttribute(n)) return !0;
                return !1
            }
    
            function Sp(t, e, n) {
                const o = n.nodeBefore;
                t.change((t => {
                    o ? t.setSelectionAttribute(o.getAttributes()) : t.removeSelectionAttribute(e)
                }))
            }
    
            function Np(t) {
                t.preventDefault()
            }
    
            function Bp(t, e) {
                const {
                    nodeBefore: n,
                    nodeAfter: o
                } = t;
                for (const t of e) {
                    const e = n ? n.getAttribute(t) : void 0;
                    if ((o ? o.getAttribute(t) : void 0) !== e) return !0
                }
                return !1
            }
            var Pp = /[\\^$.*+?()[\]{}|]/g,
                zp = RegExp(Pp.source);
            const Lp = function(t) {
                    return (t = ua(t)) && zp.test(t) ? t.replace(Pp, "\\$&") : t
                },
                Op = {
                    copyright: {
                        from: "(c)",
                        to: ""
                    },
                    registeredTrademark: {
                        from: "(r)",
                        to: ""
                    },
                    trademark: {
                        from: "(tm)",
                        to: ""
                    },
                    oneHalf: {
                        from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
                        to: [null, "", null]
                    },
                    oneThird: {
                        from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
                        to: [null, "", null]
                    },
                    twoThirds: {
                        from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
                        to: [null, "", null]
                    },
                    oneForth: {
                        from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
                        to: [null, "", null]
                    },
                    threeQuarters: {
                        from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
                        to: [null, "", null]
                    },
                    lessThanOrEqual: {
                        from: "<=",
                        to: ""
                    },
                    greaterThanOrEqual: {
                        from: ">=",
                        to: ""
                    },
                    notEqual: {
                        from: "!=",
                        to: ""
                    },
                    arrowLeft: {
                        from: "<-",
                        to: ""
                    },
                    arrowRight: {
                        from: "->",
                        to: ""
                    },
                    horizontalEllipsis: {
                        from: "...",
                        to: ""
                    },
                    enDash: {
                        from: /(^| )(--)( )$/,
                        to: [null, "", null]
                    },
                    emDash: {
                        from: /(^| )(---)( )$/,
                        to: [null, "", null]
                    },
                    quotesPrimary: {
                        from: Up('"'),
                        to: [null, "", null, ""]
                    },
                    quotesSecondary: {
                        from: Up("'"),
                        to: [null, "", null, ""]
                    },
                    quotesPrimaryEnGb: {
                        from: Up("'"),
                        to: [null, "", null, ""]
                    },
                    quotesSecondaryEnGb: {
                        from: Up('"'),
                        to: [null, "", null, ""]
                    },
                    quotesPrimaryPl: {
                        from: Up('"'),
                        to: [null, "", null, ""]
                    },
                    quotesSecondaryPl: {
                        from: Up("'"),
                        to: [null, "", null, ""]
                    }
                },
                Rp = {
                    symbols: ["copyright", "registeredTrademark", "trademark"],
                    mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
                    typography: ["horizontalEllipsis", "enDash", "emDash"],
                    quotes: ["quotesPrimary", "quotesSecondary"]
                },
                jp = ["symbols", "mathematical", "typography", "quotes"];
    
            function Fp(t) {
                return "string" == typeof t ? new RegExp(`(${Lp(t)})$`) : t
            }
    
            function Vp(t) {
                return "string" == typeof t ? () => [t] : t instanceof Array ? () => t : t
            }
    
            function Hp(t) {
                return (t.textNode ? t.textNode : t.nodeAfter).getAttributes()
            }
    
            function Up(t) {
                return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
            }
    
            function Wp(t, e, n, o) {
                return o.createRange(qp(t, e, n, !0, o), qp(t, e, n, !1, o))
            }
    
            function qp(t, e, n, o, i) {
                let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter),
                    s = null;
                for (; r && r.getAttribute(e) == n;) s = r, r = o ? r.previousSibling : r.nextSibling;
                return s ? i.createPositionAt(s, o ? "before" : "after") : t
            }
    
            function* Gp(t, e) {
                for (const n of e) n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n)
            }
            class $p extends xs {
                execute() {
                    this.editor.model.change((t => {
                        this.enterBlock(t), this.fire("afterExecute", {
                            writer: t
                        })
                    }))
                }
                enterBlock(t) {
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = e.schema,
                        i = n.isCollapsed,
                        r = n.getFirstRange(),
                        s = r.start.parent,
                        a = r.end.parent;
                    if (o.isLimit(s) || o.isLimit(a)) return i || s != a || e.deleteContent(n), !1;
                    if (i) {
                        const e = Gp(t.model.schema, n.getAttributes());
                        return Yp(t, r.start), t.setSelectionAttribute(e), !0
                    } {
                        const o = !(r.start.isAtStart && r.end.isAtEnd),
                            i = s == a;
                        if (e.deleteContent(n, {
                                leaveUnmerged: o
                            }), o) {
                            if (i) return Yp(t, n.focus), !0;
                            t.setSelection(a, 0)
                        }
                    }
                    return !1
                }
            }
    
            function Yp(t, e) {
                t.split(e), t.setSelection(e.parent.nextSibling, 0)
            }
            const Kp = {
                insertParagraph: {
                    isSoft: !1
                },
                insertLineBreak: {
                    isSoft: !0
                }
            };
            class Qp extends ul {
                constructor(t) {
                    super(t);
                    const e = this.document;
                    e.on("beforeinput", ((n, o) => {
                        if (!this.isEnabled) return;
                        const i = o.domEvent,
                            r = Kp[o.inputType];
                        if (!r) return;
                        const s = new dc(e, "enter", o.targetRanges[0]);
                        e.fire(s, new ml(t, i, {
                            isSoft: r.isSoft
                        })), s.stop.called && n.stop()
                    }))
                }
                observe() {}
            }
            class Zp extends vs {
                static get pluginName() {
                    return "Enter"
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = e.document;
                    e.addObserver(Qp), t.commands.add("enter", new $p(t)), this.listenTo(n, "enter", ((o, i) => {
                        n.isComposing || i.preventDefault(), i.isSoft || (t.execute("enter"), e.scrollToTheSelection())
                    }), {
                        priority: "low"
                    })
                }
            }
            class Jp extends xs {
                execute() {
                    const t = this.editor.model,
                        e = t.document;
                    t.change((n => {
                        ! function(t, e, n) {
                            const o = n.isCollapsed,
                                i = n.getFirstRange(),
                                r = i.start.parent,
                                s = i.end.parent,
                                a = r == s;
                            if (o) {
                                const o = Gp(t.schema, n.getAttributes());
                                Xp(t, e, i.end), e.removeSelectionAttribute(n.getAttributeKeys()), e.setSelectionAttribute(o)
                            } else {
                                const o = !(i.start.isAtStart && i.end.isAtEnd);
                                t.deleteContent(n, {
                                    leaveUnmerged: o
                                }), a ? Xp(t, e, n.focus) : o && e.setSelection(s, 0)
                            }
                        }(t, n, e.selection), this.fire("afterExecute", {
                            writer: n
                        })
                    }))
                }
                refresh() {
                    const t = this.editor.model,
                        e = t.document;
                    this.isEnabled = function(t, e) {
                        if (e.rangeCount > 1) return !1;
                        const n = e.anchor;
                        if (!n || !t.checkChild(n, "softBreak")) return !1;
                        const o = e.getFirstRange(),
                            i = o.start.parent,
                            r = o.end.parent;
                        if ((tf(i, t) || tf(r, t)) && i !== r) return !1;
                        return !0
                    }(t.schema, e.selection)
                }
            }
    
            function Xp(t, e, n) {
                const o = e.createElement("softBreak");
                t.insertContent(o, n), e.setSelection(o, "after")
            }
    
            function tf(t, e) {
                return !t.is("rootElement") && (e.isLimit(t) || tf(t.parent, e))
            }
            class ef extends vs {
                static get pluginName() {
                    return "ShiftEnter"
                }
                init() {
                    const t = this.editor,
                        e = t.model.schema,
                        n = t.conversion,
                        o = t.editing.view,
                        i = o.document;
                    e.register("softBreak", {
                        allowWhere: "$text",
                        isInline: !0
                    }), n.for("upcast").elementToElement({
                        model: "softBreak",
                        view: "br"
                    }), n.for("downcast").elementToElement({
                        model: "softBreak",
                        view: (t, {
                            writer: e
                        }) => e.createEmptyElement("br")
                    }), o.addObserver(Qp), t.commands.add("shiftEnter", new Jp(t)), this.listenTo(i, "enter", ((e, n) => {
                        i.isComposing || n.preventDefault(), n.isSoft && (t.execute("shiftEnter"), o.scrollToTheSelection())
                    }), {
                        priority: "low"
                    })
                }
            }
            class nf extends(N()) {
                constructor() {
                    super(), this._stack = []
                }
                add(t, e) {
                    const n = this._stack,
                        o = n[0];
                    this._insertDescriptor(t);
                    const i = n[0];
                    o === i || of(o, i) || this.fire("change:top", {
                        oldDescriptor: o,
                        newDescriptor: i,
                        writer: e
                    })
                }
                remove(t, e) {
                    const n = this._stack,
                        o = n[0];
                    this._removeDescriptor(t);
                    const i = n[0];
                    o === i || of(o, i) || this.fire("change:top", {
                        oldDescriptor: o,
                        newDescriptor: i,
                        writer: e
                    })
                }
                _insertDescriptor(t) {
                    const e = this._stack,
                        n = e.findIndex((e => e.id === t.id));
                    if (of(t, e[n])) return;
                    n > -1 && e.splice(n, 1);
                    let o = 0;
                    for (; e[o] && rf(e[o], t);) o++;
                    e.splice(o, 0, t)
                }
                _removeDescriptor(t) {
                    const e = this._stack,
                        n = e.findIndex((e => e.id === t));
                    n > -1 && e.splice(n, 1)
                }
            }
    
            function of(t, e) {
                return t && e && t.priority == e.priority && sf(t.classes) == sf(e.classes)
            }
    
            function rf(t, e) {
                return t.priority > e.priority || !(t.priority < e.priority) && sf(t.classes) > sf(e.classes)
            }
    
            function sf(t) {
                return Array.isArray(t) ? t.sort().join(",") : t
            }
            const af = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',
                cf = "ck-widget",
                lf = "ck-widget_selected";
    
            function df(t) {
                return !!t.is("element") && !!t.getCustomProperty("widget")
            }
    
            function hf(t, e, n = {}) {
                if (!t.is("containerElement")) throw new A("widget-to-widget-wrong-element-type", null, {
                    element: t
                });
                return e.setAttribute("contenteditable", "false", t), e.addClass(cf, t), e.setCustomProperty("widget", !0, t), t.getFillerOffset = kf, e.setCustomProperty("widgetLabel", [], t), n.label && function(t, e) {
                    const n = t.getCustomProperty("widgetLabel");
                    n.push(e)
                }(t, n.label), n.hasSelectionHandle && function(t, e) {
                    const n = e.createUIElement("div", {
                        class: "ck ck-widget__selection-handle"
                    }, (function(t) {
                        const e = this.toDomElement(t),
                            n = new Jr;
                        return n.set("content", af), n.render(), e.appendChild(n.element), e
                    }));
                    e.insert(e.createPositionAt(t, 0), n), e.addClass(["ck-widget_with-selection-handle"], t)
                }(t, e), mf(t, e), t
            }
    
            function uf(t, e, n) {
                if (e.classes && n.addClass(ar(e.classes), t), e.attributes)
                    for (const o in e.attributes) n.setAttribute(o, e.attributes[o], t)
            }
    
            function gf(t, e, n) {
                if (e.classes && n.removeClass(ar(e.classes), t), e.attributes)
                    for (const o in e.attributes) n.removeAttribute(o, t)
            }
    
            function mf(t, e, n = uf, o = gf) {
                const i = new nf;
                i.on("change:top", ((e, i) => {
                    i.oldDescriptor && o(t, i.oldDescriptor, i.writer), i.newDescriptor && n(t, i.newDescriptor, i.writer)
                }));
                e.setCustomProperty("addHighlight", ((t, e, n) => i.add(e, n)), t), e.setCustomProperty("removeHighlight", ((t, e, n) => i.remove(e, n)), t)
            }
    
            function pf(t, e, n = {}) {
                return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t), e.setAttribute("role", "textbox", t), n.label && e.setAttribute("aria-label", n.label, t), e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t), t.on("change:isReadOnly", ((n, o, i) => {
                    e.setAttribute("contenteditable", i ? "false" : "true", t)
                })), t.on("change:isFocused", ((n, o, i) => {
                    i ? e.addClass("ck-editor__nested-editable_focused", t) : e.removeClass("ck-editor__nested-editable_focused", t)
                })), mf(t, e), t
            }
    
            function ff(t, e) {
                const n = t.getSelectedElement();
                if (n) {
                    const o = _f(t);
                    if (o) return e.createRange(e.createPositionAt(n, o))
                }
                return wg(t, e)
            }
    
            function kf() {
                return null
            }
            const bf = "widget-type-around";
    
            function wf(t, e, n) {
                return !!t && df(t) && !n.isInline(e)
            }
    
            function _f(t) {
                return t.getAttribute(bf)
            }
            var Af = n(4921),
                Cf = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Af.Z, Cf);
            Af.Z.locals;
            const vf = ["before", "after"],
                yf = (new DOMParser).parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild,
                xf = "ck-widget__type-around_disabled";
            class Ef extends vs {
                static get pluginName() {
                    return "WidgetTypeAround"
                }
                static get requires() {
                    return [Zp, xp]
                }
                constructor(t) {
                    super(t), this._currentFakeCaretModelElement = null
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view;
                    this.on("change:isEnabled", ((n, o, i) => {
                        e.change((t => {
                            for (const n of e.document.roots) i ? t.removeClass(xf, n) : t.addClass(xf, n)
                        })), i || t.model.change((t => {
                            t.removeSelectionAttribute(bf)
                        }))
                    })), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration()
                }
                destroy() {
                    super.destroy(), this._currentFakeCaretModelElement = null
                }
                _insertParagraph(t, e) {
                    const n = this.editor,
                        o = n.editing.view,
                        i = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", !0);
                    n.execute("insertParagraph", {
                        position: n.model.createPositionAt(t, e),
                        attributes: i
                    }), o.focus(), o.scrollToTheSelection()
                }
                _listenToIfEnabled(t, e, n, o) {
                    this.listenTo(t, e, ((...t) => {
                        this.isEnabled && n(...t)
                    }), o)
                }
                _insertParagraphAccordingToFakeCaretPosition() {
                    const t = this.editor.model.document.selection,
                        e = _f(t);
                    if (!e) return !1;
                    const n = t.getSelectedElement();
                    return this._insertParagraph(n, e), !0
                }
                _enableTypeAroundUIInjection() {
                    const t = this.editor,
                        e = t.model.schema,
                        n = t.locale.t,
                        o = {
                            before: n("Insert paragraph before block"),
                            after: n("Insert paragraph after block")
                        };
                    t.editing.downcastDispatcher.on("insert", ((t, i, r) => {
                        const s = r.mapper.toViewElement(i.item);
                        if (s && wf(s, i.item, e)) {
                            ! function(t, e, n) {
                                const o = t.createUIElement("div", {
                                    class: "ck ck-reset_all ck-widget__type-around"
                                }, (function(t) {
                                    const n = this.toDomElement(t);
                                    return function(t, e) {
                                            for (const n of vf) {
                                                const o = new Ir({
                                                    tag: "div",
                                                    attributes: {
                                                        class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`],
                                                        title: e[n],
                                                        "aria-hidden": "true"
                                                    },
                                                    children: [t.ownerDocument.importNode(yf, !0)]
                                                });
                                                t.appendChild(o.render())
                                            }
                                        }(n, e),
                                        function(t) {
                                            const e = new Ir({
                                                tag: "div",
                                                attributes: {
                                                    class: ["ck", "ck-widget__type-around__fake-caret"]
                                                }
                                            });
                                            t.appendChild(e.render())
                                        }(n), n
                                }));
                                t.insert(t.createPositionAt(n, "end"), o)
                            }(r.writer, o, s);
                            s.getCustomProperty("widgetLabel").push((() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
                        }
                    }), {
                        priority: "low"
                    })
                }
                _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                    const t = this.editor,
                        e = t.model,
                        n = e.document.selection,
                        o = e.schema,
                        i = t.editing.view;
    
                    function r(t) {
                        return `ck-widget_type-around_show-fake-caret_${t}`
                    }
                    this._listenToIfEnabled(i.document, "arrowKey", ((t, e) => {
                        this._handleArrowKeyPress(t, e)
                    }), {
                        context: [df, "$text"],
                        priority: "high"
                    }), this._listenToIfEnabled(n, "change:range", ((e, n) => {
                        n.directChange && t.model.change((t => {
                            t.removeSelectionAttribute(bf)
                        }))
                    })), this._listenToIfEnabled(e.document, "change:data", (() => {
                        const e = n.getSelectedElement();
                        if (e) {
                            if (wf(t.editing.mapper.toViewElement(e), e, o)) return
                        }
                        t.model.change((t => {
                            t.removeSelectionAttribute(bf)
                        }))
                    })), this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => {
                        const i = n.writer;
                        if (this._currentFakeCaretModelElement) {
                            const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                            t && (i.removeClass(vf.map(r), t), this._currentFakeCaretModelElement = null)
                        }
                        const s = e.selection.getSelectedElement();
                        if (!s) return;
                        const a = n.mapper.toViewElement(s);
                        if (!wf(a, s, o)) return;
                        const c = _f(e.selection);
                        c && (i.addClass(r(c), a), this._currentFakeCaretModelElement = s)
                    })), this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, o) => {
                        o || t.model.change((t => {
                            t.removeSelectionAttribute(bf)
                        }))
                    }))
                }
                _handleArrowKeyPress(t, e) {
                    const n = this.editor,
                        o = n.model,
                        i = o.document.selection,
                        r = o.schema,
                        s = n.editing.view,
                        a = function(t, e) {
                            const n = sr(t, e);
                            return "down" === n || "right" === n
                        }(e.keyCode, n.locale.contentLanguageDirection),
                        c = s.document.selection.getSelectedElement();
                    let l;
                    wf(c, n.editing.mapper.toModelElement(c), r) ? l = this._handleArrowKeyPressOnSelectedWidget(a) : i.isCollapsed ? l = this._handleArrowKeyPressWhenSelectionNextToAWidget(a) : e.shiftKey || (l = this._handleArrowKeyPressWhenNonCollapsedSelection(a)), l && (e.preventDefault(), t.stop())
                }
                _handleArrowKeyPressOnSelectedWidget(t) {
                    const e = this.editor.model,
                        n = _f(e.document.selection);
                    return e.change((e => {
                        if (!n) return e.setSelectionAttribute(bf, t ? "after" : "before"), !0;
                        if (!(n === (t ? "after" : "before"))) return e.removeSelectionAttribute(bf), !0;
                        return !1
                    }))
                }
                _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
                    const e = this.editor,
                        n = e.model,
                        o = n.schema,
                        i = e.plugins.get("Widget"),
                        r = i._getObjectElementNextToSelection(t);
                    return !!wf(e.editing.mapper.toViewElement(r), r, o) && (n.change((e => {
                        i._setSelectionOverElement(r), e.setSelectionAttribute(bf, t ? "before" : "after")
                    })), !0)
                }
                _handleArrowKeyPressWhenNonCollapsedSelection(t) {
                    const e = this.editor,
                        n = e.model,
                        o = n.schema,
                        i = e.editing.mapper,
                        r = n.document.selection,
                        s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter;
                    return !!wf(i.toViewElement(s), s, o) && (n.change((e => {
                        e.setSelection(s, "on"), e.setSelectionAttribute(bf, t ? "after" : "before")
                    })), !0)
                }
                _enableInsertingParagraphsOnButtonClick() {
                    const t = this.editor,
                        e = t.editing.view;
                    this._listenToIfEnabled(e.document, "mousedown", ((n, o) => {
                        const i = o.domTarget.closest(".ck-widget__type-around__button");
                        if (!i) return;
                        const r = function(t) {
                                return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
                            }(i),
                            s = function(t, e) {
                                const n = t.closest(".ck-widget");
                                return e.mapDomToView(n)
                            }(i, e.domConverter),
                            a = t.editing.mapper.toModelElement(s);
                        this._insertParagraph(a, r), o.preventDefault(), n.stop()
                    }))
                }
                _enableInsertingParagraphsOnEnterKeypress() {
                    const t = this.editor,
                        e = t.model.document.selection,
                        n = t.editing.view;
                    this._listenToIfEnabled(n.document, "enter", ((n, o) => {
                        if ("atTarget" != n.eventPhase) return;
                        const i = e.getSelectedElement(),
                            r = t.editing.mapper.toViewElement(i),
                            s = t.model.schema;
                        let a;
                        this._insertParagraphAccordingToFakeCaretPosition() ? a = !0 : wf(r, i, s) && (this._insertParagraph(i, o.isSoft ? "before" : "after"), a = !0), a && (o.preventDefault(), n.stop())
                    }), {
                        context: df
                    })
                }
                _enableInsertingParagraphsOnTypingKeystroke() {
                    const t = this.editor.editing.view.document;
                    this._listenToIfEnabled(t, "insertText", ((e, n) => {
                        this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = t.selection)
                    }), {
                        priority: "high"
                    }), a.isAndroid ? this._listenToIfEnabled(t, "keydown", ((t, e) => {
                        229 == e.keyCode && this._insertParagraphAccordingToFakeCaretPosition()
                    })) : this._listenToIfEnabled(t, "compositionstart", (() => {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }), {
                        priority: "high"
                    })
                }
                _enableDeleteIntegration() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = t.model,
                        o = n.schema;
                    this._listenToIfEnabled(e.document, "delete", ((e, i) => {
                        if ("atTarget" != e.eventPhase) return;
                        const r = _f(n.document.selection);
                        if (!r) return;
                        const s = i.direction,
                            a = n.document.selection.getSelectedElement(),
                            c = "forward" == s;
                        if ("before" === r === c) t.execute("delete", {
                            selection: n.createSelection(a, "on")
                        });
                        else {
                            const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s);
                            if (e)
                                if (e.isCollapsed) {
                                    const i = n.createSelection(e.start);
                                    if (n.modifySelection(i, {
                                            direction: s
                                        }), i.focus.isEqual(e.start)) {
                                        const t = function(t, e) {
                                            let n = e;
                                            for (const o of e.getAncestors({
                                                    parentFirst: !0
                                                })) {
                                                if (o.childCount > 1 || t.isLimit(o)) break;
                                                n = o
                                            }
                                            return n
                                        }(o, e.start.parent);
                                        n.deleteContent(n.createSelection(t, "on"), {
                                            doNotAutoparagraph: !0
                                        })
                                    } else n.change((n => {
                                        n.setSelection(e), t.execute(c ? "deleteForward" : "delete")
                                    }))
                                } else n.change((n => {
                                    n.setSelection(e), t.execute(c ? "deleteForward" : "delete")
                                }))
                        }
                        i.preventDefault(), e.stop()
                    }), {
                        context: df
                    })
                }
                _enableInsertContentIntegration() {
                    const t = this.editor,
                        e = this.editor.model,
                        n = e.document.selection;
                    this._listenToIfEnabled(t.model, "insertContent", ((t, [o, i]) => {
                        if (i && !i.is("documentSelection")) return;
                        const r = _f(n);
                        return r ? (t.stop(), e.change((t => {
                            const i = n.getSelectedElement(),
                                s = e.createPositionAt(i, r),
                                a = t.createSelection(s),
                                c = e.insertContent(o, a);
                            return t.setSelection(a), c
                        }))) : void 0
                    }), {
                        priority: "high"
                    })
                }
                _enableInsertObjectIntegration() {
                    const t = this.editor,
                        e = this.editor.model.document.selection;
                    this._listenToIfEnabled(t.model, "insertObject", ((t, n) => {
                        const [, o, , i = {}] = n;
                        if (o && !o.is("documentSelection")) return;
                        const r = _f(e);
                        r && (i.findOptimalPosition = r, n[3] = i)
                    }), {
                        priority: "high"
                    })
                }
                _enableDeleteContentIntegration() {
                    const t = this.editor,
                        e = this.editor.model.document.selection;
                    this._listenToIfEnabled(t.model, "deleteContent", ((t, [n]) => {
                        if (n && !n.is("documentSelection")) return;
                        _f(e) && t.stop()
                    }), {
                        priority: "high"
                    })
                }
            }
    
            function Df(t) {
                const e = t.model;
                return (n, o) => {
                    const i = o.keyCode == er.arrowup,
                        r = o.keyCode == er.arrowdown,
                        s = o.shiftKey,
                        a = e.document.selection;
                    if (!i && !r) return;
                    const c = r;
                    if (s && function(t, e) {
                            return !t.isCollapsed && t.isBackward == e
                        }(a, c)) return;
                    const l = function(t, e, n) {
                        const o = t.model;
                        if (n) {
                            const t = e.isCollapsed ? e.focus : e.getLastPosition(),
                                n = If(o, t, "forward");
                            if (!n) return null;
                            const i = o.createRange(t, n),
                                r = Tf(o.schema, i, "backward");
                            return r ? o.createRange(t, r) : null
                        } {
                            const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
                                n = If(o, t, "backward");
                            if (!n) return null;
                            const i = o.createRange(n, t),
                                r = Tf(o.schema, i, "forward");
                            return r ? o.createRange(r, t) : null
                        }
                    }(t, a, c);
                    if (l) {
                        if (l.isCollapsed) {
                            if (a.isCollapsed) return;
                            if (s) return
                        }(l.isCollapsed || function(t, e, n) {
                            const o = t.model,
                                i = t.view.domConverter;
                            if (n) {
                                const t = o.createSelection(e.start);
                                o.modifySelection(t), t.focus.isAtEnd || e.start.isEqual(t.focus) || (e = o.createRange(t.focus, e.end))
                            }
                            const r = t.mapper.toViewRange(e),
                                s = i.viewRangeToDom(r),
                                a = Ti.getDomRangeRects(s);
                            let c;
                            for (const t of a)
                                if (void 0 !== c) {
                                    if (Math.round(t.top) >= c) return !1;
                                    c = Math.max(c, Math.round(t.bottom))
                                } else c = Math.round(t.bottom);
                            return !0
                        }(t, l, c)) && (e.change((t => {
                            const n = c ? l.end : l.start;
                            if (s) {
                                const o = e.createSelection(a.anchor);
                                o.setFocus(n), t.setSelection(o)
                            } else t.setSelection(n)
                        })), n.stop(), o.preventDefault(), o.stopPropagation())
                    }
                }
            }
    
            function If(t, e, n) {
                const o = t.schema,
                    i = t.createRangeIn(e.root),
                    r = "forward" == n ? "elementStart" : "elementEnd";
                for (const {
                        previousPosition: t,
                        item: s,
                        type: a
                    }
                    of i.getWalker({
                        startPosition: e,
                        direction: n
                    })) {
                    if (o.isLimit(s) && !o.isInline(s)) return t;
                    if (a == r && o.isBlock(s)) return null
                }
                return null
            }
    
            function Tf(t, e, n) {
                const o = "backward" == n ? e.end : e.start;
                if (t.checkChild(o, "$text")) return o;
                for (const {
                        nextPosition: o
                    }
                    of e.getWalker({
                        direction: n
                    }))
                    if (t.checkChild(o, "$text")) return o;
                return null
            }
            var Mf = n(3488),
                Sf = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Mf.Z, Sf);
            Mf.Z.locals;
            class Nf extends vs {
                static get pluginName() {
                    return "Widget"
                }
                static get requires() {
                    return [Ef, xp]
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = e.document;
                    this._previouslySelected = new Set, this.editor.editing.downcastDispatcher.on("selection", ((e, n, o) => {
                        const i = o.writer,
                            r = n.selection;
                        if (r.isCollapsed) return;
                        const s = r.getSelectedElement();
                        if (!s) return;
                        const a = t.editing.mapper.toViewElement(s);
                        var c;
                        df(a) && (o.consumable.consume(r, "selection") && i.setSelection(i.createRangeOn(a), {
                            fake: !0,
                            label: (c = a, c.getCustomProperty("widgetLabel").reduce(((t, e) => "function" == typeof e ? t ? t + ". " + e() : e() : t ? t + ". " + e : e), ""))
                        }))
                    })), this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => {
                        this._clearPreviouslySelectedWidgets(n.writer);
                        const o = n.writer,
                            i = o.document.selection;
                        let r = null;
                        for (const t of i.getRanges())
                            for (const e of t) {
                                const t = e.item;
                                df(t) && !Bf(t, r) && (o.addClass(lf, t), this._previouslySelected.add(t), r = t)
                            }
                    }), {
                        priority: "low"
                    }), e.addObserver(Ig), this.listenTo(n, "mousedown", ((...t) => this._onMousedown(...t))), this.listenTo(n, "arrowKey", ((...t) => {
                        this._handleSelectionChangeOnArrowKeyPress(...t)
                    }), {
                        context: [df, "$text"]
                    }), this.listenTo(n, "arrowKey", ((...t) => {
                        this._preventDefaultOnArrowKeyPress(...t)
                    }), {
                        context: "$root"
                    }), this.listenTo(n, "arrowKey", Df(this.editor.editing), {
                        context: "$text"
                    }), this.listenTo(n, "delete", ((t, e) => {
                        this._handleDelete("forward" == e.direction) && (e.preventDefault(), t.stop())
                    }), {
                        context: "$root"
                    })
                }
                _onMousedown(t, e) {
                    const n = this.editor,
                        o = n.editing.view,
                        i = o.document;
                    let r = e.target;
                    if (function(t) {
                            let e = t;
                            for (; e;) {
                                if (e.is("editableElement") && !e.is("rootElement")) return !0;
                                if (df(e)) return !1;
                                e = e.parent
                            }
                            return !1
                        }(r)) {
                        if ((a.isSafari || a.isGecko) && e.domEvent.detail >= 3) {
                            const t = n.editing.mapper,
                                o = r.is("attributeElement") ? r.findAncestor((t => !t.is("attributeElement"))) : r,
                                i = t.toModelElement(o);
                            e.preventDefault(), this.editor.model.change((t => {
                                t.setSelection(i, "in")
                            }))
                        }
                        return
                    }
                    if (!df(r) && (r = r.findAncestor(df), !r)) return;
                    a.isAndroid && e.preventDefault(), i.isFocused || o.focus();
                    const s = n.editing.mapper.toModelElement(r);
                    this._setSelectionOverElement(s)
                }
                _handleSelectionChangeOnArrowKeyPress(t, e) {
                    const n = e.keyCode,
                        o = this.editor.model,
                        i = o.schema,
                        r = o.document.selection,
                        s = r.getSelectedElement(),
                        a = sr(n, this.editor.locale.contentLanguageDirection),
                        c = "down" == a || "right" == a,
                        l = "up" == a || "down" == a;
                    if (s && i.isObject(s)) {
                        const n = c ? r.getLastPosition() : r.getFirstPosition(),
                            s = i.getNearestSelectionRange(n, c ? "forward" : "backward");
                        return void(s && (o.change((t => {
                            t.setSelection(s)
                        })), e.preventDefault(), t.stop()))
                    }
                    if (!r.isCollapsed && !e.shiftKey) {
                        const n = r.getFirstPosition(),
                            s = r.getLastPosition(),
                            a = n.nodeAfter,
                            l = s.nodeBefore;
                        return void((a && i.isObject(a) || l && i.isObject(l)) && (o.change((t => {
                            t.setSelection(c ? s : n)
                        })), e.preventDefault(), t.stop()))
                    }
                    if (!r.isCollapsed) return;
                    const d = this._getObjectElementNextToSelection(c);
                    if (d && i.isObject(d)) {
                        if (i.isInline(d) && l) return;
                        this._setSelectionOverElement(d), e.preventDefault(), t.stop()
                    }
                }
                _preventDefaultOnArrowKeyPress(t, e) {
                    const n = this.editor.model,
                        o = n.schema,
                        i = n.document.selection.getSelectedElement();
                    i && o.isObject(i) && (e.preventDefault(), t.stop())
                }
                _handleDelete(t) {
                    if (this.editor.isReadOnly) return;
                    const e = this.editor.model.document.selection;
                    if (!e.isCollapsed) return;
                    const n = this._getObjectElementNextToSelection(t);
                    return n ? (this.editor.model.change((t => {
                        let o = e.anchor.parent;
                        for (; o.isEmpty;) {
                            const e = o;
                            o = e.parent, t.remove(e)
                        }
                        this._setSelectionOverElement(n)
                    })), !0) : void 0
                }
                _setSelectionOverElement(t) {
                    this.editor.model.change((e => {
                        e.setSelection(e.createRangeOn(t))
                    }))
                }
                _getObjectElementNextToSelection(t) {
                    const e = this.editor.model,
                        n = e.schema,
                        o = e.document.selection,
                        i = e.createSelection(o);
                    if (e.modifySelection(i, {
                            direction: t ? "forward" : "backward"
                        }), i.isEqual(o)) return null;
                    const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
                    return r && n.isObject(r) ? r : null
                }
                _clearPreviouslySelectedWidgets(t) {
                    for (const e of this._previouslySelected) t.removeClass(lf, e);
                    this._previouslySelected.clear()
                }
            }
    
            function Bf(t, e) {
                return !!e && Array.from(t.getAncestors()).includes(e)
            }
            class Pf extends vs {
                static get requires() {
                    return [Gm]
                }
                static get pluginName() {
                    return "WidgetToolbarRepository"
                }
                init() {
                    const t = this.editor;
                    if (t.plugins.has("BalloonToolbar")) {
                        const e = t.plugins.get("BalloonToolbar");
                        this.listenTo(e, "show", (e => {
                            (function(t) {
                                const e = t.getSelectedElement();
                                return !(!e || !df(e))
                            })(t.editing.view.document.selection) && e.stop()
                        }), {
                            priority: "high"
                        })
                    }
                    this._toolbarDefinitions = new Map, this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", (() => {
                        this._updateToolbarsVisibility()
                    })), this.listenTo(t.ui, "update", (() => {
                        this._updateToolbarsVisibility()
                    })), this.listenTo(t.ui.focusTracker, "change:isFocused", (() => {
                        this._updateToolbarsVisibility()
                    }), {
                        priority: "low"
                    })
                }
                destroy() {
                    super.destroy();
                    for (const t of this._toolbarDefinitions.values()) t.view.destroy()
                }
                register(t, {
                    ariaLabel: e,
                    items: n,
                    getRelatedElement: o,
                    balloonClassName: i = "ck-toolbar-container"
                }) {
                    if (!n.length) return void C("widget-toolbar-no-items", {
                        toolbarId: t
                    });
                    const r = this.editor,
                        s = r.t,
                        a = new Vg(r.locale);
                    if (a.ariaLabel = e || s("Widget toolbar"), this._toolbarDefinitions.has(t)) throw new A("widget-toolbar-duplicated", this, {
                        toolbarId: t
                    });
                    const c = {
                        view: a,
                        getRelatedElement: o,
                        balloonClassName: i,
                        itemsConfig: n,
                        initialized: !1
                    };
                    r.ui.addToolbar(a, {
                        isContextual: !0,
                        beforeFocus: () => {
                            const t = o(r.editing.view.document.selection);
                            t && this._showToolbar(c, t)
                        },
                        afterBlur: () => {
                            this._hideToolbar(c)
                        }
                    }), this._toolbarDefinitions.set(t, c)
                }
                _updateToolbarsVisibility() {
                    let t = 0,
                        e = null,
                        n = null;
                    for (const o of this._toolbarDefinitions.values()) {
                        const i = o.getRelatedElement(this.editor.editing.view.document.selection);
                        if (this.isEnabled && i)
                            if (this.editor.ui.focusTracker.isFocused) {
                                const r = i.getAncestors().length;
                                r > t && (t = r, e = i, n = o)
                            } else this._isToolbarVisible(o) && this._hideToolbar(o);
                        else this._isToolbarInBalloon(o) && this._hideToolbar(o)
                    }
                    n && this._showToolbar(n, e)
                }
                _hideToolbar(t) {
                    this._balloon.remove(t.view), this.stopListening(this._balloon, "change:visibleView")
                }
                _showToolbar(t, e) {
                    this._isToolbarVisible(t) ? zf(this.editor, e) : this._isToolbarInBalloon(t) || (t.initialized || (t.initialized = !0, t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
                        view: t.view,
                        position: Lf(this.editor, e),
                        balloonClassName: t.balloonClassName
                    }), this.listenTo(this._balloon, "change:visibleView", (() => {
                        for (const t of this._toolbarDefinitions.values())
                            if (this._isToolbarVisible(t)) {
                                const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                                zf(this.editor, e)
                            }
                    })))
                }
                _isToolbarVisible(t) {
                    return this._balloon.visibleView === t.view
                }
                _isToolbarInBalloon(t) {
                    return this._balloon.hasView(t.view)
                }
            }
    
            function zf(t, e) {
                const n = t.plugins.get("ContextualBalloon"),
                    o = Lf(t, e);
                n.updatePosition(o)
            }
    
            function Lf(t, e) {
                const n = t.editing.view,
                    o = dm.defaultPositions;
                return {
                    target: n.domConverter.mapViewToDom(e),
                    positions: [o.northArrowSouth, o.northArrowSouthWest, o.northArrowSouthEast, o.southArrowNorth, o.southArrowNorthWest, o.southArrowNorthEast, o.viewportStickyNorth]
                }
            }
            class Of extends($()) {
                constructor(t) {
                    super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = t, this._referenceCoordinates = null
                }
                get originalWidth() {
                    return this._originalWidth
                }
                get originalHeight() {
                    return this._originalHeight
                }
                get originalWidthPercents() {
                    return this._originalWidthPercents
                }
                get aspectRatio() {
                    return this._aspectRatio
                }
                begin(t, e, n) {
                    const o = new Rect(e);
                    this.activeHandlePosition = function(t) {
                        const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                        for (const n of e)
                            if (t.classList.contains(getResizerHandleClass(n))) return n
                    }(t), this._referenceCoordinates = function(t, e) {
                        const n = new Rect(t),
                            o = e.split("-"),
                            i = {
                                x: "right" == o[1] ? n.right : n.left,
                                y: "bottom" == o[0] ? n.bottom : n.top
                            };
                        return i.x += t.ownerDocument.defaultView.scrollX, i.y += t.ownerDocument.defaultView.scrollY, i
                    }(e, function(t) {
                        const e = t.split("-"),
                            n = {
                                top: "bottom",
                                bottom: "top",
                                left: "right",
                                right: "left"
                            };
                        return `${n[e[0]]}-${n[e[1]]}`
                    }(this.activeHandlePosition)), this._originalWidth = o.width, this._originalHeight = o.height, this._aspectRatio = o.width / o.height;
                    const i = n.style.width;
                    i && i.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(i) : this._originalWidthPercents = function(t, e) {
                        const n = t.parentElement,
                            o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
                        return e.width / o * 100
                    }(n, o)
                }
                update(t) {
                    this.proposedWidth = t.width, this.proposedHeight = t.height, this.proposedWidthPercents = t.widthPercents, this.proposedHandleHostWidth = t.handleHostWidth, this.proposedHandleHostHeight = t.handleHostHeight
                }
            }
            class Rf extends($()) {
                constructor(t) {
                    super(), this._options = t, this._viewResizerWrapper = null, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", ((t, e) => t && e)), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t => {
                        this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t.stop())
                    }), {
                        priority: "high"
                    })
                }
                get state() {
                    return this._state
                }
                show() {
                    this._options.editor.editing.view.change((t => {
                        t.removeClass("ck-hidden", this._viewResizerWrapper)
                    }))
                }
                hide() {
                    this._options.editor.editing.view.change((t => {
                        t.addClass("ck-hidden", this._viewResizerWrapper)
                    }))
                }
                attach() {
                    const t = this,
                        e = this._options.viewElement;
                    this._options.editor.editing.view.change((n => {
                        const o = n.createUIElement("div", {
                            class: "ck ck-reset_all ck-widget__resizer"
                        }, (function(e) {
                            const n = this.toDomElement(e);
                            return t._appendHandles(n), t._appendSizeUI(n), n
                        }));
                        n.insert(n.createPositionAt(e, "end"), o), n.addClass("ck-widget_with-resizer", e), this._viewResizerWrapper = o, this.isVisible || this.hide()
                    })), this.on("change:isVisible", (() => {
                        this.isVisible ? (this.show(), this.redraw()) : this.hide()
                    }))
                }
                begin(t) {
                    this._state = new ResizeState(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(t, this._getHandleHost(), this._getResizeHost())
                }
                updateSize(t) {
                    const e = this._proposeNewSize(t);
                    this._options.editor.editing.view.change((t => {
                        const n = this._options.unit || "%",
                            o = ("%" === n ? e.widthPercents : e.width) + n;
                        t.setStyle("width", o, this._options.viewElement)
                    }));
                    const n = this._getHandleHost(),
                        o = new Rect(n),
                        i = Math.round(o.width),
                        r = Math.round(o.height),
                        s = new Rect(n);
                    e.width = Math.round(s.width), e.height = Math.round(s.height), this.redraw(o), this.state.update({
                        ...e,
                        handleHostWidth: i,
                        handleHostHeight: r
                    })
                }
                commit() {
                    const t = this._options.unit || "%",
                        e = ("%" === t ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
                    this._options.editor.editing.view.change((() => {
                        this._cleanup(), this._options.onCommit(e)
                    }))
                }
                cancel() {
                    this._cleanup()
                }
                destroy() {
                    this.cancel()
                }
                redraw(t) {
                    const e = this._domResizerWrapper;
                    if (!(e && n.ownerDocument && n.ownerDocument.contains(n))) return;
                    var n;
                    const o = e.parentElement,
                        i = this._getHandleHost(),
                        r = this._viewResizerWrapper,
                        s = [r.getStyle("width"), r.getStyle("height"), r.getStyle("left"), r.getStyle("top")];
                    let a;
                    if (o.isSameNode(i)) {
                        const e = t || new Rect(i);
                        [e.width + "px", e.height + "px", void 0, void 0]
                    } else [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"];
                    "same" !== compareArrays(s, a) && this._options.editor.editing.view.change((t => {
                        t.setStyle({
                            width: a[0],
                            height: a[1],
                            left: a[2],
                            top: a[3]
                        }, r)
                    }))
                }
                containsHandle(t) {
                    return this._domResizerWrapper.contains(t)
                }
                static isResizeHandle(t) {
                    return t.classList.contains("ck-widget__resizer__handle")
                }
                _cleanup() {
                    this._sizeView._dismiss();
                    this._options.editor.editing.view.change((t => {
                        t.setStyle("width", this._initialViewWidth, this._options.viewElement)
                    }))
                }
                _proposeNewSize(t) {
                    const e = this.state,
                        n = {
                            x: t.pageX,
                            y: o.pageY
                        };
                    var o;
                    const i = !this._options.isCentered || this._options.isCentered(this),
                        r = {
                            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                            y: n.y - e.originalHeight - e._referenceCoordinates.y
                        };
                    i && e.activeHandlePosition.endsWith("-right") && (r.x = n.x - (e._referenceCoordinates.x + e.originalWidth)), i && (r.x *= 2);
                    let s = Math.abs(e.originalWidth + r.x),
                        a = Math.abs(e.originalHeight + r.y);
                    return "width" == (s / e.aspectRatio > a ? "width" : "height") ? s / e.aspectRatio : a * e.aspectRatio, {
                        width: Math.round(s),
                        height: Math.round(a),
                        widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * s * 100) / 100, 100)
                    }
                }
                _getResizeHost() {
                    const t = this._domResizerWrapper.parentElement;
                    return this._options.getResizeHost(t)
                }
                _getHandleHost() {
                    const t = this._domResizerWrapper.parentElement;
                    return this._options.getHandleHost(t)
                }
                get _domResizerWrapper() {
                    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper)
                }
                _appendHandles(t) {
                    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                    for (const o of e) t.appendChild(new Template({
                        tag: "div",
                        attributes: {
                            class: "ck-widget__resizer__handle " + (o, `ck-widget__resizer__handle-${n}`)
                        }
                    }).render());
                    var n
                }
                _appendSizeUI(t) {
                    this._sizeView = new SizeView, this._sizeView.render(), t.appendChild(this._sizeView.element)
                }
            }
            var jf = n(8506),
                Ff = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(jf.Z, Ff);
            jf.Z.locals;
            var Vf = "Expected a function";
            const Hf = function(t, e, n) {
                var o = !0,
                    i = !0;
                if ("function" != typeof t) throw new TypeError(Vf);
                return F(n) && (o = "leading" in n ? !!n.leading : o, i = "trailing" in n ? !!n.trailing : i), Sl(t, e, {
                    leading: o,
                    maxWait: e,
                    trailing: i
                })
            };
            var Uf = n(903),
                Wf = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Uf.Z, Wf);
            Uf.Z.locals;
            class qf extends vs {
                static get pluginName() {
                    return "DragDrop"
                }
                static get requires() {
                    return [hp, Nf]
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view;
                    this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = Hf((t => this._updateDropMarker(t)), 40), this._removeDropMarkerDelayed = Yf((() => this._removeDropMarker()), 40), this._clearDraggableAttributesDelayed = Yf((() => this._clearDraggableAttributes()), 40), e.addObserver(cp), e.addObserver(Ig), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                        n ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
                    })), this.on("change:isEnabled", ((t, e, n) => {
                        n || this._finalizeDragging(!1)
                    })), a.isAndroid && this.forceDisabled("noAndroidSupport")
                }
                destroy() {
                    return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy()
                }
                _setupDragging() {
                    const t = this.editor,
                        e = t.model,
                        n = e.document,
                        o = t.editing.view,
                        i = o.document;
                    this.listenTo(i, "dragstart", ((o, r) => {
                        const s = n.selection;
                        if (r.target && r.target.is("editableElement")) return void r.preventDefault();
                        const a = r.target ? Kf(r.target) : null;
                        if (a) {
                            const n = t.editing.mapper.toModelElement(a);
                            this._draggedRange = eh.fromRange(e.createRangeOn(n)), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop")
                        } else if (!i.selection.isCollapsed) {
                            const t = i.selection.getSelectedElement();
                            t && df(t) || (this._draggedRange = eh.fromRange(s.getFirstRange()))
                        }
                        if (!this._draggedRange) return void r.preventDefault();
                        this._draggingUid = k(), r.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", r.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                        const c = e.createSelection(this._draggedRange.toRange()),
                            l = t.data.toView(e.getSelectedContent(c));
                        i.fire("clipboardOutput", {
                            dataTransfer: r.dataTransfer,
                            content: l,
                            method: "dragstart"
                        }), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "")
                    }), {
                        priority: "low"
                    }), this.listenTo(i, "dragend", ((t, e) => {
                        this._finalizeDragging(!e.dataTransfer.isCanceled && "move" == e.dataTransfer.dropEffect)
                    }), {
                        priority: "low"
                    }), this.listenTo(i, "dragenter", (() => {
                        this.isEnabled && o.focus()
                    })), this.listenTo(i, "dragleave", (() => {
                        this._removeDropMarkerDelayed()
                    })), this.listenTo(i, "dragging", ((e, n) => {
                        if (!this.isEnabled) return void(n.dataTransfer.dropEffect = "none");
                        this._removeDropMarkerDelayed.cancel();
                        const o = Gf(t, n.targetRanges, n.target);
                        this._draggedRange || (n.dataTransfer.dropEffect = "copy"), a.isGecko || ("copy" == n.dataTransfer.effectAllowed ? n.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(n.dataTransfer.effectAllowed) && (n.dataTransfer.dropEffect = "move")), o && this._updateDropMarkerThrottled(o)
                    }), {
                        priority: "low"
                    })
                }
                _setupClipboardInputIntegration() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    this.listenTo(e, "clipboardInput", ((e, n) => {
                        if ("drop" != n.method) return;
                        const o = Gf(t, n.targetRanges, n.target);
                        if (this._removeDropMarker(), !o) return this._finalizeDragging(!1), void e.stop();
                        this._draggedRange && this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
                        if ("move" == $f(n.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(o, !0)) return this._finalizeDragging(!1), void e.stop();
                        n.targetRanges = [t.editing.mapper.toViewRange(o)]
                    }), {
                        priority: "high"
                    })
                }
                _setupContentInsertionIntegration() {
                    const t = this.editor.plugins.get(hp);
                    t.on("contentInsertion", ((t, e) => {
                        if (!this.isEnabled || "drop" !== e.method) return;
                        const n = e.targetRanges.map((t => this.editor.editing.mapper.toModelRange(t)));
                        this.editor.model.change((t => t.setSelection(n)))
                    }), {
                        priority: "high"
                    }), t.on("contentInsertion", ((t, e) => {
                        if (!this.isEnabled || "drop" !== e.method) return;
                        const n = "move" == $f(e.dataTransfer),
                            o = !e.resultRange || !e.resultRange.isCollapsed;
                        this._finalizeDragging(o && n)
                    }), {
                        priority: "lowest"
                    })
                }
                _setupDraggableAttributeHandling() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = e.document;
                    this.listenTo(n, "mousedown", ((o, i) => {
                        if (a.isAndroid || !i) return;
                        this._clearDraggableAttributesDelayed.cancel();
                        let r = Kf(i.target);
                        if (a.isBlink && !t.isReadOnly && !r && !n.selection.isCollapsed) {
                            const t = n.selection.getSelectedElement();
                            t && df(t) || (r = n.selection.editableElement)
                        }
                        r && (e.change((t => {
                            t.setAttribute("draggable", "true", r)
                        })), this._draggableElement = t.editing.mapper.toModelElement(r))
                    })), this.listenTo(n, "mouseup", (() => {
                        a.isAndroid || this._clearDraggableAttributesDelayed()
                    }))
                }
                _clearDraggableAttributes() {
                    const t = this.editor.editing;
                    t.view.change((e => {
                        this._draggableElement && "$graveyard" != this._draggableElement.root.rootName && e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement)), this._draggableElement = null
                    }))
                }
                _setupDropMarker() {
                    const t = this.editor;
                    t.conversion.for("editingDowncast").markerToHighlight({
                        model: "drop-target",
                        view: {
                            classes: ["ck-clipboard-drop-target-range"]
                        }
                    }), t.conversion.for("editingDowncast").markerToElement({
                        model: "drop-target",
                        view: (e, {
                            writer: n
                        }) => {
                            if (t.model.schema.checkChild(e.markerRange.start, "$text")) return n.createUIElement("span", {
                                class: "ck ck-clipboard-drop-target-position"
                            }, (function(t) {
                                const e = this.toDomElement(t);
                                return e.append("", t.createElement("span"), ""), e
                            }))
                        }
                    })
                }
                _updateDropMarker(t) {
                    const e = this.editor,
                        n = e.model.markers;
                    e.model.change((e => {
                        n.has("drop-target") ? n.get("drop-target").getRange().isEqual(t) || e.updateMarker("drop-target", {
                            range: t
                        }) : e.addMarker("drop-target", {
                            range: t,
                            usingOperation: !1,
                            affectsData: !1
                        })
                    }))
                }
                _removeDropMarker() {
                    const t = this.editor.model;
                    this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), t.markers.has("drop-target") && t.change((t => {
                        t.removeMarker("drop-target")
                    }))
                }
                _finalizeDragging(t) {
                    const e = this.editor,
                        n = e.model;
                    this._removeDropMarker(), this._clearDraggableAttributes(), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (t && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), {
                        doNotAutoparagraph: !0
                    }), this._draggedRange.detach(), this._draggedRange = null)
                }
            }
    
            function Gf(t, e, n) {
                const o = t.model,
                    i = t.editing.mapper;
                let r = null;
                const s = e ? e[0].start : null;
                if (n.is("uiElement") && (n = n.parent), r = function(t, e) {
                        const n = t.model,
                            o = t.editing.mapper;
                        if (df(e)) return n.createRangeOn(o.toModelElement(e));
                        if (!e.is("editableElement")) {
                            const t = e.findAncestor((t => df(t) || t.is("editableElement")));
                            if (df(t)) return n.createRangeOn(o.toModelElement(t))
                        }
                        return null
                    }(t, n), r) return r;
                const c = function(t, e) {
                        const n = t.editing.mapper,
                            o = t.editing.view,
                            i = n.toModelElement(e);
                        if (i) return i;
                        const r = o.createPositionBefore(e),
                            s = n.findMappedViewAncestor(r);
                        return n.toModelElement(s)
                    }(t, n),
                    l = s ? i.toModelPosition(s) : null;
                return l ? (r = function(t, e, n) {
                    const o = t.model;
                    if (!o.schema.checkChild(n, "$block")) return null;
                    const i = o.createPositionAt(n, 0),
                        r = e.path.slice(0, i.path.length),
                        s = o.createPositionFromPath(e.root, r),
                        a = s.nodeAfter;
                    if (a && o.schema.isObject(a)) return o.createRangeOn(a);
                    return null
                }(t, l, c), r || (r = o.schema.getNearestSelectionRange(l, a.isGecko ? "forward" : "backward"), r || function(t, e) {
                    const n = t.model;
                    let o = e;
                    for (; o;) {
                        if (n.schema.isObject(o)) return n.createRangeOn(o);
                        o = o.parent
                    }
                    return null
                }(t, l.parent))) : function(t, e) {
                    const n = t.model,
                        o = n.schema,
                        i = n.createPositionAt(e, 0);
                    return o.getNearestSelectionRange(i, "forward")
                }(t, c)
            }
    
            function $f(t) {
                return a.isGecko ? t.dropEffect : ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy"
            }
    
            function Yf(t, e) {
                let n;
    
                function o(...i) {
                    o.cancel(), n = setTimeout((() => t(...i)), e)
                }
                return o.cancel = () => {
                    clearTimeout(n)
                }, o
            }
    
            function Kf(t) {
                if (t.is("editableElement")) return null;
                if (t.hasClass("ck-widget__selection-handle")) return t.findAncestor(df);
                if (df(t)) return t;
                const e = t.findAncestor((t => df(t) || t.is("editableElement")));
                return df(e) ? e : null
            }
            class Qf extends vs {
                static get pluginName() {
                    return "PastePlainText"
                }
                static get requires() {
                    return [hp]
                }
                init() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = n.document,
                        i = e.document.selection;
                    let r = !1;
                    n.addObserver(cp), this.listenTo(o, "keydown", ((t, e) => {
                        r = e.shiftKey
                    })), t.plugins.get(hp).on("contentInsertion", ((t, n) => {
                        (r || function(t, e) {
                            if (t.childCount > 1) return !1;
                            const n = t.getChild(0);
                            if (e.isObject(n)) return !1;
                            return 0 == Array.from(n.getAttributeKeys()).length
                        }(n.content, e.schema)) && e.change((t => {
                            const o = Array.from(i.getAttributes()).filter((([t]) => e.schema.getAttributeProperties(t).isFormatting));
                            i.isCollapsed || e.deleteContent(i, {
                                doNotAutoparagraph: !0
                            }), o.push(...i.getAttributes());
                            const r = t.createRangeIn(n.content);
                            for (const e of r.getItems()) e.is("$textProxy") && t.setAttributes(o, e)
                        }))
                    }))
                }
            }
            class Zf extends vs {
                static get pluginName() {
                    return "Clipboard"
                }
                static get requires() {
                    return [hp, qf, Qf]
                }
            }
            class Jf extends xs {
                constructor(t) {
                    super(t), this.affectsData = !1
                }
                execute() {
                    const t = this.editor.model,
                        e = t.document.selection;
                    let n = t.schema.getLimitElement(e);
                    if (e.containsEntireContent(n) || !Xf(t.schema, n))
                        do {
                            if (n = n.parent, !n) return
                        } while (!Xf(t.schema, n));
                    t.change((t => {
                        t.setSelection(n, "in")
                    }))
                }
            }
    
            function Xf(t, e) {
                return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
            }
            const tk = ir("Ctrl+A");
            class ek extends vs {
                static get pluginName() {
                    return "SelectAllEditing"
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    t.commands.add("selectAll", new Jf(t)), this.listenTo(e, "keydown", ((e, n) => {
                        or(n) === tk && (t.execute("selectAll"), n.preventDefault())
                    }))
                }
            }
            class nk extends vs {
                static get pluginName() {
                    return "SelectAllUI"
                }
                init() {
                    const t = this.editor;
                    t.ui.componentFactory.add("selectAll", (e => {
                        const n = t.commands.get("selectAll"),
                            o = new es(e),
                            i = e.t;
                        return o.set({
                            label: i("Select all"),
                            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                            keystroke: "Ctrl+A",
                            tooltip: !0
                        }), o.bind("isEnabled").to(n, "isEnabled"), this.listenTo(o, "execute", (() => {
                            t.execute("selectAll"), t.editing.view.focus()
                        })), o
                    }))
                }
            }
            class ok extends vs {
                static get requires() {
                    return [ek, nk]
                }
                static get pluginName() {
                    return "SelectAll"
                }
            }
            class ik extends xs {
                constructor(t) {
                    super(t), this._stack = [], this._createdBatches = new WeakSet, this.refresh(), this.listenTo(t.data, "set", ((t, e) => {
                        e[1] = {
                            ...e[1]
                        };
                        const n = e[1];
                        n.batchType || (n.batchType = {
                            isUndoable: !1
                        })
                    }), {
                        priority: "high"
                    }), this.listenTo(t.data, "set", ((t, e) => {
                        e[1].batchType.isUndoable || this.clearStack()
                    }))
                }
                refresh() {
                    this.isEnabled = this._stack.length > 0
                }
                addBatch(t) {
                    const e = this.editor.model.document.selection,
                        n = {
                            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
                            isBackward: e.isBackward
                        };
                    this._stack.push({
                        batch: t,
                        selection: n
                    }), this.refresh()
                }
                clearStack() {
                    this._stack = [], this.refresh()
                }
                _restoreSelection(t, e, n) {
                    const o = this.editor.model,
                        i = o.document,
                        r = [],
                        s = t.map((t => t.getTransformedByOperations(n))),
                        a = s.flat();
                    for (const t of s) {
                        const e = t.filter((t => t.root != i.graveyard)).filter((t => !sk(t, a)));
                        e.length && (rk(e), r.push(e[0]))
                    }
                    r.length && o.change((t => {
                        t.setSelection(r, {
                            backward: e
                        })
                    }))
                }
                _undo(t, e) {
                    const n = this.editor.model,
                        o = n.document;
                    this._createdBatches.add(e);
                    const i = t.operations.slice().filter((t => t.isDocumentOperation));
                    i.reverse();
                    for (const t of i) {
                        const i = t.baseVersion + 1,
                            r = Array.from(o.history.getOperations(i)),
                            s = Su([t.getReversed()], r, {
                                useRelations: !0,
                                document: this.editor.model.document,
                                padWithNoOps: !1,
                                forceWeakRemove: !0
                            }).operationsA;
                        for (const i of s) e.addOperation(i), n.applyOperation(i), o.history.setOperationAsUndone(t, i)
                    }
                }
            }
    
            function rk(t) {
                t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1));
                for (let e = 1; e < t.length; e++) {
                    const n = t[e - 1].getJoined(t[e], !0);
                    n && (e--, t.splice(e, 2, n))
                }
            }
    
            function sk(t, e) {
                return e.some((e => e !== t && e.containsRange(t, !0)))
            }
            class ak extends ik {
                execute(t = null) {
                    const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1,
                        n = this._stack.splice(e, 1)[0],
                        o = this.editor.model.createBatch({
                            isUndo: !0
                        });
                    this.editor.model.enqueueChange(o, (() => {
                        this._undo(n.batch, o);
                        const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                        this._restoreSelection(n.selection.ranges, n.selection.isBackward, t), this.fire("revert", n.batch, o)
                    })), this.refresh()
                }
            }
            class ck extends ik {
                execute() {
                    const t = this._stack.pop(),
                        e = this.editor.model.createBatch({
                            isUndo: !0
                        });
                    this.editor.model.enqueueChange(e, (() => {
                        const n = t.batch.operations[t.batch.operations.length - 1].baseVersion + 1,
                            o = this.editor.model.document.history.getOperations(n);
                        this._restoreSelection(t.selection.ranges, t.selection.isBackward, o), this._undo(t.batch, e)
                    })), this.refresh()
                }
            }
            class lk extends vs {
                static get pluginName() {
                    return "UndoEditing"
                }
                constructor(t) {
                    super(t), this._batchRegistry = new WeakSet
                }
                init() {
                    const t = this.editor;
                    this._undoCommand = new ak(t), this._redoCommand = new ck(t), t.commands.add("undo", this._undoCommand), t.commands.add("redo", this._redoCommand), this.listenTo(t.model, "applyOperation", ((t, e) => {
                        const n = e[0];
                        if (!n.isDocumentOperation) return;
                        const o = n.batch,
                            i = this._redoCommand._createdBatches.has(o),
                            r = this._undoCommand._createdBatches.has(o);
                        this._batchRegistry.has(o) || (this._batchRegistry.add(o), o.isUndoable && (i ? this._undoCommand.addBatch(o) : r || (this._undoCommand.addBatch(o), this._redoCommand.clearStack())))
                    }), {
                        priority: "highest"
                    }), this.listenTo(this._undoCommand, "revert", ((t, e, n) => {
                        this._redoCommand.addBatch(n)
                    })), t.keystrokes.set("CTRL+Z", "undo"), t.keystrokes.set("CTRL+Y", "redo"), t.keystrokes.set("CTRL+SHIFT+Z", "redo")
                }
            }
            const dk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
                hk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
            class uk extends vs {
                static get pluginName() {
                    return "UndoUI"
                }
                init() {
                    const t = this.editor,
                        e = t.locale,
                        n = t.t,
                        o = "ltr" == e.uiLanguageDirection ? dk : hk,
                        i = "ltr" == e.uiLanguageDirection ? hk : dk;
                    this._addButton("undo", n("Undo"), "CTRL+Z", o), this._addButton("redo", n("Redo"), "CTRL+Y", i)
                }
                _addButton(t, e, n, o) {
                    const i = this.editor;
                    i.ui.componentFactory.add(t, (r => {
                        const s = i.commands.get(t),
                            a = new es(r);
                        return a.set({
                            label: e,
                            icon: o,
                            keystroke: n,
                            tooltip: !0
                        }), a.bind("isEnabled").to(s, "isEnabled"), this.listenTo(a, "execute", (() => {
                            i.execute(t), i.editing.view.focus()
                        })), a
                    }))
                }
            }
            class gk extends vs {
                static get requires() {
                    return [lk, uk]
                }
                static get pluginName() {
                    return "Undo"
                }
            }
            class mk extends($()) {
                constructor() {
                    super();
                    const t = new window.FileReader;
                    this._reader = t, this._data = void 0, this.set("loaded", 0), t.onprogress = t => {
                        this.loaded = t.loaded
                    }
                }
                get error() {
                    return this._reader.error
                }
                get data() {
                    return this._data
                }
                read(t) {
                    const e = this._reader;
                    return this.total = t.size, new Promise(((n, o) => {
                        e.onload = () => {
                            const t = e.result;
                            this._data = t, n(t)
                        }, e.onerror = () => {
                            o("error")
                        }, e.onabort = () => {
                            o("aborted")
                        }, this._reader.readAsDataURL(t)
                    }))
                }
                abort() {
                    this._reader.abort()
                }
            }
            class pk extends vs {
                static get pluginName() {
                    return "FileRepository"
                }
                static get requires() {
                    return [zg]
                }
                init() {
                    this.loaders = new ur, this.loaders.on("change", (() => this._updatePendingAction())), this._loadersMap = new Map, this._pendingAction = null, this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0))
                }
                getLoader(t) {
                    return this._loadersMap.get(t) || null
                }
                createLoader(t) {
                    if (!this.createUploadAdapter) return C("filerepository-no-upload-adapter"), null;
                    const e = new fk(Promise.resolve(t), this.createUploadAdapter);
                    return this.loaders.add(e), this._loadersMap.set(t, e), t instanceof Promise && e.file.then((t => {
                        this._loadersMap.set(t, e)
                    })).catch((() => {})), e.on("change:uploaded", (() => {
                        let t = 0;
                        for (const e of this.loaders) t += e.uploaded;
                        this.uploaded = t
                    })), e.on("change:uploadTotal", (() => {
                        let t = 0;
                        for (const e of this.loaders) e.uploadTotal && (t += e.uploadTotal);
                        this.uploadTotal = t
                    })), e
                }
                destroyLoader(t) {
                    const e = t instanceof fk ? t : this.getLoader(t);
                    e._destroy(), this.loaders.remove(e), this._loadersMap.forEach(((t, n) => {
                        t === e && this._loadersMap.delete(n)
                    }))
                }
                _updatePendingAction() {
                    const t = this.editor.plugins.get(zg);
                    if (this.loaders.length) {
                        if (!this._pendingAction) {
                            const e = this.editor.t,
                                n = t => `${e("Upload in progress")} ${parseInt(t)}%.`;
                            this._pendingAction = t.add(n(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                        }
                    } else t.remove(this._pendingAction), this._pendingAction = null
                }
            }
            class fk extends($()) {
                constructor(t, e) {
                    super(), this.id = k(), this._filePromiseWrapper = this._createFilePromiseWrapper(t), this._adapter = e(this), this._reader = new mk, this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)), this.set("uploadResponse", null)
                }
                get file() {
                    return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null)) : Promise.resolve(null)
                }
                get data() {
                    return this._reader.data
                }
                read() {
                    if ("idle" != this.status) throw new A("filerepository-read-wrong-status", this);
                    return this.status = "reading", this.file.then((t => this._reader.read(t))).then((t => {
                        if ("reading" !== this.status) throw this.status;
                        return this.status = "idle", t
                    })).catch((t => {
                        if ("aborted" === t) throw this.status = "aborted", "aborted";
                        throw this.status = "error", this._reader.error ? this._reader.error : t
                    }))
                }
                upload() {
                    if ("idle" != this.status) throw new A("filerepository-upload-wrong-status", this);
                    return this.status = "uploading", this.file.then((() => this._adapter.upload())).then((t => (this.uploadResponse = t, this.status = "idle", t))).catch((t => {
                        if ("aborted" === this.status) throw "aborted";
                        throw this.status = "error", t
                    }))
                }
                abort() {
                    const t = this.status;
                    this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t ? this._reader.abort() : "uploading" == t && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch((() => {})), this._filePromiseWrapper.rejecter("aborted")), this._destroy()
                }
                _destroy() {
                    this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0
                }
                _createFilePromiseWrapper(t) {
                    const e = {};
                    return e.promise = new Promise(((n, o) => {
                        e.rejecter = o, e.isFulfilled = !1, t.then((t => {
                            e.isFulfilled = !0, n(t)
                        })).catch((t => {
                            e.isFulfilled = !0, o(t)
                        }))
                    })), e
                }
            }
            class kk extends Dr {
                constructor(t) {
                    super(t), this.buttonView = new es(t), this._fileInputView = new bk(t), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: "ck-file-dialog-button"
                        },
                        children: [this.buttonView, this._fileInputView]
                    }), this.buttonView.on("execute", (() => {
                        this._fileInputView.open()
                    }))
                }
                focus() {
                    this.buttonView.focus()
                }
            }
            class bk extends Dr {
                constructor(t) {
                    super(t), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck-hidden"],
                            type: "file",
                            tabindex: "-1",
                            accept: e.to("acceptedType"),
                            multiple: e.to("allowMultipleFiles")
                        },
                        on: {
                            change: e.to((() => {
                                this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = ""
                            }))
                        }
                    })
                }
                open() {
                    this.element.click()
                }
            }
            const wk = "ckCsrfToken",
                _k = 40,
                Ak = "abcdefghijklmnopqrstuvwxyz0123456789";
    
            function Ck() {
                let t = function(t) {
                    t = t.toLowerCase();
                    const e = document.cookie.split(";");
                    for (const n of e) {
                        const e = n.split("=");
                        if (decodeURIComponent(e[0].trim().toLowerCase()) === t) return decodeURIComponent(e[1])
                    }
                    return null
                }(wk);
                var e, n;
                return t && t.length == _k || (t = function(t) {
                    let e = "";
                    const n = new Uint8Array(t);
                    window.crypto.getRandomValues(n);
                    for (let t = 0; t < n.length; t++) {
                        const o = Ak.charAt(n[t] % Ak.length);
                        e += Math.random() > .5 ? o.toUpperCase() : o
                    }
                    return e
                }(_k), e = wk, n = t, document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(n) + ";path=/"), t
            }
            class vk {
                constructor(t, e, n) {
                    this.loader = t, this.url = e, this.t = n
                }
                upload() {
                    return this.loader.file.then((t => new Promise(((e, n) => {
                        this._initRequest(), this._initListeners(e, n, t), this._sendRequest(t)
                    }))))
                }
                abort() {
                    this.xhr && this.xhr.abort()
                }
                _initRequest() {
                    const t = this.xhr = new XMLHttpRequest;
                    t.open("POST", this.url, !0), t.responseType = "json"
                }
                _initListeners(t, e, n) {
                    const o = this.xhr,
                        i = this.loader,
                        r = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
                    o.addEventListener("error", (() => e(r))), o.addEventListener("abort", (() => e())), o.addEventListener("load", (() => {
                        const n = o.response;
                        if (!n || !n.uploaded) return e(n && n.error && n.error.message ? n.error.message : r);
                        t({
                            default: n.url
                        })
                    })), o.upload && o.upload.addEventListener("progress", (t => {
                        t.lengthComputable && (i.uploadTotal = t.total, i.uploaded = t.loaded)
                    }))
                }
                _sendRequest(t) {
                    const e = new FormData;
                    e.append("upload", t), e.append("ckCsrfToken", Ck()), this.xhr.send(e)
                }
            }
    
            function yk(t, e, n, o) {
                let i, r = null;
                "function" == typeof o ? i = o : (r = t.commands.get(o), i = () => {
                    t.execute(o)
                }), t.model.document.on("change:data", ((s, a) => {
                    if (r && !r.isEnabled || !e.isEnabled) return;
                    const c = gr(t.model.document.selection.getRanges());
                    if (!c.isCollapsed) return;
                    if (a.isUndo || !a.isLocal) return;
                    const l = Array.from(t.model.document.differ.getChanges()),
                        d = l[0];
                    if (1 != l.length || "insert" !== d.type || "$text" != d.name || 1 != d.length) return;
                    const h = d.position.parent;
                    if (h.is("element", "codeBlock")) return;
                    if (h.is("element", "listItem") && "function" != typeof o && !["numberedList", "bulletedList", "todoList"].includes(o)) return;
                    if (r && !0 === r.value) return;
                    const u = h.getChild(0),
                        g = t.model.createRangeOn(u);
                    if (!g.containsRange(c) && !c.end.isEqual(g.end)) return;
                    const m = n.exec(u.data.substr(0, c.end.offset));
                    m && t.model.enqueueChange((e => {
                        const n = e.createPositionAt(h, 0),
                            o = e.createPositionAt(h, m[0].length),
                            r = new eh(n, o);
                        if (!1 !== i({
                                match: m
                            })) {
                            e.remove(r);
                            const n = t.model.document.selection.getFirstRange(),
                                o = e.createRangeIn(h);
                            !h.isEmpty || o.isEqual(n) || o.containsRange(n, !0) || e.remove(h)
                        }
                        r.detach(), t.model.enqueueChange((() => {
                            t.plugins.get("Delete").requestUndoOnBackspace()
                        }))
                    }))
                }))
            }
    
            function xk(t, e, n, o) {
                let i, r;
                n instanceof RegExp ? i = n : r = n, r = r || (t => {
                    let e;
                    const n = [],
                        o = [];
                    for (; null !== (e = i.exec(t)) && !(e && e.length < 4);) {
                        let {
                            index: t,
                            1: i,
                            2: r,
                            3: s
                        } = e;
                        const a = i + r + s;
                        t += e[0].length - a.length;
                        const c = [t, t + i.length],
                            l = [t + i.length + r.length, t + i.length + r.length + s.length];
                        n.push(c), n.push(l), o.push([t + i.length, t + i.length + r.length])
                    }
                    return {
                        remove: n,
                        format: o
                    }
                }), t.model.document.on("change:data", ((n, i) => {
                    if (i.isUndo || !i.isLocal || !e.isEnabled) return;
                    const s = t.model,
                        a = s.document.selection;
                    if (!a.isCollapsed) return;
                    const c = Array.from(s.document.differ.getChanges()),
                        l = c[0];
                    if (1 != c.length || "insert" !== l.type || "$text" != l.name || 1 != l.length) return;
                    const d = a.focus,
                        h = d.parent,
                        {
                            text: u,
                            range: g
                        } = function(t, e) {
                            let n = t.start;
                            const o = Array.from(t.getItems()).reduce(((t, o) => !o.is("$text") && !o.is("$textProxy") || o.getAttribute("code") ? (n = e.createPositionAfter(o), "") : t + o.data), "");
                            return {
                                text: o,
                                range: e.createRange(n, t.end)
                            }
                        }(s.createRange(s.createPositionAt(h, 0), d), s),
                        m = r(u),
                        p = Ek(g.start, m.format, s),
                        f = Ek(g.start, m.remove, s);
                    p.length && f.length && s.enqueueChange((e => {
                        if (!1 !== o(e, p)) {
                            for (const t of f.reverse()) e.remove(t);
                            s.enqueueChange((() => {
                                t.plugins.get("Delete").requestUndoOnBackspace()
                            }))
                        }
                    }))
                }))
            }
    
            function Ek(t, e, n) {
                return e.filter((t => void 0 !== t[0] && void 0 !== t[1])).map((e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))))
            }
    
            function Dk(t, e) {
                return (n, o) => {
                    if (!t.commands.get(e).isEnabled) return !1;
                    const i = t.model.schema.getValidRanges(o, e);
                    for (const t of i) n.setAttribute(e, !0, t);
                    n.removeSelectionAttribute(e)
                }
            }
            class Ik extends xs {
                constructor(t, e) {
                    super(t), this.attributeKey = e
                }
                refresh() {
                    const t = this.editor.model,
                        e = t.document;
                    this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = void 0 === t.forceValue ? !this.value : t.forceValue;
                    e.change((t => {
                        if (n.isCollapsed) o ? t.setSelectionAttribute(this.attributeKey, !0) : t.removeSelectionAttribute(this.attributeKey);
                        else {
                            const i = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
                            for (const e of i) o ? t.setAttribute(this.attributeKey, o, e) : t.removeAttribute(this.attributeKey, e)
                        }
                    }))
                }
                _getValueFromFirstAllowedNode() {
                    const t = this.editor.model,
                        e = t.schema,
                        n = t.document.selection;
                    if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
                    for (const t of n.getRanges())
                        for (const n of t.getItems())
                            if (e.checkAttribute(n, this.attributeKey)) return n.hasAttribute(this.attributeKey);
                    return !1
                }
            }
            const Tk = "bold";
            class Mk extends vs {
                static get pluginName() {
                    return "BoldEditing"
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: Tk
                    }), t.model.schema.setAttributeProperties(Tk, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }), t.conversion.attributeToElement({
                        model: Tk,
                        view: "strong",
                        upcastAlso: ["b", t => {
                            const e = t.getStyle("font-weight");
                            return e && ("bold" == e || Number(e) >= 600) ? {
                                name: !0,
                                styles: ["font-weight"]
                            } : null
                        }]
                    }), t.commands.add(Tk, new Ik(t, Tk)), t.keystrokes.set("CTRL+B", Tk)
                }
            }
            const Sk = "bold";
            class Nk extends vs {
                static get pluginName() {
                    return "BoldUI"
                }
                init() {
                    const t = this.editor,
                        e = t.t;
                    t.ui.componentFactory.add(Sk, (n => {
                        const o = t.commands.get(Sk),
                            i = new es(n);
                        return i.set({
                            label: e("Bold"),
                            icon: Lg.bold,
                            keystroke: "CTRL+B",
                            tooltip: !0,
                            isToggleable: !0
                        }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                            t.execute(Sk), t.editing.view.focus()
                        })), i
                    }))
                }
            }
            const Bk = "italic";
            class Pk extends vs {
                static get pluginName() {
                    return "ItalicEditing"
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: Bk
                    }), t.model.schema.setAttributeProperties(Bk, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }), t.conversion.attributeToElement({
                        model: Bk,
                        view: "i",
                        upcastAlso: ["em", {
                            styles: {
                                "font-style": "italic"
                            }
                        }]
                    }), t.commands.add(Bk, new Ik(t, Bk)), t.keystrokes.set("CTRL+I", Bk)
                }
            }
            const zk = "italic";
            class Lk extends vs {
                static get pluginName() {
                    return "ItalicUI"
                }
                init() {
                    const t = this.editor,
                        e = t.t;
                    t.ui.componentFactory.add(zk, (n => {
                        const o = t.commands.get(zk),
                            i = new es(n);
                        return i.set({
                            label: e("Italic"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                            keystroke: "CTRL+I",
                            tooltip: !0,
                            isToggleable: !0
                        }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                            t.execute(zk), t.editing.view.focus()
                        })), i
                    }))
                }
            }
            class Ok extends xs {
                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.schema,
                        o = e.document.selection,
                        i = Array.from(o.getSelectedBlocks()),
                        r = void 0 === t.forceValue ? !this.value : t.forceValue;
                    e.change((t => {
                        if (r) {
                            const e = i.filter((t => Rk(t) || Fk(n, t)));
                            this._applyQuote(t, e)
                        } else this._removeQuote(t, i.filter(Rk))
                    }))
                }
                _getValue() {
                    const t = gr(this.editor.model.document.selection.getSelectedBlocks());
                    return !(!t || !Rk(t))
                }
                _checkEnabled() {
                    if (this.value) return !0;
                    const t = this.editor.model.document.selection,
                        e = this.editor.model.schema,
                        n = gr(t.getSelectedBlocks());
                    return !!n && Fk(e, n)
                }
                _removeQuote(t, e) {
                    jk(t, e).reverse().forEach((e => {
                        if (e.start.isAtStart && e.end.isAtEnd) return void t.unwrap(e.start.parent);
                        if (e.start.isAtStart) {
                            const n = t.createPositionBefore(e.start.parent);
                            return void t.move(e, n)
                        }
                        e.end.isAtEnd || t.split(e.end);
                        const n = t.createPositionAfter(e.end.parent);
                        t.move(e, n)
                    }))
                }
                _applyQuote(t, e) {
                    const n = [];
                    jk(t, e).reverse().forEach((e => {
                        let o = Rk(e.start);
                        o || (o = t.createElement("blockQuote"), t.wrap(e, o)), n.push(o)
                    })), n.reverse().reduce(((e, n) => e.nextSibling == n ? (t.merge(t.createPositionAfter(e)), e) : n))
                }
            }
    
            function Rk(t) {
                return "blockQuote" == t.parent.name ? t.parent : null
            }
    
            function jk(t, e) {
                let n, o = 0;
                const i = [];
                for (; o < e.length;) {
                    const r = e[o],
                        s = e[o + 1];
                    n || (n = t.createPositionBefore(r)), s && r.nextSibling == s || (i.push(t.createRange(n, t.createPositionAfter(r))), n = null), o++
                }
                return i
            }
    
            function Fk(t, e) {
                const n = t.checkChild(e.parent, "blockQuote"),
                    o = t.checkChild(["$root", "blockQuote"], e);
                return n && o
            }
            class Vk extends vs {
                static get pluginName() {
                    return "BlockQuoteEditing"
                }
                static get requires() {
                    return [Zp, xp]
                }
                init() {
                    const t = this.editor,
                        e = t.model.schema;
                    t.commands.add("blockQuote", new Ok(t)), e.register("blockQuote", {
                        inheritAllFrom: "$container"
                    }), t.conversion.elementToElement({
                        model: "blockQuote",
                        view: "blockquote"
                    }), t.model.document.registerPostFixer((n => {
                        const o = t.model.document.differ.getChanges();
                        for (const t of o)
                            if ("insert" == t.type) {
                                const o = t.position.nodeAfter;
                                if (!o) continue;
                                if (o.is("element", "blockQuote") && o.isEmpty) return n.remove(o), !0;
                                if (o.is("element", "blockQuote") && !e.checkChild(t.position, o)) return n.unwrap(o), !0;
                                if (o.is("element")) {
                                    const t = n.createRangeIn(o);
                                    for (const o of t.getItems())
                                        if (o.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(o), o)) return n.unwrap(o), !0
                                }
                            } else if ("remove" == t.type) {
                            const e = t.position.parent;
                            if (e.is("element", "blockQuote") && e.isEmpty) return n.remove(e), !0
                        }
                        return !1
                    }));
                    const n = this.editor.editing.view.document,
                        o = t.model.document.selection,
                        i = t.commands.get("blockQuote");
                    this.listenTo(n, "enter", ((e, n) => {
                        if (!o.isCollapsed || !i.value) return;
                        o.getLastPosition().parent.isEmpty && (t.execute("blockQuote"), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop())
                    }), {
                        context: "blockquote"
                    }), this.listenTo(n, "delete", ((e, n) => {
                        if ("backward" != n.direction || !o.isCollapsed || !i.value) return;
                        const r = o.getLastPosition().parent;
                        r.isEmpty && !r.previousSibling && (t.execute("blockQuote"), t.editing.view.scrollToTheSelection(), n.preventDefault(), e.stop())
                    }), {
                        context: "blockquote"
                    })
                }
            }
            var Hk = n(3062),
                Uk = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Hk.Z, Uk);
            Hk.Z.locals;
            class Wk extends vs {
                static get pluginName() {
                    return "BlockQuoteUI"
                }
                init() {
                    const t = this.editor,
                        e = t.t;
                    t.ui.componentFactory.add("blockQuote", (n => {
                        const o = t.commands.get("blockQuote"),
                            i = new es(n);
                        return i.set({
                            label: e("Block quote"),
                            icon: Lg.quote,
                            tooltip: !0,
                            isToggleable: !0
                        }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), this.listenTo(i, "execute", (() => {
                            t.execute("blockQuote"), t.editing.view.focus()
                        })), i
                    }))
                }
            }
            class qk extends vs {
                static get pluginName() {
                    return "CKBoxUI"
                }
                afterInit() {
                    const t = this.editor;
                    if (!t.commands.get("ckbox")) return;
                    const e = t.t;
                    t.ui.componentFactory.add("ckbox", (n => {
                        const o = t.commands.get("ckbox"),
                            i = new es(n);
                        return i.set({
                            label: e("Open file manager"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
                            tooltip: !0
                        }), i.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), i.on("execute", (() => {
                            t.execute("ckbox")
                        })), i
                    }))
                }
            }
            const Gk = 4e3,
                $k = 80,
                Yk = 10;
    
            function Kk({
                token: t,
                id: e,
                origin: n,
                width: o,
                extension: i
            }) {
                const r = Qk(t),
                    s = function(t) {
                        const e = [t * Yk / 100, $k],
                            n = Math.floor(Math.max(...e)),
                            o = [Math.min(t, Gk)];
                        let i = o[0];
                        for (; i - n >= n;) i -= n, o.unshift(i);
                        return o
                    }(o),
                    a = function(t) {
                        if ("bmp" === t || "tiff" === t || "jpg" === t) return "jpeg";
                        return t
                    }(i);
                return {
                    imageFallbackUrl: Zk({
                        environmentId: r,
                        id: e,
                        origin: n,
                        width: o,
                        extension: a
                    }),
                    imageSources: [{
                        srcset: s.map((t => `${Zk({environmentId:r,id:e,origin:n,width:t,extension:"webp"})} ${t}w`)).join(","),
                        sizes: `(max-width: ${o}px) 100vw, ${o}px`,
                        type: "image/webp"
                    }]
                }
            }
    
            function Qk(t) {
                const [, e] = t.value.split(".");
                return JSON.parse(atob(e)).aud
            }
    
            function Zk({
                environmentId: t,
                id: e,
                origin: n,
                width: o,
                extension: i
            }) {
                return new URL(`${t}/assets/${e}/images/${o}.${i}`, n).toString()
            }
            class Jk extends xs {
                constructor(t) {
                    super(t), this._chosenAssets = new Set, this._wrapper = null, this._initListeners()
                }
                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }
                execute() {
                    this.fire("ckbox:open")
                }
                _getValue() {
                    return null !== this._wrapper
                }
                _checkEnabled() {
                    const t = this.editor.commands.get("insertImage"),
                        e = this.editor.commands.get("link");
                    return !(!t.isEnabled && !e.isEnabled)
                }
                _prepareOptions() {
                    const t = this.editor.config.get("ckbox");
                    return {
                        theme: t.theme,
                        language: t.language,
                        tokenUrl: t.tokenUrl,
                        serviceOrigin: t.serviceOrigin,
                        assetsOrigin: t.assetsOrigin,
                        dialog: {
                            onClose: () => this.fire("ckbox:close")
                        },
                        assets: {
                            onChoose: t => this.fire("ckbox:choose", t)
                        }
                    }
                }
                _initListeners() {
                    const t = this.editor,
                        e = t.model,
                        n = !t.config.get("ckbox.ignoreDataId");
                    this.on("ckbox", (() => {
                        this.refresh()
                    }), {
                        priority: "low"
                    }), this.on("ckbox:open", (() => {
                        this.isEnabled && !this.value && (this._wrapper = Ct(document, "div", {
                            class: "ck ckbox-wrapper"
                        }), document.body.appendChild(this._wrapper), window.CKBox.mount(this._wrapper, this._prepareOptions()))
                    })), this.on("ckbox:close", (() => {
                        this.value && (this._wrapper.remove(), this._wrapper = null)
                    })), this.on("ckbox:choose", ((o, i) => {
                        if (!this.isEnabled) return;
                        const r = t.commands.get("insertImage"),
                            s = t.commands.get("link"),
                            a = t.plugins.get("CKBoxEditing"),
                            c = function({
                                assets: t,
                                origin: e,
                                token: n,
                                isImageAllowed: o,
                                isLinkAllowed: i
                            }) {
                                return t.map((t => ({
                                    id: t.data.id,
                                    type: tb(t) ? "image" : "link",
                                    attributes: Xk(t, n, e)
                                }))).filter((t => "image" === t.type ? o : i))
                            }({
                                assets: i,
                                origin: t.config.get("ckbox.assetsOrigin"),
                                token: a.getToken(),
                                isImageAllowed: r.isEnabled,
                                isLinkAllowed: s.isEnabled
                            });
                        0 !== c.length && e.change((t => {
                            for (const e of c) {
                                const o = e === c[c.length - 1];
                                this._insertAsset(e, o, t), n && (setTimeout((() => this._chosenAssets.delete(e)), 1e3), this._chosenAssets.add(e))
                            }
                        }))
                    })), this.listenTo(t, "destroy", (() => {
                        this.fire("ckbox:close"), this._chosenAssets.clear()
                    }))
                }
                _insertAsset(t, e, n) {
                    const o = this.editor.model.document.selection;
                    n.removeSelectionAttribute("linkHref"), "image" === t.type ? this._insertImage(t) : this._insertLink(t, n), e || n.setSelection(o.getLastPosition())
                }
                _insertImage(t) {
                    const e = this.editor,
                        {
                            imageFallbackUrl: n,
                            imageSources: o,
                            imageTextAlternative: i
                        } = t.attributes;
                    e.execute("insertImage", {
                        source: {
                            src: n,
                            sources: o,
                            alt: i
                        }
                    })
                }
                _insertLink(t, e) {
                    const n = this.editor,
                        o = n.model,
                        i = o.document.selection,
                        {
                            linkName: r,
                            linkHref: s
                        } = t.attributes;
                    if (i.isCollapsed) {
                        const t = fr(i.getAttributes()),
                            n = e.createText(r, t),
                            s = o.insertContent(n);
                        e.setSelection(s)
                    }
                    n.execute("link", s)
                }
            }
    
            function Xk(t, e, n) {
                if (tb(t)) {
                    const {
                        imageFallbackUrl: o,
                        imageSources: i
                    } = Kk({
                        token: e,
                        origin: n,
                        id: t.data.id,
                        width: t.data.metadata.width,
                        extension: t.data.extension
                    });
                    return {
                        imageFallbackUrl: o,
                        imageSources: i,
                        imageTextAlternative: t.data.metadata.description || ""
                    }
                }
                return {
                    linkName: t.data.name,
                    linkHref: eb(t, e, n)
                }
            }
    
            function tb(t) {
                const e = t.data.metadata;
                return !!e && (e.width && e.height)
            }
    
            function eb(t, e, n) {
                const o = Qk(e),
                    i = new URL(`${o}/assets/${t.data.id}/file`, n);
                return i.searchParams.set("download", "true"), i.toString()
            }
            class nb extends vs {
                static get requires() {
                    return ["ImageUploadEditing", "ImageUploadProgress", pk, rb]
                }
                static get pluginName() {
                    return "CKBoxUploadAdapter"
                }
                async afterInit() {
                    const t = this.editor,
                        e = !!t.config.get("ckbox"),
                        n = !!window.CKBox;
                    if (!e && !n) return;
                    const o = t.plugins.get(pk),
                        i = t.plugins.get(rb);
                    o.createUploadAdapter = e => new ob(e, i.getToken(), t);
                    const r = !t.config.get("ckbox.ignoreDataId"),
                        s = t.plugins.get("ImageUploadEditing");
                    r && s.on("uploadComplete", ((e, {
                        imageElement: n,
                        data: o
                    }) => {
                        t.model.change((t => {
                            t.setAttribute("ckboxImageId", o.ckboxImageId, n)
                        }))
                    }))
                }
            }
            class ob {
                constructor(t, e, n) {
                    this.loader = t, this.token = e, this.editor = n, this.controller = new AbortController, this.serviceOrigin = n.config.get("ckbox.serviceOrigin"), this.assetsOrigin = n.config.get("ckbox.assetsOrigin")
                }
                async getAvailableCategories(t = 0) {
                    const e = new URL("categories", this.serviceOrigin);
                    return e.searchParams.set("limit", 50..toString()), e.searchParams.set("offset", t.toString()), this._sendHttpRequest({
                        url: e
                    }).then((async e => {
                        if (e.totalCount - (t + 50) > 0) {
                            const n = await this.getAvailableCategories(t + 50);
                            return [...e.items, ...n]
                        }
                        return e.items
                    })).catch((() => {
                        this.controller.signal.throwIfAborted(), v("ckbox-fetch-category-http-error")
                    }))
                }
                async getCategoryIdForFile(t) {
                    const e = ib(t.name),
                        n = await this.getAvailableCategories();
                    if (!n) return null;
                    const o = this.editor.config.get("ckbox.defaultUploadCategories");
                    if (o) {
                        const t = Object.keys(o).find((t => o[t].includes(e)));
                        if (t) {
                            const e = n.find((e => e.id === t || e.name === t));
                            return e ? e.id : null
                        }
                    }
                    const i = n.find((t => t.extensions.includes(e)));
                    return i ? i.id : null
                }
                async upload() {
                    const t = this.editor.t,
                        e = t("Cannot determine a category for the uploaded file."),
                        n = await this.loader.file,
                        o = await this.getCategoryIdForFile(n);
                    if (!o) return Promise.reject(e);
                    const i = new URL("assets", this.serviceOrigin),
                        r = new FormData;
                    r.append("categoryId", o), r.append("file", n);
                    const s = {
                        method: "POST",
                        url: i,
                        data: r,
                        onUploadProgress: t => {
                            t.lengthComputable && (this.loader.uploadTotal = t.total, this.loader.uploaded = t.loaded)
                        }
                    };
                    return this._sendHttpRequest(s).then((async t => {
                        const e = await this._getImageWidth(),
                            o = ib(n.name),
                            i = Kk({
                                token: this.token,
                                id: t.id,
                                origin: this.assetsOrigin,
                                width: e,
                                extension: o
                            });
                        return {
                            ckboxImageId: t.id,
                            default: i.imageFallbackUrl,
                            sources: i.imageSources
                        }
                    })).catch((() => {
                        const e = t("Cannot upload file:") + ` ${n.name}.`;
                        return Promise.reject(e)
                    }))
                }
                abort() {
                    this.controller.abort()
                }
                _sendHttpRequest(t) {
                    const {
                        url: e,
                        data: n,
                        onUploadProgress: o
                    } = t, i = t.method || "GET", r = this.controller.signal, s = new XMLHttpRequest;
                    s.open(i, e.toString(), !0), s.setRequestHeader("Authorization", this.token.value), s.setRequestHeader("CKBox-Version", "CKEditor 5"), s.responseType = "json";
                    const a = () => {
                        s.abort()
                    };
                    return new Promise(((t, e) => {
                        r.addEventListener("abort", a), s.addEventListener("loadstart", (() => {
                            r.addEventListener("abort", a)
                        })), s.addEventListener("loadend", (() => {
                            r.removeEventListener("abort", a)
                        })), s.addEventListener("error", (() => {
                            e()
                        })), s.addEventListener("abort", (() => {
                            e()
                        })), s.addEventListener("load", (async () => {
                            const n = s.response;
                            return !n || n.statusCode >= 400 ? e(n && n.message) : t(n)
                        })), o && s.upload.addEventListener("progress", (t => {
                            o(t)
                        })), s.send(n)
                    }))
                }
                _getImageWidth() {
                    return new Promise((t => {
                        const e = new Image;
                        e.onload = () => {
                            URL.revokeObjectURL(e.src), t(e.width)
                        }, e.src = this.loader.data
                    }))
                }
            }
    
            function ib(t) {
                return t.match(/\.(?<ext>[^.]+)$/).groups.ext
            }
            class rb extends vs {
                static get pluginName() {
                    return "CKBoxEditing"
                }
                static get requires() {
                    return ["CloudServices", "LinkEditing", "PictureEditing", nb]
                }
                async init() {
                    const t = this.editor,
                        e = !!t.config.get("ckbox"),
                        n = !!window.CKBox;
                    if (!e && !n) return;
                    this._initConfig();
                    const o = t.plugins.get("CloudServicesCore"),
                        i = t.config.get("ckbox.tokenUrl"),
                        r = t.config.get("cloudServices.tokenUrl");
                    this._token = i === r ? t.plugins.get("CloudServices").token : await o.createToken(i).init(), t.config.get("ckbox.ignoreDataId") || (this._initSchema(), this._initConversion(), this._initFixers()), n && t.commands.add("ckbox", new Jk(t))
                }
                getToken() {
                    return this._token
                }
                _initConfig() {
                    const t = this.editor;
                    t.config.define("ckbox", {
                        serviceOrigin: "https://api.ckbox.io",
                        assetsOrigin: "https://ckbox.cloud",
                        defaultUploadCategories: null,
                        ignoreDataId: !1,
                        language: t.locale.uiLanguage,
                        theme: "default",
                        tokenUrl: t.config.get("cloudServices.tokenUrl")
                    });
                    if (!t.config.get("ckbox.tokenUrl")) throw new A("ckbox-plugin-missing-token-url", this);
                    t.plugins.has("ImageBlockEditing") || t.plugins.has("ImageInlineEditing") || v("ckbox-plugin-image-feature-missing", t)
                }
                _initSchema() {
                    const t = this.editor.model.schema;
                    t.extend("$text", {
                        allowAttributes: "ckboxLinkId"
                    }), t.isRegistered("imageBlock") && t.extend("imageBlock", {
                        allowAttributes: ["ckboxImageId", "ckboxLinkId"]
                    }), t.isRegistered("imageInline") && t.extend("imageInline", {
                        allowAttributes: ["ckboxImageId", "ckboxLinkId"]
                    }), t.addAttributeCheck(((t, e) => {
                        if (!!!t.last.getAttribute("linkHref") && "ckboxLinkId" === e) return !1
                    }))
                }
                _initConversion() {
                    const t = this.editor;
                    t.conversion.for("downcast").add((t => {
                        t.on("attribute:ckboxLinkId:imageBlock", ((t, e, n) => {
                            const {
                                writer: o,
                                mapper: i,
                                consumable: r
                            } = n;
                            if (!r.consume(e.item, t.name)) return;
                            const s = [...i.toViewElement(e.item).getChildren()].find((t => "a" === t.name));
                            s && (e.item.hasAttribute("ckboxLinkId") ? o.setAttribute("data-ckbox-resource-id", e.item.getAttribute("ckboxLinkId"), s) : o.removeAttribute("data-ckbox-resource-id", s))
                        }), {
                            priority: "low"
                        }), t.on("attribute:ckboxLinkId", ((t, e, n) => {
                            const {
                                writer: o,
                                mapper: i,
                                consumable: r
                            } = n;
                            if (r.consume(e.item, t.name)) {
                                if (e.attributeOldValue) {
                                    const t = ab(o, e.attributeOldValue);
                                    o.unwrap(i.toViewRange(e.range), t)
                                }
                                if (e.attributeNewValue) {
                                    const t = ab(o, e.attributeNewValue);
                                    if (e.item.is("selection")) {
                                        const e = o.document.selection;
                                        o.wrap(e.getFirstRange(), t)
                                    } else o.wrap(i.toViewRange(e.range), t)
                                }
                            }
                        }), {
                            priority: "low"
                        })
                    })), t.conversion.for("upcast").add((t => {
                        t.on("element:a", ((t, e, n) => {
                            const {
                                writer: o,
                                consumable: i
                            } = n;
                            if (!e.viewItem.getAttribute("href")) return;
                            if (!i.consume(e.viewItem, {
                                    attributes: ["data-ckbox-resource-id"]
                                })) return;
                            const r = e.viewItem.getAttribute("data-ckbox-resource-id");
                            if (r)
                                if (e.modelRange)
                                    for (let t of e.modelRange.getItems()) t.is("$textProxy") && (t = t.textNode), cb(t) && o.setAttribute("ckboxLinkId", r, t);
                                else {
                                    const t = e.modelCursor.nodeBefore || e.modelCursor.parent;
                                    o.setAttribute("ckboxLinkId", r, t)
                                }
                        }), {
                            priority: "low"
                        })
                    })), t.conversion.for("downcast").attributeToAttribute({
                        model: "ckboxImageId",
                        view: "data-ckbox-resource-id"
                    }), t.conversion.for("upcast").elementToAttribute({
                        model: {
                            key: "ckboxImageId",
                            value: t => t.getAttribute("data-ckbox-resource-id")
                        },
                        view: {
                            attributes: {
                                "data-ckbox-resource-id": /[\s\S]+/
                            }
                        }
                    })
                }
                _initFixers() {
                    const t = this.editor,
                        e = t.model,
                        n = e.document.selection;
                    e.document.registerPostFixer(function(t) {
                        return e => {
                            let n = !1;
                            const o = t.model,
                                i = t.commands.get("ckbox");
                            if (!i) return n;
                            for (const t of o.document.differ.getChanges()) {
                                if ("insert" !== t.type && "attribute" !== t.type) continue;
                                const o = "insert" === t.type ? new Ud(t.position, t.position.getShiftedBy(t.length)) : t.range,
                                    r = "attribute" === t.type && "linkHref" === t.attributeKey && null === t.attributeNewValue;
                                for (const t of o.getItems()) {
                                    if (r && t.hasAttribute("ckboxLinkId")) {
                                        e.removeAttribute("ckboxLinkId", t), n = !0;
                                        continue
                                    }
                                    const o = sb(t, i._chosenAssets);
                                    for (const i of o) {
                                        const o = "image" === i.type ? "ckboxImageId" : "ckboxLinkId";
                                        i.id !== t.getAttribute(o) && (e.setAttribute(o, i.id, t), n = !0)
                                    }
                                }
                            }
                            return n
                        }
                    }(t)), e.document.registerPostFixer(function(t) {
                        return e => {
                            !t.hasAttribute("linkHref") && t.hasAttribute("ckboxLinkId") && e.removeSelectionAttribute("ckboxLinkId")
                        }
                    }(n))
                }
            }
    
            function sb(t, e) {
                const n = t.is("element", "imageInline") || t.is("element", "imageBlock"),
                    o = t.hasAttribute("linkHref");
                return [...e].filter((e => "image" === e.type && n ? e.attributes.imageFallbackUrl === t.getAttribute("src") : "link" === e.type && o ? e.attributes.linkHref === t.getAttribute("linkHref") : void 0))
            }
    
            function ab(t, e) {
                const n = t.createAttributeElement("a", {
                    "data-ckbox-resource-id": e
                }, {
                    priority: 5
                });
                return t.setCustomProperty("link", !0, n), n
            }
    
            function cb(t) {
                return !!t.is("$text") || !(!t.is("element", "imageInline") && !t.is("element", "imageBlock"))
            }
            class lb extends vs {
                static get pluginName() {
                    return "CKFinderUI"
                }
                init() {
                    const t = this.editor,
                        e = t.ui.componentFactory,
                        n = t.t;
                    e.add("ckfinder", (e => {
                        const o = t.commands.get("ckfinder"),
                            i = new es(e);
                        return i.set({
                            label: n("Insert image or file"),
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
                            tooltip: !0
                        }), i.bind("isEnabled").to(o), i.on("execute", (() => {
                            t.execute("ckfinder"), t.editing.view.focus()
                        })), i
                    }))
                }
            }
            class db extends xs {
                constructor(t) {
                    super(t), this._affectsData = !1, this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", (() => this.refresh()), {
                        priority: "low"
                    })
                }
                refresh() {
                    const t = this.editor.commands.get("insertImage"),
                        e = this.editor.commands.get("link");
                    this.isEnabled = t.isEnabled || e.isEnabled
                }
                execute() {
                    const t = this.editor,
                        e = this.editor.config.get("ckfinder.openerMethod") || "modal";
                    if ("popup" != e && "modal" != e) throw new A("ckfinder-unknown-openermethod", t);
                    const n = this.editor.config.get("ckfinder.options") || {};
                    n.chooseFiles = !0;
                    const o = n.onInit;
                    n.language || (n.language = t.locale.uiLanguage), n.onInit = e => {
                        o && o(e), e.on("files:choose", (n => {
                            const o = n.data.files.toArray(),
                                i = o.filter((t => !t.isImage())),
                                r = o.filter((t => t.isImage()));
                            for (const e of i) t.execute("link", e.getUrl());
                            const s = [];
                            for (const t of r) {
                                const n = t.getUrl();
                                s.push(n || e.request("file:getProxyUrl", {
                                    file: t
                                }))
                            }
                            s.length && hb(t, s)
                        })), e.on("file:choose:resizedImage", (e => {
                            const n = e.data.resizedUrl;
                            if (n) hb(t, [n]);
                            else {
                                const e = t.plugins.get("Notification"),
                                    n = t.locale.t;
                                e.showWarning(n("Could not obtain resized image URL."), {
                                    title: n("Selecting resized image failed"),
                                    namespace: "ckfinder"
                                })
                            }
                        }))
                    }, window.CKFinder[e](n)
                }
            }
    
            function hb(t, e) {
                if (t.commands.get("insertImage").isEnabled) t.execute("insertImage", {
                    source: e
                });
                else {
                    const e = t.plugins.get("Notification"),
                        n = t.locale.t;
                    e.showWarning(n("Could not insert image at the current position."), {
                        title: n("Inserting image failed"),
                        namespace: "ckfinder"
                    })
                }
            }
            class ub extends vs {
                static get pluginName() {
                    return "CKFinderEditing"
                }
                static get requires() {
                    return [jm, "LinkEditing"]
                }
                init() {
                    const t = this.editor;
                    if (!t.plugins.has("ImageBlockEditing") && !t.plugins.has("ImageInlineEditing")) throw new A("ckfinder-missing-image-plugin", t);
                    t.commands.add("ckfinder", new db(t))
                }
            }
            class gb extends vs {
                static get pluginName() {
                    return "CloudServicesUploadAdapter"
                }
                static get requires() {
                    return ["CloudServices", pk]
                }
                init() {
                    const t = this.editor,
                        e = t.plugins.get("CloudServices"),
                        n = e.token,
                        o = e.uploadUrl;
                    n && (this._uploadGateway = t.plugins.get("CloudServicesCore").createUploadGateway(n, o), t.plugins.get(pk).createUploadAdapter = t => new mb(this._uploadGateway, t))
                }
            }
            class mb {
                constructor(t, e) {
                    this.uploadGateway = t, this.loader = e
                }
                upload() {
                    return this.loader.file.then((t => (this.fileUploader = this.uploadGateway.upload(t), this.fileUploader.on("progress", ((t, e) => {
                        this.loader.uploadTotal = e.total, this.loader.uploaded = e.uploaded
                    })), this.fileUploader.send())))
                }
                abort() {
                    this.fileUploader.abort()
                }
            }
            class pb extends xs {
                refresh() {
                    const t = this.editor.model,
                        e = gr(t.document.selection.getSelectedBlocks());
                    this.value = !!e && e.is("element", "paragraph"), this.isEnabled = !!e && fb(e, t.schema)
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.document;
                    e.change((o => {
                        const i = (t.selection || n.selection).getSelectedBlocks();
                        for (const t of i) !t.is("element", "paragraph") && fb(t, e.schema) && o.rename(t, "paragraph")
                    }))
                }
            }
    
            function fb(t, e) {
                return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
            }
            class kb extends xs {
                execute(t) {
                    const e = this.editor.model,
                        n = t.attributes;
                    let o = t.position;
                    e.change((t => {
                        const i = t.createElement("paragraph");
                        if (n && e.schema.setAllowedAttributes(i, n, t), !e.schema.checkChild(o.parent, i)) {
                            const n = e.schema.findAllowedParent(o, i);
                            if (!n) return;
                            o = t.split(o, n).position
                        }
                        e.insertContent(i, o), t.setSelection(i, "in")
                    }))
                }
            }
            class bb extends vs {
                static get pluginName() {
                    return "Paragraph"
                }
                init() {
                    const t = this.editor,
                        e = t.model;
                    t.commands.add("paragraph", new pb(t)), t.commands.add("insertParagraph", new kb(t)), e.schema.register("paragraph", {
                        inheritAllFrom: "$block"
                    }), t.conversion.elementToElement({
                        model: "paragraph",
                        view: "p"
                    }), t.conversion.for("upcast").elementToElement({
                        model: (t, {
                            writer: e
                        }) => bb.paragraphLikeElements.has(t.name) ? t.isEmpty ? null : e.createElement("paragraph") : null,
                        view: /.+/,
                        converterPriority: "low"
                    })
                }
            }
            bb.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
            class wb extends xs {
                constructor(t, e) {
                    super(t), this.modelElements = e
                }
                refresh() {
                    const t = gr(this.editor.model.document.selection.getSelectedBlocks());
                    this.value = !!t && this.modelElements.includes(t.name) && t.name, this.isEnabled = !!t && this.modelElements.some((e => _b(t, e, this.editor.model.schema)))
                }
                execute(t) {
                    const e = this.editor.model,
                        n = e.document,
                        o = t.value;
                    e.change((t => {
                        const i = Array.from(n.selection.getSelectedBlocks()).filter((t => _b(t, o, e.schema)));
                        for (const e of i) e.is("element", o) || t.rename(e, o)
                    }))
                }
            }
    
            function _b(t, e, n) {
                return n.checkChild(t.parent, e) && !n.isObject(t)
            }
            const Ab = "paragraph";
            class Cb extends vs {
                static get pluginName() {
                    return "HeadingEditing"
                }
                constructor(t) {
                    super(t), t.config.define("heading", {
                        options: [{
                            model: "paragraph",
                            title: "Paragraph",
                            class: "ck-heading_paragraph"
                        }, {
                            model: "heading1",
                            view: "h2",
                            title: "Heading 1",
                            class: "ck-heading_heading1"
                        }, {
                            model: "heading2",
                            view: "h3",
                            title: "Heading 2",
                            class: "ck-heading_heading2"
                        }, {
                            model: "heading3",
                            view: "h4",
                            title: "Heading 3",
                            class: "ck-heading_heading3"
                        }]
                    })
                }
                static get requires() {
                    return [bb]
                }
                init() {
                    const t = this.editor,
                        e = t.config.get("heading.options"),
                        n = [];
                    for (const o of e) "paragraph" !== o.model && (t.model.schema.register(o.model, {
                        inheritAllFrom: "$block"
                    }), t.conversion.elementToElement(o), n.push(o.model));
                    this._addDefaultH1Conversion(t), t.commands.add("heading", new wb(t, n))
                }
                afterInit() {
                    const t = this.editor,
                        e = t.commands.get("enter"),
                        n = t.config.get("heading.options");
                    e && this.listenTo(e, "afterExecute", ((e, o) => {
                        const i = t.model.document.selection.getFirstPosition().parent;
                        n.some((t => i.is("element", t.model))) && !i.is("element", Ab) && 0 === i.childCount && o.writer.rename(i, Ab)
                    }))
                }
                _addDefaultH1Conversion(t) {
                    t.conversion.for("upcast").elementToElement({
                        model: "heading1",
                        view: "h1",
                        converterPriority: b.get("low") + 1
                    })
                }
            }
            var vb = n(8733),
                yb = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(vb.Z, yb);
            vb.Z.locals;
            class xb extends vs {
                static get pluginName() {
                    return "HeadingUI"
                }
                init() {
                    const t = this.editor,
                        e = t.t,
                        n = function(t) {
                            const e = t.t,
                                n = {
                                    Paragraph: e("Paragraph"),
                                    "Heading 1": e("Heading 1"),
                                    "Heading 2": e("Heading 2"),
                                    "Heading 3": e("Heading 3"),
                                    "Heading 4": e("Heading 4"),
                                    "Heading 5": e("Heading 5"),
                                    "Heading 6": e("Heading 6")
                                };
                            return t.config.get("heading.options").map((t => {
                                const e = n[t.title];
                                return e && e != t.title && (t.title = e), t
                            }))
                        }(t),
                        o = e("Choose heading"),
                        i = e("Heading");
                    t.ui.componentFactory.add("heading", (e => {
                        const r = {},
                            s = new ur,
                            a = t.commands.get("heading"),
                            c = t.commands.get("paragraph"),
                            l = [a];
                        for (const t of n) {
                            const e = {
                                type: "button",
                                model: new Fm({
                                    label: t.title,
                                    class: t.class,
                                    withText: !0
                                })
                            };
                            "paragraph" === t.model ? (e.model.bind("isOn").to(c, "value"), e.model.set("commandName", "paragraph"), l.push(c)) : (e.model.bind("isOn").to(a, "value", (e => e === t.model)), e.model.set({
                                commandName: "heading",
                                commandValue: t.model
                            })), s.add(e), r[t.model] = t.title
                        }
                        const d = tm(e);
                        return om(d, s), d.buttonView.set({
                            isOn: !1,
                            withText: !0,
                            tooltip: i
                        }), d.extendTemplate({
                            attributes: {
                                class: ["ck-heading-dropdown"]
                            }
                        }), d.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some((t => t)))), d.buttonView.bind("label").to(a, "value", c, "value", ((t, e) => {
                            const n = t || e && "paragraph";
                            return "boolean" == typeof n ? o : r[n] ? r[n] : o
                        })), this.listenTo(d, "execute", (e => {
                            const {
                                commandName: n,
                                commandValue: o
                            } = e.source;
                            t.execute(n, o ? {
                                value: o
                            } : void 0), t.editing.view.focus()
                        })), d
                    }))
                }
            }
            class Eb extends xs {
                refresh() {
                    const t = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!t, this.isEnabled && t.hasAttribute("alt") ? this.value = t.getAttribute("alt") : this.value = !1
                }
                execute(t) {
                    const e = this.editor,
                        n = e.plugins.get("ImageUtils"),
                        o = e.model,
                        i = n.getClosestSelectedImageElement(o.document.selection);
                    o.change((e => {
                        e.setAttribute("alt", t.newValue, i)
                    }))
                }
            }
    
            function Db(t) {
                return t.createContainerElement("figure", {
                    class: "image"
                }, [t.createEmptyElement("img"), t.createSlot()])
            }
    
            function Ib(t, e) {
                const n = t.plugins.get("ImageUtils"),
                    o = t.plugins.has("ImageInlineEditing") && t.plugins.has("ImageBlockEditing");
                return t => {
                    if (!n.isInlineImageView(t)) return null;
                    if (!o) return i(t);
                    return ("block" == t.getStyle("display") || t.findAncestor(n.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(t)
                };
    
                function i(t) {
                    const e = {
                        name: !0
                    };
                    return t.hasAttribute("src") && (e.attributes = ["src"]), e
                }
            }
    
            function Tb(t, e) {
                const n = gr(e.getSelectedBlocks());
                return !n || t.isObject(n) || n.isEmpty && "listItem" != n.name ? "imageBlock" : "imageInline"
            }
            class Mb extends vs {
                static get pluginName() {
                    return "ImageUtils"
                }
                isImage(t) {
                    return this.isInlineImage(t) || this.isBlockImage(t)
                }
                isInlineImageView(t) {
                    return !!t && t.is("element", "img")
                }
                isBlockImageView(t) {
                    return !!t && t.is("element", "figure") && t.hasClass("image")
                }
                insertImage(t = {}, e = null, n = null) {
                    const o = this.editor,
                        i = o.model,
                        r = i.document.selection;
                    n = Sb(o, e || r, n), t = {
                        ...Object.fromEntries(r.getAttributes()),
                        ...t
                    };
                    for (const e in t) i.schema.checkAttribute(n, e) || delete t[e];
                    return i.change((o => {
                        const r = o.createElement(n, t);
                        return i.insertObject(r, e, null, {
                            setSelection: "on",
                            findOptimalPosition: !e && "imageInline" != n
                        }), r.parent ? r : null
                    }))
                }
                getClosestSelectedImageWidget(t) {
                    const e = t.getFirstPosition();
                    if (!e) return null;
                    const n = t.getSelectedElement();
                    if (n && this.isImageWidget(n)) return n;
                    let o = e.parent;
                    for (; o;) {
                        if (o.is("element") && this.isImageWidget(o)) return o;
                        o = o.parent
                    }
                    return null
                }
                getClosestSelectedImageElement(t) {
                    const e = t.getSelectedElement();
                    return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock")
                }
                isImageAllowed() {
                    const t = this.editor.model.document.selection;
                    return function(t, e) {
                        const n = Sb(t, e);
                        if ("imageBlock" == n) {
                            const n = function(t, e) {
                                const n = ff(t, e),
                                    o = n.start.parent;
                                if (o.isEmpty && !o.is("element", "$root")) return o.parent;
                                return o
                            }(e, t.model);
                            if (t.model.schema.checkChild(n, "imageBlock")) return !0
                        } else if (t.model.schema.checkChild(e.focus, "imageInline")) return !0;
                        return !1
                    }(this.editor, t) && function(t) {
                        return [...t.focus.getAncestors()].every((t => !t.is("element", "imageBlock")))
                    }(t)
                }
                toImageWidget(t, e, n) {
                    e.setCustomProperty("image", !0, t);
                    return hf(t, e, {
                        label: () => {
                            const e = this.findViewImgElement(t).getAttribute("alt");
                            return e ? `${e} ${n}` : n
                        }
                    })
                }
                isImageWidget(t) {
                    return !!t.getCustomProperty("image") && df(t)
                }
                isBlockImage(t) {
                    return !!t && t.is("element", "imageBlock")
                }
                isInlineImage(t) {
                    return !!t && t.is("element", "imageInline")
                }
                findViewImgElement(t) {
                    if (this.isInlineImageView(t)) return t;
                    const e = this.editor.editing.view;
                    for (const {
                            item: n
                        }
                        of e.createRangeIn(t))
                        if (this.isInlineImageView(n)) return n
                }
            }
    
            function Sb(t, e, n) {
                const o = t.model.schema,
                    i = t.config.get("image.insert.type");
                return t.plugins.has("ImageBlockEditing") ? t.plugins.has("ImageInlineEditing") ? n || ("inline" === i ? "imageInline" : "block" === i ? "imageBlock" : e.is("selection") ? Tb(o, e) : o.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline"
            }
            class Nb extends vs {
                static get requires() {
                    return [Mb]
                }
                static get pluginName() {
                    return "ImageTextAlternativeEditing"
                }
                init() {
                    this.editor.commands.add("imageTextAlternative", new Eb(this.editor))
                }
            }
            var Bb = n(1905),
                Pb = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Bb.Z, Pb);
            Bb.Z.locals;
            var zb = n(6764),
                Lb = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(zb.Z, Lb);
            zb.Z.locals;
            class Ob extends Dr {
                constructor(t) {
                    super(t);
                    const n = this.locale.t;
                    this.focusTracker = new mr, this.keystrokes = new pr, this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(n("Save"), Lg.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), Lg.cancel, "ck-button-cancel", "cancel"), this._focusables = new Cr, this._focusCycler = new bs({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }), this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                    }), e(this)
                }
                render() {
                    super.render(), this.keystrokes.listenTo(this.element), i({
                        view: this
                    }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => {
                        this._focusables.add(t), this.focusTracker.add(t.element)
                    }))
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                _createButton(t, e, n, o) {
                    const i = new es(this.locale);
                    return i.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), i.extendTemplate({
                        attributes: {
                            class: n
                        }
                    }), o && i.delegate("execute").to(this, o), i
                }
                _createLabeledInputView() {
                    const t = this.locale.t,
                        e = new Om(this.locale, Rm);
                    return e.label = t("Text alternative"), e
                }
            }
    
            function Rb(t) {
                const e = t.editing.view,
                    n = dm.defaultPositions,
                    o = t.plugins.get("ImageUtils");
                return {
                    target: e.domConverter.mapViewToDom(o.getClosestSelectedImageWidget(e.document.selection)),
                    positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth]
                }
            }
            class jb extends vs {
                static get requires() {
                    return [Gm]
                }
                static get pluginName() {
                    return "ImageTextAlternativeUI"
                }
                init() {
                    this._createButton()
                }
                destroy() {
                    super.destroy(), this._form && this._form.destroy()
                }
                _createButton() {
                    const t = this.editor,
                        e = t.t;
                    t.ui.componentFactory.add("imageTextAlternative", (n => {
                        const o = t.commands.get("imageTextAlternative"),
                            i = new es(n);
                        return i.set({
                            label: e("Change image text alternative"),
                            icon: Lg.lowVision,
                            tooltip: !0
                        }), i.bind("isEnabled").to(o, "isEnabled"), i.bind("isOn").to(o, "value", (t => !!t)), this.listenTo(i, "execute", (() => {
                            this._showForm()
                        })), i
                    }))
                }
                _createForm() {
                    const e = this.editor,
                        n = e.editing.view.document,
                        o = e.plugins.get("ImageUtils");
                    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new Ob(e.locale), this._form.render(), this.listenTo(this._form, "submit", (() => {
                        e.execute("imageTextAlternative", {
                            newValue: this._form.labeledInput.fieldView.element.value
                        }), this._hideForm(!0)
                    })), this.listenTo(this._form, "cancel", (() => {
                        this._hideForm(!0)
                    })), this._form.keystrokes.set("Esc", ((t, e) => {
                        this._hideForm(!0), e()
                    })), this.listenTo(e.ui, "update", (() => {
                        o.getClosestSelectedImageWidget(n.selection) ? this._isVisible && function(t) {
                            const e = t.plugins.get("ContextualBalloon");
                            if (t.plugins.get("ImageUtils").getClosestSelectedImageWidget(t.editing.view.document.selection)) {
                                const n = Rb(t);
                                e.updatePosition(n)
                            }
                        }(e) : this._hideForm(!0)
                    })), t({
                        emitter: this._form,
                        activator: () => this._isVisible,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideForm()
                    })
                }
                _showForm() {
                    if (this._isVisible) return;
                    this._form || this._createForm();
                    const t = this.editor,
                        e = t.commands.get("imageTextAlternative"),
                        n = this._form.labeledInput;
                    this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
                        view: this._form,
                        position: Rb(t)
                    }), n.fieldView.value = n.fieldView.element.value = e.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions()
                }
                _hideForm(t) {
                    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t && this.editor.editing.view.focus())
                }
                get _isVisible() {
                    return !!this._balloon && this._balloon.visibleView === this._form
                }
                get _isInBalloon() {
                    return !!this._balloon && this._balloon.hasView(this._form)
                }
            }
            class Fb extends vs {
                static get requires() {
                    return [Nb, jb]
                }
                static get pluginName() {
                    return "ImageTextAlternative"
                }
            }
    
            function Vb(t, e) {
                return t => {
                    t.on(`attribute:srcset:${e}`, n)
                };
    
                function n(e, n, o) {
                    if (!o.consumable.consume(n.item, e.name)) return;
                    const i = o.writer,
                        r = o.mapper.toViewElement(n.item),
                        s = t.findViewImgElement(r);
                    if (null === n.attributeNewValue) {
                        const t = n.attributeOldValue;
                        t.data && (i.removeAttribute("srcset", s), i.removeAttribute("sizes", s), t.width && i.removeAttribute("width", s))
                    } else {
                        const t = n.attributeNewValue;
                        t.data && (i.setAttribute("srcset", t.data, s), i.setAttribute("sizes", "100vw", s), t.width && i.setAttribute("width", t.width, s))
                    }
                }
            }
    
            function Hb(t, e, n) {
                return t => {
                    t.on(`attribute:${n}:${e}`, o)
                };
    
                function o(e, n, o) {
                    if (!o.consumable.consume(n.item, e.name)) return;
                    const i = o.writer,
                        r = o.mapper.toViewElement(n.item),
                        s = t.findViewImgElement(r);
                    i.setAttribute(n.attributeKey, n.attributeNewValue || "", s)
                }
            }
            class Ub extends ul {
                observe(t) {
                    this.listenTo(t, "load", ((t, e) => {
                        const n = e.target;
                        this.checkShouldIgnoreEventFromTarget(n) || "IMG" == n.tagName && this._fireEvents(e)
                    }), {
                        useCapture: !0
                    })
                }
                _fireEvents(t) {
                    this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t))
                }
            }
            class Wb extends xs {
                constructor(t) {
                    super(t);
                    const e = t.config.get("image.insert.type");
                    t.plugins.has("ImageBlockEditing") || "block" === e && C("image-block-plugin-required"), t.plugins.has("ImageInlineEditing") || "inline" === e && C("image-inline-plugin-required")
                }
                refresh() {
                    this.isEnabled = this.editor.plugins.get("ImageUtils").isImageAllowed()
                }
                execute(t) {
                    const e = ar(t.source),
                        n = this.editor.model.document.selection,
                        o = this.editor.plugins.get("ImageUtils"),
                        i = Object.fromEntries(n.getAttributes());
                    e.forEach(((t, e) => {
                        const r = n.getSelectedElement();
                        if ("string" == typeof t && (t = {
                                src: t
                            }), e && r && o.isImage(r)) {
                            const e = this.editor.model.createPositionAfter(r);
                            o.insertImage({
                                ...t,
                                ...i
                            }, e)
                        } else o.insertImage({
                            ...t,
                            ...i
                        })
                    }))
                }
            }
            class qb extends xs {
                refresh() {
                    const t = this.editor.plugins.get("ImageUtils"),
                        e = this.editor.model.document.selection.getSelectedElement();
                    this.isEnabled = t.isImage(e), this.value = this.isEnabled ? e.getAttribute("src") : null
                }
                execute(t) {
                    const e = this.editor.model.document.selection.getSelectedElement();
                    this.editor.model.change((n => {
                        n.setAttribute("src", t.source, e), n.removeAttribute("srcset", e), n.removeAttribute("sizes", e)
                    }))
                }
            }
            class Gb extends vs {
                static get requires() {
                    return [Mb]
                }
                static get pluginName() {
                    return "ImageEditing"
                }
                init() {
                    const t = this.editor,
                        e = t.conversion;
                    t.editing.view.addObserver(Ub), e.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "alt"
                        },
                        model: "alt"
                    }).attributeToAttribute({
                        view: {
                            name: "img",
                            key: "srcset"
                        },
                        model: {
                            key: "srcset",
                            value: t => {
                                const e = {
                                    data: t.getAttribute("srcset")
                                };
                                return t.hasAttribute("width") && (e.width = t.getAttribute("width")), e
                            }
                        }
                    });
                    const n = new Wb(t),
                        o = new qb(t);
                    t.commands.add("insertImage", n), t.commands.add("replaceImageSource", o), t.commands.add("imageInsert", n)
                }
            }
            class $b extends xs {
                constructor(t, e) {
                    super(t), this._modelElementName = e
                }
                refresh() {
                    const t = this.editor.plugins.get("ImageUtils"),
                        e = t.getClosestSelectedImageElement(this.editor.model.document.selection);
                    "imageBlock" === this._modelElementName ? this.isEnabled = t.isInlineImage(e) : this.isEnabled = t.isBlockImage(e)
                }
                execute() {
                    const t = this.editor,
                        e = this.editor.model,
                        n = t.plugins.get("ImageUtils"),
                        o = n.getClosestSelectedImageElement(e.document.selection),
                        i = Object.fromEntries(o.getAttributes());
                    return i.src || i.uploadId ? e.change((t => {
                        const r = Array.from(e.markers).filter((t => t.getRange().containsItem(o))),
                            s = n.insertImage(i, e.createSelection(o, "on"), this._modelElementName);
                        if (!s) return null;
                        const a = t.createRangeOn(s);
                        for (const e of r) {
                            const n = e.getRange(),
                                o = "$graveyard" != n.root.rootName ? n.getJoined(a, !0) : a;
                            t.updateMarker(e, {
                                range: o
                            })
                        }
                        return {
                            oldElement: o,
                            newElement: s
                        }
                    })) : null
                }
            }
            class Yb extends vs {
                static get requires() {
                    return [Gb, Mb, hp]
                }
                static get pluginName() {
                    return "ImageBlockEditing"
                }
                init() {
                    const t = this.editor;
                    t.model.schema.register("imageBlock", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["alt", "src", "srcset"]
                    }), this._setupConversion(), t.plugins.has("ImageInlineEditing") && (t.commands.add("imageTypeBlock", new $b(this.editor, "imageBlock")), this._setupClipboardIntegration())
                }
                _setupConversion() {
                    const t = this.editor,
                        e = t.t,
                        n = t.conversion,
                        o = t.plugins.get("ImageUtils");
                    n.for("dataDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (t, {
                            writer: e
                        }) => Db(e)
                    }), n.for("editingDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (t, {
                            writer: n
                        }) => o.toImageWidget(Db(n), n, e("image widget"))
                    }), n.for("downcast").add(Hb(o, "imageBlock", "src")).add(Hb(o, "imageBlock", "alt")).add(Vb(o, "imageBlock")), n.for("upcast").elementToElement({
                        view: Ib(t, "imageBlock"),
                        model: (t, {
                            writer: e
                        }) => e.createElement("imageBlock", t.hasAttribute("src") ? {
                            src: t.getAttribute("src")
                        } : null)
                    }).add(function(t) {
                        return t => {
                            t.on("element:figure", e)
                        };
    
                        function e(e, n, o) {
                            if (!o.consumable.test(n.viewItem, {
                                    name: !0,
                                    classes: "image"
                                })) return;
                            const i = t.findViewImgElement(n.viewItem);
                            if (!i || !o.consumable.test(i, {
                                    name: !0
                                })) return;
                            o.consumable.consume(n.viewItem, {
                                name: !0,
                                classes: "image"
                            });
                            const r = gr(o.convertItem(i, n.modelCursor).modelRange.getItems());
                            r ? (o.convertChildren(n.viewItem, r), o.updateConversionResult(r, n)) : o.consumable.revert(n.viewItem, {
                                name: !0,
                                classes: "image"
                            })
                        }
                    }(o))
                }
                _setupClipboardIntegration() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = t.plugins.get("ImageUtils");
                    this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((i, r) => {
                        const s = Array.from(r.content.getChildren());
                        let a;
                        if (!s.every(o.isInlineImageView)) return;
                        a = r.targetRanges ? t.editing.mapper.toModelRange(r.targetRanges[0]) : e.document.selection.getFirstRange();
                        const c = e.createSelection(a);
                        if ("imageBlock" === Tb(e.schema, c)) {
                            const t = new Tg(n.document),
                                e = s.map((e => t.createElement("figure", {
                                    class: "image"
                                }, e)));
                            r.content = t.createDocumentFragment(e)
                        }
                    }))
                }
            }
            var Kb = n(3508),
                Qb = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Kb.Z, Qb);
            Kb.Z.locals;
            class Zb extends vs {
                static get requires() {
                    return [Yb, Nf, Fb]
                }
                static get pluginName() {
                    return "ImageBlock"
                }
            }
            class Jb extends vs {
                static get requires() {
                    return [Gb, Mb, hp]
                }
                static get pluginName() {
                    return "ImageInlineEditing"
                }
                init() {
                    const t = this.editor,
                        e = t.model.schema;
                    e.register("imageInline", {
                        inheritAllFrom: "$inlineObject",
                        allowAttributes: ["alt", "src", "srcset"]
                    }), e.addChildCheck(((t, e) => {
                        if (t.endsWith("caption") && "imageInline" === e.name) return !1
                    })), this._setupConversion(), t.plugins.has("ImageBlockEditing") && (t.commands.add("imageTypeInline", new $b(this.editor, "imageInline")), this._setupClipboardIntegration())
                }
                _setupConversion() {
                    const t = this.editor,
                        e = t.t,
                        n = t.conversion,
                        o = t.plugins.get("ImageUtils");
                    n.for("dataDowncast").elementToElement({
                        model: "imageInline",
                        view: (t, {
                            writer: e
                        }) => e.createEmptyElement("img")
                    }), n.for("editingDowncast").elementToStructure({
                        model: "imageInline",
                        view: (t, {
                            writer: n
                        }) => o.toImageWidget(function(t) {
                            return t.createContainerElement("span", {
                                class: "image-inline"
                            }, t.createEmptyElement("img"))
                        }(n), n, e("image widget"))
                    }), n.for("downcast").add(Hb(o, "imageInline", "src")).add(Hb(o, "imageInline", "alt")).add(Vb(o, "imageInline")), n.for("upcast").elementToElement({
                        view: Ib(t, "imageInline"),
                        model: (t, {
                            writer: e
                        }) => e.createElement("imageInline", t.hasAttribute("src") ? {
                            src: t.getAttribute("src")
                        } : null)
                    })
                }
                _setupClipboardIntegration() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view,
                        o = t.plugins.get("ImageUtils");
                    this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((i, r) => {
                        const s = Array.from(r.content.getChildren());
                        let a;
                        if (!s.every(o.isBlockImageView)) return;
                        a = r.targetRanges ? t.editing.mapper.toModelRange(r.targetRanges[0]) : e.document.selection.getFirstRange();
                        const c = e.createSelection(a);
                        if ("imageInline" === Tb(e.schema, c)) {
                            const t = new Tg(n.document),
                                e = s.map((e => 1 === e.childCount ? (Array.from(e.getAttributes()).forEach((n => t.setAttribute(...n, o.findViewImgElement(e)))), e.getChild(0)) : e));
                            r.content = t.createDocumentFragment(e)
                        }
                    }))
                }
            }
            class Xb extends vs {
                static get requires() {
                    return [Jb, Nf, Fb]
                }
                static get pluginName() {
                    return "ImageInline"
                }
            }
            class tw extends xs {
                refresh() {
                    const t = this.editor,
                        e = t.plugins.get("ImageCaptionUtils");
                    if (!t.plugins.has(Yb)) return this.isEnabled = !1, void(this.value = !1);
                    const n = t.model.document.selection,
                        o = n.getSelectedElement();
                    if (!o) {
                        const t = e.getCaptionFromModelSelection(n);
                        return this.isEnabled = !!t, void(this.value = !!t)
                    }
                    this.isEnabled = this.editor.plugins.get("ImageUtils").isImage(o), this.isEnabled ? this.value = !!e.getCaptionFromImageModelElement(o) : this.value = !1
                }
                execute(t = {}) {
                    const {
                        focusCaptionOnShow: e
                    } = t;
                    this.editor.model.change((t => {
                        this.value ? this._hideImageCaption(t) : this._showImageCaption(t, e)
                    }))
                }
                _showImageCaption(t, e) {
                    const n = this.editor.model.document.selection,
                        o = this.editor.plugins.get("ImageCaptionEditing");
                    let i = n.getSelectedElement();
                    const r = o._getSavedCaption(i);
                    this.editor.plugins.get("ImageUtils").isInlineImage(i) && (this.editor.execute("imageTypeBlock"), i = n.getSelectedElement());
                    const s = r || t.createElement("caption");
                    t.append(s, i), e && t.setSelection(s, "in")
                }
                _hideImageCaption(t) {
                    const e = this.editor,
                        n = e.model.document.selection,
                        o = e.plugins.get("ImageCaptionEditing"),
                        i = e.plugins.get("ImageCaptionUtils");
                    let r, s = n.getSelectedElement();
                    s ? r = i.getCaptionFromImageModelElement(s) : (r = i.getCaptionFromModelSelection(n), s = r.parent), o._saveCaption(s, r), t.setSelection(s, "on"), t.remove(r)
                }
            }
            class ew extends vs {
                static get pluginName() {
                    return "ImageCaptionUtils"
                }
                static get requires() {
                    return [Mb]
                }
                getCaptionFromImageModelElement(t) {
                    for (const e of t.getChildren())
                        if (e && e.is("element", "caption")) return e;
                    return null
                }
                getCaptionFromModelSelection(t) {
                    const e = this.editor.plugins.get("ImageUtils"),
                        n = t.getFirstPosition().findAncestor("caption");
                    return n && e.isBlockImage(n.parent) ? n : null
                }
                matchImageCaptionViewElement(t) {
                    const e = this.editor.plugins.get("ImageUtils");
                    return "figcaption" == t.name && e.isBlockImageView(t.parent) ? {
                        name: !0
                    } : null
                }
            }
            class nw extends vs {
                static get requires() {
                    return [Mb, ew]
                }
                static get pluginName() {
                    return "ImageCaptionEditing"
                }
                constructor(t) {
                    super(t), this._savedCaptionsMap = new WeakMap
                }
                init() {
                    const t = this.editor,
                        e = t.model.schema;
                    e.isRegistered("caption") ? e.extend("caption", {
                        allowIn: "imageBlock"
                    }) : e.register("caption", {
                        allowIn: "imageBlock",
                        allowContentOf: "$block",
                        isLimit: !0
                    }), t.commands.add("toggleImageCaption", new tw(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion()
                }
                _setupConversion() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = t.plugins.get("ImageUtils"),
                        o = t.plugins.get("ImageCaptionUtils"),
                        i = t.t;
                    t.conversion.for("upcast").elementToElement({
                        view: t => o.matchImageCaptionViewElement(t),
                        model: "caption"
                    }), t.conversion.for("dataDowncast").elementToElement({
                        model: "caption",
                        view: (t, {
                            writer: e
                        }) => n.isBlockImage(t.parent) ? e.createContainerElement("figcaption") : null
                    }), t.conversion.for("editingDowncast").elementToElement({
                        model: "caption",
                        view: (t, {
                            writer: o
                        }) => {
                            if (!n.isBlockImage(t.parent)) return null;
                            const r = o.createEditableElement("figcaption");
                            o.setCustomProperty("imageCaption", !0, r), Ps({
                                view: e,
                                element: r,
                                text: i("Enter image caption"),
                                keepOnFocus: !0
                            });
                            const s = t.parent.getAttribute("alt");
                            return pf(r, o, {
                                label: s ? i("Caption for image: %0", [s]) : i("Caption for the image")
                            })
                        }
                    })
                }
                _setupImageTypeCommandsIntegration() {
                    const t = this.editor,
                        e = t.plugins.get("ImageUtils"),
                        n = t.plugins.get("ImageCaptionUtils"),
                        o = t.commands.get("imageTypeInline"),
                        i = t.commands.get("imageTypeBlock"),
                        r = t => {
                            if (!t.return) return;
                            const {
                                oldElement: o,
                                newElement: i
                            } = t.return;
                            if (!o) return;
                            if (e.isBlockImage(o)) {
                                const t = n.getCaptionFromImageModelElement(o);
                                if (t) return void this._saveCaption(i, t)
                            }
                            const r = this._getSavedCaption(o);
                            r && this._saveCaption(i, r)
                        };
                    o && this.listenTo(o, "execute", r, {
                        priority: "low"
                    }), i && this.listenTo(i, "execute", r, {
                        priority: "low"
                    })
                }
                _getSavedCaption(t) {
                    const e = this._savedCaptionsMap.get(t);
                    return e ? Pd.fromJSON(e) : null
                }
                _saveCaption(t, e) {
                    this._savedCaptionsMap.set(t, e.toJSON())
                }
                _registerCaptionReconversion() {
                    const t = this.editor,
                        e = t.model,
                        n = t.plugins.get("ImageUtils"),
                        o = t.plugins.get("ImageCaptionUtils");
                    e.document.on("change:data", (() => {
                        const i = e.document.differ.getChanges();
                        for (const e of i) {
                            if ("alt" !== e.attributeKey) continue;
                            const i = e.range.start.nodeAfter;
                            if (n.isBlockImage(i)) {
                                const e = o.getCaptionFromImageModelElement(i);
                                if (!e) return;
                                t.editing.reconvertItem(e)
                            }
                        }
                    }))
                }
            }
            class ow extends vs {
                static get requires() {
                    return [ew]
                }
                static get pluginName() {
                    return "ImageCaptionUI"
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view,
                        n = t.plugins.get("ImageCaptionUtils"),
                        o = t.t;
                    t.ui.componentFactory.add("toggleImageCaption", (i => {
                        const r = t.commands.get("toggleImageCaption"),
                            s = new es(i);
                        return s.set({
                            icon: Lg.caption,
                            tooltip: !0,
                            isToggleable: !0
                        }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.bind("label").to(r, "value", (t => o(t ? "Toggle caption off" : "Toggle caption on"))), this.listenTo(s, "execute", (() => {
                            t.execute("toggleImageCaption", {
                                focusCaptionOnShow: !0
                            });
                            const o = n.getCaptionFromModelSelection(t.model.document.selection);
                            if (o) {
                                const n = t.editing.mapper.toViewElement(o);
                                e.scrollToTheSelection(), e.change((t => {
                                    t.addClass("image__caption_highlighted", n)
                                }))
                            }
                            t.editing.view.focus()
                        })), s
                    }))
                }
            }
            var iw = n(2640),
                rw = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(iw.Z, rw);
            iw.Z.locals;
            class sw extends xs {
                constructor(t, e) {
                    super(t), this._defaultStyles = {
                        imageBlock: !1,
                        imageInline: !1
                    }, this._styles = new Map(e.map((t => {
                        if (t.isDefault)
                            for (const e of t.modelElements) this._defaultStyles[e] = t.name;
                        return [t.name, t]
                    })))
                }
                refresh() {
                    const t = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!t, this.isEnabled ? t.hasAttribute("imageStyle") ? this.value = t.getAttribute("imageStyle") : this.value = this._defaultStyles[t.name] : this.value = !1
                }
                execute(t = {}) {
                    const e = this.editor,
                        n = e.model,
                        o = e.plugins.get("ImageUtils");
                    n.change((e => {
                        const i = t.value;
                        let r = o.getClosestSelectedImageElement(n.document.selection);
                        i && this.shouldConvertImageType(i, r) && (this.editor.execute(o.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"), r = o.getClosestSelectedImageElement(n.document.selection)), !i || this._styles.get(i).isDefault ? e.removeAttribute("imageStyle", r) : e.setAttribute("imageStyle", i, r)
                    }))
                }
                shouldConvertImageType(t, e) {
                    return !this._styles.get(t).modelElements.includes(e.name)
                }
            }
            const {
                objectFullWidth: aw,
                objectInline: cw,
                objectLeft: lw,
                objectRight: dw,
                objectCenter: hw,
                objectBlockLeft: uw,
                objectBlockRight: gw
            } = Lg, mw = {
                get inline() {
                    return {
                        name: "inline",
                        title: "In line",
                        icon: cw,
                        modelElements: ["imageInline"],
                        isDefault: !0
                    }
                },
                get alignLeft() {
                    return {
                        name: "alignLeft",
                        title: "Left aligned image",
                        icon: lw,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-left"
                    }
                },
                get alignBlockLeft() {
                    return {
                        name: "alignBlockLeft",
                        title: "Left aligned image",
                        icon: uw,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-left"
                    }
                },
                get alignCenter() {
                    return {
                        name: "alignCenter",
                        title: "Centered image",
                        icon: hw,
                        modelElements: ["imageBlock"],
                        className: "image-style-align-center"
                    }
                },
                get alignRight() {
                    return {
                        name: "alignRight",
                        title: "Right aligned image",
                        icon: dw,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-right"
                    }
                },
                get alignBlockRight() {
                    return {
                        name: "alignBlockRight",
                        title: "Right aligned image",
                        icon: gw,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-right"
                    }
                },
                get block() {
                    return {
                        name: "block",
                        title: "Centered image",
                        icon: hw,
                        modelElements: ["imageBlock"],
                        isDefault: !0
                    }
                },
                get side() {
                    return {
                        name: "side",
                        title: "Side image",
                        icon: dw,
                        modelElements: ["imageBlock"],
                        className: "image-style-side"
                    }
                }
            }, pw = {
                full: aw,
                left: uw,
                right: gw,
                center: hw,
                inlineLeft: lw,
                inlineRight: dw,
                inline: cw
            }, fw = [{
                name: "imageStyle:wrapText",
                title: "Wrap text",
                defaultItem: "imageStyle:alignLeft",
                items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
            }, {
                name: "imageStyle:breakText",
                title: "Break text",
                defaultItem: "imageStyle:block",
                items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
            }];
    
            function kw(t) {
                C("image-style-configuration-definition-invalid", t)
            }
            const bw = {
                normalizeStyles: function(t) {
                    return (t.configuredStyles.options || []).map((t => function(t) {
                        t = "string" == typeof t ? mw[t] ? {
                            ...mw[t]
                        } : {
                            name: t
                        } : function(t, e) {
                            const n = {
                                ...e
                            };
                            for (const o in t) Object.prototype.hasOwnProperty.call(e, o) || (n[o] = t[o]);
                            return n
                        }(mw[t.name], t);
                        "string" == typeof t.icon && (t.icon = pw[t.icon] || t.icon);
                        return t
                    }(t))).filter((e => function(t, {
                        isBlockPluginLoaded: e,
                        isInlinePluginLoaded: n
                    }) {
                        const {
                            modelElements: o,
                            name: i
                        } = t;
                        if (!(o && o.length && i)) return kw({
                            style: t
                        }), !1;
                        {
                            const i = [e ? "imageBlock" : null, n ? "imageInline" : null];
                            if (!o.some((t => i.includes(t)))) return C("image-style-missing-dependency", {
                                style: t,
                                missingPlugins: o.map((t => "imageBlock" === t ? "ImageBlockEditing" : "ImageInlineEditing"))
                            }), !1
                        }
                        return !0
                    }(e, t)))
                },
                getDefaultStylesConfiguration: function(t, e) {
                    return t && e ? {
                        options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]
                    } : t ? {
                        options: ["block", "side"]
                    } : e ? {
                        options: ["inline", "alignLeft", "alignRight"]
                    } : {}
                },
                getDefaultDropdownDefinitions: function(t) {
                    return t.has("ImageBlockEditing") && t.has("ImageInlineEditing") ? [...fw] : []
                },
                warnInvalidStyle: kw,
                DEFAULT_OPTIONS: mw,
                DEFAULT_ICONS: pw,
                DEFAULT_DROPDOWN_DEFINITIONS: fw
            };
    
            function ww(t, e) {
                for (const n of e)
                    if (n.name === t) return n
            }
            class _w extends vs {
                static get pluginName() {
                    return "ImageStyleEditing"
                }
                static get requires() {
                    return [Mb]
                }
                init() {
                    const {
                        normalizeStyles: t,
                        getDefaultStylesConfiguration: e
                    } = bw, n = this.editor, o = n.plugins.has("ImageBlockEditing"), i = n.plugins.has("ImageInlineEditing");
                    n.config.define("image.styles", e(o, i)), this.normalizedStyles = t({
                        configuredStyles: n.config.get("image.styles"),
                        isBlockPluginLoaded: o,
                        isInlinePluginLoaded: i
                    }), this._setupConversion(o, i), this._setupPostFixer(), n.commands.add("imageStyle", new sw(n, this.normalizedStyles))
                }
                _setupConversion(t, e) {
                    const n = this.editor,
                        o = n.model.schema,
                        i = (r = this.normalizedStyles, (t, e, n) => {
                            if (!n.consumable.consume(e.item, t.name)) return;
                            const o = ww(e.attributeNewValue, r),
                                i = ww(e.attributeOldValue, r),
                                s = n.mapper.toViewElement(e.item),
                                a = n.writer;
                            i && a.removeClass(i.className, s), o && a.addClass(o.className, s)
                        });
                    var r;
                    const s = function(t) {
                        const e = {
                            imageInline: t.filter((t => !t.isDefault && t.modelElements.includes("imageInline"))),
                            imageBlock: t.filter((t => !t.isDefault && t.modelElements.includes("imageBlock")))
                        };
                        return (t, n, o) => {
                            if (!n.modelRange) return;
                            const i = n.viewItem,
                                r = gr(n.modelRange.getItems());
                            if (r && o.schema.checkAttribute(r, "imageStyle"))
                                for (const t of e[r.name]) o.consumable.consume(i, {
                                    classes: t.className
                                }) && o.writer.setAttribute("imageStyle", t.name, r)
                        }
                    }(this.normalizedStyles);
                    n.editing.downcastDispatcher.on("attribute:imageStyle", i), n.data.downcastDispatcher.on("attribute:imageStyle", i), t && (o.extend("imageBlock", {
                        allowAttributes: "imageStyle"
                    }), n.data.upcastDispatcher.on("element:figure", s, {
                        priority: "low"
                    })), e && (o.extend("imageInline", {
                        allowAttributes: "imageStyle"
                    }), n.data.upcastDispatcher.on("element:img", s, {
                        priority: "low"
                    }))
                }
                _setupPostFixer() {
                    const t = this.editor,
                        e = t.model.document,
                        n = t.plugins.get(Mb),
                        o = new Map(this.normalizedStyles.map((t => [t.name, t])));
                    e.registerPostFixer((t => {
                        let i = !1;
                        for (const r of e.differ.getChanges())
                            if ("insert" == r.type || "attribute" == r.type && "imageStyle" == r.attributeKey) {
                                let e = "insert" == r.type ? r.position.nodeAfter : r.range.start.nodeAfter;
                                if (e && e.is("element", "paragraph") && e.childCount > 0 && (e = e.getChild(0)), !n.isImage(e)) continue;
                                const s = e.getAttribute("imageStyle");
                                if (!s) continue;
                                const a = o.get(s);
                                a && a.modelElements.includes(e.name) || (t.removeAttribute("imageStyle", e), i = !0)
                            } return i
                    }))
                }
            }
            var Aw = n(5083),
                Cw = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Aw.Z, Cw);
            Aw.Z.locals;
            class vw extends vs {
                static get requires() {
                    return [_w]
                }
                static get pluginName() {
                    return "ImageStyleUI"
                }
                get localizedDefaultStylesTitles() {
                    const t = this.editor.t;
                    return {
                        "Wrap text": t("Wrap text"),
                        "Break text": t("Break text"),
                        "In line": t("In line"),
                        "Full size image": t("Full size image"),
                        "Side image": t("Side image"),
                        "Left aligned image": t("Left aligned image"),
                        "Centered image": t("Centered image"),
                        "Right aligned image": t("Right aligned image")
                    }
                }
                init() {
                    const t = this.editor.plugins,
                        e = this.editor.config.get("image.toolbar") || [],
                        n = yw(t.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
                    for (const t of n) this._createButton(t);
                    const o = yw([...e.filter(F), ...bw.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles);
                    for (const t of o) this._createDropdown(t, n)
                }
                _createDropdown(t, e) {
                    const n = this.editor.ui.componentFactory;
                    n.add(t.name, (o => {
                        let i;
                        const {
                            defaultItem: r,
                            items: s,
                            title: a
                        } = t, c = s.filter((t => e.find((({
                            name: e
                        }) => xw(e) === t)))).map((t => {
                            const e = n.create(t);
                            return t === r && (i = e), e
                        }));
                        s.length !== c.length && bw.warnInvalidStyle({
                            dropdown: t
                        });
                        const l = tm(o, fs),
                            d = l.buttonView,
                            h = d.arrowView;
                        return em(l, c, {
                            enableActiveItemFocusOnDropdownOpen: !0
                        }), d.set({
                            label: Ew(a, i.label),
                            class: null,
                            tooltip: !0
                        }), h.unbind("label"), h.set({
                            label: a
                        }), d.bind("icon").toMany(c, "isOn", ((...t) => {
                            const e = t.findIndex(Ma);
                            return e < 0 ? i.icon : c[e].icon
                        })), d.bind("label").toMany(c, "isOn", ((...t) => {
                            const e = t.findIndex(Ma);
                            return Ew(a, e < 0 ? i.label : c[e].label)
                        })), d.bind("isOn").toMany(c, "isOn", ((...t) => t.some(Ma))), d.bind("class").toMany(c, "isOn", ((...t) => t.some(Ma) ? "ck-splitbutton_flatten" : null)), d.on("execute", (() => {
                            c.some((({
                                isOn: t
                            }) => t)) ? l.isOpen = !l.isOpen : i.fire("execute")
                        })), l.bind("isEnabled").toMany(c, "isEnabled", ((...t) => t.some(Ma))), this.listenTo(l, "execute", (() => {
                            this.editor.editing.view.focus()
                        })), l
                    }))
                }
                _createButton(t) {
                    const e = t.name;
                    this.editor.ui.componentFactory.add(xw(e), (n => {
                        const o = this.editor.commands.get("imageStyle"),
                            i = new es(n);
                        return i.set({
                            label: t.title,
                            icon: t.icon,
                            tooltip: !0,
                            isToggleable: !0
                        }), i.bind("isEnabled").to(o, "isEnabled"), i.bind("isOn").to(o, "value", (t => t === e)), i.on("execute", this._executeCommand.bind(this, e)), i
                    }))
                }
                _executeCommand(t) {
                    this.editor.execute("imageStyle", {
                        value: t
                    }), this.editor.editing.view.focus()
                }
            }
    
            function yw(t, e) {
                for (const n of t) e[n.title] && (n.title = e[n.title]);
                return t
            }
    
            function xw(t) {
                return `imageStyle:${t}`
            }
    
            function Ew(t, e) {
                return (t ? t + ": " : "") + e
            }
    
            function Dw(t) {
                const e = t.map((t => t.replace("+", "\\+")));
                return new RegExp(`^image\\/(${e.join("|")})$`)
            }
    
            function Iw(t) {
                return new Promise(((e, n) => {
                    const o = t.getAttribute("src");
                    fetch(o).then((t => t.blob())).then((t => {
                        const n = Tw(t, o),
                            i = n.replace("image/", ""),
                            r = new File([t], `image.${i}`, {
                                type: n
                            });
                        e(r)
                    })).catch((t => t && "TypeError" === t.name ? function(t) {
                        return function(t) {
                            return new Promise(((e, n) => {
                                const o = vi.document.createElement("img");
                                o.addEventListener("load", (() => {
                                    const t = vi.document.createElement("canvas");
                                    t.width = o.width, t.height = o.height;
                                    t.getContext("2d").drawImage(o, 0, 0), t.toBlob((t => t ? e(t) : n()))
                                })), o.addEventListener("error", (() => n())), o.src = t
                            }))
                        }(t).then((e => {
                            const n = Tw(e, t),
                                o = n.replace("image/", "");
                            return new File([e], `image.${o}`, {
                                type: n
                            })
                        }))
                    }(o).then(e).catch(n) : n(t)))
                }))
            }
    
            function Tw(t, e) {
                return t.type ? t.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg"
            }
            class Mw extends vs {
                static get pluginName() {
                    return "ImageUploadUI"
                }
                init() {
                    const t = this.editor,
                        e = t.t,
                        n = n => {
                            const o = new kk(n),
                                i = t.commands.get("uploadImage"),
                                r = t.config.get("image.upload.types"),
                                s = Dw(r);
                            return o.set({
                                acceptedType: r.map((t => `image/${t}`)).join(","),
                                allowMultipleFiles: !0
                            }), o.buttonView.set({
                                label: e("Insert image"),
                                icon: Lg.image,
                                tooltip: !0
                            }), o.buttonView.bind("isEnabled").to(i), o.on("done", ((e, n) => {
                                const o = Array.from(n).filter((t => s.test(t.type)));
                                o.length && (t.execute("uploadImage", {
                                    file: o
                                }), t.editing.view.focus())
                            })), o
                        };
                    t.ui.componentFactory.add("uploadImage", n), t.ui.componentFactory.add("imageUpload", n)
                }
            }
            var Sw = n(3689),
                Nw = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Sw.Z, Nw);
            Sw.Z.locals;
            var Bw = n(4036),
                Pw = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Bw.Z, Pw);
            Bw.Z.locals;
            var zw = n(3773),
                Lw = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(zw.Z, Lw);
            zw.Z.locals;
            class Ow extends vs {
                static get pluginName() {
                    return "ImageUploadProgress"
                }
                constructor(t) {
                    super(t), this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                }
                init() {
                    const t = this.editor;
                    t.plugins.has("ImageBlockEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", ((...t) => this.uploadStatusChange(...t))), t.plugins.has("ImageInlineEditing") && t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", ((...t) => this.uploadStatusChange(...t)))
                }
                uploadStatusChange(t, e, n) {
                    const o = this.editor,
                        i = e.item,
                        r = i.getAttribute("uploadId");
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const s = o.plugins.get("ImageUtils"),
                        a = o.plugins.get(pk),
                        c = r ? e.attributeNewValue : null,
                        l = this.placeholder,
                        d = o.editing.mapper.toViewElement(i),
                        h = n.writer;
                    if ("reading" == c) return Rw(d, h), void jw(s, l, d, h);
                    if ("uploading" == c) {
                        const t = a.loaders.get(r);
                        return Rw(d, h), void(t ? (Fw(d, h), function(t, e, n, o) {
                            const i = function(t) {
                                const e = t.createUIElement("div", {
                                    class: "ck-progress-bar"
                                });
                                return t.setCustomProperty("progressBar", !0, e), e
                            }(e);
                            e.insert(e.createPositionAt(t, "end"), i), n.on("change:uploadedPercent", ((t, e, n) => {
                                o.change((t => {
                                    t.setStyle("width", n + "%", i)
                                }))
                            }))
                        }(d, h, t, o.editing.view), function(t, e, n, o) {
                            if (o.data) {
                                const i = t.findViewImgElement(e);
                                n.setAttribute("src", o.data, i)
                            }
                        }(s, d, h, t)) : jw(s, l, d, h))
                    }
                    "complete" == c && a.loaders.get(r) && function(t, e, n) {
                            const o = e.createUIElement("div", {
                                class: "ck-image-upload-complete-icon"
                            });
                            e.insert(e.createPositionAt(t, "end"), o), setTimeout((() => {
                                n.change((t => t.remove(t.createRangeOn(o))))
                            }), 3e3)
                        }(d, h, o.editing.view),
                        function(t, e) {
                            Hw(t, e, "progressBar")
                        }(d, h), Fw(d, h),
                        function(t, e) {
                            e.removeClass("ck-appear", t)
                        }(d, h)
                }
            }
    
            function Rw(t, e) {
                t.hasClass("ck-appear") || e.addClass("ck-appear", t)
            }
    
            function jw(t, e, n, o) {
                n.hasClass("ck-image-upload-placeholder") || o.addClass("ck-image-upload-placeholder", n);
                const i = t.findViewImgElement(n);
                i.getAttribute("src") !== e && o.setAttribute("src", e, i), Vw(n, "placeholder") || o.insert(o.createPositionAfter(i), function(t) {
                    const e = t.createUIElement("div", {
                        class: "ck-upload-placeholder-loader"
                    });
                    return t.setCustomProperty("placeholder", !0, e), e
                }(o))
            }
    
            function Fw(t, e) {
                t.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", t), Hw(t, e, "placeholder")
            }
    
            function Vw(t, e) {
                for (const n of t.getChildren())
                    if (n.getCustomProperty(e)) return n
            }
    
            function Hw(t, e, n) {
                const o = Vw(t, n);
                o && e.remove(e.createRangeOn(o))
            }
            class Uw extends xs {
                refresh() {
                    const t = this.editor,
                        e = t.plugins.get("ImageUtils"),
                        n = t.model.document.selection.getSelectedElement();
                    this.isEnabled = e.isImageAllowed() || e.isImage(n)
                }
                execute(t) {
                    const e = ar(t.file),
                        n = this.editor.model.document.selection,
                        o = this.editor.plugins.get("ImageUtils"),
                        i = Object.fromEntries(n.getAttributes());
                    e.forEach(((t, e) => {
                        const r = n.getSelectedElement();
                        if (e && r && o.isImage(r)) {
                            const e = this.editor.model.createPositionAfter(r);
                            this._uploadImage(t, i, e)
                        } else this._uploadImage(t, i)
                    }))
                }
                _uploadImage(t, e, n) {
                    const o = this.editor,
                        i = o.plugins.get(pk).createLoader(t),
                        r = o.plugins.get("ImageUtils");
                    i && r.insertImage({
                        ...e,
                        uploadId: i.id
                    }, n)
                }
            }
            class Ww extends vs {
                static get requires() {
                    return [pk, jm, hp, Mb]
                }
                static get pluginName() {
                    return "ImageUploadEditing"
                }
                constructor(t) {
                    super(t), t.config.define("image", {
                        upload: {
                            types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
                        }
                    }), this._uploadImageElements = new Map
                }
                init() {
                    const t = this.editor,
                        e = t.model.document,
                        n = t.conversion,
                        o = t.plugins.get(pk),
                        i = t.plugins.get("ImageUtils"),
                        r = Dw(t.config.get("image.upload.types")),
                        s = new Uw(t);
                    t.commands.add("uploadImage", s), t.commands.add("imageUpload", s), n.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "uploadId"
                        },
                        model: "uploadId"
                    }), this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                        if (o = n.dataTransfer, Array.from(o.types).includes("text/html") && "" !== o.getData("text/html")) return;
                        var o;
                        const i = Array.from(n.dataTransfer.files).filter((t => !!t && r.test(t.type)));
                        i.length && (e.stop(), t.model.change((e => {
                            n.targetRanges && e.setSelection(n.targetRanges.map((e => t.editing.mapper.toModelRange(e)))), t.model.enqueueChange((() => {
                                t.execute("uploadImage", {
                                    file: i
                                })
                            }))
                        })))
                    })), this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", ((e, n) => {
                        const r = Array.from(t.editing.view.createRangeIn(n.content)).filter((t => function(t, e) {
                            return !(!t.isInlineImageView(e) || !e.getAttribute("src")) && (e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || e.getAttribute("src").match(/^blob:/g))
                        }(i, t.item) && !t.item.getAttribute("uploadProcessed"))).map((t => ({
                            promise: Iw(t.item),
                            imageElement: t.item
                        })));
                        if (!r.length) return;
                        const s = new Tg(t.editing.view.document);
                        for (const t of r) {
                            s.setAttribute("uploadProcessed", !0, t.imageElement);
                            const e = o.createLoader(t.promise);
                            e && (s.setAttribute("src", "", t.imageElement), s.setAttribute("uploadId", e.id, t.imageElement))
                        }
                    })), t.editing.view.document.on("dragover", ((t, e) => {
                        e.preventDefault()
                    })), e.on("change", (() => {
                        const n = e.differ.getChanges({
                                includeChangesInGraveyard: !0
                            }).reverse(),
                            i = new Set;
                        for (const e of n)
                            if ("insert" == e.type && "$text" != e.name) {
                                const n = e.position.nodeAfter,
                                    r = "$graveyard" == e.position.root.rootName;
                                for (const e of qw(t, n)) {
                                    const t = e.getAttribute("uploadId");
                                    if (!t) continue;
                                    const n = o.loaders.get(t);
                                    n && (r ? i.has(t) || n.abort() : (i.add(t), this._uploadImageElements.set(t, e), "idle" == n.status && this._readAndUpload(n)))
                                }
                            }
                    })), this.on("uploadComplete", ((t, {
                        imageElement: e,
                        data: n
                    }) => {
                        const o = n.urls ? n.urls : n;
                        this.editor.model.change((t => {
                            t.setAttribute("src", o.default, e), this._parseAndSetSrcsetAttributeOnImage(o, e, t)
                        }))
                    }), {
                        priority: "low"
                    })
                }
                afterInit() {
                    const t = this.editor.model.schema;
                    this.editor.plugins.has("ImageBlockEditing") && t.extend("imageBlock", {
                        allowAttributes: ["uploadId", "uploadStatus"]
                    }), this.editor.plugins.has("ImageInlineEditing") && t.extend("imageInline", {
                        allowAttributes: ["uploadId", "uploadStatus"]
                    })
                }
                _readAndUpload(t) {
                    const e = this.editor,
                        n = e.model,
                        o = e.locale.t,
                        i = e.plugins.get(pk),
                        r = e.plugins.get(jm),
                        s = e.plugins.get("ImageUtils"),
                        c = this._uploadImageElements;
                    return n.enqueueChange({
                        isUndoable: !1
                    }, (e => {
                        e.setAttribute("uploadStatus", "reading", c.get(t.id))
                    })), t.read().then((() => {
                        const o = t.upload(),
                            i = c.get(t.id);
                        if (a.isSafari) {
                            const t = e.editing.mapper.toViewElement(i),
                                n = s.findViewImgElement(t);
                            e.editing.view.once("render", (() => {
                                if (!n.parent) return;
                                const t = e.editing.view.domConverter.mapViewToDom(n.parent);
                                if (!t) return;
                                const o = t.style.display;
                                t.style.display = "none", t._ckHack = t.offsetHeight, t.style.display = o
                            }))
                        }
                        return n.enqueueChange({
                            isUndoable: !1
                        }, (t => {
                            t.setAttribute("uploadStatus", "uploading", i)
                        })), o
                    })).then((e => {
                        n.enqueueChange({
                            isUndoable: !1
                        }, (n => {
                            const o = c.get(t.id);
                            n.setAttribute("uploadStatus", "complete", o), this.fire("uploadComplete", {
                                data: e,
                                imageElement: o
                            })
                        })), l()
                    })).catch((e => {
                        if ("error" !== t.status && "aborted" !== t.status) throw e;
                        "error" == t.status && e && r.showWarning(e, {
                            title: o("Upload failed"),
                            namespace: "upload"
                        }), n.enqueueChange({
                            isUndoable: !1
                        }, (e => {
                            e.remove(c.get(t.id))
                        })), l()
                    }));
    
                    function l() {
                        n.enqueueChange({
                            isUndoable: !1
                        }, (e => {
                            const n = c.get(t.id);
                            e.removeAttribute("uploadId", n), e.removeAttribute("uploadStatus", n), c.delete(t.id)
                        })), i.destroyLoader(t)
                    }
                }
                _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                    let o = 0;
                    const i = Object.keys(t).filter((t => {
                        const e = parseInt(t, 10);
                        if (!isNaN(e)) return o = Math.max(o, e), !0
                    })).map((e => `${t[e]} ${e}w`)).join(", ");
                    "" != i && n.setAttribute("srcset", {
                        data: i,
                        width: o
                    }, e)
                }
            }
    
            function qw(t, e) {
                const n = t.plugins.get("ImageUtils");
                return Array.from(t.model.createRangeOn(e)).filter((t => n.isImage(t.item))).map((t => t.item))
            }
            class Gw extends vs {
                static get pluginName() {
                    return "IndentEditing"
                }
                init() {
                    const t = this.editor;
                    t.commands.add("indent", new Ds(t)), t.commands.add("outdent", new Ds(t))
                }
            }
            const $w = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
                Yw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
            class Kw extends vs {
                static get pluginName() {
                    return "IndentUI"
                }
                init() {
                    const t = this.editor,
                        e = t.locale,
                        n = t.t,
                        o = "ltr" == e.uiLanguageDirection ? $w : Yw,
                        i = "ltr" == e.uiLanguageDirection ? Yw : $w;
                    this._defineButton("indent", n("Increase indent"), o), this._defineButton("outdent", n("Decrease indent"), i)
                }
                _defineButton(t, e, n) {
                    const o = this.editor;
                    o.ui.componentFactory.add(t, (i => {
                        const r = o.commands.get(t),
                            s = new es(i);
                        return s.set({
                            label: e,
                            icon: n,
                            tooltip: !0
                        }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", (() => {
                            o.execute(t), o.editing.view.focus()
                        })), s
                    }))
                }
            }
            class Qw {
                constructor() {
                    this._definitions = new Set
                }
                get length() {
                    return this._definitions.size
                }
                add(t) {
                    Array.isArray(t) ? t.forEach((t => this._definitions.add(t))) : this._definitions.add(t)
                }
                getDispatcher() {
                    return t => {
                        t.on("attribute:linkHref", ((t, e, n) => {
                            if (!n.consumable.test(e.item, "attribute:linkHref")) return;
                            if (!e.item.is("selection") && !n.schema.isInline(e.item)) return;
                            const o = n.writer,
                                i = o.document.selection;
                            for (const t of this._definitions) {
                                const r = o.createAttributeElement("a", t.attributes, {
                                    priority: 5
                                });
                                t.classes && o.addClass(t.classes, r);
                                for (const e in t.styles) o.setStyle(e, t.styles[e], r);
                                o.setCustomProperty("link", !0, r), t.callback(e.attributeNewValue) ? e.item.is("selection") ? o.wrap(i.getFirstRange(), r) : o.wrap(n.mapper.toViewRange(e.range), r) : o.unwrap(n.mapper.toViewRange(e.range), r)
                            }
                        }), {
                            priority: "high"
                        })
                    }
                }
                getDispatcherForLinkedImage() {
                    return t => {
                        t.on("attribute:linkHref:imageBlock", ((t, e, {
                            writer: n,
                            mapper: o
                        }) => {
                            const i = o.toViewElement(e.item),
                                r = Array.from(i.getChildren()).find((t => "a" === t.name));
                            for (const t of this._definitions) {
                                const o = fr(t.attributes);
                                if (t.callback(e.attributeNewValue)) {
                                    for (const [t, e] of o) "class" === t ? n.addClass(e, r) : n.setAttribute(t, e, r);
                                    t.classes && n.addClass(t.classes, r);
                                    for (const e in t.styles) n.setStyle(e, t.styles[e], r)
                                } else {
                                    for (const [t, e] of o) "class" === t ? n.removeClass(e, r) : n.removeAttribute(t, r);
                                    t.classes && n.removeClass(t.classes, r);
                                    for (const e in t.styles) n.removeStyle(e, r)
                                }
                            }
                        }))
                    }
                }
            }
            const Zw = function(t, e, n) {
                var o = t.length;
                return n = void 0 === n ? o : n, !e && n >= o ? t : ba(t, e, n)
            };
            var Jw = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
            const Xw = function(t) {
                return Jw.test(t)
            };
            const t_ = function(t) {
                return t.split("")
            };
            var e_ = "\\ud800-\\udfff",
                n_ = "[" + e_ + "]",
                o_ = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
                i_ = "\\ud83c[\\udffb-\\udfff]",
                r_ = "[^" + e_ + "]",
                s_ = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                a_ = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                c_ = "(?:" + o_ + "|" + i_ + ")" + "?",
                l_ = "[\\ufe0e\\ufe0f]?",
                d_ = l_ + c_ + ("(?:\\u200d(?:" + [r_, s_, a_].join("|") + ")" + l_ + c_ + ")*"),
                h_ = "(?:" + [r_ + o_ + "?", o_, s_, a_, n_].join("|") + ")",
                u_ = RegExp(i_ + "(?=" + i_ + ")|" + h_ + d_, "g");
            const g_ = function(t) {
                return t.match(u_) || []
            };
            const m_ = function(t) {
                return Xw(t) ? g_(t) : t_(t)
            };
            const p_ = function(t) {
                    return function(e) {
                        e = ua(e);
                        var n = Xw(e) ? m_(e) : void 0,
                            o = n ? n[0] : e.charAt(0),
                            i = n ? Zw(n, 1).join("") : e.slice(1);
                        return o[t]() + i
                    }
                }("toUpperCase"),
                f_ = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
                k_ = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
                b_ = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
                w_ = /^((\w+:(\/{2,})?)|(\W))/i,
                __ = "Ctrl+K";
    
            function A_(t, {
                writer: e
            }) {
                const n = e.createAttributeElement("a", {
                    href: t
                }, {
                    priority: 5
                });
                return e.setCustomProperty("link", !0, n), n
            }
    
            function C_(t) {
                return function(t) {
                    const e = t.replace(f_, "");
                    return e.match(k_)
                }(t = String(t)) ? t : "#"
            }
    
            function v_(t, e) {
                return !!t && e.checkAttribute(t.name, "linkHref")
            }
    
            function y_(t, e) {
                const n = (o = t, b_.test(o) ? "mailto:" : e);
                var o;
                const i = !!n && !x_(t);
                return t && i ? n + t : t
            }
    
            function x_(t) {
                return w_.test(t)
            }
    
            function E_(t) {
                window.open(t, "_blank", "noopener")
            }
            class D_ extends xs {
                constructor(t) {
                    super(t), this.manualDecorators = new ur, this.automaticDecorators = new Qw
                }
                restoreManualDecoratorStates() {
                    for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id)
                }
                refresh() {
                    const t = this.editor.model,
                        e = t.document.selection,
                        n = e.getSelectedElement() || gr(e.getSelectedBlocks());
                    v_(n, t.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttribute(n, "linkHref")) : (this.value = e.getAttribute("linkHref"), this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref"));
                    for (const t of this.manualDecorators) t.value = this._getDecoratorStateFromModel(t.id)
                }
                execute(t, e = {}) {
                    const n = this.editor.model,
                        o = n.document.selection,
                        i = [],
                        r = [];
                    for (const t in e) e[t] ? i.push(t) : r.push(t);
                    n.change((e => {
                        if (o.isCollapsed) {
                            const s = o.getFirstPosition();
                            if (o.hasAttribute("linkHref")) {
                                const a = Wp(s, "linkHref", o.getAttribute("linkHref"), n);
                                e.setAttribute("linkHref", t, a), i.forEach((t => {
                                    e.setAttribute(t, !0, a)
                                })), r.forEach((t => {
                                    e.removeAttribute(t, a)
                                })), e.setSelection(e.createPositionAfter(a.end.nodeBefore))
                            } else if ("" !== t) {
                                const r = fr(o.getAttributes());
                                r.set("linkHref", t), i.forEach((t => {
                                    r.set(t, !0)
                                }));
                                const {
                                    end: a
                                } = n.insertContent(e.createText(t, r), s);
                                e.setSelection(a)
                            } ["linkHref", ...i, ...r].forEach((t => {
                                e.removeSelectionAttribute(t)
                            }))
                        } else {
                            const s = n.schema.getValidRanges(o.getRanges(), "linkHref"),
                                a = [];
                            for (const t of o.getSelectedBlocks()) n.schema.checkAttribute(t, "linkHref") && a.push(e.createRangeOn(t));
                            const c = a.slice();
                            for (const t of s) this._isRangeToUpdate(t, a) && c.push(t);
                            for (const n of c) e.setAttribute("linkHref", t, n), i.forEach((t => {
                                e.setAttribute(t, !0, n)
                            })), r.forEach((t => {
                                e.removeAttribute(t, n)
                            }))
                        }
                    }))
                }
                _getDecoratorStateFromModel(t) {
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = n.getSelectedElement();
                    return v_(o, e.schema) ? o.getAttribute(t) : n.getAttribute(t)
                }
                _isRangeToUpdate(t, e) {
                    for (const n of e)
                        if (n.containsRange(t)) return !1;
                    return !0
                }
            }
            class I_ extends xs {
                refresh() {
                    const t = this.editor.model,
                        e = t.document.selection,
                        n = e.getSelectedElement();
                    v_(n, t.schema) ? this.isEnabled = t.schema.checkAttribute(n, "linkHref") : this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref")
                }
                execute() {
                    const t = this.editor,
                        e = this.editor.model,
                        n = e.document.selection,
                        o = t.commands.get("link");
                    e.change((t => {
                        const i = n.isCollapsed ? [Wp(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref");
                        for (const e of i)
                            if (t.removeAttribute("linkHref", e), o)
                                for (const n of o.manualDecorators) t.removeAttribute(n.id, e)
                    }))
                }
            }
            class T_ {
                constructor({
                    id: t,
                    label: e,
                    attributes: n,
                    classes: o,
                    styles: i,
                    defaultValue: r
                }) {
                    this.id = t, this.set("value"), this.defaultValue = r, this.label = e, this.attributes = n, this.classes = o, this.styles = i
                }
                _createPattern() {
                    return {
                        attributes: this.attributes,
                        classes: this.classes,
                        styles: this.styles
                    }
                }
            }
            g(T_, $);
            var M_ = n(9773),
                S_ = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(M_.Z, S_);
            M_.Z.locals;
            const N_ = "automatic",
                B_ = /^(https?:)?\/\//;
            class P_ extends vs {
                static get pluginName() {
                    return "LinkEditing"
                }
                static get requires() {
                    return [Tp, fp, hp]
                }
                constructor(t) {
                    super(t), t.config.define("link", {
                        addTargetToExternalLinks: !1
                    })
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: "linkHref"
                    }), t.conversion.for("dataDowncast").attributeToElement({
                        model: "linkHref",
                        view: A_
                    }), t.conversion.for("editingDowncast").attributeToElement({
                        model: "linkHref",
                        view: (t, e) => A_(C_(t), e)
                    }), t.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "a",
                            attributes: {
                                href: !0
                            }
                        },
                        model: {
                            key: "linkHref",
                            value: t => t.getAttribute("href")
                        }
                    }), t.commands.add("link", new D_(t)), t.commands.add("unlink", new I_(t));
                    const e = function(t, e) {
                        const n = {
                            "Open in a new tab": t("Open in a new tab"),
                            Downloadable: t("Downloadable")
                        };
                        return e.forEach((t => (t.label && n[t.label] && (t.label = n[t.label]), t))), e
                    }(t.t, function(t) {
                        const e = [];
                        if (t)
                            for (const [n, o] of Object.entries(t)) {
                                const t = Object.assign({}, o, {
                                    id: `link${p_(n)}`
                                });
                                e.push(t)
                            }
                        return e
                    }(t.config.get("link.decorators")));
                    this._enableAutomaticDecorators(e.filter((t => t.mode === N_))), this._enableManualDecorators(e.filter((t => "manual" === t.mode)));
                    t.plugins.get(Tp).registerAttribute("linkHref"),
                        function(t, e, n, o) {
                            const i = t.editing.view,
                                r = new Set;
                            i.document.registerPostFixer((i => {
                                const s = t.model.document.selection;
                                let a = !1;
                                if (s.hasAttribute(e)) {
                                    const c = Wp(s.getFirstPosition(), e, s.getAttribute(e), t.model),
                                        l = t.editing.mapper.toViewRange(c);
                                    for (const t of l.getItems()) t.is("element", n) && !t.hasClass(o) && (i.addClass(o, t), r.add(t), a = !0)
                                }
                                return a
                            })), t.conversion.for("editingDowncast").add((t => {
                                function e() {
                                    i.change((t => {
                                        for (const e of r.values()) t.removeClass(o, e), r.delete(e)
                                    }))
                                }
                                t.on("insert", e, {
                                    priority: "highest"
                                }), t.on("remove", e, {
                                    priority: "highest"
                                }), t.on("attribute", e, {
                                    priority: "highest"
                                }), t.on("selection", e, {
                                    priority: "highest"
                                })
                            }))
                        }(t, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration()
                }
                _enableAutomaticDecorators(t) {
                    const e = this.editor,
                        n = e.commands.get("link").automaticDecorators;
                    e.config.get("link.addTargetToExternalLinks") && n.add({
                        id: "linkIsExternal",
                        mode: N_,
                        callback: t => B_.test(t),
                        attributes: {
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    }), n.add(t), n.length && e.conversion.for("downcast").add(n.getDispatcher())
                }
                _enableManualDecorators(t) {
                    if (!t.length) return;
                    const e = this.editor,
                        n = e.commands.get("link").manualDecorators;
                    t.forEach((t => {
                        e.model.schema.extend("$text", {
                            allowAttributes: t.id
                        }), t = new T_(t), n.add(t), e.conversion.for("downcast").attributeToElement({
                            model: t.id,
                            view: (e, {
                                writer: n,
                                schema: o
                            }, {
                                item: i
                            }) => {
                                if ((i.is("selection") || o.isInline(i)) && e) {
                                    const e = n.createAttributeElement("a", t.attributes, {
                                        priority: 5
                                    });
                                    t.classes && n.addClass(t.classes, e);
                                    for (const o in t.styles) n.setStyle(o, t.styles[o], e);
                                    return n.setCustomProperty("link", !0, e), e
                                }
                            }
                        }), e.conversion.for("upcast").elementToAttribute({
                            view: {
                                name: "a",
                                ...t._createPattern()
                            },
                            model: {
                                key: t.id
                            }
                        })
                    }))
                }
                _enableLinkOpen() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    this.listenTo(e, "click", ((t, e) => {
                        if (!(a.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey)) return;
                        let n = e.domTarget;
                        if ("a" != n.tagName.toLowerCase() && (n = n.closest("a")), !n) return;
                        const o = n.getAttribute("href");
                        o && (t.stop(), e.preventDefault(), E_(o))
                    }), {
                        context: "$capture"
                    }), this.listenTo(e, "keydown", ((e, n) => {
                        const o = t.commands.get("link").value;
                        o && n.keyCode === er.enter && n.altKey && (e.stop(), E_(o))
                    }))
                }
                _enableInsertContentSelectionAttributesFixer() {
                    const t = this.editor.model,
                        e = t.document.selection;
                    this.listenTo(t, "insertContent", (() => {
                        const n = e.anchor.nodeBefore,
                            o = e.anchor.nodeAfter;
                        e.hasAttribute("linkHref") && n && n.hasAttribute("linkHref") && (o && o.hasAttribute("linkHref") || t.change((e => {
                            z_(e, O_(t.schema))
                        })))
                    }), {
                        priority: "low"
                    })
                }
                _enableClickingAfterLink() {
                    const t = this.editor,
                        e = t.model;
                    t.editing.view.addObserver(Ig);
                    let n = !1;
                    this.listenTo(t.editing.view.document, "mousedown", (() => {
                        n = !0
                    })), this.listenTo(t.editing.view.document, "selectionChange", (() => {
                        if (!n) return;
                        n = !1;
                        const t = e.document.selection;
                        if (!t.isCollapsed) return;
                        if (!t.hasAttribute("linkHref")) return;
                        const o = t.getFirstPosition(),
                            i = Wp(o, "linkHref", t.getAttribute("linkHref"), e);
                        (o.isTouching(i.start) || o.isTouching(i.end)) && e.change((t => {
                            z_(t, O_(e.schema))
                        }))
                    }))
                }
                _enableTypingOverLink() {
                    const t = this.editor,
                        e = t.editing.view;
                    let n, o;
                    this.listenTo(e.document, "delete", (() => {
                        o = !0
                    }), {
                        priority: "high"
                    }), this.listenTo(t.model, "deleteContent", (() => {
                        const e = t.model.document.selection;
                        e.isCollapsed || (o ? o = !1 : L_(t) && function(t) {
                            const e = t.document.selection,
                                n = e.getFirstPosition(),
                                o = e.getLastPosition(),
                                i = n.nodeAfter;
                            if (!i) return !1;
                            if (!i.is("$text")) return !1;
                            if (!i.hasAttribute("linkHref")) return !1;
                            const r = o.textNode || o.nodeBefore;
                            if (i === r) return !0;
                            return Wp(n, "linkHref", i.getAttribute("linkHref"), t).containsRange(t.createRange(n, o), !0)
                        }(t.model) && (n = e.getAttributes()))
                    }), {
                        priority: "high"
                    }), this.listenTo(t.model, "insertContent", ((e, [i]) => {
                        o = !1, L_(t) && n && (t.model.change((t => {
                            for (const [e, o] of n) t.setAttribute(e, o, i)
                        })), n = null)
                    }), {
                        priority: "high"
                    })
                }
                _handleDeleteContentAfterLink() {
                    const t = this.editor,
                        e = t.model,
                        n = e.document.selection,
                        o = t.editing.view;
                    let i = !1,
                        r = !1;
                    this.listenTo(o.document, "delete", ((t, e) => {
                        r = "backward" === e.direction
                    }), {
                        priority: "high"
                    }), this.listenTo(e, "deleteContent", (() => {
                        i = !1;
                        const t = n.getFirstPosition(),
                            o = n.getAttribute("linkHref");
                        if (!o) return;
                        const r = Wp(t, "linkHref", o, e);
                        i = r.containsPosition(t) || r.end.isEqual(t)
                    }), {
                        priority: "high"
                    }), this.listenTo(e, "deleteContent", (() => {
                        r && (r = !1, i || t.model.enqueueChange((t => {
                            z_(t, O_(e.schema))
                        })))
                    }), {
                        priority: "low"
                    })
                }
                _enableClipboardIntegration() {
                    const t = this.editor,
                        e = t.model,
                        n = this.editor.config.get("link.defaultProtocol");
                    n && this.listenTo(t.plugins.get("ClipboardPipeline"), "contentInsertion", ((t, o) => {
                        e.change((t => {
                            const e = t.createRangeIn(o.content);
                            for (const o of e.getItems())
                                if (o.hasAttribute("linkHref")) {
                                    const e = y_(o.getAttribute("linkHref"), n);
                                    t.setAttribute("linkHref", e, o)
                                }
                        }))
                    }))
                }
            }
    
            function z_(t, e) {
                t.removeSelectionAttribute("linkHref");
                for (const n of e) t.removeSelectionAttribute(n)
            }
    
            function L_(t) {
                return t.model.change((t => t.batch)).isTyping
            }
    
            function O_(t) {
                return t.getDefinition("$text").allowAttributes.filter((t => t.startsWith("link")))
            }
            var R_ = n(7754),
                j_ = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(R_.Z, j_);
            R_.Z.locals;
            class F_ extends Dr {
                constructor(t, n) {
                    super(t);
                    const o = t.t;
                    this.focusTracker = new mr, this.keystrokes = new pr, this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(o("Save"), Lg.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(o("Cancel"), Lg.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(n), this.children = this._createFormChildren(n.manualDecorators), this._focusables = new Cr, this._focusCycler = new bs({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    const i = ["ck", "ck-link-form", "ck-responsive-form"];
                    n.manualDecorators.length && i.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: i,
                            tabindex: "-1"
                        },
                        children: this.children
                    }), e(this)
                }
                getDecoratorSwitchesState() {
                    return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => (t[e.name] = e.isOn, t)), {})
                }
                render() {
                    super.render(), i({
                        view: this
                    });
                    [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t => {
                        this._focusables.add(t), this.focusTracker.add(t.element)
                    })), this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                _createUrlInput() {
                    const t = this.locale.t,
                        e = new Om(this.locale, Rm);
                    return e.label = t("Link URL"), e
                }
                _createButton(t, e, n, o) {
                    const i = new es(this.locale);
                    return i.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), i.extendTemplate({
                        attributes: {
                            class: n
                        }
                    }), o && i.delegate("execute").to(this, o), i
                }
                _createManualDecoratorSwitches(t) {
                    const e = this.createCollection();
                    for (const n of t.manualDecorators) {
                        const o = new is(this.locale);
                        o.set({
                            name: n.id,
                            label: n.label,
                            withText: !0
                        }), o.bind("isOn").toMany([n, t], "value", ((t, e) => void 0 === e && void 0 === t ? n.defaultValue : t)), o.on("execute", (() => {
                            n.set("value", !o.isOn)
                        })), e.add(o)
                    }
                    return e
                }
                _createFormChildren(t) {
                    const e = this.createCollection();
                    if (e.add(this.urlInputView), t.length) {
                        const t = new Dr;
                        t.setTemplate({
                            tag: "ul",
                            children: this._manualDecoratorSwitches.map((t => ({
                                tag: "li",
                                children: [t],
                                attributes: {
                                    class: ["ck", "ck-list__item"]
                                }
                            }))),
                            attributes: {
                                class: ["ck", "ck-reset", "ck-list"]
                            }
                        }), e.add(t)
                    }
                    return e.add(this.saveButtonView), e.add(this.cancelButtonView), e
                }
            }
            var V_ = n(2347),
                H_ = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(V_.Z, H_);
            V_.Z.locals;
            class U_ extends Dr {
                constructor(t) {
                    super(t);
                    const e = t.t;
                    this.focusTracker = new mr, this.keystrokes = new pr, this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e("Edit link"), Lg.pencil, "edit"), this.set("href"), this._focusables = new Cr, this._focusCycler = new bs({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-link-actions", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                    })
                }
                render() {
                    super.render();
                    [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t => {
                        this._focusables.add(t), this.focusTracker.add(t.element)
                    })), this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                _createButton(t, e, n) {
                    const o = new es(this.locale);
                    return o.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), o.delegate("execute").to(this, n), o
                }
                _createPreviewButton() {
                    const t = new es(this.locale),
                        e = this.bindTemplate,
                        n = this.t;
                    return t.set({
                        withText: !0,
                        tooltip: n("Open link in new tab")
                    }), t.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-link-actions__preview"],
                            href: e.to("href", (t => t && C_(t))),
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    }), t.bind("label").to(this, "href", (t => t || n("This link has no URL"))), t.bind("isEnabled").to(this, "href", (t => !!t)), t.template.tag = "a", t.template.eventListeners = {}, t
                }
            }
            const W_ = "link-ui";
            class q_ extends vs {
                static get requires() {
                    return [Gm]
                }
                static get pluginName() {
                    return "LinkUI"
                }
                init() {
                    const t = this.editor;
                    t.editing.view.addObserver(Dg), this.actionsView = null, this.formView = null, this._balloon = t.plugins.get(Gm), this._createToolbarLinkButton(), this._enableBalloonActivators(), t.conversion.for("editingDowncast").markerToHighlight({
                        model: W_,
                        view: {
                            classes: ["ck-fake-link-selection"]
                        }
                    }), t.conversion.for("editingDowncast").markerToElement({
                        model: W_,
                        view: {
                            name: "span",
                            classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
                        }
                    })
                }
                destroy() {
                    super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy()
                }
                _createViews() {
                    this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions()
                }
                _createActionsView() {
                    const t = this.editor,
                        e = new U_(t.locale),
                        n = t.commands.get("link"),
                        o = t.commands.get("unlink");
                    return e.bind("href").to(n, "value"), e.editButtonView.bind("isEnabled").to(n), e.unlinkButtonView.bind("isEnabled").to(o), this.listenTo(e, "edit", (() => {
                        this._addFormView()
                    })), this.listenTo(e, "unlink", (() => {
                        t.execute("unlink"), this._hideUI()
                    })), e.keystrokes.set("Esc", ((t, e) => {
                        this._hideUI(), e()
                    })), e.keystrokes.set(__, ((t, e) => {
                        this._addFormView(), e()
                    })), e
                }
                _createFormView() {
                    const t = this.editor,
                        e = t.commands.get("link"),
                        n = t.config.get("link.defaultProtocol"),
                        o = new F_(t.locale, e);
                    return o.urlInputView.fieldView.bind("value").to(e, "value"), o.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t)), o.saveButtonView.bind("isEnabled").to(e), this.listenTo(o, "submit", (() => {
                        const {
                            value: e
                        } = o.urlInputView.fieldView.element, i = y_(e, n);
                        t.execute("link", i, o.getDecoratorSwitchesState()), this._closeFormView()
                    })), this.listenTo(o, "cancel", (() => {
                        this._closeFormView()
                    })), o.keystrokes.set("Esc", ((t, e) => {
                        this._closeFormView(), e()
                    })), o
                }
                _createToolbarLinkButton() {
                    const t = this.editor,
                        e = t.commands.get("link"),
                        n = t.t;
                    t.ui.componentFactory.add("link", (t => {
                        const o = new es(t);
                        return o.isEnabled = !0, o.label = n("Link"), o.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', o.keystroke = __, o.tooltip = !0, o.isToggleable = !0, o.bind("isEnabled").to(e, "isEnabled"), o.bind("isOn").to(e, "value", (t => !!t)), this.listenTo(o, "execute", (() => this._showUI(!0))), o
                    }))
                }
                _enableBalloonActivators() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    this.listenTo(e, "click", (() => {
                        this._getSelectedLinkElement() && this._showUI()
                    })), t.keystrokes.set(__, ((e, n) => {
                        n(), t.commands.get("link").isEnabled && this._showUI(!0)
                    }))
                }
                _enableUserBalloonInteractions() {
                    this.editor.keystrokes.set("Tab", ((t, e) => {
                        this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e())
                    }), {
                        priority: "high"
                    }), this.editor.keystrokes.set("Esc", ((t, e) => {
                        this._isUIVisible && (this._hideUI(), e())
                    })), t({
                        emitter: this.formView,
                        activator: () => this._isUIInPanel,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideUI()
                    })
                }
                _addActionsView() {
                    this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({
                        view: this.actionsView,
                        position: this._getBalloonPositionData()
                    })
                }
                _addFormView() {
                    if (this.formView || this._createViews(), this._isFormInPanel) return;
                    const t = this.editor.commands.get("link");
                    this.formView.disableCssTransitions(), this._balloon.add({
                        view: this.formView,
                        position: this._getBalloonPositionData()
                    }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t.value || ""
                }
                _closeFormView() {
                    const t = this.editor.commands.get("link");
                    t.restoreManualDecoratorStates(), void 0 !== t.value ? this._removeFormView() : this._hideUI()
                }
                _removeFormView() {
                    this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection())
                }
                _showUI(t = !1) {
                    this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), t && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI()
                }
                _hideUI() {
                    if (!this._isUIInPanel) return;
                    const t = this.editor;
                    this.stopListening(t.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection()
                }
                _startUpdatingUI() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    let n = this._getSelectedLinkElement(),
                        o = r();
                    const i = () => {
                        const t = this._getSelectedLinkElement(),
                            e = r();
                        n && !t || !n && e !== o ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = t, o = e
                    };
    
                    function r() {
                        return e.selection.focus.getAncestors().reverse().find((t => t.is("element")))
                    }
                    this.listenTo(t.ui, "update", i), this.listenTo(this._balloon, "change:visibleView", i)
                }
                get _isFormInPanel() {
                    return this._balloon.hasView(this.formView)
                }
                get _areActionsInPanel() {
                    return this._balloon.hasView(this.actionsView)
                }
                get _areActionsVisible() {
                    return this._balloon.visibleView === this.actionsView
                }
                get _isUIInPanel() {
                    return this._isFormInPanel || this._areActionsInPanel
                }
                get _isUIVisible() {
                    return this._balloon.visibleView == this.formView || this._areActionsVisible
                }
                _getBalloonPositionData() {
                    const t = this.editor.editing.view,
                        e = this.editor.model,
                        n = t.document;
                    let o = null;
                    if (e.markers.has(W_)) {
                        const e = Array.from(this.editor.editing.mapper.markerNameToElements(W_)),
                            n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
                        o = t.domConverter.viewRangeToDom(n)
                    } else o = () => {
                        const e = this._getSelectedLinkElement();
                        return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange())
                    };
                    return {
                        target: o
                    }
                }
                _getSelectedLinkElement() {
                    const t = this.editor.editing.view,
                        e = t.document.selection,
                        n = e.getSelectedElement();
                    if (e.isCollapsed || n && df(n)) return G_(e.getFirstPosition());
                    {
                        const n = e.getFirstRange().getTrimmed(),
                            o = G_(n.start),
                            i = G_(n.end);
                        return o && o == i && t.createRangeIn(o).getTrimmed().isEqual(n) ? o : null
                    }
                }
                _showFakeVisualSelection() {
                    const t = this.editor.model;
                    t.change((e => {
                        const n = t.document.selection.getFirstRange();
                        if (t.markers.has(W_)) e.updateMarker(W_, {
                            range: n
                        });
                        else if (n.start.isAtEnd) {
                            const o = n.start.getLastMatchingPosition((({
                                item: e
                            }) => !t.schema.isContent(e)), {
                                boundaries: n
                            });
                            e.addMarker(W_, {
                                usingOperation: !1,
                                affectsData: !1,
                                range: e.createRange(o, n.end)
                            })
                        } else e.addMarker(W_, {
                            usingOperation: !1,
                            affectsData: !1,
                            range: n
                        })
                    }))
                }
                _hideFakeVisualSelection() {
                    const t = this.editor.model;
                    t.markers.has(W_) && t.change((t => {
                        t.removeMarker(W_)
                    }))
                }
            }
    
            function G_(t) {
                return t.getAncestors().find((t => {
                    return (e = t).is("attributeElement") && !!e.getCustomProperty("link");
                    var e
                }))
            }
            const $_ = 4,
                Y_ = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i"),
                K_ = 2;
            class Q_ extends vs {
                static get requires() {
                    return [xp]
                }
                static get pluginName() {
                    return "AutoLink"
                }
                init() {
                    const t = this.editor.model.document.selection;
                    t.on("change:range", (() => {
                        this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
                    })), this._enableTypingHandling()
                }
                afterInit() {
                    this._enableEnterHandling(), this._enableShiftEnterHandling()
                }
                _enableTypingHandling() {
                    const t = this.editor,
                        e = new Ip(t.model, (t => {
                            if (! function(t) {
                                    return t.length > $_ && " " === t[t.length - 1] && " " !== t[t.length - 2]
                                }(t)) return;
                            const e = Z_(t.substr(0, t.length - 1));
                            return e ? {
                                url: e
                            } : void 0
                        }));
                    e.on("matched:data", ((e, n) => {
                        const {
                            batch: o,
                            range: i,
                            url: r
                        } = n;
                        if (!o.isTyping) return;
                        const s = i.end.getShiftedBy(-1),
                            a = s.getShiftedBy(-r.length),
                            c = t.model.createRange(a, s);
                        this._applyAutoLink(r, c)
                    })), e.bind("isEnabled").to(this)
                }
                _enableEnterHandling() {
                    const t = this.editor,
                        e = t.model,
                        n = t.commands.get("enter");
                    n && n.on("execute", (() => {
                        const t = e.document.selection.getFirstPosition();
                        if (!t.parent.previousSibling) return;
                        const n = e.createRangeIn(t.parent.previousSibling);
                        this._checkAndApplyAutoLinkOnRange(n)
                    }))
                }
                _enableShiftEnterHandling() {
                    const t = this.editor,
                        e = t.model,
                        n = t.commands.get("shiftEnter");
                    n && n.on("execute", (() => {
                        const t = e.document.selection.getFirstPosition(),
                            n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                        this._checkAndApplyAutoLinkOnRange(n)
                    }))
                }
                _checkAndApplyAutoLinkOnRange(t) {
                    const e = this.editor.model,
                        {
                            text: n,
                            range: o
                        } = Dp(t, e),
                        i = Z_(n);
                    if (i) {
                        const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
                        this._applyAutoLink(i, t)
                    }
                }
                _applyAutoLink(t, e) {
                    const n = this.editor.model,
                        o = y_(t, this.editor.config.get("link.defaultProtocol"));
                    this.isEnabled && function(t, e) {
                        return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref")
                    }(e, n) && x_(o) && ! function(t) {
                        const e = t.start.nodeAfter;
                        return e && e.hasAttribute("linkHref")
                    }(e) && this._persistAutoLink(o, e)
                }
                _persistAutoLink(t, e) {
                    const n = this.editor.model,
                        o = this.editor.plugins.get("Delete");
                    n.enqueueChange((i => {
                        i.setAttribute("linkHref", t, e), n.enqueueChange((() => {
                            o.requestUndoOnBackspace()
                        }))
                    }))
                }
            }
    
            function Z_(t) {
                const e = Y_.exec(t);
                return e ? e[K_] : null
            }
            class J_ extends xs {
                constructor(t, e) {
                    super(t), this.type = e
                }
                refresh() {
                    this.value = this._getValue(), this.isEnabled = this._checkEnabled()
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = e.document,
                        o = Array.from(n.selection.getSelectedBlocks()).filter((t => tA(t, e.schema))),
                        i = void 0 !== t.forceValue ? !t.forceValue : this.value;
                    e.change((t => {
                        if (i) {
                            let e = o[o.length - 1].nextSibling,
                                n = Number.POSITIVE_INFINITY,
                                i = [];
                            for (; e && "listItem" == e.name && 0 !== e.getAttribute("listIndent");) {
                                const t = e.getAttribute("listIndent");
                                t < n && (n = t);
                                const o = t - n;
                                i.push({
                                    element: e,
                                    listIndent: o
                                }), e = e.nextSibling
                            }
                            i = i.reverse();
                            for (const e of i) t.setAttribute("listIndent", e.listIndent, e.element)
                        }
                        if (!i) {
                            let t = Number.POSITIVE_INFINITY;
                            for (const e of o) e.is("element", "listItem") && e.getAttribute("listIndent") < t && (t = e.getAttribute("listIndent"));
                            t = 0 === t ? 1 : t, X_(o, !0, t), X_(o, !1, t)
                        }
                        for (const e of o.reverse()) i && "listItem" == e.name ? t.rename(e, "paragraph") : i || "listItem" == e.name ? i || "listItem" != e.name || e.getAttribute("listType") == this.type || t.setAttribute("listType", this.type, e) : (t.setAttributes({
                            listType: this.type,
                            listIndent: 0
                        }, e), t.rename(e, "listItem"));
                        this.fire("_executeCleanup", o)
                    }))
                }
                _getValue() {
                    const t = gr(this.editor.model.document.selection.getSelectedBlocks());
                    return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type
                }
                _checkEnabled() {
                    if (this.value) return !0;
                    const t = this.editor.model.document.selection,
                        e = this.editor.model.schema,
                        n = gr(t.getSelectedBlocks());
                    return !!n && tA(n, e)
                }
            }
    
            function X_(t, e, n) {
                const o = e ? t[0] : t[t.length - 1];
                if (o.is("element", "listItem")) {
                    let i = o[e ? "previousSibling" : "nextSibling"],
                        r = o.getAttribute("listIndent");
                    for (; i && i.is("element", "listItem") && i.getAttribute("listIndent") >= n;) r > i.getAttribute("listIndent") && (r = i.getAttribute("listIndent")), i.getAttribute("listIndent") == r && t[e ? "unshift" : "push"](i), i = i[e ? "previousSibling" : "nextSibling"]
                }
            }
    
            function tA(t, e) {
                return e.checkChild(t.parent, "listItem") && !e.isObject(t)
            }
            class eA extends xs {
                constructor(t, e) {
                    super(t), this._indentBy = "forward" == e ? 1 : -1
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    const t = this.editor.model,
                        e = t.document;
                    let n = Array.from(e.selection.getSelectedBlocks());
                    t.change((t => {
                        const e = n[n.length - 1];
                        let o = e.nextSibling;
                        for (; o && "listItem" == o.name && o.getAttribute("listIndent") > e.getAttribute("listIndent");) n.push(o), o = o.nextSibling;
                        this._indentBy < 0 && (n = n.reverse());
                        for (const e of n) {
                            const n = e.getAttribute("listIndent") + this._indentBy;
                            n < 0 ? t.rename(e, "paragraph") : t.setAttribute("listIndent", n, e)
                        }
                        this.fire("_executeCleanup", n)
                    }))
                }
                _checkEnabled() {
                    const t = gr(this.editor.model.document.selection.getSelectedBlocks());
                    if (!t || !t.is("element", "listItem")) return !1;
                    if (this._indentBy > 0) {
                        const e = t.getAttribute("listIndent"),
                            n = t.getAttribute("listType");
                        let o = t.previousSibling;
                        for (; o && o.is("element", "listItem") && o.getAttribute("listIndent") >= e;) {
                            if (o.getAttribute("listIndent") == e) return o.getAttribute("listType") == n;
                            o = o.previousSibling
                        }
                        return !1
                    }
                    return !0
                }
            }
    
            function nA(t, e) {
                const n = e.mapper,
                    o = e.writer,
                    i = "numbered" == t.getAttribute("listType") ? "ol" : "ul",
                    r = function(t) {
                        const e = t.createContainerElement("li");
                        return e.getFillerOffset = hA, e
                    }(o),
                    s = o.createContainerElement(i, null);
                return o.insert(o.createPositionAt(s, 0), r), n.bindElements(t, r), r
            }
    
            function oA(t, e, n, o) {
                const i = e.parent,
                    r = n.mapper,
                    s = n.writer;
                let a = r.toViewPosition(o.createPositionBefore(t));
                const c = sA(t.previousSibling, {
                        sameIndent: !0,
                        smallerIndent: !0,
                        listIndent: t.getAttribute("listIndent")
                    }),
                    l = t.previousSibling;
                if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) {
                    const t = r.toViewElement(c);
                    a = s.breakContainer(s.createPositionAfter(t))
                } else if (l && "listItem" == l.name) {
                    a = r.toViewPosition(o.createPositionAt(l, "end"));
                    const t = r.findMappedViewAncestor(a),
                        e = function(t) {
                            for (const e of t.getChildren())
                                if ("ul" == e.name || "ol" == e.name) return e;
                            return null
                        }(t);
                    a = e ? s.createPositionBefore(e) : s.createPositionAt(t, "end")
                } else a = r.toViewPosition(o.createPositionBefore(t));
                if (a = rA(a), s.insert(a, i), l && "listItem" == l.name) {
                    const t = r.toViewElement(l),
                        n = s.createRange(s.createPositionAt(t, 0), a).getWalker({
                            ignoreElementEnd: !0
                        });
                    for (const t of n)
                        if (t.item.is("element", "li")) {
                            const o = s.breakContainer(s.createPositionBefore(t.item)),
                                i = t.item.parent,
                                r = s.createPositionAt(e, "end");
                            iA(s, r.nodeBefore, r.nodeAfter), s.move(s.createRangeOn(i), r), n.position = o
                        }
                } else {
                    const n = i.nextSibling;
                    if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                        let o = null;
                        for (const e of n.getChildren()) {
                            const n = r.toModelElement(e);
                            if (!(n && n.getAttribute("listIndent") > t.getAttribute("listIndent"))) break;
                            o = e
                        }
                        o && (s.breakContainer(s.createPositionAfter(o)), s.move(s.createRangeOn(o.parent), s.createPositionAt(e, "end")))
                    }
                }
                iA(s, i, i.nextSibling), iA(s, i.previousSibling, i)
            }
    
            function iA(t, e, n) {
                return !e || !n || "ul" != e.name && "ol" != e.name || e.name != n.name || e.getAttribute("class") !== n.getAttribute("class") ? null : t.mergeContainers(t.createPositionAfter(e))
            }
    
            function rA(t) {
                return t.getLastMatchingPosition((t => t.item.is("uiElement")))
            }
    
            function sA(t, e) {
                const n = !!e.sameIndent,
                    o = !!e.smallerIndent,
                    i = e.listIndent;
                let r = t;
                for (; r && "listItem" == r.name;) {
                    const t = r.getAttribute("listIndent");
                    if (n && i == t || o && i > t) return r;
                    r = "forward" === e.direction ? r.nextSibling : r.previousSibling
                }
                return null
            }
    
            function aA(t, e, n, o) {
                t.ui.componentFactory.add(e, (i => {
                    const r = t.commands.get(e),
                        s = new es(i);
                    return s.set({
                        label: n,
                        icon: o,
                        tooltip: !0,
                        isToggleable: !0
                    }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), s.on("execute", (() => {
                        t.execute(e), t.editing.view.focus()
                    })), s
                }))
            }
    
            function cA(t, e) {
                const n = [],
                    o = t.parent,
                    i = {
                        ignoreElementEnd: !1,
                        startPosition: t,
                        shallow: !0,
                        direction: e
                    },
                    r = o.getAttribute("listIndent"),
                    s = [...new zd(i)].filter((t => t.item.is("element"))).map((t => t.item));
                for (const t of s) {
                    if (!t.is("element", "listItem")) break;
                    if (t.getAttribute("listIndent") < r) break;
                    if (!(t.getAttribute("listIndent") > r)) {
                        if (t.getAttribute("listType") !== o.getAttribute("listType")) break;
                        if (t.getAttribute("listStyle") !== o.getAttribute("listStyle")) break;
                        if (t.getAttribute("listReversed") !== o.getAttribute("listReversed")) break;
                        if (t.getAttribute("listStart") !== o.getAttribute("listStart")) break;
                        "backward" === e ? n.unshift(t) : n.push(t)
                    }
                }
                return n
            }
            const lA = ["disc", "circle", "square"],
                dA = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
    
            function hA() {
                const t = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
                return this.isEmpty || t ? 0 : tc.call(this)
            }
            class uA extends vs {
                static get pluginName() {
                    return "ListUtils"
                }
                getListTypeFromListStyleType(t) {
                    return function(t) {
                        return lA.includes(t) ? "bulleted" : dA.includes(t) ? "numbered" : null
                    }(t)
                }
                getSelectedListItems(t) {
                    return function(t) {
                        let e = [...t.document.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((e => {
                            const n = t.change((t => t.createPositionAt(e, 0)));
                            return [...cA(n, "backward"), ...cA(n, "forward")]
                        })).flat();
                        return e = [...new Set(e)], e
                    }(t)
                }
                getSiblingNodes(t, e) {
                    return cA(t, e)
                }
            }
    
            function gA(t) {
                return (e, n, o) => {
                    const i = o.consumable;
                    if (!i.test(n.item, "insert") || !i.test(n.item, "attribute:listType") || !i.test(n.item, "attribute:listIndent")) return;
                    i.consume(n.item, "insert"), i.consume(n.item, "attribute:listType"), i.consume(n.item, "attribute:listIndent");
                    const r = n.item;
                    oA(r, nA(r, o), o, t)
                }
            }
            const mA = (t, e, n) => {
                    if (!n.consumable.test(e.item, t.name)) return;
                    const o = n.mapper.toViewElement(e.item),
                        i = n.writer;
                    i.breakContainer(i.createPositionBefore(o)), i.breakContainer(i.createPositionAfter(o));
                    const r = o.parent,
                        s = "numbered" == e.attributeNewValue ? "ol" : "ul";
                    i.rename(s, r)
                },
                pA = (t, e, n) => {
                    n.consumable.consume(e.item, t.name);
                    const o = n.mapper.toViewElement(e.item).parent,
                        i = n.writer;
                    iA(i, o, o.nextSibling), iA(i, o.previousSibling, o)
                };
            const fA = (t, e, n) => {
                    if (n.consumable.test(e.item, t.name) && "listItem" != e.item.name) {
                        let t = n.mapper.toViewPosition(e.range.start);
                        const o = n.writer,
                            i = [];
                        for (;
                            ("ul" == t.parent.name || "ol" == t.parent.name) && (t = o.breakContainer(t), "li" == t.parent.name);) {
                            const e = t,
                                n = o.createPositionAt(t.parent, "end");
                            if (!e.isEqual(n)) {
                                const t = o.remove(o.createRange(e, n));
                                i.push(t)
                            }
                            t = o.createPositionAfter(t.parent)
                        }
                        if (i.length > 0) {
                            for (let e = 0; e < i.length; e++) {
                                const n = t.nodeBefore;
                                if (t = o.insert(t, i[e]).end, e > 0) {
                                    const e = iA(o, n, n.nextSibling);
                                    e && e.parent == n && t.offset--
                                }
                            }
                            iA(o, t.nodeBefore, t.nodeAfter)
                        }
                    }
                },
                kA = (t, e, n) => {
                    const o = n.mapper.toViewPosition(e.position),
                        i = o.nodeBefore,
                        r = o.nodeAfter;
                    iA(n.writer, i, r)
                },
                bA = (t, e, n) => {
                    if (n.consumable.consume(e.viewItem, {
                            name: !0
                        })) {
                        const t = n.writer,
                            o = t.createElement("listItem"),
                            i = function(t) {
                                let e = 0,
                                    n = t.parent;
                                for (; n;) {
                                    if (n.is("element", "li")) e++;
                                    else {
                                        const t = n.previousSibling;
                                        t && t.is("element", "li") && e++
                                    }
                                    n = n.parent
                                }
                                return e
                            }(e.viewItem);
                        t.setAttribute("listIndent", i, o);
                        const r = e.viewItem.parent && "ol" == e.viewItem.parent.name ? "numbered" : "bulleted";
                        if (t.setAttribute("listType", r, o), !n.safeInsert(o, e.modelCursor)) return;
                        const s = function(t, e, n) {
                            const {
                                writer: o,
                                schema: i
                            } = n;
                            let r = o.createPositionAfter(t);
                            for (const s of e)
                                if ("ul" == s.name || "ol" == s.name) r = n.convertItem(s, r).modelCursor;
                                else {
                                    const e = n.convertItem(s, o.createPositionAt(t, "end")),
                                        a = e.modelRange.start.nodeAfter;
                                    a && a.is("element") && !i.checkChild(t, a.name) && (t = e.modelCursor.parent.is("element", "listItem") ? e.modelCursor.parent : vA(e.modelCursor), r = o.createPositionAfter(t))
                                } return r
                        }(o, e.viewItem.getChildren(), n);
                        e.modelRange = t.createRange(e.modelCursor, s), n.updateConversionResult(o, e)
                    }
                },
                wA = (t, e, n) => {
                    if (n.consumable.test(e.viewItem, {
                            name: !0
                        })) {
                        const t = Array.from(e.viewItem.getChildren());
                        for (const e of t) {
                            !(e.is("element", "li") || xA(e)) && e._remove()
                        }
                    }
                },
                _A = (t, e, n) => {
                    if (n.consumable.test(e.viewItem, {
                            name: !0
                        })) {
                        if (0 === e.viewItem.childCount) return;
                        const t = [...e.viewItem.getChildren()];
                        let n = !1;
                        for (const e of t) n && !xA(e) && e._remove(), xA(e) && (n = !0)
                    }
                };
    
            function AA(t) {
                return (e, n) => {
                    if (n.isPhantom) return;
                    const o = n.modelPosition.nodeBefore;
                    if (o && o.is("element", "listItem")) {
                        const e = n.mapper.toViewElement(o),
                            i = e.getAncestors().find(xA),
                            r = t.createPositionAt(e, 0).getWalker();
                        for (const t of r) {
                            if ("elementStart" == t.type && t.item.is("element", "li")) {
                                n.viewPosition = t.previousPosition;
                                break
                            }
                            if ("elementEnd" == t.type && t.item == i) {
                                n.viewPosition = t.nextPosition;
                                break
                            }
                        }
                    }
                }
            }
            const CA = function(t, [e, n, o]) {
                const i = this;
                let r, s = e.is("documentFragment") ? e.getChild(0) : e;
                if (r = n ? i.createSelection(n, o) : i.document.selection, s && s.is("element", "listItem")) {
                    const t = r.getFirstPosition();
                    let e = null;
                    if (t.parent.is("element", "listItem") ? e = t.parent : t.nodeBefore && t.nodeBefore.is("element", "listItem") && (e = t.nodeBefore), e) {
                        const t = e.getAttribute("listIndent");
                        if (t > 0)
                            for (; s && s.is("element", "listItem");) s._setAttribute("listIndent", s.getAttribute("listIndent") + t), s = s.nextSibling
                    }
                }
            };
    
            function vA(t) {
                const e = new zd({
                    startPosition: t
                });
                let n;
                do {
                    n = e.next()
                } while (!n.value.item.is("element", "listItem"));
                return n.value.item
            }
    
            function yA(t, e, n, o, i, r) {
                const s = sA(e.nodeBefore, {
                        sameIndent: !0,
                        smallerIndent: !0,
                        listIndent: t
                    }),
                    a = i.mapper,
                    c = i.writer,
                    l = s ? s.getAttribute("listIndent") : null;
                let d;
                if (s)
                    if (l == t) {
                        const t = a.toViewElement(s).parent;
                        d = c.createPositionAfter(t)
                    } else {
                        const t = r.createPositionAt(s, "end");
                        d = a.toViewPosition(t)
                    }
                else d = n;
                d = rA(d);
                for (const t of [...o.getChildren()]) xA(t) && (d = c.move(c.createRangeOn(t), d).end, iA(c, t, t.nextSibling), iA(c, t.previousSibling, t))
            }
    
            function xA(t) {
                return t.is("element", "ol") || t.is("element", "ul")
            }
            var EA = n(4564),
                DA = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(EA.Z, DA);
            EA.Z.locals;
            class IA extends vs {
                static get pluginName() {
                    return "ListEditing"
                }
                static get requires() {
                    return [Zp, xp, uA]
                }
                init() {
                    const t = this.editor;
                    t.model.schema.register("listItem", {
                        inheritAllFrom: "$block",
                        allowAttributes: ["listType", "listIndent"]
                    });
                    const e = t.data,
                        n = t.editing;
                    var o;
                    t.model.document.registerPostFixer((e => function(t, e) {
                        const n = t.document.differ.getChanges(),
                            o = new Map;
                        let i = !1;
                        for (const o of n)
                            if ("insert" == o.type && "listItem" == o.name) r(o.position);
                            else if ("insert" == o.type && "listItem" != o.name) {
                            if ("$text" != o.name) {
                                const n = o.position.nodeAfter;
                                n.hasAttribute("listIndent") && (e.removeAttribute("listIndent", n), i = !0), n.hasAttribute("listType") && (e.removeAttribute("listType", n), i = !0), n.hasAttribute("listStyle") && (e.removeAttribute("listStyle", n), i = !0), n.hasAttribute("listReversed") && (e.removeAttribute("listReversed", n), i = !0), n.hasAttribute("listStart") && (e.removeAttribute("listStart", n), i = !0);
                                for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) r(e.previousPosition)
                            }
                            r(o.position.getShiftedBy(o.length))
                        } else "remove" == o.type && "listItem" == o.name ? r(o.position) : ("attribute" == o.type && "listIndent" == o.attributeKey || "attribute" == o.type && "listType" == o.attributeKey) && r(o.range.start);
                        for (const t of o.values()) s(t), a(t);
                        return i;
    
                        function r(t) {
                            const e = t.nodeBefore;
                            if (e && e.is("element", "listItem")) {
                                let t = e;
                                if (o.has(t)) return;
                                for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling)
                                    if (t = e, o.has(t)) return;
                                o.set(e, t)
                            } else {
                                const e = t.nodeAfter;
                                e && e.is("element", "listItem") && o.set(e, e)
                            }
                        }
    
                        function s(t) {
                            let n = 0,
                                o = null;
                            for (; t && t.is("element", "listItem");) {
                                const r = t.getAttribute("listIndent");
                                if (r > n) {
                                    let s;
                                    null === o ? (o = r - n, s = n) : (o > r && (o = r), s = r - o), e.setAttribute("listIndent", s, t), i = !0
                                } else o = null, n = t.getAttribute("listIndent") + 1;
                                t = t.nextSibling
                            }
                        }
    
                        function a(t) {
                            let n = [],
                                o = null;
                            for (; t && t.is("element", "listItem");) {
                                const r = t.getAttribute("listIndent");
                                if (o && o.getAttribute("listIndent") > r && (n = n.slice(0, r + 1)), 0 != r)
                                    if (n[r]) {
                                        const o = n[r];
                                        t.getAttribute("listType") != o && (e.setAttribute("listType", o, t), i = !0)
                                    } else n[r] = t.getAttribute("listType");
                                o = t, t = t.nextSibling
                            }
                        }
                    }(t.model, e))), n.mapper.registerViewToModelLength("li", TA), e.mapper.registerViewToModelLength("li", TA), n.mapper.on("modelToViewPosition", AA(n.view)), n.mapper.on("viewToModelPosition", (o = t.model, (t, e) => {
                        const n = e.viewPosition,
                            i = n.parent,
                            r = e.mapper;
                        if ("ul" == i.name || "ol" == i.name) {
                            if (n.isAtEnd) {
                                const t = r.toModelElement(n.nodeBefore),
                                    i = r.getModelLength(n.nodeBefore);
                                e.modelPosition = o.createPositionBefore(t).getShiftedBy(i)
                            } else {
                                const t = r.toModelElement(n.nodeAfter);
                                e.modelPosition = o.createPositionBefore(t)
                            }
                            t.stop()
                        } else if ("li" == i.name && n.nodeBefore && ("ul" == n.nodeBefore.name || "ol" == n.nodeBefore.name)) {
                            const s = r.toModelElement(i);
                            let a = 1,
                                c = n.nodeBefore;
                            for (; c && xA(c);) a += r.getModelLength(c), c = c.previousSibling;
                            e.modelPosition = o.createPositionBefore(s).getShiftedBy(a), t.stop()
                        }
                    })), e.mapper.on("modelToViewPosition", AA(n.view)), t.conversion.for("editingDowncast").add((e => {
                        e.on("insert", fA, {
                            priority: "high"
                        }), e.on("insert:listItem", gA(t.model)), e.on("attribute:listType:listItem", mA, {
                            priority: "high"
                        }), e.on("attribute:listType:listItem", pA, {
                            priority: "low"
                        }), e.on("attribute:listIndent:listItem", function(t) {
                            return (e, n, o) => {
                                if (!o.consumable.consume(n.item, "attribute:listIndent")) return;
                                const i = o.mapper.toViewElement(n.item),
                                    r = o.writer;
                                r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                                const s = i.parent,
                                    a = s.previousSibling,
                                    c = r.createRangeOn(s);
                                r.remove(c), a && a.nextSibling && iA(r, a, a.nextSibling), yA(n.attributeOldValue + 1, n.range.start, c.start, i, o, t), oA(n.item, i, o, t);
                                for (const t of n.item.getChildren()) o.consumable.consume(t, "insert")
                            }
                        }(t.model)), e.on("remove:listItem", function(t) {
                            return (e, n, o) => {
                                const i = o.mapper.toViewPosition(n.position).getLastMatchingPosition((t => !t.item.is("element", "li"))).nodeAfter,
                                    r = o.writer;
                                r.breakContainer(r.createPositionBefore(i)), r.breakContainer(r.createPositionAfter(i));
                                const s = i.parent,
                                    a = s.previousSibling,
                                    c = r.createRangeOn(s),
                                    l = r.remove(c);
                                a && a.nextSibling && iA(r, a, a.nextSibling), yA(o.mapper.toModelElement(i).getAttribute("listIndent") + 1, n.position, c.start, i, o, t);
                                for (const t of r.createRangeIn(l).getItems()) o.mapper.unbindViewElement(t);
                                e.stop()
                            }
                        }(t.model)), e.on("remove", kA, {
                            priority: "low"
                        })
                    })), t.conversion.for("dataDowncast").add((e => {
                        e.on("insert", fA, {
                            priority: "high"
                        }), e.on("insert:listItem", gA(t.model))
                    })), t.conversion.for("upcast").add((t => {
                        t.on("element:ul", wA, {
                            priority: "high"
                        }), t.on("element:ol", wA, {
                            priority: "high"
                        }), t.on("element:li", _A, {
                            priority: "high"
                        }), t.on("element:li", bA)
                    })), t.model.on("insertContent", CA, {
                        priority: "high"
                    }), t.commands.add("numberedList", new J_(t, "numbered")), t.commands.add("bulletedList", new J_(t, "bulleted")), t.commands.add("indentList", new eA(t, "forward")), t.commands.add("outdentList", new eA(t, "backward"));
                    const i = n.view.document;
                    this.listenTo(i, "enter", ((t, e) => {
                        const n = this.editor.model.document,
                            o = n.selection.getLastPosition().parent;
                        n.selection.isCollapsed && "listItem" == o.name && o.isEmpty && (this.editor.execute("outdentList"), e.preventDefault(), t.stop())
                    }), {
                        context: "li"
                    }), this.listenTo(i, "delete", ((t, e) => {
                        if ("backward" !== e.direction) return;
                        const n = this.editor.model.document.selection;
                        if (!n.isCollapsed) return;
                        const o = n.getFirstPosition();
                        if (!o.isAtStart) return;
                        const i = o.parent;
                        if ("listItem" !== i.name) return;
                        i.previousSibling && "listItem" === i.previousSibling.name || (this.editor.execute("outdentList"), e.preventDefault(), t.stop())
                    }), {
                        context: "li"
                    }), this.listenTo(t.editing.view.document, "tab", ((e, n) => {
                        const o = n.shiftKey ? "outdentList" : "indentList";
                        this.editor.commands.get(o).isEnabled && (t.execute(o), n.stopPropagation(), n.preventDefault(), e.stop())
                    }), {
                        context: "li"
                    })
                }
                afterInit() {
                    const t = this.editor.commands,
                        e = t.get("indent"),
                        n = t.get("outdent");
                    e && e.registerChildCommand(t.get("indentList")), n && n.registerChildCommand(t.get("outdentList"))
                }
            }
    
            function TA(t) {
                let e = 1;
                for (const n of t.getChildren())
                    if ("ul" == n.name || "ol" == n.name)
                        for (const t of n.getChildren()) e += TA(t);
                return e
            }
            class MA extends vs {
                static get pluginName() {
                    return "ListUI"
                }
                init() {
                    const t = this.editor.t;
                    aA(this.editor, "numberedList", t("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), aA(this.editor, "bulletedList", t("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>')
                }
            }
    
            function SA(t, e) {
                return t => {
                    t.on("attribute:url:media", n)
                };
    
                function n(n, o, i) {
                    if (!i.consumable.consume(o.item, n.name)) return;
                    const r = o.attributeNewValue,
                        s = i.writer,
                        a = i.mapper.toViewElement(o.item),
                        c = [...a.getChildren()].find((t => t.getCustomProperty("media-content")));
                    s.remove(c);
                    const l = t.getMediaViewElement(s, r, e);
                    s.insert(s.createPositionAt(a, 0), l)
                }
            }
    
            function NA(t, e, n, o) {
                return t.createContainerElement("figure", {
                    class: "media"
                }, [e.getMediaViewElement(t, n, o), t.createSlot()])
            }
    
            function BA(t) {
                const e = t.getSelectedElement();
                return e && e.is("element", "media") ? e : null
            }
    
            function PA(t, e, n, o) {
                t.change((i => {
                    const r = i.createElement("media", {
                        url: e
                    });
                    t.insertObject(r, n, null, {
                        setSelection: "on",
                        findOptimalPosition: o
                    })
                }))
            }
            class zA extends xs {
                refresh() {
                    const t = this.editor.model,
                        e = t.document.selection,
                        n = BA(e);
                    this.value = n ? n.getAttribute("url") : null, this.isEnabled = function(t) {
                        const e = t.getSelectedElement();
                        return !!e && "media" === e.name
                    }(e) || function(t, e) {
                        const n = ff(t, e);
                        let o = n.start.parent;
                        o.isEmpty && !e.schema.isLimit(o) && (o = o.parent);
                        return e.schema.checkChild(o, "media")
                    }(e, t)
                }
                execute(t) {
                    const e = this.editor.model,
                        n = e.document.selection,
                        o = BA(n);
                    o ? e.change((e => {
                        e.setAttribute("url", t, o)
                    })) : PA(e, t, n, !0)
                }
            }
            class LA {
                constructor(t, e) {
                    const n = e.providers,
                        o = e.extraProviders || [],
                        i = new Set(e.removeProviders),
                        r = n.concat(o).filter((t => {
                            const e = t.name;
                            return e ? !i.has(e) : (C("media-embed-no-provider-name", {
                                provider: t
                            }), !1)
                        }));
                    this.locale = t, this.providerDefinitions = r
                }
                hasMedia(t) {
                    return !!this._getMedia(t)
                }
                getMediaViewElement(t, e, n) {
                    return this._getMedia(e).getViewElement(t, n)
                }
                _getMedia(t) {
                    if (!t) return new OA(this.locale);
                    t = t.trim();
                    for (const e of this.providerDefinitions) {
                        const n = e.html,
                            o = ar(e.url);
                        for (const e of o) {
                            const o = this._getUrlMatches(t, e);
                            if (o) return new OA(this.locale, t, o, n)
                        }
                    }
                    return null
                }
                _getUrlMatches(t, e) {
                    let n = t.match(e);
                    if (n) return n;
                    let o = t.replace(/^https?:\/\//, "");
                    return n = o.match(e), n || (o = o.replace(/^www\./, ""), n = o.match(e), n || null)
                }
            }
            class OA {
                constructor(t, e, n, o) {
                    this.url = this._getValidUrl(e), this._locale = t, this._match = n, this._previewRenderer = o
                }
                getViewElement(t, e) {
                    const n = {};
                    let o;
                    if (e.renderForEditingView || e.renderMediaPreview && this.url && this._previewRenderer) {
                        this.url && (n["data-oembed-url"] = this.url), e.renderForEditingView && (n.class = "ck-media__wrapper");
                        const i = this._getPreviewHtml(e);
                        o = t.createRawElement("div", n, ((t, e) => {
                            e.setContentOf(t, i)
                        }))
                    } else this.url && (n.url = this.url), o = t.createEmptyElement(e.elementName, n);
                    return t.setCustomProperty("media-content", !0, o), o
                }
                _getPreviewHtml(t) {
                    return this._previewRenderer ? this._previewRenderer(this._match) : this.url && t.renderForEditingView ? this._getPlaceholderHtml() : ""
                }
                _getPlaceholderHtml() {
                    const t = new Jr,
                        e = this._locale.t;
                    t.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', t.viewBox = "0 0 64 42";
                    return new Ir({
                        tag: "div",
                        attributes: {
                            class: "ck ck-reset_all ck-media__placeholder"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: "ck-media__placeholder__icon"
                            },
                            children: [t]
                        }, {
                            tag: "a",
                            attributes: {
                                class: "ck-media__placeholder__url",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                href: this.url,
                                "data-cke-tooltip-text": e("Open media in new tab")
                            },
                            children: [{
                                tag: "span",
                                attributes: {
                                    class: "ck-media__placeholder__url__text"
                                },
                                children: [this.url]
                            }]
                        }]
                    }).render().outerHTML
                }
                _getValidUrl(t) {
                    return t ? t.match(/^https?/) ? t : "https://" + t : null
                }
            }
            var RA = n(7442),
                jA = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(RA.Z, jA);
            RA.Z.locals;
            class FA extends vs {
                static get pluginName() {
                    return "MediaEmbedEditing"
                }
                constructor(t) {
                    super(t), t.config.define("mediaEmbed", {
                        elementName: "oembed",
                        providers: [{
                            name: "dailymotion",
                            url: /^dailymotion\.com\/video\/(\w+)/,
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
                        }, {
                            name: "spotify",
                            url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
                        }, {
                            name: "youtube",
                            url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/],
                            html: t => {
                                const e = t[1],
                                    n = t[2];
                                return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${e}${n?`?start=${n}`:""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`
                            }
                        }, {
                            name: "vimeo",
                            url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
                        }, {
                            name: "instagram",
                            url: /^instagram\.com\/p\/(\w+)/
                        }, {
                            name: "twitter",
                            url: /^twitter\.com/
                        }, {
                            name: "googleMaps",
                            url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/]
                        }, {
                            name: "flickr",
                            url: /^flickr\.com/
                        }, {
                            name: "facebook",
                            url: /^facebook\.com/
                        }]
                    }), this.registry = new LA(t.locale, t.config.get("mediaEmbed"))
                }
                init() {
                    const t = this.editor,
                        e = t.model.schema,
                        n = t.t,
                        o = t.conversion,
                        i = t.config.get("mediaEmbed.previewsInData"),
                        r = t.config.get("mediaEmbed.elementName"),
                        s = this.registry;
                    t.commands.add("mediaEmbed", new zA(t)), e.register("media", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["url"]
                    }), o.for("dataDowncast").elementToStructure({
                        model: "media",
                        view: (t, {
                            writer: e
                        }) => {
                            const n = t.getAttribute("url");
                            return NA(e, s, n, {
                                elementName: r,
                                renderMediaPreview: n && i
                            })
                        }
                    }), o.for("dataDowncast").add(SA(s, {
                        elementName: r,
                        renderMediaPreview: i
                    })), o.for("editingDowncast").elementToStructure({
                        model: "media",
                        view: (t, {
                            writer: e
                        }) => {
                            const o = t.getAttribute("url");
                            return function(t, e, n) {
                                return e.setCustomProperty("media", !0, t), hf(t, e, {
                                    label: n
                                })
                            }(NA(e, s, o, {
                                elementName: r,
                                renderForEditingView: !0
                            }), e, n("media widget"))
                        }
                    }), o.for("editingDowncast").add(SA(s, {
                        elementName: r,
                        renderForEditingView: !0
                    })), o.for("upcast").elementToElement({
                        view: t => ["oembed", r].includes(t.name) && t.getAttribute("url") ? {
                            name: !0
                        } : null,
                        model: (t, {
                            writer: e
                        }) => {
                            const n = t.getAttribute("url");
                            if (s.hasMedia(n)) return e.createElement("media", {
                                url: n
                            })
                        }
                    }).elementToElement({
                        view: {
                            name: "div",
                            attributes: {
                                "data-oembed-url": !0
                            }
                        },
                        model: (t, {
                            writer: e
                        }) => {
                            const n = t.getAttribute("data-oembed-url");
                            if (s.hasMedia(n)) return e.createElement("media", {
                                url: n
                            })
                        }
                    }).add((t => {
                        t.on("element:figure", (function(t, e, n) {
                            if (!n.consumable.consume(e.viewItem, {
                                    name: !0,
                                    classes: "media"
                                })) return;
                            const {
                                modelRange: o,
                                modelCursor: i
                            } = n.convertChildren(e.viewItem, e.modelCursor);
                            e.modelRange = o, e.modelCursor = i;
                            gr(o.getItems()) || n.consumable.revert(e.viewItem, {
                                name: !0,
                                classes: "media"
                            })
                        }))
                    }))
                }
            }
            const VA = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
            class HA extends vs {
                static get requires() {
                    return [Zf, xp, gk]
                }
                static get pluginName() {
                    return "AutoMediaEmbed"
                }
                constructor(t) {
                    super(t), this._timeoutId = null, this._positionToInsert = null
                }
                init() {
                    const t = this.editor,
                        e = t.model.document;
                    this.listenTo(t.plugins.get("ClipboardPipeline"), "inputTransformation", (() => {
                        const t = e.selection.getFirstRange(),
                            n = Ru.fromPosition(t.start);
                        n.stickiness = "toPrevious";
                        const o = Ru.fromPosition(t.end);
                        o.stickiness = "toNext", e.once("change:data", (() => {
                            this._embedMediaBetweenPositions(n, o), n.detach(), o.detach()
                        }), {
                            priority: "high"
                        })
                    })), t.commands.get("undo").on("execute", (() => {
                        this._timeoutId && (vi.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null)
                    }), {
                        priority: "high"
                    })
                }
                _embedMediaBetweenPositions(t, e) {
                    const n = this.editor,
                        o = n.plugins.get(FA).registry,
                        i = new eh(t, e),
                        r = i.getWalker({
                            ignoreElementEnd: !0
                        });
                    let s = "";
                    for (const t of r) t.item.is("$textProxy") && (s += t.item.data);
                    if (s = s.trim(), !s.match(VA)) return void i.detach();
                    if (!o.hasMedia(s)) return void i.detach();
                    n.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Ru.fromPosition(t), this._timeoutId = vi.window.setTimeout((() => {
                        n.model.change((t => {
                            let e;
                            this._timeoutId = null, t.remove(i), i.detach(), "$graveyard" !== this._positionToInsert.root.rootName && (e = this._positionToInsert), PA(n.model, s, e, !1), this._positionToInsert.detach(), this._positionToInsert = null
                        })), n.plugins.get("Delete").requestUndoOnBackspace()
                    }), 100)) : i.detach()
                }
            }
            var UA = n(9292),
                WA = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(UA.Z, WA);
            UA.Z.locals;
            class qA extends Dr {
                constructor(t, n) {
                    super(n);
                    const o = n.t;
                    this.focusTracker = new mr, this.keystrokes = new pr, this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(o("Save"), Lg.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t => !!t)), this.cancelButtonView = this._createButton(o("Cancel"), Lg.cancel, "ck-button-cancel", "cancel"), this._focusables = new Cr, this._focusCycler = new bs({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }), this._validators = t, this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-media-form", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.urlInputView, this.saveButtonView, this.cancelButtonView]
                    }), e(this)
                }
                render() {
                    super.render(), i({
                        view: this
                    });
                    [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((t => {
                        this._focusables.add(t), this.focusTracker.add(t.element)
                    })), this.keystrokes.listenTo(this.element);
                    const t = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", t), this.keystrokes.set("arrowleft", t), this.keystrokes.set("arrowup", t), this.keystrokes.set("arrowdown", t), this.listenTo(this.urlInputView.element, "selectstart", ((t, e) => {
                        e.stopPropagation()
                    }), {
                        priority: "high"
                    })
                }
                destroy() {
                    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                get url() {
                    return this.urlInputView.fieldView.element.value.trim()
                }
                set url(t) {
                    this.urlInputView.fieldView.element.value = t.trim()
                }
                isValid() {
                    this.resetFormStatus();
                    for (const t of this._validators) {
                        const e = t(this);
                        if (e) return this.urlInputView.errorText = e, !1
                    }
                    return !0
                }
                resetFormStatus() {
                    this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault
                }
                _createUrlInput() {
                    const t = this.locale.t,
                        e = new Om(this.locale, Rm),
                        n = e.fieldView;
                    return this._urlInputViewInfoDefault = t("Paste the media URL in the input."), this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster."), e.label = t("Media URL"), e.infoText = this._urlInputViewInfoDefault, n.on("input", (() => {
                        e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n.element.value.trim()
                    })), e
                }
                _createButton(t, e, n, o) {
                    const i = new es(this.locale);
                    return i.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), i.extendTemplate({
                        attributes: {
                            class: n
                        }
                    }), o && i.delegate("execute").to(this, o), i
                }
            }
            class GA extends vs {
                static get requires() {
                    return [FA]
                }
                static get pluginName() {
                    return "MediaEmbedUI"
                }
                init() {
                    const t = this.editor,
                        e = t.commands.get("mediaEmbed");
                    t.ui.componentFactory.add("mediaEmbed", (t => {
                        const n = tm(t);
                        return this._setUpDropdown(n, e), n
                    }))
                }
                _setUpDropdown(t, e) {
                    const n = this.editor,
                        o = n.t,
                        i = t.buttonView,
                        r = n.plugins.get(FA).registry;
                    t.once("change:isOpen", (() => {
                        const o = new qA(function(t, e) {
                            return [e => {
                                if (!e.url.length) return t("The URL must not be empty.")
                            }, n => {
                                if (!e.hasMedia(n.url)) return t("This media URL is not supported.")
                            }]
                        }(n.t, r), n.locale);
                        t.panelView.children.add(o), i.on("open", (() => {
                            o.disableCssTransitions(), o.url = e.value || "", o.urlInputView.fieldView.select(), o.enableCssTransitions()
                        }), {
                            priority: "low"
                        }), t.on("submit", (() => {
                            o.isValid() && (n.execute("mediaEmbed", o.url), n.editing.view.focus())
                        })), t.on("change:isOpen", (() => o.resetFormStatus())), t.on("cancel", (() => {
                            n.editing.view.focus()
                        })), o.delegate("submit", "cancel").to(t), o.urlInputView.bind("value").to(e, "value"), o.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t))
                    })), t.bind("isEnabled").to(e), i.set({
                        label: o("Insert media"),
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>',
                        tooltip: !0
                    })
                }
            }
            var $A = n(4652),
                YA = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()($A.Z, YA);
            $A.Z.locals;
    
            function KA(t, e, n, {
                blockElements: o,
                inlineObjectElements: i
            }) {
                let r = n.createPositionAt(t, "forward" == e ? "after" : "before");
                return r = r.getLastMatchingPosition((({
                    item: t
                }) => t.is("element") && !o.includes(t.name) && !i.includes(t.name)), {
                    direction: e
                }), "forward" == e ? r.nodeAfter : r.nodeBefore
            }
    
            function QA(t, e) {
                return !!t && t.is("element") && e.includes(t.name)
            }
    
            function ZA(t, e) {
                if (!t.childCount) return;
                const n = new Tg(t.document),
                    o = function(t, e) {
                        const n = e.createRangeIn(t),
                            o = new qs({
                                name: /^p|h\d+$/,
                                styles: {
                                    "mso-list": /.*/
                                }
                            }),
                            i = [];
                        for (const t of n)
                            if ("elementStart" === t.type && o.match(t.item)) {
                                const e = tC(t.item);
                                i.push({
                                    element: t.item,
                                    id: e.id,
                                    order: e.order,
                                    indent: e.indent
                                })
                            } return i
                    }(t, n);
                if (!o.length) return;
                let i = null,
                    r = 1;
                o.forEach(((t, s) => {
                    const a = function(t, e) {
                            if (!t) return !0;
                            if (t.id !== e.id) return e.indent - t.indent != 1;
                            const n = e.element.previousSibling;
                            if (!n) return !0;
                            return o = n, !(o.is("element", "ol") || o.is("element", "ul"));
                            var o
                        }(o[s - 1], t),
                        c = a ? null : o[s - 1],
                        l = (h = t, (d = c) ? h.indent - d.indent : h.indent - 1);
                    var d, h;
                    if (a && (i = null, r = 1), !i || 0 !== l) {
                        const o = function(t, e) {
                            const n = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, "gi"),
                                o = /mso-level-number-format:([^;]{0,100});/gi,
                                i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,
                                r = n.exec(e);
                            let s = "decimal",
                                a = "ol",
                                c = null;
                            if (r && r[1]) {
                                const e = o.exec(r[1]);
                                if (e && e[1] && (s = e[1].trim(), a = "bullet" !== s && "image" !== s ? "ol" : "ul"), "bullet" === s) {
                                    const e = function(t) {
                                        const e = function(t) {
                                            if (t.getChild(0).is("$text")) return null;
                                            for (const e of t.getChildren()) {
                                                if (!e.is("element", "span")) continue;
                                                const t = e.getChild(0);
                                                return t.is("$text") ? t : t.getChild(0)
                                            }
                                            return null
                                        }(t);
                                        if (!e) return null;
                                        const n = e._data;
                                        if ("o" === n) return "circle";
                                        if ("" === n) return "disc";
                                        if ("" === n) return "square";
                                        return null
                                    }(t.element);
                                    e && (s = e)
                                } else {
                                    const t = i.exec(r[1]);
                                    t && t[1] && (c = parseInt(t[1]))
                                }
                            }
                            return {
                                type: a,
                                startIndex: c,
                                style: JA(s)
                            }
                        }(t, e);
                        if (i) {
                            if (t.indent > r) {
                                const t = i.getChild(i.childCount - 1),
                                    e = t.getChild(t.childCount - 1);
                                i = XA(o, e, n), r += 1
                            } else if (t.indent < r) {
                                const e = r - t.indent;
                                i = function(t, e) {
                                    const n = t.getAncestors({
                                        parentFirst: !0
                                    });
                                    let o = null,
                                        i = 0;
                                    for (const t of n)
                                        if ((t.is("element", "ul") || t.is("element", "ol")) && i++, i === e) {
                                            o = t;
                                            break
                                        } return o
                                }(i, e), r = t.indent
                            }
                        } else i = XA(o, t.element, n);
                        t.indent <= r && (i.is("element", o.type) || (i = n.rename(o.type, i)))
                    }
                    const u = function(t, e) {
                        return function(t, e) {
                            const n = new qs({
                                    name: "span",
                                    styles: {
                                        "mso-list": "Ignore"
                                    }
                                }),
                                o = e.createRangeIn(t);
                            for (const t of o) "elementStart" === t.type && n.match(t.item) && e.remove(t.item)
                        }(t, e), e.rename("li", t)
                    }(t.element, n);
                    n.appendChild(u, i)
                }))
            }
    
            function JA(t) {
                if (t.startsWith("arabic-leading-zero")) return "decimal-leading-zero";
                switch (t) {
                    case "alpha-upper":
                        return "upper-alpha";
                    case "alpha-lower":
                        return "lower-alpha";
                    case "roman-upper":
                        return "upper-roman";
                    case "roman-lower":
                        return "lower-roman";
                    case "circle":
                    case "disc":
                    case "square":
                        return t;
                    default:
                        return null
                }
            }
    
            function XA(t, e, n) {
                const o = e.parent,
                    i = n.createElement(t.type),
                    r = o.getChildIndex(e) + 1;
                return n.insertChild(r, i, o), t.style && n.setStyle("list-style-type", t.style, i), t.startIndex && t.startIndex > 1 && n.setAttribute("start", t.startIndex, i), i
            }
    
            function tC(t) {
                const e = {},
                    n = t.getStyle("mso-list");
                if (n) {
                    const t = n.match(/(^|\s{1,100})l(\d+)/i),
                        o = n.match(/\s{0,100}lfo(\d+)/i),
                        i = n.match(/\s{0,100}level(\d+)/i);
                    t && o && i && (e.id = t[2], e.order = o[1], e.indent = parseInt(i[1]))
                }
                return e
            }
            const eC = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
            class nC {
                constructor(t) {
                    this.document = t
                }
                isActive(t) {
                    return eC.test(t)
                }
                execute(t) {
                    const e = new Tg(this.document),
                        {
                            body: n
                        } = t._parsedData;
                    ! function(t, e) {
                        for (const n of t.getChildren())
                            if (n.is("element", "b") && "normal" === n.getStyle("font-weight")) {
                                const o = t.getChildIndex(n);
                                e.remove(n), e.insertChild(o, n.getChildren(), t)
                            }
                    }(n, e),
                    function(t, e) {
                        for (const n of e.createRangeIn(t)) {
                            const t = n.item;
                            if (t.is("element", "li")) {
                                const n = t.getChild(0);
                                n && n.is("element", "p") && e.unwrapElement(n)
                            }
                        }
                    }(n, e),
                    function(t, e) {
                        const n = new kc(e.document.stylesProcessor),
                            o = new cl(n, {
                                renderingMode: "data"
                            }),
                            i = o.blockElements,
                            r = o.inlineObjectElements,
                            s = [];
                        for (const n of e.createRangeIn(t)) {
                            const t = n.item;
                            if (t.is("element", "br")) {
                                const n = KA(t, "forward", e, {
                                        blockElements: i,
                                        inlineObjectElements: r
                                    }),
                                    o = KA(t, "backward", e, {
                                        blockElements: i,
                                        inlineObjectElements: r
                                    }),
                                    a = QA(n, i);
                                (QA(o, i) || a) && s.push(t)
                            }
                        }
                        for (const t of s) t.hasClass("Apple-interchange-newline") ? e.remove(t) : e.replace(t, e.createElement("p"))
                    }(n, e), t.content = n
                }
            }
    
            function oC(t, e) {
                if (!t.childCount) return;
                const n = new Tg(t.document),
                    o = function(t, e) {
                        const n = e.createRangeIn(t),
                            o = new qs({
                                name: /v:(.+)/
                            }),
                            i = [];
                        for (const t of n) {
                            if ("elementStart" != t.type) continue;
                            const e = t.item,
                                n = e.previousSibling,
                                r = n && n.is("element") ? n.name : null;
                            o.match(e) && e.getAttribute("o:gfxdata") && "v:shapetype" !== r && i.push(t.item.getAttribute("id"))
                        }
                        return i
                    }(t, n);
                ! function(t, e, n) {
                    const o = n.createRangeIn(e),
                        i = new qs({
                            name: "img"
                        }),
                        r = [];
                    for (const e of o)
                        if (e.item.is("element") && i.match(e.item)) {
                            const n = e.item,
                                o = n.getAttribute("v:shapes") ? n.getAttribute("v:shapes").split(" ") : [];
                            o.length && o.every((e => t.indexOf(e) > -1)) ? r.push(n) : n.getAttribute("src") || r.push(n)
                        } for (const t of r) n.remove(t)
                }(o, t, n),
                function(t, e, n) {
                    const o = n.createRangeIn(e),
                        i = [];
                    for (const e of o)
                        if ("elementStart" == e.type && e.item.is("element", "v:shape")) {
                            const n = e.item.getAttribute("id");
                            if (t.includes(n)) continue;
                            r(e.item.parent.getChildren(), n) || i.push(e.item)
                        } for (const t of i) {
                        const e = {
                            src: s(t)
                        };
                        t.hasAttribute("alt") && (e.alt = t.getAttribute("alt"));
                        const o = n.createElement("img", e);
                        n.insertChild(t.index + 1, o, t.parent)
                    }
    
                    function r(t, e) {
                        for (const n of t)
                            if (n.is("element")) {
                                if ("img" == n.name && n.getAttribute("v:shapes") == e) return !0;
                                if (r(n.getChildren(), e)) return !0
                            } return !1
                    }
    
                    function s(t) {
                        for (const e of t.getChildren())
                            if (e.is("element") && e.getAttribute("src")) return e.getAttribute("src")
                    }
                }(o, t, n),
                function(t, e) {
                    const n = e.createRangeIn(t),
                        o = new qs({
                            name: /v:(.+)/
                        }),
                        i = [];
                    for (const t of n) "elementStart" == t.type && o.match(t.item) && i.push(t.item);
                    for (const t of i) e.remove(t)
                }(t, n);
                const i = function(t, e) {
                    const n = e.createRangeIn(t),
                        o = new qs({
                            name: "img"
                        }),
                        i = [];
                    for (const t of n) t.item.is("element") && o.match(t.item) && t.item.getAttribute("src").startsWith("file://") && i.push(t.item);
                    return i
                }(t, n);
                i.length && function(t, e, n) {
                    if (t.length === e.length)
                        for (let o = 0; o < t.length; o++) {
                            const i = `data:${e[o].type};base64,${iC(e[o].hex)}`;
                            n.setAttribute("src", i, t[o])
                        }
                }(i, function(t) {
                    if (!t) return [];
                    const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
                        n = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"),
                        o = t.match(n),
                        i = [];
                    if (o)
                        for (const t of o) {
                            let n = !1;
                            t.includes("\\pngblip") ? n = "image/png" : t.includes("\\jpegblip") && (n = "image/jpeg"), n && i.push({
                                hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""),
                                type: n
                            })
                        }
                    return i
                }(e), n)
            }
    
            function iC(t) {
                return btoa(t.match(/\w{2}/g).map((t => String.fromCharCode(parseInt(t, 16)))).join(""))
            }
            const rC = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
                sC = /xmlns:o="urn:schemas-microsoft-com/i;
            class aC {
                constructor(t) {
                    this.document = t
                }
                isActive(t) {
                    return rC.test(t) || sC.test(t)
                }
                execute(t) {
                    const {
                        body: e,
                        stylesString: n
                    } = t._parsedData;
                    ZA(e, n), oC(e, t.dataTransfer.getData("text/rtf")), t.content = e
                }
            }
    
            function cC(t) {
                return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => 1 === e.length ? " " : Array(e.length + 1).join("  ").substr(0, e.length)))
            }
    
            function lC(t, e) {
                const n = new DOMParser,
                    o = function(t) {
                        return cC(cC(t)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><")
                    }(function(t) {
                        const e = "</body>",
                            n = "</html>",
                            o = t.indexOf(e);
                        if (o < 0) return t;
                        const i = t.indexOf(n, o + e.length);
                        return t.substring(0, o + e.length) + (i >= 0 ? t.substring(i) : "")
                    }(t = t.replace(/<!--\[if gte vml 1]>/g, ""))),
                    i = n.parseFromString(o, "text/html");
                ! function(t) {
                    t.querySelectorAll("span[style*=spacerun]").forEach((t => {
                        const e = t,
                            n = e.innerText.length || 0;
                        e.innerText = Array(n + 1).join("  ").substr(0, n)
                    }))
                }(i);
                const r = i.body.innerHTML,
                    s = function(t, e) {
                        const n = new kc(e),
                            o = new cl(n, {
                                renderingMode: "data"
                            }),
                            i = t.createDocumentFragment(),
                            r = t.body.childNodes;
                        for (; r.length > 0;) i.appendChild(r[0]);
                        return o.domToView(i, {
                            skipComments: !0
                        })
                    }(i, e),
                    a = function(t) {
                        const e = [],
                            n = [],
                            o = Array.from(t.getElementsByTagName("style"));
                        for (const t of o) t.sheet && t.sheet.cssRules && t.sheet.cssRules.length && (e.push(t.sheet), n.push(t.innerHTML));
                        return {
                            styles: e,
                            stylesString: n.join(" ")
                        }
                    }(i);
                return {
                    body: s,
                    bodyString: r,
                    styles: a.styles,
                    stylesString: a.stylesString
                }
            }
    
            function dC(t, e, n, o, i = 1) {
                e > i ? o.setAttribute(t, e, n) : o.removeAttribute(t, n)
            }
    
            function hC(t, e, n = {}) {
                const o = t.createElement("tableCell", n);
                return t.insertElement("paragraph", o), t.insert(o, e), o
            }
    
            function uC(t, e) {
                const n = e.parent.parent,
                    o = parseInt(n.getAttribute("headingColumns") || 0),
                    {
                        column: i
                    } = t.getCellLocation(e);
                return !!o && i < o
            }
    
            function gC() {
                return t => {
                    t.on("element:table", ((t, e, n) => {
                        const o = e.viewItem;
                        if (!n.consumable.test(o, {
                                name: !0
                            })) return;
                        const {
                            rows: i,
                            headingRows: r,
                            headingColumns: s
                        } = function(t) {
                            const e = {
                                    headingRows: 0,
                                    headingColumns: 0
                                },
                                n = [],
                                o = [];
                            let i;
                            for (const r of Array.from(t.getChildren()))
                                if ("tbody" === r.name || "thead" === r.name || "tfoot" === r.name) {
                                    "thead" !== r.name || i || (i = r);
                                    const t = Array.from(r.getChildren()).filter((t => t.is("element", "tr")));
                                    for (const r of t)
                                        if ("thead" === r.parent.name && r.parent === i) e.headingRows++, n.push(r);
                                        else {
                                            o.push(r);
                                            const t = pC(r);
                                            t > e.headingColumns && (e.headingColumns = t)
                                        }
                                } return e.rows = [...n, ...o], e
                        }(o), a = {};
                        s && (a.headingColumns = s), r && (a.headingRows = r);
                        const c = n.writer.createElement("table", a);
                        if (n.safeInsert(c, e.modelCursor)) {
                            if (n.consumable.consume(o, {
                                    name: !0
                                }), i.forEach((t => n.convertItem(t, n.writer.createPositionAt(c, "end")))), n.convertChildren(o, n.writer.createPositionAt(c, "end")), c.isEmpty) {
                                const t = n.writer.createElement("tableRow");
                                n.writer.insert(t, n.writer.createPositionAt(c, "end")), hC(n.writer, n.writer.createPositionAt(t, "end"))
                            }
                            n.updateConversionResult(c, e)
                        }
                    }))
                }
            }
    
            function mC(t) {
                return e => {
                    e.on(`element:${t}`, ((t, e, {
                        writer: n
                    }) => {
                        if (!e.modelRange) return;
                        const o = e.modelRange.start.nodeAfter,
                            i = n.createPositionAt(o, 0);
                        if (e.viewItem.isEmpty) return void n.insertElement("paragraph", i);
                        const r = Array.from(o.getChildren());
                        if (r.every((t => t.is("element", "$marker")))) {
                            const t = n.createElement("paragraph");
                            n.insert(t, n.createPositionAt(o, 0));
                            for (const e of r) n.move(n.createRangeOn(e), n.createPositionAt(t, "end"))
                        }
                    }), {
                        priority: "low"
                    })
                }
            }
    
            function pC(t) {
                let e = 0,
                    n = 0;
                const o = Array.from(t.getChildren()).filter((t => "th" === t.name || "td" === t.name));
                for (; n < o.length && "th" === o[n].name;) {
                    const t = o[n];
                    e += parseInt(t.getAttribute("colspan") || 1), n++
                }
                return e
            }
            class fC {
                constructor(t, e = {}) {
                    this._table = t, this._startRow = void 0 !== e.row ? e.row : e.startRow || 0, this._endRow = void 0 !== e.row ? e.row : e.endRow, this._startColumn = void 0 !== e.column ? e.column : e.startColumn || 0, this._endColumn = void 0 !== e.column ? e.column : e.endColumn, this._includeAllSlots = !!e.includeAllSlots, this._skipRows = new Set, this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = new Map, this._nextCellAtColumn = -1
                } [Symbol.iterator]() {
                    return this
                }
                next() {
                    const t = this._table.getChild(this._rowIndex);
                    if (!t || this._isOverEndRow()) return {
                        done: !0
                    };
                    if (!t.is("element", "tableRow")) return this._rowIndex++, this.next();
                    if (this._isOverEndColumn()) return this._advanceToNextRow();
                    let e = null;
                    const n = this._getSpanned();
                    if (n) this._includeAllSlots && !this._shouldSkipSlot() && (e = this._formatOutValue(n.cell, n.row, n.column));
                    else {
                        const n = t.getChild(this._cellIndex);
                        if (!n) return this._advanceToNextRow();
                        const o = parseInt(n.getAttribute("colspan") || 1),
                            i = parseInt(n.getAttribute("rowspan") || 1);
                        (o > 1 || i > 1) && this._recordSpans(n, i, o), this._shouldSkipSlot() || (e = this._formatOutValue(n)), this._nextCellAtColumn = this._column + o
                    }
                    return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, e || this.next()
                }
                skipRow(t) {
                    this._skipRows.add(t)
                }
                _advanceToNextRow() {
                    return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next()
                }
                _isOverEndRow() {
                    return void 0 !== this._endRow && this._row > this._endRow
                }
                _isOverEndColumn() {
                    return void 0 !== this._endColumn && this._column > this._endColumn
                }
                _formatOutValue(t, e = this._row, n = this._column) {
                    return {
                        done: !1,
                        value: new kC(this, t, e, n)
                    }
                }
                _shouldSkipSlot() {
                    const t = this._skipRows.has(this._row),
                        e = this._row < this._startRow,
                        n = this._column < this._startColumn,
                        o = void 0 !== this._endColumn && this._column > this._endColumn;
                    return t || e || n || o
                }
                _getSpanned() {
                    const t = this._spannedCells.get(this._row);
                    return t && t.get(this._column) || null
                }
                _recordSpans(t, e, n) {
                    const o = {
                        cell: t,
                        row: this._row,
                        column: this._column
                    };
                    for (let t = this._row; t < this._row + e; t++)
                        for (let e = this._column; e < this._column + n; e++) t == this._row && e == this._column || this._markSpannedCell(t, e, o)
                }
                _markSpannedCell(t, e, n) {
                    this._spannedCells.has(t) || this._spannedCells.set(t, new Map);
                    this._spannedCells.get(t).set(e, n)
                }
            }
            class kC {
                constructor(t, e, n, o) {
                    this.cell = e, this.row = t._row, this.column = t._column, this.cellAnchorRow = n, this.cellAnchorColumn = o, this._cellIndex = t._cellIndex, this._rowIndex = t._rowIndex, this._table = t._table
                }
                get isAnchor() {
                    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
                }
                get cellWidth() {
                    return parseInt(this.cell.getAttribute("colspan") || 1)
                }
                get cellHeight() {
                    return parseInt(this.cell.getAttribute("rowspan") || 1)
                }
                get rowIndex() {
                    return this._rowIndex
                }
                getPositionBefore() {
                    return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex)
                }
            }
    
            function bC(t, e = {}) {
                return (n, {
                    writer: o
                }) => {
                    const i = n.getAttribute("headingRows") || 0,
                        r = [];
                    i > 0 && r.push(o.createContainerElement("thead", null, o.createSlot((t => t.is("element", "tableRow") && t.index < i)))), i < t.getRows(n) && r.push(o.createContainerElement("tbody", null, o.createSlot((t => t.is("element", "tableRow") && t.index >= i))));
                    const s = o.createContainerElement("figure", {
                        class: "table"
                    }, [o.createContainerElement("table", null, r), o.createSlot((t => !t.is("element", "tableRow")))]);
                    return e.asWidget ? function(t, e) {
                        return e.setCustomProperty("table", !0, t), hf(t, e, {
                            hasSelectionHandle: !0
                        })
                    }(s, o) : s
                }
            }
    
            function wC(t = {}) {
                return (e, {
                    writer: n
                }) => {
                    const o = e.parent,
                        i = o.parent,
                        r = i.getChildIndex(o),
                        s = new fC(i, {
                            row: r
                        }),
                        a = i.getAttribute("headingRows") || 0,
                        c = i.getAttribute("headingColumns") || 0;
                    for (const o of s)
                        if (o.cell == e) {
                            const e = o.row < a || o.column < c ? "th" : "td";
                            return t.asWidget ? pf(n.createEditableElement(e), n) : n.createContainerElement(e)
                        }
                }
            }
    
            function _C(t = {}) {
                return (e, {
                    writer: n
                }) => {
                    if (e.parent.is("element", "tableCell") && AC(e)) {
                        if (t.asWidget) return n.createContainerElement("span", {
                            class: "ck-table-bogus-paragraph"
                        });
                        {
                            const t = n.createContainerElement("p");
                            return n.setCustomProperty("dataPipeline:transparentRendering", !0, t), t
                        }
                    }
                }
            }
    
            function AC(t) {
                return 1 == t.parent.childCount && ![...t.getAttributeKeys()].length
            }
            class CC extends xs {
                refresh() {
                    const t = this.editor.model,
                        e = t.document.selection,
                        n = t.schema;
                    this.isEnabled = function(t, e) {
                        const n = t.getFirstPosition().parent,
                            o = n === n.root ? n : n.parent;
                        return e.checkChild(o, "table")
                    }(e, n)
                }
                execute(t = {}) {
                    const e = this.editor.model,
                        n = this.editor.plugins.get("TableUtils"),
                        o = this.editor.config.get("table"),
                        i = o.defaultHeadings.rows,
                        r = o.defaultHeadings.columns;
                    void 0 === t.headingRows && i && (t.headingRows = i), void 0 === t.headingColumns && r && (t.headingColumns = r), e.change((o => {
                        const i = n.createTable(o, t);
                        e.insertObject(i, null, null, {
                            findOptimalPosition: "auto"
                        }), o.setSelection(o.createPositionAt(i.getNodeByPath([0, 0, 0]), 0))
                    }))
                }
            }
            class vC extends xs {
                constructor(t, e = {}) {
                    super(t), this.order = e.order || "below"
                }
                refresh() {
                    const t = this.editor.model.document.selection,
                        e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
                    this.isEnabled = e
                }
                execute() {
                    const t = this.editor,
                        e = t.model.document.selection,
                        n = t.plugins.get("TableUtils"),
                        o = "above" === this.order,
                        i = n.getSelectionAffectedTableCells(e),
                        r = n.getRowIndexes(i),
                        s = o ? r.first : r.last,
                        a = i[0].findAncestor("table");
                    n.insertRows(a, {
                        at: o ? s : s + 1,
                        copyStructureFromAbove: !o
                    })
                }
            }
            class yC extends xs {
                constructor(t, e = {}) {
                    super(t), this.order = e.order || "right"
                }
                refresh() {
                    const t = this.editor.model.document.selection,
                        e = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t).length;
                    this.isEnabled = e
                }
                execute() {
                    const t = this.editor,
                        e = t.model.document.selection,
                        n = t.plugins.get("TableUtils"),
                        o = "left" === this.order,
                        i = n.getSelectionAffectedTableCells(e),
                        r = n.getColumnIndexes(i),
                        s = o ? r.first : r.last,
                        a = i[0].findAncestor("table");
                    n.insertColumns(a, {
                        columns: 1,
                        at: o ? s : s + 1
                    })
                }
            }
            class xC extends xs {
                constructor(t, e = {}) {
                    super(t), this.direction = e.direction || "horizontally"
                }
                refresh() {
                    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = 1 === t.length
                }
                execute() {
                    const t = this.editor.plugins.get("TableUtils"),
                        e = t.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
                    "horizontally" === this.direction ? t.splitCellHorizontally(e, 2) : t.splitCellVertically(e, 2)
                }
            }
    
            function EC(t, e, n) {
                const {
                    startRow: o,
                    startColumn: i,
                    endRow: r,
                    endColumn: s
                } = e, a = n.createElement("table"), c = r - o + 1;
                for (let t = 0; t < c; t++) n.insertElement("tableRow", a, "end");
                const l = [...new fC(t, {
                    startRow: o,
                    endRow: r,
                    startColumn: i,
                    endColumn: s,
                    includeAllSlots: !0
                })];
                for (const {
                        row: t,
                        column: e,
                        cell: c,
                        isAnchor: d,
                        cellAnchorRow: h,
                        cellAnchorColumn: u
                    }
                    of l) {
                    const l = t - o,
                        g = a.getChild(l);
                    if (d) {
                        const o = n.cloneElement(c);
                        n.append(o, g), SC(o, t, e, r, s, n)
                    } else(h < o || u < i) && hC(n, n.createPositionAt(g, "end"))
                }
                return function(t, e, n, o, i) {
                    const r = parseInt(e.getAttribute("headingRows") || 0);
                    if (r > 0) {
                        dC("headingRows", r - n, t, i, 0)
                    }
                    const s = parseInt(e.getAttribute("headingColumns") || 0);
                    if (s > 0) {
                        dC("headingColumns", s - o, t, i, 0)
                    }
                }(a, t, o, i, n), a
            }
    
            function DC(t, e, n = 0) {
                const o = [],
                    i = new fC(t, {
                        startRow: n,
                        endRow: e - 1
                    });
                for (const t of i) {
                    const {
                        row: n,
                        cellHeight: i
                    } = t;
                    n < e && e <= n + i - 1 && o.push(t)
                }
                return o
            }
    
            function IC(t, e, n) {
                const o = t.parent,
                    i = o.parent,
                    r = o.index,
                    s = e - r,
                    a = {},
                    c = parseInt(t.getAttribute("rowspan")) - s;
                c > 1 && (a.rowspan = c);
                const l = parseInt(t.getAttribute("colspan") || 1);
                l > 1 && (a.colspan = l);
                const d = r + s,
                    h = [...new fC(i, {
                        startRow: r,
                        endRow: d,
                        includeAllSlots: !0
                    })];
                let u, g = null;
                for (const e of h) {
                    const {
                        row: o,
                        column: i,
                        cell: r
                    } = e;
                    r === t && void 0 === u && (u = i), void 0 !== u && u === i && o === d && (g = hC(n, e.getPositionBefore(), a))
                }
                return dC("rowspan", s, t, n), g
            }
    
            function TC(t, e) {
                const n = [],
                    o = new fC(t);
                for (const t of o) {
                    const {
                        column: o,
                        cellWidth: i
                    } = t;
                    o < e && e <= o + i - 1 && n.push(t)
                }
                return n
            }
    
            function MC(t, e, n, o) {
                const i = n - e,
                    r = {},
                    s = parseInt(t.getAttribute("colspan")) - i;
                s > 1 && (r.colspan = s);
                const a = parseInt(t.getAttribute("rowspan") || 1);
                a > 1 && (r.rowspan = a);
                const c = hC(o, o.createPositionAfter(t), r);
                return dC("colspan", i, t, o), c
            }
    
            function SC(t, e, n, o, i, r) {
                const s = parseInt(t.getAttribute("colspan") || 1),
                    a = parseInt(t.getAttribute("rowspan") || 1);
                if (n + s - 1 > i) {
                    dC("colspan", i - n + 1, t, r, 1)
                }
                if (e + a - 1 > o) {
                    dC("rowspan", o - e + 1, t, r, 1)
                }
            }
    
            function NC(t, e) {
                const n = e.getColumns(t),
                    o = new Array(n).fill(0);
                for (const {
                        column: e
                    }
                    of new fC(t)) o[e]++;
                const i = o.reduce(((t, e, n) => e ? t : [...t, n]), []);
                if (i.length > 0) {
                    const n = i[i.length - 1];
                    return e.removeColumns(t, {
                        at: n
                    }), !0
                }
                return !1
            }
    
            function BC(t, e) {
                const n = [],
                    o = e.getRows(t);
                for (let e = 0; e < o; e++) {
                    t.getChild(e).isEmpty && n.push(e)
                }
                if (n.length > 0) {
                    const o = n[n.length - 1];
                    return e.removeRows(t, {
                        at: o
                    }), !0
                }
                return !1
            }
    
            function PC(t, e) {
                NC(t, e) || BC(t, e)
            }
    
            function zC(t, e) {
                const n = Array.from(new fC(t, {
                    startColumn: e.firstColumn,
                    endColumn: e.lastColumn,
                    row: e.lastRow
                }));
                if (n.every((({
                        cellHeight: t
                    }) => 1 === t))) return e.lastRow;
                const o = n[0].cellHeight - 1;
                return e.lastRow + o
            }
    
            function LC(t, e) {
                const n = Array.from(new fC(t, {
                    startRow: e.firstRow,
                    endRow: e.lastRow,
                    column: e.lastColumn
                }));
                if (n.every((({
                        cellWidth: t
                    }) => 1 === t))) return e.lastColumn;
                const o = n[0].cellWidth - 1;
                return e.lastColumn + o
            }
            class OC extends xs {
                constructor(t, e) {
                    super(t), this.direction = e.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction
                }
                refresh() {
                    const t = this._getMergeableCell();
                    this.value = t, this.isEnabled = !!t
                }
                execute() {
                    const t = this.editor.model,
                        e = t.document,
                        n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e.selection)[0],
                        o = this.value,
                        i = this.direction;
                    t.change((t => {
                        const e = "right" == i || "down" == i,
                            r = e ? n : o,
                            s = e ? o : n,
                            a = s.parent;
                        ! function(t, e, n) {
                            RC(t) || (RC(e) && n.remove(n.createRangeIn(e)), n.move(n.createRangeIn(t), n.createPositionAt(e, "end")));
                            n.remove(t)
                        }(s, r, t);
                        const c = this.isHorizontal ? "colspan" : "rowspan",
                            l = parseInt(n.getAttribute(c) || 1),
                            d = parseInt(o.getAttribute(c) || 1);
                        t.setAttribute(c, l + d, r), t.setSelection(t.createRangeIn(r));
                        const h = this.editor.plugins.get("TableUtils");
                        PC(a.findAncestor("table"), h)
                    }))
                }
                _getMergeableCell() {
                    const t = this.editor.model.document,
                        e = this.editor.plugins.get("TableUtils"),
                        n = e.getTableCellsContainingSelection(t.selection)[0];
                    if (!n) return;
                    const o = this.isHorizontal ? function(t, e, n) {
                        const o = t.parent,
                            i = o.parent,
                            r = "right" == e ? t.nextSibling : t.previousSibling,
                            s = (i.getAttribute("headingColumns") || 0) > 0;
                        if (!r) return;
                        const a = "right" == e ? t : r,
                            c = "right" == e ? r : t,
                            {
                                column: l
                            } = n.getCellLocation(a),
                            {
                                column: d
                            } = n.getCellLocation(c),
                            h = parseInt(a.getAttribute("colspan") || 1),
                            u = uC(n, a),
                            g = uC(n, c);
                        if (s && u != g) return;
                        return l + h === d ? r : void 0
                    }(n, this.direction, e) : function(t, e, n) {
                        const o = t.parent,
                            i = o.parent,
                            r = i.getChildIndex(o);
                        if ("down" == e && r === n.getRows(i) - 1 || "up" == e && 0 === r) return;
                        const s = parseInt(t.getAttribute("rowspan") || 1),
                            a = i.getAttribute("headingRows") || 0,
                            c = "down" == e && r + s === a,
                            l = "up" == e && r === a;
                        if (a && (c || l)) return;
                        const d = parseInt(t.getAttribute("rowspan") || 1),
                            h = "down" == e ? r + d : r,
                            u = [...new fC(i, {
                                endRow: h
                            })],
                            g = u.find((e => e.cell === t)),
                            m = g.column,
                            p = u.find((({
                                row: t,
                                cellHeight: n,
                                column: o
                            }) => o === m && ("down" == e ? t === h : h === t + n)));
                        return p && p.cell
                    }(n, this.direction, e);
                    if (!o) return;
                    const i = this.isHorizontal ? "rowspan" : "colspan",
                        r = parseInt(n.getAttribute(i) || 1);
                    return parseInt(o.getAttribute(i) || 1) === r ? o : void 0
                }
            }
    
            function RC(t) {
                return 1 == t.childCount && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
            }
            class jC extends xs {
                refresh() {
                    const t = this.editor.plugins.get("TableUtils"),
                        e = t.getSelectionAffectedTableCells(this.editor.model.document.selection),
                        n = e[0];
                    if (n) {
                        const o = n.findAncestor("table"),
                            i = this.editor.plugins.get("TableUtils").getRows(o) - 1,
                            r = t.getRowIndexes(e),
                            s = 0 === r.first && r.last === i;
                        this.isEnabled = !s
                    } else this.isEnabled = !1
                }
                execute() {
                    const t = this.editor.model,
                        e = this.editor.plugins.get("TableUtils"),
                        n = e.getSelectionAffectedTableCells(t.document.selection),
                        o = e.getRowIndexes(n),
                        i = n[0],
                        r = i.findAncestor("table"),
                        s = e.getCellLocation(i).column;
                    t.change((t => {
                        const n = o.last - o.first + 1;
                        e.removeRows(r, {
                            at: o.first,
                            rows: n
                        });
                        const i = function(t, e, n, o) {
                            const i = t.getChild(Math.min(e, o - 1));
                            let r = i.getChild(0),
                                s = 0;
                            for (const t of i.getChildren()) {
                                if (s > n) return r;
                                r = t, s += parseInt(t.getAttribute("colspan") || 1)
                            }
                            return r
                        }(r, o.first, s, e.getRows(r));
                        t.setSelection(t.createPositionAt(i, 0))
                    }))
                }
            }
            class FC extends xs {
                refresh() {
                    const t = this.editor.plugins.get("TableUtils"),
                        e = t.getSelectionAffectedTableCells(this.editor.model.document.selection),
                        n = e[0];
                    if (n) {
                        const o = n.findAncestor("table"),
                            i = t.getColumns(o),
                            {
                                first: r,
                                last: s
                            } = t.getColumnIndexes(e);
                        this.isEnabled = s - r < i - 1
                    } else this.isEnabled = !1
                }
                execute() {
                    const t = this.editor.plugins.get("TableUtils"),
                        [e, n] = function(t, e) {
                            const n = e.getSelectionAffectedTableCells(t),
                                o = n[0],
                                i = n.pop(),
                                r = [o, i];
                            return o.isBefore(i) ? r : r.reverse()
                        }(this.editor.model.document.selection, t),
                        o = e.parent.parent,
                        i = [...new fC(o)],
                        r = {
                            first: i.find((t => t.cell === e)).column,
                            last: i.find((t => t.cell === n)).column
                        },
                        s = function(t, e, n, o) {
                            const i = parseInt(n.getAttribute("colspan") || 1);
                            return i > 1 ? n : e.previousSibling || n.nextSibling ? n.nextSibling || e.previousSibling : o.first ? t.reverse().find((({
                                column: t
                            }) => t < o.first)).cell : t.reverse().find((({
                                column: t
                            }) => t > o.last)).cell
                        }(i, e, n, r);
                    this.editor.model.change((t => {
                        const e = r.last - r.first + 1;
                        this.editor.plugins.get("TableUtils").removeColumns(o, {
                            at: r.first,
                            columns: e
                        }), t.setSelection(t.createPositionAt(s, 0))
                    }))
                }
            }
            class VC extends xs {
                refresh() {
                    const t = this.editor.plugins.get("TableUtils"),
                        e = this.editor.model,
                        n = t.getSelectionAffectedTableCells(e.document.selection),
                        o = n.length > 0;
                    this.isEnabled = o, this.value = o && n.every((t => this._isInHeading(t, t.parent.parent)))
                }
                execute(t = {}) {
                    if (t.forceValue === this.value) return;
                    const e = this.editor.plugins.get("TableUtils"),
                        n = this.editor.model,
                        o = e.getSelectionAffectedTableCells(n.document.selection),
                        i = o[0].findAncestor("table"),
                        {
                            first: r,
                            last: s
                        } = e.getRowIndexes(o),
                        a = this.value ? r : s + 1,
                        c = i.getAttribute("headingRows") || 0;
                    n.change((t => {
                        if (a) {
                            const e = DC(i, a, a > c ? c : 0);
                            for (const {
                                    cell: n
                                }
                                of e) IC(n, a, t)
                        }
                        dC("headingRows", a, i, t, 0)
                    }))
                }
                _isInHeading(t, e) {
                    const n = parseInt(e.getAttribute("headingRows") || 0);
                    return !!n && t.parent.index < n
                }
            }
            class HC extends xs {
                refresh() {
                    const t = this.editor.model,
                        e = this.editor.plugins.get("TableUtils"),
                        n = e.getSelectionAffectedTableCells(t.document.selection),
                        o = n.length > 0;
                    this.isEnabled = o, this.value = o && n.every((t => uC(e, t)))
                }
                execute(t = {}) {
                    if (t.forceValue === this.value) return;
                    const e = this.editor.plugins.get("TableUtils"),
                        n = this.editor.model,
                        o = e.getSelectionAffectedTableCells(n.document.selection),
                        i = o[0].findAncestor("table"),
                        {
                            first: r,
                            last: s
                        } = e.getColumnIndexes(o),
                        a = this.value ? r : s + 1;
                    n.change((t => {
                        if (a) {
                            const e = TC(i, a);
                            for (const {
                                    cell: n,
                                    column: o
                                }
                                of e) MC(n, o, a, t)
                        }
                        dC("headingColumns", a, i, t, 0)
                    }))
                }
            }
            class UC extends vs {
                static get pluginName() {
                    return "TableUtils"
                }
                init() {
                    this.decorate("insertColumns"), this.decorate("insertRows")
                }
                getCellLocation(t) {
                    const e = t.parent,
                        n = e.parent,
                        o = n.getChildIndex(e),
                        i = new fC(n, {
                            row: o
                        });
                    for (const {
                            cell: e,
                            row: n,
                            column: o
                        }
                        of i)
                        if (e === t) return {
                            row: n,
                            column: o
                        }
                }
                createTable(t, e) {
                    const n = t.createElement("table"),
                        o = parseInt(e.rows) || 2,
                        i = parseInt(e.columns) || 2;
                    return WC(t, n, 0, o, i), e.headingRows && dC("headingRows", Math.min(e.headingRows, o), n, t, 0), e.headingColumns && dC("headingColumns", Math.min(e.headingColumns, i), n, t, 0), n
                }
                insertRows(t, e = {}) {
                    const n = this.editor.model,
                        o = e.at || 0,
                        i = e.rows || 1,
                        r = void 0 !== e.copyStructureFromAbove,
                        s = e.copyStructureFromAbove ? o - 1 : o,
                        a = this.getRows(t),
                        c = this.getColumns(t);
                    if (o > a) throw new A("tableutils-insertrows-insert-out-of-range", this, {
                        options: e
                    });
                    n.change((e => {
                        const n = t.getAttribute("headingRows") || 0;
                        if (n > o && dC("headingRows", n + i, t, e, 0), !r && (0 === o || o === a)) return void WC(e, t, o, i, c);
                        const l = r ? Math.max(o, s) : o,
                            d = new fC(t, {
                                endRow: l
                            }),
                            h = new Array(c).fill(1);
                        for (const {
                                row: t,
                                column: n,
                                cellHeight: a,
                                cellWidth: c,
                                cell: l
                            }
                            of d) {
                            const d = t + a - 1,
                                u = t <= s && s <= d;
                            t < o && o <= d ? (e.setAttribute("rowspan", a + i, l), h[n] = -c) : r && u && (h[n] = c)
                        }
                        for (let n = 0; n < i; n++) {
                            const n = e.createElement("tableRow");
                            e.insert(n, t, o);
                            for (let t = 0; t < h.length; t++) {
                                const o = h[t],
                                    i = e.createPositionAt(n, "end");
                                o > 0 && hC(e, i, o > 1 ? {
                                    colspan: o
                                } : null), t += Math.abs(o) - 1
                            }
                        }
                    }))
                }
                insertColumns(t, e = {}) {
                    const n = this.editor.model,
                        o = e.at || 0,
                        i = e.columns || 1;
                    n.change((e => {
                        const n = t.getAttribute("headingColumns");
                        o < n && e.setAttribute("headingColumns", n + i, t);
                        const r = this.getColumns(t);
                        if (0 === o || r === o) {
                            for (const n of t.getChildren()) n.is("element", "tableRow") && qC(i, e, e.createPositionAt(n, o ? "end" : 0));
                            return
                        }
                        const s = new fC(t, {
                            column: o,
                            includeAllSlots: !0
                        });
                        for (const t of s) {
                            const {
                                row: n,
                                cell: r,
                                cellAnchorColumn: a,
                                cellAnchorRow: c,
                                cellWidth: l,
                                cellHeight: d
                            } = t;
                            if (a < o) {
                                e.setAttribute("colspan", l + i, r);
                                const t = c + d - 1;
                                for (let e = n; e <= t; e++) s.skipRow(e)
                            } else qC(i, e, t.getPositionBefore())
                        }
                    }))
                }
                removeRows(t, e) {
                    const n = this.editor.model,
                        o = e.rows || 1,
                        i = this.getRows(t),
                        r = e.at,
                        s = r + o - 1;
                    if (s > i - 1) throw new A("tableutils-removerows-row-index-out-of-range", this, {
                        table: t,
                        options: e
                    });
                    n.change((e => {
                        const {
                            cellsToMove: n,
                            cellsToTrim: o
                        } = function(t, e, n) {
                            const o = new Map,
                                i = [];
                            for (const {
                                    row: r,
                                    column: s,
                                    cellHeight: a,
                                    cell: c
                                }
                                of new fC(t, {
                                    endRow: n
                                })) {
                                const t = r + a - 1;
                                if (r >= e && r <= n && t > n) {
                                    const t = a - (n - r + 1);
                                    o.set(s, {
                                        cell: c,
                                        rowspan: t
                                    })
                                }
                                if (r < e && t >= e) {
                                    let o;
                                    o = t >= n ? n - e + 1 : t - e + 1, i.push({
                                        cell: c,
                                        rowspan: a - o
                                    })
                                }
                            }
                            return {
                                cellsToMove: o,
                                cellsToTrim: i
                            }
                        }(t, r, s);
                        if (n.size) {
                            ! function(t, e, n, o) {
                                const i = new fC(t, {
                                        includeAllSlots: !0,
                                        row: e
                                    }),
                                    r = [...i],
                                    s = t.getChild(e);
                                let a;
                                for (const {
                                        column: t,
                                        cell: e,
                                        isAnchor: i
                                    }
                                    of r)
                                    if (n.has(t)) {
                                        const {
                                            cell: e,
                                            rowspan: i
                                        } = n.get(t), r = a ? o.createPositionAfter(a) : o.createPositionAt(s, 0);
                                        o.move(o.createRangeOn(e), r), dC("rowspan", i, e, o), a = e
                                    } else i && (a = e)
                            }(t, s + 1, n, e)
                        }
                        for (let n = s; n >= r; n--) e.remove(t.getChild(n));
                        for (const {
                                rowspan: t,
                                cell: n
                            }
                            of o) dC("rowspan", t, n, e);
                        ! function(t, e, n, o) {
                            const i = t.getAttribute("headingRows") || 0;
                            if (e < i) {
                                dC("headingRows", n < i ? i - (n - e + 1) : e, t, o, 0)
                            }
                        }(t, r, s, e), NC(t, this) || BC(t, this)
                    }))
                }
                removeColumns(t, e) {
                    const n = this.editor.model,
                        o = e.at,
                        i = e.columns || 1,
                        r = e.at + i - 1;
                    n.change((e => {
                        ! function(t, e, n) {
                            const o = t.getAttribute("headingColumns") || 0;
                            if (o && e.first < o) {
                                const i = Math.min(o - 1, e.last) - e.first + 1;
                                n.setAttribute("headingColumns", o - i, t)
                            }
                        }(t, {
                            first: o,
                            last: r
                        }, e);
                        for (let n = r; n >= o; n--)
                            for (const {
                                    cell: o,
                                    column: i,
                                    cellWidth: r
                                }
                                of [...new fC(t)]) i <= n && r > 1 && i + r > n ? dC("colspan", r - 1, o, e) : i === n && e.remove(o);
                        BC(t, this) || NC(t, this)
                    }))
                }
                splitCellVertically(t, e = 2) {
                    const n = this.editor.model,
                        o = t.parent.parent,
                        i = parseInt(t.getAttribute("rowspan") || 1),
                        r = parseInt(t.getAttribute("colspan") || 1);
                    n.change((n => {
                        if (r > 1) {
                            const {
                                newCellsSpan: o,
                                updatedSpan: s
                            } = GC(r, e);
                            dC("colspan", s, t, n);
                            const a = {};
                            o > 1 && (a.colspan = o), i > 1 && (a.rowspan = i);
                            qC(r > e ? e - 1 : r - 1, n, n.createPositionAfter(t), a)
                        }
                        if (r < e) {
                            const s = e - r,
                                a = [...new fC(o)],
                                {
                                    column: c
                                } = a.find((({
                                    cell: e
                                }) => e === t)),
                                l = a.filter((({
                                    cell: e,
                                    cellWidth: n,
                                    column: o
                                }) => e !== t && o === c || o < c && o + n > c));
                            for (const {
                                    cell: t,
                                    cellWidth: e
                                }
                                of l) n.setAttribute("colspan", e + s, t);
                            const d = {};
                            i > 1 && (d.rowspan = i), qC(s, n, n.createPositionAfter(t), d);
                            const h = o.getAttribute("headingColumns") || 0;
                            h > c && dC("headingColumns", h + s, o, n)
                        }
                    }))
                }
                splitCellHorizontally(t, e = 2) {
                    const n = this.editor.model,
                        o = t.parent,
                        i = o.parent,
                        r = i.getChildIndex(o),
                        s = parseInt(t.getAttribute("rowspan") || 1),
                        a = parseInt(t.getAttribute("colspan") || 1);
                    n.change((n => {
                        if (s > 1) {
                            const o = [...new fC(i, {
                                    startRow: r,
                                    endRow: r + s - 1,
                                    includeAllSlots: !0
                                })],
                                {
                                    newCellsSpan: c,
                                    updatedSpan: l
                                } = GC(s, e);
                            dC("rowspan", l, t, n);
                            const {
                                column: d
                            } = o.find((({
                                cell: e
                            }) => e === t)), h = {};
                            c > 1 && (h.rowspan = c), a > 1 && (h.colspan = a);
                            for (const t of o) {
                                const {
                                    column: e,
                                    row: o
                                } = t;
                                o >= r + l && e === d && (o + r + l) % c == 0 && qC(1, n, t.getPositionBefore(), h)
                            }
                        }
                        if (s < e) {
                            const o = e - s,
                                c = [...new fC(i, {
                                    startRow: 0,
                                    endRow: r
                                })];
                            for (const {
                                    cell: e,
                                    cellHeight: i,
                                    row: s
                                }
                                of c)
                                if (e !== t && s + i > r) {
                                    const t = i + o;
                                    n.setAttribute("rowspan", t, e)
                                } const l = {};
                            a > 1 && (l.colspan = a), WC(n, i, r + 1, o, 1, l);
                            const d = i.getAttribute("headingRows") || 0;
                            d > r && dC("headingRows", d + o, i, n)
                        }
                    }))
                }
                getColumns(t) {
                    return [...t.getChild(0).getChildren()].reduce(((t, e) => t + parseInt(e.getAttribute("colspan") || 1)), 0)
                }
                getRows(t) {
                    return Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0)
                }
                createTableWalker(t, e = {}) {
                    return new fC(t, e)
                }
                getSelectedTableCells(t) {
                    const e = [];
                    for (const n of this.sortRanges(t.getRanges())) {
                        const t = n.getContainedElement();
                        t && t.is("element", "tableCell") && e.push(t)
                    }
                    return e
                }
                getTableCellsContainingSelection(t) {
                    const e = [];
                    for (const n of t.getRanges()) {
                        const t = n.start.findAncestor("tableCell");
                        t && e.push(t)
                    }
                    return e
                }
                getSelectionAffectedTableCells(t) {
                    const e = this.getSelectedTableCells(t);
                    return e.length ? e : this.getTableCellsContainingSelection(t)
                }
                getRowIndexes(t) {
                    const e = t.map((t => t.parent.index));
                    return this._getFirstLastIndexesObject(e)
                }
                getColumnIndexes(t) {
                    const e = t[0].findAncestor("table"),
                        n = [...new fC(e)].filter((e => t.includes(e.cell))).map((t => t.column));
                    return this._getFirstLastIndexesObject(n)
                }
                isSelectionRectangular(t) {
                    if (t.length < 2 || !this._areCellInTheSameTableSection(t)) return !1;
                    const e = new Set,
                        n = new Set;
                    let o = 0;
                    for (const i of t) {
                        const {
                            row: t,
                            column: r
                        } = this.getCellLocation(i), s = parseInt(i.getAttribute("rowspan") || 1), a = parseInt(i.getAttribute("colspan") || 1);
                        e.add(t), n.add(r), s > 1 && e.add(t + s - 1), a > 1 && n.add(r + a - 1), o += s * a
                    }
                    const i = function(t, e) {
                        const n = Array.from(t.values()),
                            o = Array.from(e.values()),
                            i = Math.max(...n),
                            r = Math.min(...n),
                            s = Math.max(...o),
                            a = Math.min(...o);
                        return (i - r + 1) * (s - a + 1)
                    }(e, n);
                    return i == o
                }
                sortRanges(t) {
                    return Array.from(t).sort($C)
                }
                _getFirstLastIndexesObject(t) {
                    const e = t.sort(((t, e) => t - e));
                    return {
                        first: e[0],
                        last: e[e.length - 1]
                    }
                }
                _areCellInTheSameTableSection(t) {
                    const e = t[0].findAncestor("table"),
                        n = this.getRowIndexes(t),
                        o = parseInt(e.getAttribute("headingRows") || 0);
                    if (!this._areIndexesInSameSection(n, o)) return !1;
                    const i = parseInt(e.getAttribute("headingColumns") || 0),
                        r = this.getColumnIndexes(t);
                    return this._areIndexesInSameSection(r, i)
                }
                _areIndexesInSameSection({
                    first: t,
                    last: e
                }, n) {
                    return t < n === e < n
                }
            }
    
            function WC(t, e, n, o, i, r = {}) {
                for (let s = 0; s < o; s++) {
                    const o = t.createElement("tableRow");
                    t.insert(o, e, n), qC(i, t, t.createPositionAt(o, "end"), r)
                }
            }
    
            function qC(t, e, n, o = {}) {
                for (let i = 0; i < t; i++) hC(e, n, o)
            }
    
            function GC(t, e) {
                if (t < e) return {
                    newCellsSpan: 1,
                    updatedSpan: 1
                };
                const n = Math.floor(t / e);
                return {
                    newCellsSpan: n,
                    updatedSpan: t - n * e + n
                }
            }
    
            function $C(t, e) {
                const n = t.start,
                    o = e.start;
                return n.isBefore(o) ? -1 : 1
            }
            class YC extends xs {
                refresh() {
                    const t = this.editor.plugins.get(UC),
                        e = t.getSelectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = t.isSelectionRectangular(e, this.editor.plugins.get(UC))
                }
                execute() {
                    const t = this.editor.model,
                        e = this.editor.plugins.get(UC);
                    t.change((n => {
                        const o = e.getSelectedTableCells(t.document.selection),
                            i = o.shift(),
                            {
                                mergeWidth: r,
                                mergeHeight: s
                            } = function(t, e, n) {
                                let o = 0,
                                    i = 0;
                                for (const t of e) {
                                    const {
                                        row: e,
                                        column: r
                                    } = n.getCellLocation(t);
                                    o = ZC(t, r, o, "colspan"), i = ZC(t, e, i, "rowspan")
                                }
                                const {
                                    row: r,
                                    column: s
                                } = n.getCellLocation(t), a = o - s, c = i - r;
                                return {
                                    mergeWidth: a,
                                    mergeHeight: c
                                }
                            }(i, o, e);
                        dC("colspan", r, i, n), dC("rowspan", s, i, n);
                        for (const t of o) KC(t, i, n);
                        PC(i.findAncestor("table"), e), n.setSelection(i, "in")
                    }))
                }
            }
    
            function KC(t, e, n) {
                QC(t) || (QC(e) && n.remove(n.createRangeIn(e)), n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))), n.remove(t)
            }
    
            function QC(t) {
                return 1 == t.childCount && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
            }
    
            function ZC(t, e, n, o) {
                const i = parseInt(t.getAttribute(o) || 1);
                return Math.max(n, e + i)
            }
            class JC extends xs {
                constructor(t) {
                    super(t), this.affectsData = !1
                }
                refresh() {
                    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = t.length > 0
                }
                execute() {
                    const t = this.editor.model,
                        e = this.editor.plugins.get("TableUtils"),
                        n = e.getSelectionAffectedTableCells(t.document.selection),
                        o = e.getRowIndexes(n),
                        i = n[0].findAncestor("table"),
                        r = [];
                    for (let e = o.first; e <= o.last; e++)
                        for (const n of i.getChild(e).getChildren()) r.push(t.createRangeOn(n));
                    t.change((t => {
                        t.setSelection(r)
                    }))
                }
            }
            class XC extends xs {
                constructor(t) {
                    super(t), this.affectsData = !1
                }
                refresh() {
                    const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = t.length > 0
                }
                execute() {
                    const t = this.editor.plugins.get("TableUtils"),
                        e = this.editor.model,
                        n = t.getSelectionAffectedTableCells(e.document.selection),
                        o = n[0],
                        i = n.pop(),
                        r = o.findAncestor("table"),
                        s = t.getCellLocation(o),
                        a = t.getCellLocation(i),
                        c = Math.min(s.column, a.column),
                        l = Math.max(s.column, a.column),
                        d = [];
                    for (const t of new fC(r, {
                            startColumn: c,
                            endColumn: l
                        })) d.push(e.createRangeOn(t.cell));
                    e.change((t => {
                        t.setSelection(d)
                    }))
                }
            }
    
            function tv(t) {
                t.document.registerPostFixer((e => function(t, e) {
                    const n = e.document.differ.getChanges();
                    let o = !1;
                    const i = new Set;
                    for (const e of n) {
                        let n;
                        "table" == e.name && "insert" == e.type && (n = e.position.nodeAfter), "tableRow" != e.name && "tableCell" != e.name || (n = e.position.findAncestor("table")), ov(e) && (n = e.range.start.findAncestor("table")), n && !i.has(n) && (o = ev(n, t) || o, o = nv(n, t) || o, i.add(n))
                    }
                    return o
                }(e, t)))
            }
    
            function ev(t, e) {
                let n = !1;
                const o = function(t) {
                    const e = parseInt(t.getAttribute("headingRows") || 0),
                        n = Array.from(t.getChildren()).reduce(((t, e) => e.is("element", "tableRow") ? t + 1 : t), 0),
                        o = [];
                    for (const {
                            row: i,
                            cell: r,
                            cellHeight: s
                        }
                        of new fC(t)) {
                        if (s < 2) continue;
                        const t = i < e ? e : n;
                        if (i + s > t) {
                            const e = t - i;
                            o.push({
                                cell: r,
                                rowspan: e
                            })
                        }
                    }
                    return o
                }(t);
                if (o.length) {
                    n = !0;
                    for (const t of o) dC("rowspan", t.rowspan, t.cell, e, 1)
                }
                return n
            }
    
            function nv(t, e) {
                let n = !1;
                const o = function(t) {
                        const e = new Array(t.childCount).fill(0);
                        for (const {
                                rowIndex: n
                            }
                            of new fC(t, {
                                includeAllSlots: !0
                            })) e[n]++;
                        return e
                    }(t),
                    i = [];
                for (const [e, n] of o.entries()) !n && t.getChild(e).is("element", "tableRow") && i.push(e);
                if (i.length) {
                    n = !0;
                    for (const n of i.reverse()) e.remove(t.getChild(n)), o.splice(n, 1)
                }
                const r = o.filter(((e, n) => t.getChild(n).is("element", "tableRow"))),
                    s = r[0];
                if (!r.every((t => t === s))) {
                    const o = r.reduce(((t, e) => e > t ? e : t), 0);
                    for (const [i, s] of r.entries()) {
                        const r = o - s;
                        if (r) {
                            for (let n = 0; n < r; n++) hC(e, e.createPositionAt(t.getChild(i), "end"));
                            n = !0
                        }
                    }
                }
                return n
            }
    
            function ov(t) {
                const e = "attribute" === t.type,
                    n = t.attributeKey;
                return e && ("headingRows" === n || "colspan" === n || "rowspan" === n)
            }
    
            function iv(t) {
                t.document.registerPostFixer((e => function(t, e) {
                    const n = e.document.differ.getChanges();
                    let o = !1;
                    for (const e of n) "insert" == e.type && "table" == e.name && (o = rv(e.position.nodeAfter, t) || o), "insert" == e.type && "tableRow" == e.name && (o = sv(e.position.nodeAfter, t) || o), "insert" == e.type && "tableCell" == e.name && (o = av(e.position.nodeAfter, t) || o), cv(e) && (o = av(e.position.parent, t) || o);
                    return o
                }(e, t)))
            }
    
            function rv(t, e) {
                let n = !1;
                for (const o of t.getChildren()) o.is("element", "tableRow") && (n = sv(o, e) || n);
                return n
            }
    
            function sv(t, e) {
                let n = !1;
                for (const o of t.getChildren()) n = av(o, e) || n;
                return n
            }
    
            function av(t, e) {
                if (0 == t.childCount) return e.insertElement("paragraph", t), !0;
                const n = Array.from(t.getChildren()).filter((t => t.is("$text")));
                for (const t of n) e.wrap(e.createRangeOn(t), "paragraph");
                return !!n.length
            }
    
            function cv(t) {
                return !(!t.position || !t.position.parent.is("element", "tableCell")) && ("insert" == t.type && "$text" == t.name || "remove" == t.type)
            }
    
            function lv(t, e) {
                if (!t.is("element", "paragraph")) return !1;
                const n = e.toViewElement(t);
                return !!n && AC(t) !== n.is("element", "span")
            }
            var dv = n(3881),
                hv = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(dv.Z, hv);
            dv.Z.locals;
            class uv extends vs {
                static get pluginName() {
                    return "TableEditing"
                }
                static get requires() {
                    return [UC]
                }
                init() {
                    const t = this.editor,
                        e = t.model,
                        n = e.schema,
                        o = t.conversion,
                        i = t.plugins.get(UC);
                    n.register("table", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["headingRows", "headingColumns"]
                    }), n.register("tableRow", {
                        allowIn: "table",
                        isLimit: !0
                    }), n.register("tableCell", {
                        allowContentOf: "$container",
                        allowIn: "tableRow",
                        allowAttributes: ["colspan", "rowspan"],
                        isLimit: !0,
                        isSelectable: !0
                    }), o.for("upcast").add((t => {
                        t.on("element:figure", ((t, e, n) => {
                            if (!n.consumable.test(e.viewItem, {
                                    name: !0,
                                    classes: "table"
                                })) return;
                            const o = function(t) {
                                for (const e of t.getChildren())
                                    if (e.is("element", "table")) return e
                            }(e.viewItem);
                            if (!o || !n.consumable.test(o, {
                                    name: !0
                                })) return;
                            n.consumable.consume(e.viewItem, {
                                name: !0,
                                classes: "table"
                            });
                            const i = gr(n.convertItem(o, e.modelCursor).modelRange.getItems());
                            i ? (n.convertChildren(e.viewItem, n.writer.createPositionAt(i, "end")), n.updateConversionResult(i, e)) : n.consumable.revert(e.viewItem, {
                                name: !0,
                                classes: "table"
                            })
                        }))
                    })), o.for("upcast").add(gC()), o.for("editingDowncast").elementToStructure({
                        model: {
                            name: "table",
                            attributes: ["headingRows"]
                        },
                        view: bC(i, {
                            asWidget: !0
                        })
                    }), o.for("dataDowncast").elementToStructure({
                        model: {
                            name: "table",
                            attributes: ["headingRows"]
                        },
                        view: bC(i)
                    }), o.for("upcast").elementToElement({
                        model: "tableRow",
                        view: "tr"
                    }), o.for("upcast").add((t => {
                        t.on("element:tr", ((t, e) => {
                            e.viewItem.isEmpty && 0 == e.modelCursor.index && t.stop()
                        }), {
                            priority: "high"
                        })
                    })), o.for("downcast").elementToElement({
                        model: "tableRow",
                        view: (t, {
                            writer: e
                        }) => t.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr")
                    }), o.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "td"
                    }), o.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "th"
                    }), o.for("upcast").add(mC("td")), o.for("upcast").add(mC("th")), o.for("editingDowncast").elementToElement({
                        model: "tableCell",
                        view: wC({
                            asWidget: !0
                        })
                    }), o.for("dataDowncast").elementToElement({
                        model: "tableCell",
                        view: wC()
                    }), o.for("editingDowncast").elementToElement({
                        model: "paragraph",
                        view: _C({
                            asWidget: !0
                        }),
                        converterPriority: "high"
                    }), o.for("dataDowncast").elementToElement({
                        model: "paragraph",
                        view: _C(),
                        converterPriority: "high"
                    }), o.for("downcast").attributeToAttribute({
                        model: "colspan",
                        view: "colspan"
                    }), o.for("upcast").attributeToAttribute({
                        model: {
                            key: "colspan",
                            value: gv("colspan")
                        },
                        view: "colspan"
                    }), o.for("downcast").attributeToAttribute({
                        model: "rowspan",
                        view: "rowspan"
                    }), o.for("upcast").attributeToAttribute({
                        model: {
                            key: "rowspan",
                            value: gv("rowspan")
                        },
                        view: "rowspan"
                    }), t.config.define("table.defaultHeadings.rows", 0), t.config.define("table.defaultHeadings.columns", 0), t.commands.add("insertTable", new CC(t)), t.commands.add("insertTableRowAbove", new vC(t, {
                        order: "above"
                    })), t.commands.add("insertTableRowBelow", new vC(t, {
                        order: "below"
                    })), t.commands.add("insertTableColumnLeft", new yC(t, {
                        order: "left"
                    })), t.commands.add("insertTableColumnRight", new yC(t, {
                        order: "right"
                    })), t.commands.add("removeTableRow", new jC(t)), t.commands.add("removeTableColumn", new FC(t)), t.commands.add("splitTableCellVertically", new xC(t, {
                        direction: "vertically"
                    })), t.commands.add("splitTableCellHorizontally", new xC(t, {
                        direction: "horizontally"
                    })), t.commands.add("mergeTableCells", new YC(t)), t.commands.add("mergeTableCellRight", new OC(t, {
                        direction: "right"
                    })), t.commands.add("mergeTableCellLeft", new OC(t, {
                        direction: "left"
                    })), t.commands.add("mergeTableCellDown", new OC(t, {
                        direction: "down"
                    })), t.commands.add("mergeTableCellUp", new OC(t, {
                        direction: "up"
                    })), t.commands.add("setTableColumnHeader", new HC(t)), t.commands.add("setTableRowHeader", new VC(t)), t.commands.add("selectTableRow", new JC(t)), t.commands.add("selectTableColumn", new XC(t)), tv(e), iv(e), this.listenTo(e.document, "change:data", (() => {
                        ! function(t, e) {
                            const n = t.document.differ;
                            for (const t of n.getChanges()) {
                                let n, o = !1;
                                if ("attribute" == t.type) {
                                    const e = t.range.start.nodeAfter;
                                    if (!e || !e.is("element", "table")) continue;
                                    if ("headingRows" != t.attributeKey && "headingColumns" != t.attributeKey) continue;
                                    n = e, o = "headingRows" == t.attributeKey
                                } else "tableRow" != t.name && "tableCell" != t.name || (n = t.position.findAncestor("table"), o = "tableRow" == t.name);
                                if (!n) continue;
                                const i = n.getAttribute("headingRows") || 0,
                                    r = n.getAttribute("headingColumns") || 0,
                                    s = new fC(n);
                                for (const t of s) {
                                    const n = t.row < i || t.column < r ? "th" : "td",
                                        s = e.mapper.toViewElement(t.cell);
                                    s && s.is("element") && s.name != n && e.reconvertItem(o ? t.cell.parent : t.cell)
                                }
                            }
                        }(e, t.editing),
                        function(t, e) {
                            const n = t.document.differ,
                                o = new Set;
                            for (const t of n.getChanges()) {
                                const e = "attribute" == t.type ? t.range.start.parent : t.position.parent;
                                e.is("element", "tableCell") && o.add(e)
                            }
                            for (const t of o.values()) {
                                const n = Array.from(t.getChildren()).filter((t => lv(t, e.mapper)));
                                for (const t of n) e.reconvertItem(t)
                            }
                        }(e, t.editing)
                    }))
                }
            }
    
            function gv(t) {
                return e => {
                    const n = parseInt(e.getAttribute(t));
                    return Number.isNaN(n) || n <= 0 ? null : n
                }
            }
            var mv = n(1613),
                pv = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(mv.Z, pv);
            mv.Z.locals;
            class fv extends Dr {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.items = this._createGridCollection(), this.keystrokes = new pr, this.focusTracker = new mr, this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", ((t, e) => `${e}  ${t}`)), this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck"]
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-insert-table-dropdown__grid"]
                            },
                            on: {
                                "mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover")
                            },
                            children: this.items
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-insert-table-dropdown__label"],
                                "aria-hidden": !0
                            },
                            children: [{
                                text: e.to("label")
                            }]
                        }],
                        on: {
                            mousedown: e.to((t => {
                                t.preventDefault()
                            })),
                            click: e.to((() => {
                                this.fire("execute")
                            }))
                        }
                    }), this.on("boxover", ((t, e) => {
                        const {
                            row: n,
                            column: o
                        } = e.target.dataset;
                        this.items.get(10 * (parseInt(n, 10) - 1) + (parseInt(o, 10) - 1)).focus()
                    })), this.focusTracker.on("change:focusedElement", ((t, e, n) => {
                        if (!n) return;
                        const {
                            row: o,
                            column: i
                        } = n.dataset;
                        this.set({
                            rows: parseInt(o),
                            columns: parseInt(i)
                        })
                    })), this.on("change:columns", (() => this._highlightGridBoxes())), this.on("change:rows", (() => this._highlightGridBoxes()))
                }
                render() {
                    super.render(),
                        function({
                            keystrokeHandler: t,
                            focusTracker: e,
                            gridItems: n,
                            numberOfColumns: o,
                            uiLanguageDirection: i
                        }) {
                            const r = "number" == typeof o ? () => o : o;
    
                            function s(t) {
                                return o => {
                                    const i = n.find((t => t.element === e.focusedElement)),
                                        r = n.getIndex(i),
                                        s = t(r, n);
                                    n.get(s).focus(), o.stopPropagation(), o.preventDefault()
                                }
                            }
    
                            function a(t, e) {
                                return t === e - 1 ? 0 : t + 1
                            }
    
                            function c(t, e) {
                                return 0 === t ? e - 1 : t - 1
                            }
                            t.set("arrowright", s(((t, e) => "rtl" === i ? c(t, e.length) : a(t, e.length)))), t.set("arrowleft", s(((t, e) => "rtl" === i ? a(t, e.length) : c(t, e.length)))), t.set("arrowup", s(((t, e) => {
                                let n = t - r();
                                return n < 0 && (n = t + r() * Math.floor(e.length / r()), n > e.length - 1 && (n -= r())), n
                            }))), t.set("arrowdown", s(((t, e) => {
                                let n = t + r();
                                return n > e.length - 1 && (n = t % r()), n
                            })))
                        }({
                            keystrokeHandler: this.keystrokes,
                            focusTracker: this.focusTracker,
                            gridItems: this.items,
                            numberOfColumns: 10,
                            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                        });
                    for (const t of this.items) this.focusTracker.add(t.element);
                    this.keystrokes.listenTo(this.element)
                }
                focus() {
                    this.items.get(0).focus()
                }
                focusLast() {
                    this.items.get(0).focus()
                }
                _highlightGridBoxes() {
                    const t = this.rows,
                        e = this.columns;
                    this.items.map(((n, o) => {
                        const i = Math.floor(o / 10) < t && o % 10 < e;
                        n.set("isOn", i)
                    }))
                }
                _createGridButton(t, e, n, o) {
                    const i = new es(t);
                    return i.set({
                        label: o,
                        class: "ck-insert-table-dropdown-grid-box"
                    }), i.extendTemplate({
                        attributes: {
                            "data-row": e,
                            "data-column": n
                        }
                    }), i
                }
                _createGridCollection() {
                    const t = [];
                    for (let e = 0; e < 100; e++) {
                        const n = Math.floor(e / 10),
                            o = e % 10,
                            i = `${n+1}  ${o+1}`;
                        t.push(this._createGridButton(this.locale, n + 1, o + 1, i))
                    }
                    return this.createCollection(t)
                }
            }
            class kv extends vs {
                static get pluginName() {
                    return "TableUI"
                }
                init() {
                    const t = this.editor,
                        e = this.editor.t,
                        n = "ltr" === t.locale.contentLanguageDirection;
                    t.ui.componentFactory.add("insertTable", (n => {
                        const o = t.commands.get("insertTable"),
                            i = tm(n);
                        let r;
                        return i.bind("isEnabled").to(o), i.buttonView.set({
                            icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
                            label: e("Insert table"),
                            tooltip: !0
                        }), i.on("change:isOpen", (() => {
                            r || (r = new fv(n), i.panelView.children.add(r), r.delegate("execute").to(i), i.on("execute", (() => {
                                t.execute("insertTable", {
                                    rows: r.rows,
                                    columns: r.columns
                                }), t.editing.view.focus()
                            })))
                        })), i
                    })), t.ui.componentFactory.add("tableColumn", (t => {
                        const o = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableColumnHeader",
                                label: e("Header column"),
                                bindIsOn: !0
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight",
                                label: e("Insert column left")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft",
                                label: e("Insert column right")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableColumn",
                                label: e("Delete column")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "selectTableColumn",
                                label: e("Select column")
                            }
                        }];
                        return this._prepareDropdown(e("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', o, t)
                    })), t.ui.componentFactory.add("tableRow", (t => {
                        const n = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableRowHeader",
                                label: e("Header row"),
                                bindIsOn: !0
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowAbove",
                                label: e("Insert row above")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowBelow",
                                label: e("Insert row below")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableRow",
                                label: e("Delete row")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "selectTableRow",
                                label: e("Select row")
                            }
                        }];
                        return this._prepareDropdown(e("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n, t)
                    })), t.ui.componentFactory.add("mergeTableCells", (t => {
                        const o = [{
                            type: "button",
                            model: {
                                commandName: "mergeTableCellUp",
                                label: e("Merge cell up")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft",
                                label: e("Merge cell right")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "mergeTableCellDown",
                                label: e("Merge cell down")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight",
                                label: e("Merge cell left")
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellVertically",
                                label: e("Split cell vertically")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellHorizontally",
                                label: e("Split cell horizontally")
                            }
                        }];
                        return this._prepareMergeSplitButtonDropdown(e("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', o, t)
                    }))
                }
                _prepareDropdown(t, e, n, o) {
                    const i = this.editor,
                        r = tm(o),
                        s = this._fillDropdownWithListOptions(r, n);
                    return r.buttonView.set({
                        label: t,
                        icon: e,
                        tooltip: !0
                    }), r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t)))), this.listenTo(r, "execute", (t => {
                        i.execute(t.source.commandName), t.source instanceof is || i.editing.view.focus()
                    })), r
                }
                _prepareMergeSplitButtonDropdown(t, e, n, o) {
                    const i = this.editor,
                        r = tm(o, fs),
                        s = "mergeTableCells",
                        a = i.commands.get(s),
                        c = this._fillDropdownWithListOptions(r, n);
                    return r.buttonView.set({
                        label: t,
                        icon: e,
                        tooltip: !0,
                        isEnabled: !0
                    }), r.bind("isEnabled").toMany([a, ...c], "isEnabled", ((...t) => t.some((t => t)))), this.listenTo(r.buttonView, "execute", (() => {
                        i.execute(s), i.editing.view.focus()
                    })), this.listenTo(r, "execute", (t => {
                        i.execute(t.source.commandName), i.editing.view.focus()
                    })), r
                }
                _fillDropdownWithListOptions(t, e) {
                    const n = this.editor,
                        o = [],
                        i = new ur;
                    for (const t of e) bv(t, n, o, i);
                    return om(t, i), o
                }
            }
    
            function bv(t, e, n, o) {
                const i = t.model = new Fm(t.model),
                    {
                        commandName: r,
                        bindIsOn: s
                    } = t.model;
                if ("button" === t.type || "switchbutton" === t.type) {
                    const t = e.commands.get(r);
                    n.push(t), i.set({
                        commandName: r
                    }), i.bind("isEnabled").to(t), s && i.bind("isOn").to(t, "value")
                }
                i.set({
                    withText: !0
                }), o.add(t)
            }
            var wv = n(6945),
                _v = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(wv.Z, _v);
            wv.Z.locals;
            class Av extends vs {
                static get pluginName() {
                    return "TableSelection"
                }
                static get requires() {
                    return [UC, UC]
                }
                init() {
                    const t = this.editor,
                        e = t.model,
                        n = t.editing.view;
                    this.listenTo(e, "deleteContent", ((t, e) => this._handleDeleteContent(t, e)), {
                        priority: "high"
                    }), this.listenTo(n.document, "insertText", ((t, e) => this._handleInsertTextEvent(t, e)), {
                        priority: "high"
                    }), this._defineSelectionConverter(), this._enablePluginDisabling()
                }
                getSelectedTableCells() {
                    const t = this.editor.plugins.get(UC),
                        e = this.editor.model.document.selection,
                        n = t.getSelectedTableCells(e);
                    return 0 == n.length ? null : n
                }
                getSelectionAsFragment() {
                    const t = this.editor.plugins.get(UC),
                        e = this.getSelectedTableCells();
                    return e ? this.editor.model.change((n => {
                        const o = n.createDocumentFragment(),
                            {
                                first: i,
                                last: r
                            } = t.getColumnIndexes(e),
                            {
                                first: s,
                                last: a
                            } = t.getRowIndexes(e),
                            c = e[0].findAncestor("table");
                        let l = a,
                            d = r;
                        if (t.isSelectionRectangular(e)) {
                            const t = {
                                firstColumn: i,
                                lastColumn: r,
                                firstRow: s,
                                lastRow: a
                            };
                            l = zC(c, t), d = LC(c, t)
                        }
                        const h = EC(c, {
                            startRow: s,
                            startColumn: i,
                            endRow: l,
                            endColumn: d
                        }, n);
                        return n.insert(h, o, 0), o
                    })) : null
                }
                setCellSelection(t, e) {
                    const n = this._getCellsToSelect(t, e);
                    this.editor.model.change((t => {
                        t.setSelection(n.cells.map((e => t.createRangeOn(e))), {
                            backward: n.backward
                        })
                    }))
                }
                getFocusCell() {
                    const t = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
                    return t && t.is("element", "tableCell") ? t : null
                }
                getAnchorCell() {
                    const t = gr(this.editor.model.document.selection.getRanges()).getContainedElement();
                    return t && t.is("element", "tableCell") ? t : null
                }
                _defineSelectionConverter() {
                    const t = this.editor,
                        e = new Set;
                    t.conversion.for("editingDowncast").add((t => t.on("selection", ((t, n, o) => {
                        const i = o.writer;
                        ! function(t) {
                            for (const n of e) t.removeClass("ck-editor__editable_selected", n);
                            e.clear()
                        }(i);
                        const r = this.getSelectedTableCells();
                        if (!r) return;
                        for (const t of r) {
                            const n = o.mapper.toViewElement(t);
                            i.addClass("ck-editor__editable_selected", n), e.add(n)
                        }
                        const s = o.mapper.toViewElement(r[r.length - 1]);
                        i.setSelection(s, 0)
                    }), {
                        priority: "lowest"
                    })))
                }
                _enablePluginDisabling() {
                    const t = this.editor;
                    this.on("change:isEnabled", (() => {
                        if (!this.isEnabled) {
                            const e = this.getSelectedTableCells();
                            if (!e) return;
                            t.model.change((n => {
                                const o = n.createPositionAt(e[0], 0),
                                    i = t.model.schema.getNearestSelectionRange(o);
                                n.setSelection(i)
                            }))
                        }
                    }))
                }
                _handleDeleteContent(t, e) {
                    const n = this.editor.plugins.get(UC),
                        [o, i] = e,
                        r = this.editor.model,
                        s = !i || "backward" == i.direction,
                        a = n.getSelectedTableCells(o);
                    a.length && (t.stop(), r.change((t => {
                        const e = a[s ? a.length - 1 : 0];
                        r.change((t => {
                            for (const e of a) r.deleteContent(t.createSelection(e, "in"))
                        }));
                        const n = r.schema.getNearestSelectionRange(t.createPositionAt(e, 0));
                        o.is("documentSelection") ? t.setSelection(n) : o.setTo(n)
                    })))
                }
                _handleInsertTextEvent(t, e) {
                    const n = this.editor,
                        o = n.model.document.selection,
                        i = this.getSelectedTableCells(o);
                    if (!i) return;
                    const r = n.editing.view,
                        s = n.editing.mapper,
                        a = i.map((t => r.createRangeOn(s.toViewElement(t))));
                    e.selection = r.createSelection(a)
                }
                _getCellsToSelect(t, e) {
                    const n = this.editor.plugins.get("TableUtils"),
                        o = n.getCellLocation(t),
                        i = n.getCellLocation(e),
                        r = Math.min(o.row, i.row),
                        s = Math.max(o.row, i.row),
                        a = Math.min(o.column, i.column),
                        c = Math.max(o.column, i.column),
                        l = new Array(s - r + 1).fill(null).map((() => [])),
                        d = {
                            startRow: r,
                            endRow: s,
                            startColumn: a,
                            endColumn: c
                        };
                    for (const {
                            row: e,
                            cell: n
                        }
                        of new fC(t.findAncestor("table"), d)) l[e - r].push(n);
                    const h = i.row < o.row,
                        u = i.column < o.column;
                    return h && l.reverse(), u && l.forEach((t => t.reverse())), {
                        cells: l.flat(),
                        backward: h || u
                    }
                }
            }
            class Cv extends vs {
                static get pluginName() {
                    return "TableClipboard"
                }
                static get requires() {
                    return [Av, UC]
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view.document;
                    this.listenTo(e, "copy", ((t, e) => this._onCopyCut(t, e))), this.listenTo(e, "cut", ((t, e) => this._onCopyCut(t, e))), this.listenTo(t.model, "insertContent", ((t, e) => this._onInsertContent(t, ...e)), {
                        priority: "high"
                    }), this.decorate("_replaceTableSlotCell")
                }
                _onCopyCut(t, e) {
                    const n = this.editor.plugins.get(Av);
                    if (!n.getSelectedTableCells()) return;
                    if ("cut" == t.name && this.editor.isReadOnly) return;
                    e.preventDefault(), t.stop();
                    const o = this.editor.data,
                        i = this.editor.editing.view.document,
                        r = o.toView(n.getSelectionAsFragment());
                    i.fire("clipboardOutput", {
                        dataTransfer: e.dataTransfer,
                        content: r,
                        method: t.name
                    })
                }
                _onInsertContent(t, e, n) {
                    if (n && !n.is("documentSelection")) return;
                    const o = this.editor.model,
                        i = this.editor.plugins.get(UC);
                    let r = vv(e, o);
                    if (!r) return;
                    const s = i.getSelectionAffectedTableCells(o.document.selection);
                    s.length ? (t.stop(), o.change((t => {
                        const e = {
                                width: i.getColumns(r),
                                height: i.getRows(r)
                            },
                            n = function(t, e, n, o) {
                                const i = t[0].findAncestor("table"),
                                    r = o.getColumnIndexes(t),
                                    s = o.getRowIndexes(t),
                                    a = {
                                        firstColumn: r.first,
                                        lastColumn: r.last,
                                        firstRow: s.first,
                                        lastRow: s.last
                                    },
                                    c = 1 === t.length;
                                c && (a.lastRow += e.height - 1, a.lastColumn += e.width - 1, function(t, e, n, o) {
                                    const i = o.getColumns(t),
                                        r = o.getRows(t);
                                    n > i && o.insertColumns(t, {
                                        at: i,
                                        columns: n - i
                                    });
                                    e > r && o.insertRows(t, {
                                        at: r,
                                        rows: e - r
                                    })
                                }(i, a.lastRow + 1, a.lastColumn + 1, o));
                                c || !o.isSelectionRectangular(t) ? function(t, e, n) {
                                    const {
                                        firstRow: o,
                                        lastRow: i,
                                        firstColumn: r,
                                        lastColumn: s
                                    } = e, a = {
                                        first: o,
                                        last: i
                                    }, c = {
                                        first: r,
                                        last: s
                                    };
                                    xv(t, r, a, n), xv(t, s + 1, a, n), yv(t, o, c, n), yv(t, i + 1, c, n, o)
                                }(i, a, n) : (a.lastRow = zC(i, a), a.lastColumn = LC(i, a));
                                return a
                            }(s, e, t, i),
                            o = n.lastRow - n.firstRow + 1,
                            a = n.lastColumn - n.firstColumn + 1,
                            c = {
                                startRow: 0,
                                startColumn: 0,
                                endRow: Math.min(o, e.height) - 1,
                                endColumn: Math.min(a, e.width) - 1
                            };
                        r = EC(r, c, t);
                        const l = s[0].findAncestor("table"),
                            d = this._replaceSelectedCellsWithPasted(r, e, l, n, t);
                        if (this.editor.plugins.get("TableSelection").isEnabled) {
                            const e = i.sortRanges(d.map((e => t.createRangeOn(e))));
                            t.setSelection(e)
                        } else t.setSelection(d[0], 0)
                    }))) : PC(r, i)
                }
                _replaceSelectedCellsWithPasted(t, e, n, o, i) {
                    const {
                        width: r,
                        height: s
                    } = e, a = function(t, e, n) {
                        const o = new Array(n).fill(null).map((() => new Array(e).fill(null)));
                        for (const {
                                column: e,
                                row: n,
                                cell: i
                            }
                            of new fC(t)) o[n][e] = i;
                        return o
                    }(t, r, s), c = [...new fC(n, {
                        startRow: o.firstRow,
                        endRow: o.lastRow,
                        startColumn: o.firstColumn,
                        endColumn: o.lastColumn,
                        includeAllSlots: !0
                    })], l = [];
                    let d;
                    for (const t of c) {
                        const {
                            row: e,
                            column: n
                        } = t;
                        n === o.firstColumn && (d = t.getPositionBefore());
                        const c = e - o.firstRow,
                            h = n - o.firstColumn,
                            u = a[c % s][h % r],
                            g = u ? i.cloneElement(u) : null,
                            m = this._replaceTableSlotCell(t, g, d, i);
                        m && (SC(m, e, n, o.lastRow, o.lastColumn, i), l.push(m), d = i.createPositionAfter(m))
                    }
                    const h = parseInt(n.getAttribute("headingRows") || 0),
                        u = parseInt(n.getAttribute("headingColumns") || 0),
                        g = o.firstRow < h && h <= o.lastRow,
                        m = o.firstColumn < u && u <= o.lastColumn;
                    if (g) {
                        const t = yv(n, h, {
                            first: o.firstColumn,
                            last: o.lastColumn
                        }, i, o.firstRow);
                        l.push(...t)
                    }
                    if (m) {
                        const t = xv(n, u, {
                            first: o.firstRow,
                            last: o.lastRow
                        }, i);
                        l.push(...t)
                    }
                    return l
                }
                _replaceTableSlotCell(t, e, n, o) {
                    const {
                        cell: i,
                        isAnchor: r
                    } = t;
                    return r && o.remove(i), e ? (o.insert(e, n), e) : null
                }
                getTableIfOnlyTableInContent(t, e) {
                    return vv(t, e)
                }
            }
    
            function vv(t, e) {
                if (!t.is("documentFragment") && !t.is("element")) return null;
                if (t.is("element", "table")) return t;
                if (1 == t.childCount && t.getChild(0).is("element", "table")) return t.getChild(0);
                const n = e.createRangeIn(t);
                for (const t of n.getItems())
                    if (t.is("element", "table")) {
                        const o = e.createRange(n.start, e.createPositionBefore(t));
                        if (e.hasContent(o, {
                                ignoreWhitespaces: !0
                            })) return null;
                        const i = e.createRange(e.createPositionAfter(t), n.end);
                        return e.hasContent(i, {
                            ignoreWhitespaces: !0
                        }) ? null : t
                    } return null
            }
    
            function yv(t, e, n, o, i = 0) {
                if (e < 1) return;
                return DC(t, e, i).filter((({
                    column: t,
                    cellWidth: e
                }) => Ev(t, e, n))).map((({
                    cell: t
                }) => IC(t, e, o)))
            }
    
            function xv(t, e, n, o) {
                if (e < 1) return;
                return TC(t, e).filter((({
                    row: t,
                    cellHeight: e
                }) => Ev(t, e, n))).map((({
                    cell: t,
                    column: n
                }) => MC(t, n, e, o)))
            }
    
            function Ev(t, e, n) {
                const o = t + e - 1,
                    {
                        first: i,
                        last: r
                    } = n;
                return t >= i && t <= r || t < i && o >= i
            }
            class Dv extends vs {
                static get pluginName() {
                    return "TableKeyboard"
                }
                static get requires() {
                    return [Av, UC]
                }
                init() {
                    const t = this.editor.editing.view.document;
                    this.listenTo(t, "arrowKey", ((...t) => this._onArrowKey(...t)), {
                        context: "table"
                    }), this.listenTo(t, "tab", ((...t) => this._handleTabOnSelectedTable(...t)), {
                        context: "figure"
                    }), this.listenTo(t, "tab", ((...t) => this._handleTab(...t)), {
                        context: ["th", "td"]
                    })
                }
                _handleTabOnSelectedTable(t, e) {
                    const n = this.editor,
                        o = n.model.document.selection.getSelectedElement();
                    o && o.is("element", "table") && (e.preventDefault(), e.stopPropagation(), t.stop(), n.model.change((t => {
                        t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)))
                    })))
                }
                _handleTab(t, e) {
                    const n = this.editor,
                        o = this.editor.plugins.get(UC),
                        i = n.model.document.selection,
                        r = !e.shiftKey;
                    let s = o.getTableCellsContainingSelection(i)[0];
                    if (s || (s = this.editor.plugins.get("TableSelection").getFocusCell()), !s) return;
                    e.preventDefault(), e.stopPropagation(), t.stop();
                    const a = s.parent,
                        c = a.parent,
                        l = c.getChildIndex(a),
                        d = a.getChildIndex(s),
                        h = 0 === d;
                    if (!r && h && 0 === l) return void n.model.change((t => {
                        t.setSelection(t.createRangeOn(c))
                    }));
                    const u = d === a.childCount - 1,
                        g = l === o.getRows(c) - 1;
                    if (r && g && u && (n.execute("insertTableRowBelow"), l === o.getRows(c) - 1)) return void n.model.change((t => {
                        t.setSelection(t.createRangeOn(c))
                    }));
                    let m;
                    if (r && u) {
                        const t = c.getChild(l + 1);
                        m = t.getChild(0)
                    } else if (!r && h) {
                        const t = c.getChild(l - 1);
                        m = t.getChild(t.childCount - 1)
                    } else m = a.getChild(d + (r ? 1 : -1));
                    n.model.change((t => {
                        t.setSelection(t.createRangeIn(m))
                    }))
                }
                _onArrowKey(t, e) {
                    const n = this.editor,
                        o = sr(e.keyCode, n.locale.contentLanguageDirection);
                    this._handleArrowKeys(o, e.shiftKey) && (e.preventDefault(), e.stopPropagation(), t.stop())
                }
                _handleArrowKeys(t, e) {
                    const n = this.editor.plugins.get(UC),
                        o = this.editor.model,
                        i = o.document.selection,
                        r = ["right", "down"].includes(t),
                        s = n.getSelectedTableCells(i);
                    if (s.length) {
                        let n;
                        return n = e ? this.editor.plugins.get("TableSelection").getFocusCell() : r ? s[s.length - 1] : s[0], this._navigateFromCellInDirection(n, t, e), !0
                    }
                    const a = i.focus.findAncestor("tableCell");
                    if (!a) return !1;
                    if (!i.isCollapsed)
                        if (e) {
                            if (i.isBackward == r && !i.containsEntireContent(a)) return !1
                        } else {
                            const t = i.getSelectedElement();
                            if (!t || !o.schema.isObject(t)) return !1
                        } return !!this._isSelectionAtCellEdge(i, a, r) && (this._navigateFromCellInDirection(a, t, e), !0)
                }
                _isSelectionAtCellEdge(t, e, n) {
                    const o = this.editor.model,
                        i = this.editor.model.schema,
                        r = n ? t.getLastPosition() : t.getFirstPosition();
                    if (!i.getLimitElement(r).is("element", "tableCell")) {
                        return o.createPositionAt(e, n ? "end" : 0).isTouching(r)
                    }
                    const s = o.createSelection(r);
                    return o.modifySelection(s, {
                        direction: n ? "forward" : "backward"
                    }), r.isEqual(s.focus)
                }
                _navigateFromCellInDirection(t, e, n = !1) {
                    const o = this.editor.model,
                        i = t.findAncestor("table"),
                        r = [...new fC(i, {
                            includeAllSlots: !0
                        })],
                        {
                            row: s,
                            column: a
                        } = r[r.length - 1],
                        c = r.find((({
                            cell: e
                        }) => e == t));
                    let {
                        row: l,
                        column: d
                    } = c;
                    switch (e) {
                        case "left":
                            d--;
                            break;
                        case "up":
                            l--;
                            break;
                        case "right":
                            d += c.cellWidth;
                            break;
                        case "down":
                            l += c.cellHeight
                    }
                    if (l < 0 || l > s || d < 0 && l <= 0 || d > a && l >= s) return void o.change((t => {
                        t.setSelection(t.createRangeOn(i))
                    }));
                    d < 0 ? (d = n ? 0 : a, l--) : d > a && (d = n ? a : 0, l++);
                    const h = r.find((t => t.row == l && t.column == d)).cell,
                        u = ["right", "down"].includes(e),
                        g = this.editor.plugins.get("TableSelection");
                    if (n && g.isEnabled) {
                        const e = g.getAnchorCell() || t;
                        g.setCellSelection(e, h)
                    } else {
                        const t = o.createPositionAt(h, u ? 0 : "end");
                        o.change((e => {
                            e.setSelection(t)
                        }))
                    }
                }
            }
            class Iv extends pl {
                constructor(t) {
                    super(t), this.domEventType = ["mousemove", "mouseleave"]
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            class Tv extends vs {
                static get pluginName() {
                    return "TableMouse"
                }
                static get requires() {
                    return [Av, UC]
                }
                init() {
                    this.editor.editing.view.addObserver(Iv), this._enableShiftClickSelection(), this._enableMouseDragSelection()
                }
                _enableShiftClickSelection() {
                    const t = this.editor,
                        e = t.plugins.get(UC);
                    let n = !1;
                    const o = t.plugins.get(Av);
                    this.listenTo(t.editing.view.document, "mousedown", ((i, r) => {
                        const s = t.model.document.selection;
                        if (!this.isEnabled || !o.isEnabled) return;
                        if (!r.domEvent.shiftKey) return;
                        const a = o.getAnchorCell() || e.getTableCellsContainingSelection(s)[0];
                        if (!a) return;
                        const c = this._getModelTableCellFromDomEvent(r);
                        c && Mv(a, c) && (n = !0, o.setCellSelection(a, c), r.preventDefault())
                    })), this.listenTo(t.editing.view.document, "mouseup", (() => {
                        n = !1
                    })), this.listenTo(t.editing.view.document, "selectionChange", (t => {
                        n && t.stop()
                    }), {
                        priority: "highest"
                    })
                }
                _enableMouseDragSelection() {
                    const t = this.editor;
                    let e, n, o = !1,
                        i = !1;
                    const r = t.plugins.get(Av);
                    this.listenTo(t.editing.view.document, "mousedown", ((t, n) => {
                        this.isEnabled && r.isEnabled && (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey || (e = this._getModelTableCellFromDomEvent(n)))
                    })), this.listenTo(t.editing.view.document, "mousemove", ((t, s) => {
                        if (!s.domEvent.buttons) return;
                        if (!e) return;
                        const a = this._getModelTableCellFromDomEvent(s);
                        a && Mv(e, a) && (n = a, o || n == e || (o = !0)), o && (i = !0, r.setCellSelection(e, n), s.preventDefault())
                    })), this.listenTo(t.editing.view.document, "mouseup", (() => {
                        o = !1, i = !1, e = null, n = null
                    })), this.listenTo(t.editing.view.document, "selectionChange", (t => {
                        i && t.stop()
                    }), {
                        priority: "highest"
                    })
                }
                _getModelTableCellFromDomEvent(t) {
                    const e = t.target,
                        n = this.editor.editing.view.createPositionAt(e, 0);
                    return this.editor.editing.mapper.toModelPosition(n).parent.findAncestor("tableCell", {
                        includeSelf: !0
                    })
                }
            }
    
            function Mv(t, e) {
                return t.parent.parent == e.parent.parent
            }
            var Sv = n(6306),
                Nv = {
                    injectType: "singletonStyleTag",
                    attributes: {
                        "data-cke": !0
                    },
                    insert: "head",
                    singleton: !0
                };
            yr()(Sv.Z, Nv);
            Sv.Z.locals;
    
            function Bv(t) {
                const e = t.getSelectedElement();
                return e && zv(e) ? e : null
            }
    
            function Pv(t) {
                const e = t.getFirstPosition();
                if (!e) return null;
                let n = e.parent;
                for (; n;) {
                    if (n.is("element") && zv(n)) return n;
                    n = n.parent
                }
                return null
            }
    
            function zv(t) {
                return !!t.getCustomProperty("table") && df(t)
            }
            const Lv = {
                    autoRefresh: !0
                },
                Ov = 36e5;
            class Rv {
                constructor(t, e = Lv) {
                    if (!t) throw new A("token-missing-token-url", this);
                    e.initValue && this._validateTokenValue(e.initValue), this.set("value", e.initValue), this._refresh = "function" == typeof t ? t : () => {
                        return e = t, new Promise(((t, n) => {
                            const o = new XMLHttpRequest;
                            o.open("GET", e), o.addEventListener("load", (() => {
                                const e = o.status,
                                    i = o.response;
                                return e < 200 || e > 299 ? n(new A("token-cannot-download-new-token", null)) : t(i)
                            })), o.addEventListener("error", (() => n(new Error("Network Error")))), o.addEventListener("abort", (() => n(new Error("Abort")))), o.send()
                        }));
                        var e
                    }, this._options = Object.assign({}, Lv, e)
                }
                init() {
                    return new Promise(((t, e) => {
                        this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), t(this)) : this.refreshToken().then(t).catch(e)
                    }))
                }
                refreshToken() {
                    return this._refresh().then((t => {
                        this._validateTokenValue(t), this.set("value", t), this._options.autoRefresh && this._registerRefreshTokenTimeout()
                    })).then((() => this))
                }
                destroy() {
                    clearTimeout(this._tokenRefreshTimeout)
                }
                _validateTokenValue(t) {
                    const e = "string" == typeof t,
                        n = !/^".*"$/.test(t),
                        o = e && 3 === t.split(".").length;
                    if (!n || !o) throw new A("token-not-in-jwt-format", this)
                }
                _registerRefreshTokenTimeout() {
                    const t = this._getTokenRefreshTimeoutTime();
                    clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout((() => {
                        this.refreshToken()
                    }), t)
                }
                _getTokenRefreshTimeoutTime() {
                    try {
                        const [, t] = this.value.split("."), {
                            exp: e
                        } = JSON.parse(atob(t));
                        if (!e) return Ov;
                        return Math.floor((1e3 * e - Date.now()) / 2)
                    } catch (t) {
                        return Ov
                    }
                }
                static create(t, e = Lv) {
                    return new Rv(t, e).init()
                }
            }
            g(Rv, $);
            const jv = Rv,
                Fv = /^data:(\S*?);base64,/;
            class Vv {
                constructor(t, e, n) {
                    if (!t) throw new A("fileuploader-missing-file", null);
                    if (!e) throw new A("fileuploader-missing-token", null);
                    if (!n) throw new A("fileuploader-missing-api-address", null);
                    this.file = function(t) {
                        if ("string" != typeof t) return !1;
                        const e = t.match(Fv);
                        return !(!e || !e.length)
                    }(t) ? function(t, e = 512) {
                        try {
                            const n = t.match(Fv)[1],
                                o = atob(t.replace(Fv, "")),
                                i = [];
                            for (let t = 0; t < o.length; t += e) {
                                const n = o.slice(t, t + e),
                                    r = new Array(n.length);
                                for (let t = 0; t < n.length; t++) r[t] = n.charCodeAt(t);
                                i.push(new Uint8Array(r))
                            }
                            return new Blob(i, {
                                type: n
                            })
                        } catch (t) {
                            throw new A("fileuploader-decoding-image-data-error", null)
                        }
                    }(t) : t, this._token = e, this._apiAddress = n
                }
                onProgress(t) {
                    return this.on("progress", ((e, n) => t(n))), this
                }
                onError(t) {
                    return this.once("error", ((e, n) => t(n))), this
                }
                abort() {
                    this.xhr.abort()
                }
                send() {
                    return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest()
                }
                _prepareRequest() {
                    const t = new XMLHttpRequest;
                    t.open("POST", this._apiAddress), t.setRequestHeader("Authorization", this._token.value), t.responseType = "json", this.xhr = t
                }
                _attachXHRListeners() {
                    const t = this,
                        e = this.xhr;
    
                    function n(e) {
                        return () => t.fire("error", e)
                    }
                    e.addEventListener("error", n("Network Error")), e.addEventListener("abort", n("Abort")), e.upload && e.upload.addEventListener("progress", (t => {
                        t.lengthComputable && this.fire("progress", {
                            total: t.total,
                            uploaded: t.loaded
                        })
                    })), e.addEventListener("load", (() => {
                        const t = e.status,
                            n = e.response;
                        if (t < 200 || t > 299) return this.fire("error", n.message || n.error)
                    }))
                }
                _sendRequest() {
                    const t = new FormData,
                        e = this.xhr;
                    return t.append("file", this.file), new Promise(((n, o) => {
                        e.addEventListener("load", (() => {
                            const t = e.status,
                                i = e.response;
                            return t < 200 || t > 299 ? i.message ? o(new A("fileuploader-uploading-data-failed", this, {
                                message: i.message
                            })) : o(i.error) : n(i)
                        })), e.addEventListener("error", (() => o(new Error("Network Error")))), e.addEventListener("abort", (() => o(new Error("Abort")))), e.send(t)
                    }))
                }
            }
            g(Vv, N);
            class Hv {
                constructor(t, e) {
                    if (!t) throw new A("uploadgateway-missing-token", null);
                    if (!e) throw new A("uploadgateway-missing-api-address", null);
                    this._token = t, this._apiAddress = e
                }
                upload(t) {
                    return new Vv(t, this._token, this._apiAddress)
                }
            }
            class Uv extends Ms {
                static get pluginName() {
                    return "CloudServicesCore"
                }
                createToken(t, e) {
                    return new jv(t, e)
                }
                createUploadGateway(t, e) {
                    return new Hv(t, e)
                }
            }
            class Wv extends sp {}
            Wv.builtinPlugins = [class extends vs {
                static get requires() {
                    return [Zf, Zp, ok, ef, Ep, gk]
                }
                static get pluginName() {
                    return "Essentials"
                }
            }, class extends vs {
                static get requires() {
                    return [pk]
                }
                static get pluginName() {
                    return "CKFinderUploadAdapter"
                }
                init() {
                    const t = this.editor.config.get("ckfinder.uploadUrl");
                    t && (this.editor.plugins.get(pk).createUploadAdapter = e => new vk(e, t, this.editor.t))
                }
            }, class extends vs {
                static get requires() {
                    return [xp]
                }
                static get pluginName() {
                    return "Autoformat"
                }
                afterInit() {
                    this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats()
                }
                _addListAutoformats() {
                    const t = this.editor.commands;
                    t.get("bulletedList") && yk(this.editor, this, /^[*-]\s$/, "bulletedList"), t.get("numberedList") && yk(this.editor, this, /^1[.|)]\s$/, "numberedList"), t.get("todoList") && yk(this.editor, this, /^\[\s?\]\s$/, "todoList"), t.get("checkTodoList") && yk(this.editor, this, /^\[\s?x\s?\]\s$/, (() => {
                        this.editor.execute("todoList"), this.editor.execute("checkTodoList")
                    }))
                }
                _addBasicStylesAutoformats() {
                    const t = this.editor.commands;
                    if (t.get("bold")) {
                        const t = Dk(this.editor, "bold");
                        xk(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), xk(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
                    }
                    if (t.get("italic")) {
                        const t = Dk(this.editor, "italic");
                        xk(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), xk(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
                    }
                    if (t.get("code")) {
                        const t = Dk(this.editor, "code");
                        xk(this.editor, this, /(`)([^`]+)(`)$/g, t)
                    }
                    if (t.get("strikethrough")) {
                        const t = Dk(this.editor, "strikethrough");
                        xk(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
                    }
                }
                _addHeadingAutoformats() {
                    const t = this.editor.commands.get("heading");
                    t && t.modelElements.filter((t => t.match(/^heading[1-6]$/))).forEach((e => {
                        const n = e[7],
                            o = new RegExp(`^(#{${n}})\\s$`);
                        yk(this.editor, this, o, (() => {
                            if (!t.isEnabled || t.value === e) return !1;
                            this.editor.execute("heading", {
                                value: e
                            })
                        }))
                    }))
                }
                _addBlockQuoteAutoformats() {
                    this.editor.commands.get("blockQuote") && yk(this.editor, this, /^>\s$/, "blockQuote")
                }
                _addCodeBlockAutoformats() {
                    const t = this.editor,
                        e = t.model.document.selection;
                    t.commands.get("codeBlock") && yk(t, this, /^```$/, (() => {
                        if (e.getFirstPosition().parent.is("element", "listItem")) return !1;
                        this.editor.execute("codeBlock", {
                            usePreviousLanguageChoice: !0
                        })
                    }))
                }
                _addHorizontalLineAutoformats() {
                    this.editor.commands.get("horizontalLine") && yk(this.editor, this, /^---$/, "horizontalLine")
                }
            }, class extends vs {
                static get requires() {
                    return [Mk, Nk]
                }
                static get pluginName() {
                    return "Bold"
                }
            }, class extends vs {
                static get requires() {
                    return [Pk, Lk]
                }
                static get pluginName() {
                    return "Italic"
                }
            }, class extends vs {
                static get requires() {
                    return [Vk, Wk]
                }
                static get pluginName() {
                    return "BlockQuote"
                }
            }, class extends vs {
                static get pluginName() {
                    return "CKBox"
                }
                static get requires() {
                    return [rb, qk]
                }
            }, class extends vs {
                static get pluginName() {
                    return "CKFinder"
                }
                static get requires() {
                    return ["Link", "CKFinderUploadAdapter", ub, lb]
                }
            }, class extends Ms {
                static get pluginName() {
                    return "CloudServices"
                }
                static get requires() {
                    return [Uv]
                }
                init() {
                    const t = this.context.config.get("cloudServices") || {};
                    for (const e in t) this[e] = t[e];
                    if (this._tokens = new Map, this.tokenUrl) return this.token = this.context.plugins.get("CloudServicesCore").createToken(this.tokenUrl), this._tokens.set(this.tokenUrl, this.token), this.token.init();
                    this.token = null
                }
                registerTokenUrl(t) {
                    if (this._tokens.has(t)) return Promise.resolve(this.getTokenFor(t));
                    const e = this.context.plugins.get("CloudServicesCore").createToken(t);
                    return this._tokens.set(t, e), e.init()
                }
                getTokenFor(t) {
                    const e = this._tokens.get(t);
                    if (!e) throw new A("cloudservices-token-not-registered", this);
                    return e
                }
                destroy() {
                    super.destroy();
                    for (const t of this._tokens.values()) t.destroy()
                }
            }, class extends vs {
                static get requires() {
                    return [gb, "ImageUpload"]
                }
                init() {
                    const t = this.editor;
                    t.plugins.has("ImageBlockEditing") || t.plugins.has("ImageInlineEditing") || C("easy-image-image-feature-missing", t)
                }
                static get pluginName() {
                    return "EasyImage"
                }
            }, class extends vs {
                static get requires() {
                    return [Cb, xb]
                }
                static get pluginName() {
                    return "Heading"
                }
            }, class extends vs {
                static get requires() {
                    return [Zb, Xb]
                }
                static get pluginName() {
                    return "Image"
                }
            }, class extends vs {
                static get requires() {
                    return [nw, ow]
                }
                static get pluginName() {
                    return "ImageCaption"
                }
            }, class extends vs {
                static get requires() {
                    return [_w, vw]
                }
                static get pluginName() {
                    return "ImageStyle"
                }
            }, class extends vs {
                static get requires() {
                    return [Pf, Mb]
                }
                static get pluginName() {
                    return "ImageToolbar"
                }
                afterInit() {
                    const t = this.editor,
                        e = t.t,
                        n = t.plugins.get(Pf),
                        o = t.plugins.get("ImageUtils");
                    var i;
                    n.register("image", {
                        ariaLabel: e("Image toolbar"),
                        items: (i = t.config.get("image.toolbar") || [], i.map((t => F(t) ? t.name : t))),
                        getRelatedElement: t => o.getClosestSelectedImageWidget(t)
                    })
                }
            }, class extends vs {
                static get pluginName() {
                    return "ImageUpload"
                }
                static get requires() {
                    return [Ww, Mw, Ow]
                }
            }, class extends vs {
                static get pluginName() {
                    return "Indent"
                }
                static get requires() {
                    return [Gw, Kw]
                }
            }, class extends vs {
                static get requires() {
                    return [P_, q_, Q_]
                }
                static get pluginName() {
                    return "Link"
                }
            }, class extends vs {
                static get requires() {
                    return [IA, MA]
                }
                static get pluginName() {
                    return "List"
                }
            }, class extends vs {
                static get requires() {
                    return [FA, GA, HA, Nf]
                }
                static get pluginName() {
                    return "MediaEmbed"
                }
            }, bb, class extends vs {
                static get pluginName() {
                    return "PasteFromOffice"
                }
                static get requires() {
                    return [hp]
                }
                init() {
                    const t = this.editor,
                        e = t.editing.view.document,
                        n = [];
                    n.push(new aC(e)), n.push(new nC(e)), t.plugins.get("ClipboardPipeline").on("inputTransformation", ((o, i) => {
                        if (i._isTransformedWithPasteFromOffice) return;
                        if (t.model.document.selection.getFirstPosition().parent.is("element", "codeBlock")) return;
                        const r = i.dataTransfer.getData("text/html"),
                            s = n.find((t => t.isActive(r)));
                        s && (i._parsedData = lC(r, e.stylesProcessor), s.execute(i), i._isTransformedWithPasteFromOffice = !0)
                    }), {
                        priority: "high"
                    })
                }
            }, class extends vs {
                static get requires() {
                    return [Gb, Mb]
                }
                static get pluginName() {
                    return "PictureEditing"
                }
                afterInit() {
                    const t = this.editor;
                    t.plugins.has("ImageBlockEditing") && t.model.schema.extend("imageBlock", {
                        allowAttributes: ["sources"]
                    }), t.plugins.has("ImageInlineEditing") && t.model.schema.extend("imageInline", {
                        allowAttributes: ["sources"]
                    }), this._setupConversion(), this._setupImageUploadEditingIntegration()
                }
                _setupConversion() {
                    const t = this.editor,
                        e = t.conversion,
                        n = t.plugins.get("ImageUtils");
                    e.for("upcast").add(function(t) {
                        const e = ["srcset", "media", "type", "sizes"];
                        return t => {
                            t.on("element:picture", n)
                        };
    
                        function n(n, o, i) {
                            const r = o.viewItem;
                            if (!i.consumable.test(r, {
                                    name: !0
                                })) return;
                            const s = new Map;
                            for (const t of r.getChildren())
                                if (t.is("element", "source")) {
                                    const n = {};
                                    for (const o of e) t.hasAttribute(o) && i.consumable.test(t, {
                                        attributes: o
                                    }) && (n[o] = t.getAttribute(o));
                                    Object.keys(n).length && s.set(t, n)
                                } const a = t.findViewImgElement(r);
                            if (!a) return;
                            let c = o.modelCursor.parent;
                            if (!c.is("element", "imageBlock")) {
                                const t = i.convertItem(a, o.modelCursor);
                                o.modelRange = t.modelRange, o.modelCursor = t.modelCursor, c = gr(t.modelRange.getItems())
                            }
                            i.consumable.consume(r, {
                                name: !0
                            });
                            for (const [t, e] of s) i.consumable.consume(t, {
                                attributes: Object.keys(e)
                            });
                            s.size && i.writer.setAttribute("sources", Array.from(s.values()), c), i.convertChildren(r, c)
                        }
                    }(n)), e.for("downcast").add(function(t) {
                        return t => {
                            t.on("attribute:sources:imageBlock", e), t.on("attribute:sources:imageInline", e)
                        };
    
                        function e(e, n, o) {
                            if (!o.consumable.consume(n.item, e.name)) return;
                            const i = o.writer,
                                r = o.mapper.toViewElement(n.item),
                                s = t.findViewImgElement(r);
                            if (n.attributeNewValue && n.attributeNewValue.length) {
                                const t = i.createContainerElement("picture", null, n.attributeNewValue.map((t => i.createEmptyElement("source", t)))),
                                    e = [];
                                let o = s.parent;
                                for (; o && o.is("attributeElement");) {
                                    const t = o.parent;
                                    i.unwrap(i.createRangeOn(s), o), e.unshift(o), o = t
                                }
                                i.insert(i.createPositionBefore(s), t), i.move(i.createRangeOn(s), i.createPositionAt(t, "end"));
                                for (const n of e) i.wrap(i.createRangeOn(t), n)
                            } else if (s.parent.is("element", "picture")) {
                                const t = s.parent;
                                i.move(i.createRangeOn(s), i.createPositionBefore(t)), i.remove(t)
                            }
                        }
                    }(n))
                }
                _setupImageUploadEditingIntegration() {
                    const t = this.editor;
                    t.plugins.has("ImageUploadEditing") && this.listenTo(t.plugins.get("ImageUploadEditing"), "uploadComplete", ((e, {
                        imageElement: n,
                        data: o
                    }) => {
                        const i = o.sources;
                        i && t.model.change((t => {
                            t.setAttributes({
                                sources: i
                            }, n)
                        }))
                    }))
                }
            }, class extends vs {
                static get requires() {
                    return [uv, kv, Av, Tv, Dv, Cv, Nf]
                }
                static get pluginName() {
                    return "Table"
                }
            }, class extends vs {
                static get requires() {
                    return [Pf]
                }
                static get pluginName() {
                    return "TableToolbar"
                }
                afterInit() {
                    const t = this.editor,
                        e = t.t,
                        n = t.plugins.get(Pf),
                        o = t.config.get("table.contentToolbar"),
                        i = t.config.get("table.tableToolbar");
                    o && n.register("tableContent", {
                        ariaLabel: e("Table toolbar"),
                        items: o,
                        getRelatedElement: Pv
                    }), i && n.register("table", {
                        ariaLabel: e("Table toolbar"),
                        items: i,
                        getRelatedElement: Bv
                    })
                }
            }, class extends vs {
                static get requires() {
                    return ["Delete", "Input"]
                }
                static get pluginName() {
                    return "TextTransformation"
                }
                constructor(t) {
                    super(t), t.config.define("typing", {
                        transformations: {
                            include: jp
                        }
                    })
                }
                init() {
                    const t = this.editor.model.document.selection;
                    t.on("change:range", (() => {
                        this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
                    })), this._enableTransformationWatchers()
                }
                _enableTransformationWatchers() {
                    const t = this.editor,
                        e = t.model,
                        n = t.plugins.get("Delete"),
                        o = function(t) {
                            const e = t.extra || [],
                                n = t.remove || [],
                                o = t => !n.includes(t);
                            return function(t) {
                                const e = new Set;
                                for (const n of t)
                                    if ("string" == typeof n && Rp[n])
                                        for (const t of Rp[n]) e.add(t);
                                    else e.add(n);
                                return Array.from(e)
                            }(t.include.concat(e).filter(o)).filter(o).map((t => "string" == typeof t && Op[t] ? Op[t] : t)).filter((t => "object" == typeof t)).map((t => ({
                                from: Fp(t.from),
                                to: Vp(t.to)
                            })))
                        }(t.config.get("typing.transformations")),
                        i = new Ip(t.model, (t => {
                            for (const e of o) {
                                if (e.from.test(t)) return {
                                    normalizedTransformation: e
                                }
                            }
                        }));
                    i.on("matched:data", ((t, o) => {
                        if (!o.batch.isTyping) return;
                        const {
                            from: i,
                            to: r
                        } = o.normalizedTransformation, s = i.exec(o.text), a = r(s.slice(1)), c = o.range;
                        let l = s.index;
                        e.enqueueChange((t => {
                            for (let n = 1; n < s.length; n++) {
                                const o = s[n],
                                    i = a[n - 1];
                                if (null == i) {
                                    l += o.length;
                                    continue
                                }
                                const r = c.start.getShiftedBy(l),
                                    d = e.createRange(r, r.getShiftedBy(o.length)),
                                    h = Hp(r);
                                e.insertContent(t.createText(i, h), d), l += i.length
                            }
                            e.enqueueChange((() => {
                                n.requestUndoOnBackspace()
                            }))
                        }))
                    })), i.bind("isEnabled").to(this)
                }
            }], Wv.defaultConfig = {
                toolbar: {
                    items: ["heading", "|", "bold", "italic", "link", "bulletedList", "numberedList", "|", "outdent", "indent", "|", "uploadImage", "blockQuote", "insertTable", "mediaEmbed", "undo", "redo"]
                },
                image: {
                    toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"]
                },
                table: {
                    contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"]
                },
                language: "en"
            }
        })(), o = o.default
    })()));
